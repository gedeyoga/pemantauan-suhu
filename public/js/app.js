/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("window.$ = __webpack_require__(/*! ../themes/bootstrap/vendor/jquery/jquery.js */ \"./resources/themes/bootstrap/vendor/jquery/jquery.js\");\nwindow.jQuery = __webpack_require__(/*! ../themes/bootstrap/vendor/jquery/jquery.js */ \"./resources/themes/bootstrap/vendor/jquery/jquery.js\");\n__webpack_require__(/*! pusher-js */ \"./node_modules/pusher-js/dist/web/pusher.js\");\n__webpack_require__(/*! ../themes/bootstrap/vendor//bootstrap/js/bootstrap.bundle.js */ \"./resources/themes/bootstrap/vendor/bootstrap/js/bootstrap.bundle.js\");\n__webpack_require__(/*! ../themes/bootstrap/vendor//bootstrap/js/bootstrap.bundle.js */ \"./resources/themes/bootstrap/vendor/bootstrap/js/bootstrap.bundle.js\");\n__webpack_require__(/*! ../themes/bootstrap/vendor/jquery-easing/jquery_easing */ \"./resources/themes/bootstrap/vendor/jquery-easing/jquery_easing.js\");\n__webpack_require__(/*! ../themes/bootstrap/js/sb-admin-2.js */ \"./resources/themes/bootstrap/js/sb-admin-2.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvYXBwLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBQSxNQUFNLENBQUNDLENBQUMsR0FBR0MsbUJBQU8sQ0FBQyx5R0FBNkMsQ0FBQztBQUNqRUYsTUFBTSxDQUFDRyxNQUFNLEdBQUdELG1CQUFPLENBQUMseUdBQTZDLENBQUM7QUFFdEVBLG1CQUFPLENBQUMsOERBQVcsQ0FBQztBQUNwQkEsbUJBQU8sQ0FBQywwSUFBOEQsQ0FBQztBQUN2RUEsbUJBQU8sQ0FBQywwSUFBOEQsQ0FBQztBQUN2RUEsbUJBQU8sQ0FBQyxrSUFBd0QsQ0FBQztBQUNqRUEsbUJBQU8sQ0FBQywyRkFBc0MsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9hcHAuanM/Y2VkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ3aW5kb3cuJCA9IHJlcXVpcmUoXCIuLi90aGVtZXMvYm9vdHN0cmFwL3ZlbmRvci9qcXVlcnkvanF1ZXJ5LmpzXCIpO1xud2luZG93LmpRdWVyeSA9IHJlcXVpcmUoXCIuLi90aGVtZXMvYm9vdHN0cmFwL3ZlbmRvci9qcXVlcnkvanF1ZXJ5LmpzXCIpO1xuXG5yZXF1aXJlKFwicHVzaGVyLWpzXCIpO1xucmVxdWlyZShcIi4uL3RoZW1lcy9ib290c3RyYXAvdmVuZG9yLy9ib290c3RyYXAvanMvYm9vdHN0cmFwLmJ1bmRsZS5qc1wiKTtcbnJlcXVpcmUoXCIuLi90aGVtZXMvYm9vdHN0cmFwL3ZlbmRvci8vYm9vdHN0cmFwL2pzL2Jvb3RzdHJhcC5idW5kbGUuanNcIik7XG5yZXF1aXJlKFwiLi4vdGhlbWVzL2Jvb3RzdHJhcC92ZW5kb3IvanF1ZXJ5LWVhc2luZy9qcXVlcnlfZWFzaW5nXCIpO1xucmVxdWlyZShcIi4uL3RoZW1lcy9ib290c3RyYXAvanMvc2ItYWRtaW4tMi5qc1wiKTtcbiJdLCJuYW1lcyI6WyJ3aW5kb3ciLCIkIiwicmVxdWlyZSIsImpRdWVyeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/app.js\n");

/***/ }),

/***/ "./resources/themes/bootstrap/js/sb-admin-2.js":
/*!*****************************************************!*\
  !*** ./resources/themes/bootstrap/js/sb-admin-2.js ***!
  \*****************************************************/
/***/ (() => {

eval("(function ($) {\n  \"use strict\";\n\n  // Start of use strict\n\n  // Toggle the side navigation\n  $(\"#sidebarToggle, #sidebarToggleTop\").on('click', function (e) {\n    $(\"body\").toggleClass(\"sidebar-toggled\");\n    $(\".sidebar\").toggleClass(\"toggled\");\n    if ($(\".sidebar\").hasClass(\"toggled\")) {\n      $('.sidebar .collapse').collapse('hide');\n    }\n    ;\n  });\n\n  // Close any open menu accordions when window is resized below 768px\n  $(window).resize(function () {\n    if ($(window).width() < 768) {\n      $('.sidebar .collapse').collapse('hide');\n    }\n    ;\n\n    // Toggle the side navigation when window is resized below 480px\n    if ($(window).width() < 480 && !$(\".sidebar\").hasClass(\"toggled\")) {\n      $(\"body\").addClass(\"sidebar-toggled\");\n      $(\".sidebar\").addClass(\"toggled\");\n      $('.sidebar .collapse').collapse('hide');\n    }\n    ;\n  });\n\n  // Prevent the content wrapper from scrolling when the fixed side navigation hovered over\n  $('body.fixed-nav .sidebar').on('mousewheel DOMMouseScroll wheel', function (e) {\n    if ($(window).width() > 768) {\n      var e0 = e.originalEvent,\n        delta = e0.wheelDelta || -e0.detail;\n      this.scrollTop += (delta < 0 ? 1 : -1) * 30;\n      e.preventDefault();\n    }\n  });\n\n  // Scroll to top button appear\n  $(document).on('scroll', function () {\n    var scrollDistance = $(this).scrollTop();\n    if (scrollDistance > 100) {\n      $('.scroll-to-top').fadeIn();\n    } else {\n      $('.scroll-to-top').fadeOut();\n    }\n  });\n\n  // Smooth scrolling using jQuery easing\n  $(document).on('click', 'a.scroll-to-top', function (e) {\n    var $anchor = $(this);\n    $('html, body').stop().animate({\n      scrollTop: $($anchor.attr('href')).offset().top\n    }, 1000, 'easeInOutExpo');\n    e.preventDefault();\n  });\n})(jQuery); // End of use strict//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyIkIiwib24iLCJlIiwidG9nZ2xlQ2xhc3MiLCJoYXNDbGFzcyIsImNvbGxhcHNlIiwid2luZG93IiwicmVzaXplIiwid2lkdGgiLCJhZGRDbGFzcyIsImUwIiwib3JpZ2luYWxFdmVudCIsImRlbHRhIiwid2hlZWxEZWx0YSIsImRldGFpbCIsInNjcm9sbFRvcCIsInByZXZlbnREZWZhdWx0IiwiZG9jdW1lbnQiLCJzY3JvbGxEaXN0YW5jZSIsImZhZGVJbiIsImZhZGVPdXQiLCIkYW5jaG9yIiwic3RvcCIsImFuaW1hdGUiLCJhdHRyIiwib2Zmc2V0IiwidG9wIiwialF1ZXJ5Il0sInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy90aGVtZXMvYm9vdHN0cmFwL2pzL3NiLWFkbWluLTIuanM/NGIzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oJCkge1xuICBcInVzZSBzdHJpY3RcIjsgLy8gU3RhcnQgb2YgdXNlIHN0cmljdFxuXG4gIC8vIFRvZ2dsZSB0aGUgc2lkZSBuYXZpZ2F0aW9uXG4gICQoXCIjc2lkZWJhclRvZ2dsZSwgI3NpZGViYXJUb2dnbGVUb3BcIikub24oJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICQoXCJib2R5XCIpLnRvZ2dsZUNsYXNzKFwic2lkZWJhci10b2dnbGVkXCIpO1xuICAgICQoXCIuc2lkZWJhclwiKS50b2dnbGVDbGFzcyhcInRvZ2dsZWRcIik7XG4gICAgaWYgKCQoXCIuc2lkZWJhclwiKS5oYXNDbGFzcyhcInRvZ2dsZWRcIikpIHtcbiAgICAgICQoJy5zaWRlYmFyIC5jb2xsYXBzZScpLmNvbGxhcHNlKCdoaWRlJyk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQ2xvc2UgYW55IG9wZW4gbWVudSBhY2NvcmRpb25zIHdoZW4gd2luZG93IGlzIHJlc2l6ZWQgYmVsb3cgNzY4cHhcbiAgJCh3aW5kb3cpLnJlc2l6ZShmdW5jdGlvbigpIHtcbiAgICBpZiAoJCh3aW5kb3cpLndpZHRoKCkgPCA3NjgpIHtcbiAgICAgICQoJy5zaWRlYmFyIC5jb2xsYXBzZScpLmNvbGxhcHNlKCdoaWRlJyk7XG4gICAgfTtcbiAgICBcbiAgICAvLyBUb2dnbGUgdGhlIHNpZGUgbmF2aWdhdGlvbiB3aGVuIHdpbmRvdyBpcyByZXNpemVkIGJlbG93IDQ4MHB4XG4gICAgaWYgKCQod2luZG93KS53aWR0aCgpIDwgNDgwICYmICEkKFwiLnNpZGViYXJcIikuaGFzQ2xhc3MoXCJ0b2dnbGVkXCIpKSB7XG4gICAgICAkKFwiYm9keVwiKS5hZGRDbGFzcyhcInNpZGViYXItdG9nZ2xlZFwiKTtcbiAgICAgICQoXCIuc2lkZWJhclwiKS5hZGRDbGFzcyhcInRvZ2dsZWRcIik7XG4gICAgICAkKCcuc2lkZWJhciAuY29sbGFwc2UnKS5jb2xsYXBzZSgnaGlkZScpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIFByZXZlbnQgdGhlIGNvbnRlbnQgd3JhcHBlciBmcm9tIHNjcm9sbGluZyB3aGVuIHRoZSBmaXhlZCBzaWRlIG5hdmlnYXRpb24gaG92ZXJlZCBvdmVyXG4gICQoJ2JvZHkuZml4ZWQtbmF2IC5zaWRlYmFyJykub24oJ21vdXNld2hlZWwgRE9NTW91c2VTY3JvbGwgd2hlZWwnLCBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCQod2luZG93KS53aWR0aCgpID4gNzY4KSB7XG4gICAgICB2YXIgZTAgPSBlLm9yaWdpbmFsRXZlbnQsXG4gICAgICAgIGRlbHRhID0gZTAud2hlZWxEZWx0YSB8fCAtZTAuZGV0YWlsO1xuICAgICAgdGhpcy5zY3JvbGxUb3AgKz0gKGRlbHRhIDwgMCA/IDEgOiAtMSkgKiAzMDtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFNjcm9sbCB0byB0b3AgYnV0dG9uIGFwcGVhclxuICAkKGRvY3VtZW50KS5vbignc2Nyb2xsJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjcm9sbERpc3RhbmNlID0gJCh0aGlzKS5zY3JvbGxUb3AoKTtcbiAgICBpZiAoc2Nyb2xsRGlzdGFuY2UgPiAxMDApIHtcbiAgICAgICQoJy5zY3JvbGwtdG8tdG9wJykuZmFkZUluKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICQoJy5zY3JvbGwtdG8tdG9wJykuZmFkZU91dCgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gU21vb3RoIHNjcm9sbGluZyB1c2luZyBqUXVlcnkgZWFzaW5nXG4gICQoZG9jdW1lbnQpLm9uKCdjbGljaycsICdhLnNjcm9sbC10by10b3AnLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyICRhbmNob3IgPSAkKHRoaXMpO1xuICAgICQoJ2h0bWwsIGJvZHknKS5zdG9wKCkuYW5pbWF0ZSh7XG4gICAgICBzY3JvbGxUb3A6ICgkKCRhbmNob3IuYXR0cignaHJlZicpKS5vZmZzZXQoKS50b3ApXG4gICAgfSwgMTAwMCwgJ2Vhc2VJbk91dEV4cG8nKTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuXG59KShqUXVlcnkpOyAvLyBFbmQgb2YgdXNlIHN0cmljdFxuIl0sIm1hcHBpbmdzIjoiQUFBQSxDQUFDLFVBQVNBLENBQUMsRUFBRTtFQUNYLFlBQVk7O0VBQUU7O0VBRWQ7RUFDQUEsQ0FBQyxDQUFDLG1DQUFtQyxDQUFDLENBQUNDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsVUFBU0MsQ0FBQyxFQUFFO0lBQzdERixDQUFDLENBQUMsTUFBTSxDQUFDLENBQUNHLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQztJQUN4Q0gsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDRyxXQUFXLENBQUMsU0FBUyxDQUFDO0lBQ3BDLElBQUlILENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQ0ksUUFBUSxDQUFDLFNBQVMsQ0FBQyxFQUFFO01BQ3JDSixDQUFDLENBQUMsb0JBQW9CLENBQUMsQ0FBQ0ssUUFBUSxDQUFDLE1BQU0sQ0FBQztJQUMxQztJQUFDO0VBQ0gsQ0FBQyxDQUFDOztFQUVGO0VBQ0FMLENBQUMsQ0FBQ00sTUFBTSxDQUFDLENBQUNDLE1BQU0sQ0FBQyxZQUFXO0lBQzFCLElBQUlQLENBQUMsQ0FBQ00sTUFBTSxDQUFDLENBQUNFLEtBQUssRUFBRSxHQUFHLEdBQUcsRUFBRTtNQUMzQlIsQ0FBQyxDQUFDLG9CQUFvQixDQUFDLENBQUNLLFFBQVEsQ0FBQyxNQUFNLENBQUM7SUFDMUM7SUFBQzs7SUFFRDtJQUNBLElBQUlMLENBQUMsQ0FBQ00sTUFBTSxDQUFDLENBQUNFLEtBQUssRUFBRSxHQUFHLEdBQUcsSUFBSSxDQUFDUixDQUFDLENBQUMsVUFBVSxDQUFDLENBQUNJLFFBQVEsQ0FBQyxTQUFTLENBQUMsRUFBRTtNQUNqRUosQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDUyxRQUFRLENBQUMsaUJBQWlCLENBQUM7TUFDckNULENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQ1MsUUFBUSxDQUFDLFNBQVMsQ0FBQztNQUNqQ1QsQ0FBQyxDQUFDLG9CQUFvQixDQUFDLENBQUNLLFFBQVEsQ0FBQyxNQUFNLENBQUM7SUFDMUM7SUFBQztFQUNILENBQUMsQ0FBQzs7RUFFRjtFQUNBTCxDQUFDLENBQUMseUJBQXlCLENBQUMsQ0FBQ0MsRUFBRSxDQUFDLGlDQUFpQyxFQUFFLFVBQVNDLENBQUMsRUFBRTtJQUM3RSxJQUFJRixDQUFDLENBQUNNLE1BQU0sQ0FBQyxDQUFDRSxLQUFLLEVBQUUsR0FBRyxHQUFHLEVBQUU7TUFDM0IsSUFBSUUsRUFBRSxHQUFHUixDQUFDLENBQUNTLGFBQWE7UUFDdEJDLEtBQUssR0FBR0YsRUFBRSxDQUFDRyxVQUFVLElBQUksQ0FBQ0gsRUFBRSxDQUFDSSxNQUFNO01BQ3JDLElBQUksQ0FBQ0MsU0FBUyxJQUFJLENBQUNILEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUU7TUFDM0NWLENBQUMsQ0FBQ2MsY0FBYyxFQUFFO0lBQ3BCO0VBQ0YsQ0FBQyxDQUFDOztFQUVGO0VBQ0FoQixDQUFDLENBQUNpQixRQUFRLENBQUMsQ0FBQ2hCLEVBQUUsQ0FBQyxRQUFRLEVBQUUsWUFBVztJQUNsQyxJQUFJaUIsY0FBYyxHQUFHbEIsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDZSxTQUFTLEVBQUU7SUFDeEMsSUFBSUcsY0FBYyxHQUFHLEdBQUcsRUFBRTtNQUN4QmxCLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDbUIsTUFBTSxFQUFFO0lBQzlCLENBQUMsTUFBTTtNQUNMbkIsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUNvQixPQUFPLEVBQUU7SUFDL0I7RUFDRixDQUFDLENBQUM7O0VBRUY7RUFDQXBCLENBQUMsQ0FBQ2lCLFFBQVEsQ0FBQyxDQUFDaEIsRUFBRSxDQUFDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxVQUFTQyxDQUFDLEVBQUU7SUFDckQsSUFBSW1CLE9BQU8sR0FBR3JCLENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDckJBLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQ3NCLElBQUksRUFBRSxDQUFDQyxPQUFPLENBQUM7TUFDN0JSLFNBQVMsRUFBR2YsQ0FBQyxDQUFDcUIsT0FBTyxDQUFDRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQ0MsTUFBTSxFQUFFLENBQUNDO0lBQy9DLENBQUMsRUFBRSxJQUFJLEVBQUUsZUFBZSxDQUFDO0lBQ3pCeEIsQ0FBQyxDQUFDYyxjQUFjLEVBQUU7RUFDcEIsQ0FBQyxDQUFDO0FBRUosQ0FBQyxFQUFFVyxNQUFNLENBQUMsQ0FBQyxDQUFDIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL3RoZW1lcy9ib290c3RyYXAvanMvc2ItYWRtaW4tMi5qcy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/themes/bootstrap/js/sb-admin-2.js\n");

/***/ }),

/***/ "./resources/themes/bootstrap/vendor/bootstrap/js/bootstrap.bundle.js":
/*!****************************************************************************!*\
  !*** ./resources/themes/bootstrap/vendor/bootstrap/js/bootstrap.bundle.js ***!
  \****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*!\n  * Bootstrap v4.6.0 (https://getbootstrap.com/)\n  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */\n(function (global, factory) {\n  ( false ? 0 : _typeof(exports)) === 'object' && \"object\" !== 'undefined' ? factory(exports, __webpack_require__(/*! jquery */ \"jquery\")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! jquery */ \"jquery\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n})(this, function (exports, $) {\n  'use strict';\n\n  function _interopDefaultLegacy(e) {\n    return e && _typeof(e) === 'object' && 'default' in e ? e : {\n      'default': e\n    };\n  }\n  var $__default = /*#__PURE__*/_interopDefaultLegacy($);\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    return _extends.apply(this, arguments);\n  }\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v4.6.0): util.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * ------------------------------------------------------------------------\n   * Private TransitionEnd Helpers\n   * ------------------------------------------------------------------------\n   */\n\n  var TRANSITION_END = 'transitionend';\n  var MAX_UID = 1000000;\n  var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)\n\n  function toType(obj) {\n    if (obj === null || typeof obj === 'undefined') {\n      return \"\" + obj;\n    }\n    return {}.toString.call(obj).match(/\\s([a-z]+)/i)[1].toLowerCase();\n  }\n  function getSpecialTransitionEndEvent() {\n    return {\n      bindType: TRANSITION_END,\n      delegateType: TRANSITION_END,\n      handle: function handle(event) {\n        if ($__default['default'](event.target).is(this)) {\n          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params\n        }\n\n        return undefined;\n      }\n    };\n  }\n  function transitionEndEmulator(duration) {\n    var _this = this;\n    var called = false;\n    $__default['default'](this).one(Util.TRANSITION_END, function () {\n      called = true;\n    });\n    setTimeout(function () {\n      if (!called) {\n        Util.triggerTransitionEnd(_this);\n      }\n    }, duration);\n    return this;\n  }\n  function setTransitionEndSupport() {\n    $__default['default'].fn.emulateTransitionEnd = transitionEndEmulator;\n    $__default['default'].event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();\n  }\n  /**\n   * --------------------------------------------------------------------------\n   * Public Util Api\n   * --------------------------------------------------------------------------\n   */\n\n  var Util = {\n    TRANSITION_END: 'bsTransitionEnd',\n    getUID: function getUID(prefix) {\n      do {\n        prefix += ~~(Math.random() * MAX_UID); // \"~~\" acts like a faster Math.floor() here\n      } while (document.getElementById(prefix));\n      return prefix;\n    },\n    getSelectorFromElement: function getSelectorFromElement(element) {\n      var selector = element.getAttribute('data-target');\n      if (!selector || selector === '#') {\n        var hrefAttr = element.getAttribute('href');\n        selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : '';\n      }\n      try {\n        return document.querySelector(selector) ? selector : null;\n      } catch (_) {\n        return null;\n      }\n    },\n    getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {\n      if (!element) {\n        return 0;\n      } // Get transition-duration of the element\n\n      var transitionDuration = $__default['default'](element).css('transition-duration');\n      var transitionDelay = $__default['default'](element).css('transition-delay');\n      var floatTransitionDuration = parseFloat(transitionDuration);\n      var floatTransitionDelay = parseFloat(transitionDelay); // Return 0 if element or transition duration is not found\n\n      if (!floatTransitionDuration && !floatTransitionDelay) {\n        return 0;\n      } // If multiple durations are defined, take the first\n\n      transitionDuration = transitionDuration.split(',')[0];\n      transitionDelay = transitionDelay.split(',')[0];\n      return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\n    },\n    reflow: function reflow(element) {\n      return element.offsetHeight;\n    },\n    triggerTransitionEnd: function triggerTransitionEnd(element) {\n      $__default['default'](element).trigger(TRANSITION_END);\n    },\n    supportsTransitionEnd: function supportsTransitionEnd() {\n      return Boolean(TRANSITION_END);\n    },\n    isElement: function isElement(obj) {\n      return (obj[0] || obj).nodeType;\n    },\n    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {\n      for (var property in configTypes) {\n        if (Object.prototype.hasOwnProperty.call(configTypes, property)) {\n          var expectedTypes = configTypes[property];\n          var value = config[property];\n          var valueType = value && Util.isElement(value) ? 'element' : toType(value);\n          if (!new RegExp(expectedTypes).test(valueType)) {\n            throw new Error(componentName.toUpperCase() + \": \" + (\"Option \\\"\" + property + \"\\\" provided type \\\"\" + valueType + \"\\\" \") + (\"but expected type \\\"\" + expectedTypes + \"\\\".\"));\n          }\n        }\n      }\n    },\n    findShadowRoot: function findShadowRoot(element) {\n      if (!document.documentElement.attachShadow) {\n        return null;\n      } // Can find the shadow root otherwise it'll return the document\n\n      if (typeof element.getRootNode === 'function') {\n        var root = element.getRootNode();\n        return root instanceof ShadowRoot ? root : null;\n      }\n      if (element instanceof ShadowRoot) {\n        return element;\n      } // when we don't find a shadow root\n\n      if (!element.parentNode) {\n        return null;\n      }\n      return Util.findShadowRoot(element.parentNode);\n    },\n    jQueryDetection: function jQueryDetection() {\n      if (typeof $__default['default'] === 'undefined') {\n        throw new TypeError('Bootstrap\\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\\'s JavaScript.');\n      }\n      var version = $__default['default'].fn.jquery.split(' ')[0].split('.');\n      var minMajor = 1;\n      var ltMajor = 2;\n      var minMinor = 9;\n      var minPatch = 1;\n      var maxMajor = 4;\n      if (version[0] < ltMajor && version[1] < minMinor || version[0] === minMajor && version[1] === minMinor && version[2] < minPatch || version[0] >= maxMajor) {\n        throw new Error('Bootstrap\\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');\n      }\n    }\n  };\n  Util.jQueryDetection();\n  setTransitionEndSupport();\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME = 'alert';\n  var VERSION = '4.6.0';\n  var DATA_KEY = 'bs.alert';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $__default['default'].fn[NAME];\n  var SELECTOR_DISMISS = '[data-dismiss=\"alert\"]';\n  var EVENT_CLOSE = \"close\" + EVENT_KEY;\n  var EVENT_CLOSED = \"closed\" + EVENT_KEY;\n  var EVENT_CLICK_DATA_API = \"click\" + EVENT_KEY + DATA_API_KEY;\n  var CLASS_NAME_ALERT = 'alert';\n  var CLASS_NAME_FADE = 'fade';\n  var CLASS_NAME_SHOW = 'show';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Alert = /*#__PURE__*/function () {\n    function Alert(element) {\n      this._element = element;\n    } // Getters\n\n    var _proto = Alert.prototype;\n\n    // Public\n    _proto.close = function close(element) {\n      var rootElement = this._element;\n      if (element) {\n        rootElement = this._getRootElement(element);\n      }\n      var customEvent = this._triggerCloseEvent(rootElement);\n      if (customEvent.isDefaultPrevented()) {\n        return;\n      }\n      this._removeElement(rootElement);\n    };\n    _proto.dispose = function dispose() {\n      $__default['default'].removeData(this._element, DATA_KEY);\n      this._element = null;\n    } // Private\n    ;\n\n    _proto._getRootElement = function _getRootElement(element) {\n      var selector = Util.getSelectorFromElement(element);\n      var parent = false;\n      if (selector) {\n        parent = document.querySelector(selector);\n      }\n      if (!parent) {\n        parent = $__default['default'](element).closest(\".\" + CLASS_NAME_ALERT)[0];\n      }\n      return parent;\n    };\n    _proto._triggerCloseEvent = function _triggerCloseEvent(element) {\n      var closeEvent = $__default['default'].Event(EVENT_CLOSE);\n      $__default['default'](element).trigger(closeEvent);\n      return closeEvent;\n    };\n    _proto._removeElement = function _removeElement(element) {\n      var _this = this;\n      $__default['default'](element).removeClass(CLASS_NAME_SHOW);\n      if (!$__default['default'](element).hasClass(CLASS_NAME_FADE)) {\n        this._destroyElement(element);\n        return;\n      }\n      var transitionDuration = Util.getTransitionDurationFromElement(element);\n      $__default['default'](element).one(Util.TRANSITION_END, function (event) {\n        return _this._destroyElement(element, event);\n      }).emulateTransitionEnd(transitionDuration);\n    };\n    _proto._destroyElement = function _destroyElement(element) {\n      $__default['default'](element).detach().trigger(EVENT_CLOSED).remove();\n    } // Static\n    ;\n\n    Alert._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = $__default['default'](this);\n        var data = $element.data(DATA_KEY);\n        if (!data) {\n          data = new Alert(this);\n          $element.data(DATA_KEY, data);\n        }\n        if (config === 'close') {\n          data[config](this);\n        }\n      });\n    };\n    Alert._handleDismiss = function _handleDismiss(alertInstance) {\n      return function (event) {\n        if (event) {\n          event.preventDefault();\n        }\n        alertInstance.close(this);\n      };\n    };\n    _createClass(Alert, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }]);\n    return Alert;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'](document).on(EVENT_CLICK_DATA_API, SELECTOR_DISMISS, Alert._handleDismiss(new Alert()));\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'].fn[NAME] = Alert._jQueryInterface;\n  $__default['default'].fn[NAME].Constructor = Alert;\n  $__default['default'].fn[NAME].noConflict = function () {\n    $__default['default'].fn[NAME] = JQUERY_NO_CONFLICT;\n    return Alert._jQueryInterface;\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$1 = 'button';\n  var VERSION$1 = '4.6.0';\n  var DATA_KEY$1 = 'bs.button';\n  var EVENT_KEY$1 = \".\" + DATA_KEY$1;\n  var DATA_API_KEY$1 = '.data-api';\n  var JQUERY_NO_CONFLICT$1 = $__default['default'].fn[NAME$1];\n  var CLASS_NAME_ACTIVE = 'active';\n  var CLASS_NAME_BUTTON = 'btn';\n  var CLASS_NAME_FOCUS = 'focus';\n  var SELECTOR_DATA_TOGGLE_CARROT = '[data-toggle^=\"button\"]';\n  var SELECTOR_DATA_TOGGLES = '[data-toggle=\"buttons\"]';\n  var SELECTOR_DATA_TOGGLE = '[data-toggle=\"button\"]';\n  var SELECTOR_DATA_TOGGLES_BUTTONS = '[data-toggle=\"buttons\"] .btn';\n  var SELECTOR_INPUT = 'input:not([type=\"hidden\"])';\n  var SELECTOR_ACTIVE = '.active';\n  var SELECTOR_BUTTON = '.btn';\n  var EVENT_CLICK_DATA_API$1 = \"click\" + EVENT_KEY$1 + DATA_API_KEY$1;\n  var EVENT_FOCUS_BLUR_DATA_API = \"focus\" + EVENT_KEY$1 + DATA_API_KEY$1 + \" \" + (\"blur\" + EVENT_KEY$1 + DATA_API_KEY$1);\n  var EVENT_LOAD_DATA_API = \"load\" + EVENT_KEY$1 + DATA_API_KEY$1;\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Button = /*#__PURE__*/function () {\n    function Button(element) {\n      this._element = element;\n      this.shouldAvoidTriggerChange = false;\n    } // Getters\n\n    var _proto = Button.prototype;\n\n    // Public\n    _proto.toggle = function toggle() {\n      var triggerChangeEvent = true;\n      var addAriaPressed = true;\n      var rootElement = $__default['default'](this._element).closest(SELECTOR_DATA_TOGGLES)[0];\n      if (rootElement) {\n        var input = this._element.querySelector(SELECTOR_INPUT);\n        if (input) {\n          if (input.type === 'radio') {\n            if (input.checked && this._element.classList.contains(CLASS_NAME_ACTIVE)) {\n              triggerChangeEvent = false;\n            } else {\n              var activeElement = rootElement.querySelector(SELECTOR_ACTIVE);\n              if (activeElement) {\n                $__default['default'](activeElement).removeClass(CLASS_NAME_ACTIVE);\n              }\n            }\n          }\n          if (triggerChangeEvent) {\n            // if it's not a radio button or checkbox don't add a pointless/invalid checked property to the input\n            if (input.type === 'checkbox' || input.type === 'radio') {\n              input.checked = !this._element.classList.contains(CLASS_NAME_ACTIVE);\n            }\n            if (!this.shouldAvoidTriggerChange) {\n              $__default['default'](input).trigger('change');\n            }\n          }\n          input.focus();\n          addAriaPressed = false;\n        }\n      }\n      if (!(this._element.hasAttribute('disabled') || this._element.classList.contains('disabled'))) {\n        if (addAriaPressed) {\n          this._element.setAttribute('aria-pressed', !this._element.classList.contains(CLASS_NAME_ACTIVE));\n        }\n        if (triggerChangeEvent) {\n          $__default['default'](this._element).toggleClass(CLASS_NAME_ACTIVE);\n        }\n      }\n    };\n    _proto.dispose = function dispose() {\n      $__default['default'].removeData(this._element, DATA_KEY$1);\n      this._element = null;\n    } // Static\n    ;\n\n    Button._jQueryInterface = function _jQueryInterface(config, avoidTriggerChange) {\n      return this.each(function () {\n        var $element = $__default['default'](this);\n        var data = $element.data(DATA_KEY$1);\n        if (!data) {\n          data = new Button(this);\n          $element.data(DATA_KEY$1, data);\n        }\n        data.shouldAvoidTriggerChange = avoidTriggerChange;\n        if (config === 'toggle') {\n          data[config]();\n        }\n      });\n    };\n    _createClass(Button, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$1;\n      }\n    }]);\n    return Button;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'](document).on(EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE_CARROT, function (event) {\n    var button = event.target;\n    var initialButton = button;\n    if (!$__default['default'](button).hasClass(CLASS_NAME_BUTTON)) {\n      button = $__default['default'](button).closest(SELECTOR_BUTTON)[0];\n    }\n    if (!button || button.hasAttribute('disabled') || button.classList.contains('disabled')) {\n      event.preventDefault(); // work around Firefox bug #1540995\n    } else {\n      var inputBtn = button.querySelector(SELECTOR_INPUT);\n      if (inputBtn && (inputBtn.hasAttribute('disabled') || inputBtn.classList.contains('disabled'))) {\n        event.preventDefault(); // work around Firefox bug #1540995\n\n        return;\n      }\n      if (initialButton.tagName === 'INPUT' || button.tagName !== 'LABEL') {\n        Button._jQueryInterface.call($__default['default'](button), 'toggle', initialButton.tagName === 'INPUT');\n      }\n    }\n  }).on(EVENT_FOCUS_BLUR_DATA_API, SELECTOR_DATA_TOGGLE_CARROT, function (event) {\n    var button = $__default['default'](event.target).closest(SELECTOR_BUTTON)[0];\n    $__default['default'](button).toggleClass(CLASS_NAME_FOCUS, /^focus(in)?$/.test(event.type));\n  });\n  $__default['default'](window).on(EVENT_LOAD_DATA_API, function () {\n    // ensure correct active class is set to match the controls' actual values/states\n    // find all checkboxes/readio buttons inside data-toggle groups\n    var buttons = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLES_BUTTONS));\n    for (var i = 0, len = buttons.length; i < len; i++) {\n      var button = buttons[i];\n      var input = button.querySelector(SELECTOR_INPUT);\n      if (input.checked || input.hasAttribute('checked')) {\n        button.classList.add(CLASS_NAME_ACTIVE);\n      } else {\n        button.classList.remove(CLASS_NAME_ACTIVE);\n      }\n    } // find all button toggles\n\n    buttons = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE));\n    for (var _i = 0, _len = buttons.length; _i < _len; _i++) {\n      var _button = buttons[_i];\n      if (_button.getAttribute('aria-pressed') === 'true') {\n        _button.classList.add(CLASS_NAME_ACTIVE);\n      } else {\n        _button.classList.remove(CLASS_NAME_ACTIVE);\n      }\n    }\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'].fn[NAME$1] = Button._jQueryInterface;\n  $__default['default'].fn[NAME$1].Constructor = Button;\n  $__default['default'].fn[NAME$1].noConflict = function () {\n    $__default['default'].fn[NAME$1] = JQUERY_NO_CONFLICT$1;\n    return Button._jQueryInterface;\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$2 = 'carousel';\n  var VERSION$2 = '4.6.0';\n  var DATA_KEY$2 = 'bs.carousel';\n  var EVENT_KEY$2 = \".\" + DATA_KEY$2;\n  var DATA_API_KEY$2 = '.data-api';\n  var JQUERY_NO_CONFLICT$2 = $__default['default'].fn[NAME$2];\n  var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key\n\n  var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key\n\n  var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\n\n  var SWIPE_THRESHOLD = 40;\n  var Default = {\n    interval: 5000,\n    keyboard: true,\n    slide: false,\n    pause: 'hover',\n    wrap: true,\n    touch: true\n  };\n  var DefaultType = {\n    interval: '(number|boolean)',\n    keyboard: 'boolean',\n    slide: '(boolean|string)',\n    pause: '(string|boolean)',\n    wrap: 'boolean',\n    touch: 'boolean'\n  };\n  var DIRECTION_NEXT = 'next';\n  var DIRECTION_PREV = 'prev';\n  var DIRECTION_LEFT = 'left';\n  var DIRECTION_RIGHT = 'right';\n  var EVENT_SLIDE = \"slide\" + EVENT_KEY$2;\n  var EVENT_SLID = \"slid\" + EVENT_KEY$2;\n  var EVENT_KEYDOWN = \"keydown\" + EVENT_KEY$2;\n  var EVENT_MOUSEENTER = \"mouseenter\" + EVENT_KEY$2;\n  var EVENT_MOUSELEAVE = \"mouseleave\" + EVENT_KEY$2;\n  var EVENT_TOUCHSTART = \"touchstart\" + EVENT_KEY$2;\n  var EVENT_TOUCHMOVE = \"touchmove\" + EVENT_KEY$2;\n  var EVENT_TOUCHEND = \"touchend\" + EVENT_KEY$2;\n  var EVENT_POINTERDOWN = \"pointerdown\" + EVENT_KEY$2;\n  var EVENT_POINTERUP = \"pointerup\" + EVENT_KEY$2;\n  var EVENT_DRAG_START = \"dragstart\" + EVENT_KEY$2;\n  var EVENT_LOAD_DATA_API$1 = \"load\" + EVENT_KEY$2 + DATA_API_KEY$2;\n  var EVENT_CLICK_DATA_API$2 = \"click\" + EVENT_KEY$2 + DATA_API_KEY$2;\n  var CLASS_NAME_CAROUSEL = 'carousel';\n  var CLASS_NAME_ACTIVE$1 = 'active';\n  var CLASS_NAME_SLIDE = 'slide';\n  var CLASS_NAME_RIGHT = 'carousel-item-right';\n  var CLASS_NAME_LEFT = 'carousel-item-left';\n  var CLASS_NAME_NEXT = 'carousel-item-next';\n  var CLASS_NAME_PREV = 'carousel-item-prev';\n  var CLASS_NAME_POINTER_EVENT = 'pointer-event';\n  var SELECTOR_ACTIVE$1 = '.active';\n  var SELECTOR_ACTIVE_ITEM = '.active.carousel-item';\n  var SELECTOR_ITEM = '.carousel-item';\n  var SELECTOR_ITEM_IMG = '.carousel-item img';\n  var SELECTOR_NEXT_PREV = '.carousel-item-next, .carousel-item-prev';\n  var SELECTOR_INDICATORS = '.carousel-indicators';\n  var SELECTOR_DATA_SLIDE = '[data-slide], [data-slide-to]';\n  var SELECTOR_DATA_RIDE = '[data-ride=\"carousel\"]';\n  var PointerType = {\n    TOUCH: 'touch',\n    PEN: 'pen'\n  };\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Carousel = /*#__PURE__*/function () {\n    function Carousel(element, config) {\n      this._items = null;\n      this._interval = null;\n      this._activeElement = null;\n      this._isPaused = false;\n      this._isSliding = false;\n      this.touchTimeout = null;\n      this.touchStartX = 0;\n      this.touchDeltaX = 0;\n      this._config = this._getConfig(config);\n      this._element = element;\n      this._indicatorsElement = this._element.querySelector(SELECTOR_INDICATORS);\n      this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;\n      this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent);\n      this._addEventListeners();\n    } // Getters\n\n    var _proto = Carousel.prototype;\n\n    // Public\n    _proto.next = function next() {\n      if (!this._isSliding) {\n        this._slide(DIRECTION_NEXT);\n      }\n    };\n    _proto.nextWhenVisible = function nextWhenVisible() {\n      var $element = $__default['default'](this._element); // Don't call next when the page isn't visible\n      // or the carousel or its parent isn't visible\n\n      if (!document.hidden && $element.is(':visible') && $element.css('visibility') !== 'hidden') {\n        this.next();\n      }\n    };\n    _proto.prev = function prev() {\n      if (!this._isSliding) {\n        this._slide(DIRECTION_PREV);\n      }\n    };\n    _proto.pause = function pause(event) {\n      if (!event) {\n        this._isPaused = true;\n      }\n      if (this._element.querySelector(SELECTOR_NEXT_PREV)) {\n        Util.triggerTransitionEnd(this._element);\n        this.cycle(true);\n      }\n      clearInterval(this._interval);\n      this._interval = null;\n    };\n    _proto.cycle = function cycle(event) {\n      if (!event) {\n        this._isPaused = false;\n      }\n      if (this._interval) {\n        clearInterval(this._interval);\n        this._interval = null;\n      }\n      if (this._config.interval && !this._isPaused) {\n        this._updateInterval();\n        this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);\n      }\n    };\n    _proto.to = function to(index) {\n      var _this = this;\n      this._activeElement = this._element.querySelector(SELECTOR_ACTIVE_ITEM);\n      var activeIndex = this._getItemIndex(this._activeElement);\n      if (index > this._items.length - 1 || index < 0) {\n        return;\n      }\n      if (this._isSliding) {\n        $__default['default'](this._element).one(EVENT_SLID, function () {\n          return _this.to(index);\n        });\n        return;\n      }\n      if (activeIndex === index) {\n        this.pause();\n        this.cycle();\n        return;\n      }\n      var direction = index > activeIndex ? DIRECTION_NEXT : DIRECTION_PREV;\n      this._slide(direction, this._items[index]);\n    };\n    _proto.dispose = function dispose() {\n      $__default['default'](this._element).off(EVENT_KEY$2);\n      $__default['default'].removeData(this._element, DATA_KEY$2);\n      this._items = null;\n      this._config = null;\n      this._element = null;\n      this._interval = null;\n      this._isPaused = null;\n      this._isSliding = null;\n      this._activeElement = null;\n      this._indicatorsElement = null;\n    } // Private\n    ;\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends({}, Default, config);\n      Util.typeCheckConfig(NAME$2, config, DefaultType);\n      return config;\n    };\n    _proto._handleSwipe = function _handleSwipe() {\n      var absDeltax = Math.abs(this.touchDeltaX);\n      if (absDeltax <= SWIPE_THRESHOLD) {\n        return;\n      }\n      var direction = absDeltax / this.touchDeltaX;\n      this.touchDeltaX = 0; // swipe left\n\n      if (direction > 0) {\n        this.prev();\n      } // swipe right\n\n      if (direction < 0) {\n        this.next();\n      }\n    };\n    _proto._addEventListeners = function _addEventListeners() {\n      var _this2 = this;\n      if (this._config.keyboard) {\n        $__default['default'](this._element).on(EVENT_KEYDOWN, function (event) {\n          return _this2._keydown(event);\n        });\n      }\n      if (this._config.pause === 'hover') {\n        $__default['default'](this._element).on(EVENT_MOUSEENTER, function (event) {\n          return _this2.pause(event);\n        }).on(EVENT_MOUSELEAVE, function (event) {\n          return _this2.cycle(event);\n        });\n      }\n      if (this._config.touch) {\n        this._addTouchEventListeners();\n      }\n    };\n    _proto._addTouchEventListeners = function _addTouchEventListeners() {\n      var _this3 = this;\n      if (!this._touchSupported) {\n        return;\n      }\n      var start = function start(event) {\n        if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {\n          _this3.touchStartX = event.originalEvent.clientX;\n        } else if (!_this3._pointerEvent) {\n          _this3.touchStartX = event.originalEvent.touches[0].clientX;\n        }\n      };\n      var move = function move(event) {\n        // ensure swiping with one touch and not pinching\n        if (event.originalEvent.touches && event.originalEvent.touches.length > 1) {\n          _this3.touchDeltaX = 0;\n        } else {\n          _this3.touchDeltaX = event.originalEvent.touches[0].clientX - _this3.touchStartX;\n        }\n      };\n      var end = function end(event) {\n        if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {\n          _this3.touchDeltaX = event.originalEvent.clientX - _this3.touchStartX;\n        }\n        _this3._handleSwipe();\n        if (_this3._config.pause === 'hover') {\n          // If it's a touch-enabled device, mouseenter/leave are fired as\n          // part of the mouse compatibility events on first tap - the carousel\n          // would stop cycling until user tapped out of it;\n          // here, we listen for touchend, explicitly pause the carousel\n          // (as if it's the second time we tap on it, mouseenter compat event\n          // is NOT fired) and after a timeout (to allow for mouse compatibility\n          // events to fire) we explicitly restart cycling\n          _this3.pause();\n          if (_this3.touchTimeout) {\n            clearTimeout(_this3.touchTimeout);\n          }\n          _this3.touchTimeout = setTimeout(function (event) {\n            return _this3.cycle(event);\n          }, TOUCHEVENT_COMPAT_WAIT + _this3._config.interval);\n        }\n      };\n      $__default['default'](this._element.querySelectorAll(SELECTOR_ITEM_IMG)).on(EVENT_DRAG_START, function (e) {\n        return e.preventDefault();\n      });\n      if (this._pointerEvent) {\n        $__default['default'](this._element).on(EVENT_POINTERDOWN, function (event) {\n          return start(event);\n        });\n        $__default['default'](this._element).on(EVENT_POINTERUP, function (event) {\n          return end(event);\n        });\n        this._element.classList.add(CLASS_NAME_POINTER_EVENT);\n      } else {\n        $__default['default'](this._element).on(EVENT_TOUCHSTART, function (event) {\n          return start(event);\n        });\n        $__default['default'](this._element).on(EVENT_TOUCHMOVE, function (event) {\n          return move(event);\n        });\n        $__default['default'](this._element).on(EVENT_TOUCHEND, function (event) {\n          return end(event);\n        });\n      }\n    };\n    _proto._keydown = function _keydown(event) {\n      if (/input|textarea/i.test(event.target.tagName)) {\n        return;\n      }\n      switch (event.which) {\n        case ARROW_LEFT_KEYCODE:\n          event.preventDefault();\n          this.prev();\n          break;\n        case ARROW_RIGHT_KEYCODE:\n          event.preventDefault();\n          this.next();\n          break;\n      }\n    };\n    _proto._getItemIndex = function _getItemIndex(element) {\n      this._items = element && element.parentNode ? [].slice.call(element.parentNode.querySelectorAll(SELECTOR_ITEM)) : [];\n      return this._items.indexOf(element);\n    };\n    _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {\n      var isNextDirection = direction === DIRECTION_NEXT;\n      var isPrevDirection = direction === DIRECTION_PREV;\n      var activeIndex = this._getItemIndex(activeElement);\n      var lastItemIndex = this._items.length - 1;\n      var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;\n      if (isGoingToWrap && !this._config.wrap) {\n        return activeElement;\n      }\n      var delta = direction === DIRECTION_PREV ? -1 : 1;\n      var itemIndex = (activeIndex + delta) % this._items.length;\n      return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];\n    };\n    _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {\n      var targetIndex = this._getItemIndex(relatedTarget);\n      var fromIndex = this._getItemIndex(this._element.querySelector(SELECTOR_ACTIVE_ITEM));\n      var slideEvent = $__default['default'].Event(EVENT_SLIDE, {\n        relatedTarget: relatedTarget,\n        direction: eventDirectionName,\n        from: fromIndex,\n        to: targetIndex\n      });\n      $__default['default'](this._element).trigger(slideEvent);\n      return slideEvent;\n    };\n    _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {\n      if (this._indicatorsElement) {\n        var indicators = [].slice.call(this._indicatorsElement.querySelectorAll(SELECTOR_ACTIVE$1));\n        $__default['default'](indicators).removeClass(CLASS_NAME_ACTIVE$1);\n        var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];\n        if (nextIndicator) {\n          $__default['default'](nextIndicator).addClass(CLASS_NAME_ACTIVE$1);\n        }\n      }\n    };\n    _proto._updateInterval = function _updateInterval() {\n      var element = this._activeElement || this._element.querySelector(SELECTOR_ACTIVE_ITEM);\n      if (!element) {\n        return;\n      }\n      var elementInterval = parseInt(element.getAttribute('data-interval'), 10);\n      if (elementInterval) {\n        this._config.defaultInterval = this._config.defaultInterval || this._config.interval;\n        this._config.interval = elementInterval;\n      } else {\n        this._config.interval = this._config.defaultInterval || this._config.interval;\n      }\n    };\n    _proto._slide = function _slide(direction, element) {\n      var _this4 = this;\n      var activeElement = this._element.querySelector(SELECTOR_ACTIVE_ITEM);\n      var activeElementIndex = this._getItemIndex(activeElement);\n      var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);\n      var nextElementIndex = this._getItemIndex(nextElement);\n      var isCycling = Boolean(this._interval);\n      var directionalClassName;\n      var orderClassName;\n      var eventDirectionName;\n      if (direction === DIRECTION_NEXT) {\n        directionalClassName = CLASS_NAME_LEFT;\n        orderClassName = CLASS_NAME_NEXT;\n        eventDirectionName = DIRECTION_LEFT;\n      } else {\n        directionalClassName = CLASS_NAME_RIGHT;\n        orderClassName = CLASS_NAME_PREV;\n        eventDirectionName = DIRECTION_RIGHT;\n      }\n      if (nextElement && $__default['default'](nextElement).hasClass(CLASS_NAME_ACTIVE$1)) {\n        this._isSliding = false;\n        return;\n      }\n      var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);\n      if (slideEvent.isDefaultPrevented()) {\n        return;\n      }\n      if (!activeElement || !nextElement) {\n        // Some weirdness is happening, so we bail\n        return;\n      }\n      this._isSliding = true;\n      if (isCycling) {\n        this.pause();\n      }\n      this._setActiveIndicatorElement(nextElement);\n      this._activeElement = nextElement;\n      var slidEvent = $__default['default'].Event(EVENT_SLID, {\n        relatedTarget: nextElement,\n        direction: eventDirectionName,\n        from: activeElementIndex,\n        to: nextElementIndex\n      });\n      if ($__default['default'](this._element).hasClass(CLASS_NAME_SLIDE)) {\n        $__default['default'](nextElement).addClass(orderClassName);\n        Util.reflow(nextElement);\n        $__default['default'](activeElement).addClass(directionalClassName);\n        $__default['default'](nextElement).addClass(directionalClassName);\n        var transitionDuration = Util.getTransitionDurationFromElement(activeElement);\n        $__default['default'](activeElement).one(Util.TRANSITION_END, function () {\n          $__default['default'](nextElement).removeClass(directionalClassName + \" \" + orderClassName).addClass(CLASS_NAME_ACTIVE$1);\n          $__default['default'](activeElement).removeClass(CLASS_NAME_ACTIVE$1 + \" \" + orderClassName + \" \" + directionalClassName);\n          _this4._isSliding = false;\n          setTimeout(function () {\n            return $__default['default'](_this4._element).trigger(slidEvent);\n          }, 0);\n        }).emulateTransitionEnd(transitionDuration);\n      } else {\n        $__default['default'](activeElement).removeClass(CLASS_NAME_ACTIVE$1);\n        $__default['default'](nextElement).addClass(CLASS_NAME_ACTIVE$1);\n        this._isSliding = false;\n        $__default['default'](this._element).trigger(slidEvent);\n      }\n      if (isCycling) {\n        this.cycle();\n      }\n    } // Static\n    ;\n\n    Carousel._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $__default['default'](this).data(DATA_KEY$2);\n        var _config = _extends({}, Default, $__default['default'](this).data());\n        if (_typeof(config) === 'object') {\n          _config = _extends({}, _config, config);\n        }\n        var action = typeof config === 'string' ? config : _config.slide;\n        if (!data) {\n          data = new Carousel(this, _config);\n          $__default['default'](this).data(DATA_KEY$2, data);\n        }\n        if (typeof config === 'number') {\n          data.to(config);\n        } else if (typeof action === 'string') {\n          if (typeof data[action] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + action + \"\\\"\");\n          }\n          data[action]();\n        } else if (_config.interval && _config.ride) {\n          data.pause();\n          data.cycle();\n        }\n      });\n    };\n    Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {\n      var selector = Util.getSelectorFromElement(this);\n      if (!selector) {\n        return;\n      }\n      var target = $__default['default'](selector)[0];\n      if (!target || !$__default['default'](target).hasClass(CLASS_NAME_CAROUSEL)) {\n        return;\n      }\n      var config = _extends({}, $__default['default'](target).data(), $__default['default'](this).data());\n      var slideIndex = this.getAttribute('data-slide-to');\n      if (slideIndex) {\n        config.interval = false;\n      }\n      Carousel._jQueryInterface.call($__default['default'](target), config);\n      if (slideIndex) {\n        $__default['default'](target).data(DATA_KEY$2).to(slideIndex);\n      }\n      event.preventDefault();\n    };\n    _createClass(Carousel, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$2;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }]);\n    return Carousel;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'](document).on(EVENT_CLICK_DATA_API$2, SELECTOR_DATA_SLIDE, Carousel._dataApiClickHandler);\n  $__default['default'](window).on(EVENT_LOAD_DATA_API$1, function () {\n    var carousels = [].slice.call(document.querySelectorAll(SELECTOR_DATA_RIDE));\n    for (var i = 0, len = carousels.length; i < len; i++) {\n      var $carousel = $__default['default'](carousels[i]);\n      Carousel._jQueryInterface.call($carousel, $carousel.data());\n    }\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'].fn[NAME$2] = Carousel._jQueryInterface;\n  $__default['default'].fn[NAME$2].Constructor = Carousel;\n  $__default['default'].fn[NAME$2].noConflict = function () {\n    $__default['default'].fn[NAME$2] = JQUERY_NO_CONFLICT$2;\n    return Carousel._jQueryInterface;\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$3 = 'collapse';\n  var VERSION$3 = '4.6.0';\n  var DATA_KEY$3 = 'bs.collapse';\n  var EVENT_KEY$3 = \".\" + DATA_KEY$3;\n  var DATA_API_KEY$3 = '.data-api';\n  var JQUERY_NO_CONFLICT$3 = $__default['default'].fn[NAME$3];\n  var Default$1 = {\n    toggle: true,\n    parent: ''\n  };\n  var DefaultType$1 = {\n    toggle: 'boolean',\n    parent: '(string|element)'\n  };\n  var EVENT_SHOW = \"show\" + EVENT_KEY$3;\n  var EVENT_SHOWN = \"shown\" + EVENT_KEY$3;\n  var EVENT_HIDE = \"hide\" + EVENT_KEY$3;\n  var EVENT_HIDDEN = \"hidden\" + EVENT_KEY$3;\n  var EVENT_CLICK_DATA_API$3 = \"click\" + EVENT_KEY$3 + DATA_API_KEY$3;\n  var CLASS_NAME_SHOW$1 = 'show';\n  var CLASS_NAME_COLLAPSE = 'collapse';\n  var CLASS_NAME_COLLAPSING = 'collapsing';\n  var CLASS_NAME_COLLAPSED = 'collapsed';\n  var DIMENSION_WIDTH = 'width';\n  var DIMENSION_HEIGHT = 'height';\n  var SELECTOR_ACTIVES = '.show, .collapsing';\n  var SELECTOR_DATA_TOGGLE$1 = '[data-toggle=\"collapse\"]';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Collapse = /*#__PURE__*/function () {\n    function Collapse(element, config) {\n      this._isTransitioning = false;\n      this._element = element;\n      this._config = this._getConfig(config);\n      this._triggerArray = [].slice.call(document.querySelectorAll(\"[data-toggle=\\\"collapse\\\"][href=\\\"#\" + element.id + \"\\\"],\" + (\"[data-toggle=\\\"collapse\\\"][data-target=\\\"#\" + element.id + \"\\\"]\")));\n      var toggleList = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE$1));\n      for (var i = 0, len = toggleList.length; i < len; i++) {\n        var elem = toggleList[i];\n        var selector = Util.getSelectorFromElement(elem);\n        var filterElement = [].slice.call(document.querySelectorAll(selector)).filter(function (foundElem) {\n          return foundElem === element;\n        });\n        if (selector !== null && filterElement.length > 0) {\n          this._selector = selector;\n          this._triggerArray.push(elem);\n        }\n      }\n      this._parent = this._config.parent ? this._getParent() : null;\n      if (!this._config.parent) {\n        this._addAriaAndCollapsedClass(this._element, this._triggerArray);\n      }\n      if (this._config.toggle) {\n        this.toggle();\n      }\n    } // Getters\n\n    var _proto = Collapse.prototype;\n\n    // Public\n    _proto.toggle = function toggle() {\n      if ($__default['default'](this._element).hasClass(CLASS_NAME_SHOW$1)) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    };\n    _proto.show = function show() {\n      var _this = this;\n      if (this._isTransitioning || $__default['default'](this._element).hasClass(CLASS_NAME_SHOW$1)) {\n        return;\n      }\n      var actives;\n      var activesData;\n      if (this._parent) {\n        actives = [].slice.call(this._parent.querySelectorAll(SELECTOR_ACTIVES)).filter(function (elem) {\n          if (typeof _this._config.parent === 'string') {\n            return elem.getAttribute('data-parent') === _this._config.parent;\n          }\n          return elem.classList.contains(CLASS_NAME_COLLAPSE);\n        });\n        if (actives.length === 0) {\n          actives = null;\n        }\n      }\n      if (actives) {\n        activesData = $__default['default'](actives).not(this._selector).data(DATA_KEY$3);\n        if (activesData && activesData._isTransitioning) {\n          return;\n        }\n      }\n      var startEvent = $__default['default'].Event(EVENT_SHOW);\n      $__default['default'](this._element).trigger(startEvent);\n      if (startEvent.isDefaultPrevented()) {\n        return;\n      }\n      if (actives) {\n        Collapse._jQueryInterface.call($__default['default'](actives).not(this._selector), 'hide');\n        if (!activesData) {\n          $__default['default'](actives).data(DATA_KEY$3, null);\n        }\n      }\n      var dimension = this._getDimension();\n      $__default['default'](this._element).removeClass(CLASS_NAME_COLLAPSE).addClass(CLASS_NAME_COLLAPSING);\n      this._element.style[dimension] = 0;\n      if (this._triggerArray.length) {\n        $__default['default'](this._triggerArray).removeClass(CLASS_NAME_COLLAPSED).attr('aria-expanded', true);\n      }\n      this.setTransitioning(true);\n      var complete = function complete() {\n        $__default['default'](_this._element).removeClass(CLASS_NAME_COLLAPSING).addClass(CLASS_NAME_COLLAPSE + \" \" + CLASS_NAME_SHOW$1);\n        _this._element.style[dimension] = '';\n        _this.setTransitioning(false);\n        $__default['default'](_this._element).trigger(EVENT_SHOWN);\n      };\n      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n      var scrollSize = \"scroll\" + capitalizedDimension;\n      var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n      $__default['default'](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      this._element.style[dimension] = this._element[scrollSize] + \"px\";\n    };\n    _proto.hide = function hide() {\n      var _this2 = this;\n      if (this._isTransitioning || !$__default['default'](this._element).hasClass(CLASS_NAME_SHOW$1)) {\n        return;\n      }\n      var startEvent = $__default['default'].Event(EVENT_HIDE);\n      $__default['default'](this._element).trigger(startEvent);\n      if (startEvent.isDefaultPrevented()) {\n        return;\n      }\n      var dimension = this._getDimension();\n      this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + \"px\";\n      Util.reflow(this._element);\n      $__default['default'](this._element).addClass(CLASS_NAME_COLLAPSING).removeClass(CLASS_NAME_COLLAPSE + \" \" + CLASS_NAME_SHOW$1);\n      var triggerArrayLength = this._triggerArray.length;\n      if (triggerArrayLength > 0) {\n        for (var i = 0; i < triggerArrayLength; i++) {\n          var trigger = this._triggerArray[i];\n          var selector = Util.getSelectorFromElement(trigger);\n          if (selector !== null) {\n            var $elem = $__default['default']([].slice.call(document.querySelectorAll(selector)));\n            if (!$elem.hasClass(CLASS_NAME_SHOW$1)) {\n              $__default['default'](trigger).addClass(CLASS_NAME_COLLAPSED).attr('aria-expanded', false);\n            }\n          }\n        }\n      }\n      this.setTransitioning(true);\n      var complete = function complete() {\n        _this2.setTransitioning(false);\n        $__default['default'](_this2._element).removeClass(CLASS_NAME_COLLAPSING).addClass(CLASS_NAME_COLLAPSE).trigger(EVENT_HIDDEN);\n      };\n      this._element.style[dimension] = '';\n      var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n      $__default['default'](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n    };\n    _proto.setTransitioning = function setTransitioning(isTransitioning) {\n      this._isTransitioning = isTransitioning;\n    };\n    _proto.dispose = function dispose() {\n      $__default['default'].removeData(this._element, DATA_KEY$3);\n      this._config = null;\n      this._parent = null;\n      this._element = null;\n      this._triggerArray = null;\n      this._isTransitioning = null;\n    } // Private\n    ;\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends({}, Default$1, config);\n      config.toggle = Boolean(config.toggle); // Coerce string values\n\n      Util.typeCheckConfig(NAME$3, config, DefaultType$1);\n      return config;\n    };\n    _proto._getDimension = function _getDimension() {\n      var hasWidth = $__default['default'](this._element).hasClass(DIMENSION_WIDTH);\n      return hasWidth ? DIMENSION_WIDTH : DIMENSION_HEIGHT;\n    };\n    _proto._getParent = function _getParent() {\n      var _this3 = this;\n      var parent;\n      if (Util.isElement(this._config.parent)) {\n        parent = this._config.parent; // It's a jQuery object\n\n        if (typeof this._config.parent.jquery !== 'undefined') {\n          parent = this._config.parent[0];\n        }\n      } else {\n        parent = document.querySelector(this._config.parent);\n      }\n      var selector = \"[data-toggle=\\\"collapse\\\"][data-parent=\\\"\" + this._config.parent + \"\\\"]\";\n      var children = [].slice.call(parent.querySelectorAll(selector));\n      $__default['default'](children).each(function (i, element) {\n        _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);\n      });\n      return parent;\n    };\n    _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {\n      var isOpen = $__default['default'](element).hasClass(CLASS_NAME_SHOW$1);\n      if (triggerArray.length) {\n        $__default['default'](triggerArray).toggleClass(CLASS_NAME_COLLAPSED, !isOpen).attr('aria-expanded', isOpen);\n      }\n    } // Static\n    ;\n\n    Collapse._getTargetFromElement = function _getTargetFromElement(element) {\n      var selector = Util.getSelectorFromElement(element);\n      return selector ? document.querySelector(selector) : null;\n    };\n    Collapse._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = $__default['default'](this);\n        var data = $element.data(DATA_KEY$3);\n        var _config = _extends({}, Default$1, $element.data(), _typeof(config) === 'object' && config ? config : {});\n        if (!data && _config.toggle && typeof config === 'string' && /show|hide/.test(config)) {\n          _config.toggle = false;\n        }\n        if (!data) {\n          data = new Collapse(this, _config);\n          $element.data(DATA_KEY$3, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n          data[config]();\n        }\n      });\n    };\n    _createClass(Collapse, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$3;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$1;\n      }\n    }]);\n    return Collapse;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'](document).on(EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$1, function (event) {\n    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\n    if (event.currentTarget.tagName === 'A') {\n      event.preventDefault();\n    }\n    var $trigger = $__default['default'](this);\n    var selector = Util.getSelectorFromElement(this);\n    var selectors = [].slice.call(document.querySelectorAll(selector));\n    $__default['default'](selectors).each(function () {\n      var $target = $__default['default'](this);\n      var data = $target.data(DATA_KEY$3);\n      var config = data ? 'toggle' : $trigger.data();\n      Collapse._jQueryInterface.call($target, config);\n    });\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'].fn[NAME$3] = Collapse._jQueryInterface;\n  $__default['default'].fn[NAME$3].Constructor = Collapse;\n  $__default['default'].fn[NAME$3].noConflict = function () {\n    $__default['default'].fn[NAME$3] = JQUERY_NO_CONFLICT$3;\n    return Collapse._jQueryInterface;\n  };\n\n  /**!\n   * @fileOverview Kickass library to create and place poppers near their reference elements.\n   * @version 1.16.1\n   * @license\n   * Copyright (c) 2016 Federico Zivolo and contributors\n   *\n   * Permission is hereby granted, free of charge, to any person obtaining a copy\n   * of this software and associated documentation files (the \"Software\"), to deal\n   * in the Software without restriction, including without limitation the rights\n   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   * copies of the Software, and to permit persons to whom the Software is\n   * furnished to do so, subject to the following conditions:\n   *\n   * The above copyright notice and this permission notice shall be included in all\n   * copies or substantial portions of the Software.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   * SOFTWARE.\n   */\n  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';\n  var timeoutDuration = function () {\n    var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\n    for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n      if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n        return 1;\n      }\n    }\n    return 0;\n  }();\n  function microtaskDebounce(fn) {\n    var called = false;\n    return function () {\n      if (called) {\n        return;\n      }\n      called = true;\n      window.Promise.resolve().then(function () {\n        called = false;\n        fn();\n      });\n    };\n  }\n  function taskDebounce(fn) {\n    var scheduled = false;\n    return function () {\n      if (!scheduled) {\n        scheduled = true;\n        setTimeout(function () {\n          scheduled = false;\n          fn();\n        }, timeoutDuration);\n      }\n    };\n  }\n  var supportsMicroTasks = isBrowser && window.Promise;\n\n  /**\n  * Create a debounced version of a method, that's asynchronously deferred\n  * but called in the minimum time possible.\n  *\n  * @method\n  * @memberof Popper.Utils\n  * @argument {Function} fn\n  * @returns {Function}\n  */\n  var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;\n\n  /**\n   * Check if the given variable is a function\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Any} functionToCheck - variable to check\n   * @returns {Boolean} answer to: is a function?\n   */\n  function isFunction(functionToCheck) {\n    var getType = {};\n    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n  }\n\n  /**\n   * Get CSS computed property of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Eement} element\n   * @argument {String} property\n   */\n  function getStyleComputedProperty(element, property) {\n    if (element.nodeType !== 1) {\n      return [];\n    }\n    // NOTE: 1 DOM access here\n    var window = element.ownerDocument.defaultView;\n    var css = window.getComputedStyle(element, null);\n    return property ? css[property] : css;\n  }\n\n  /**\n   * Returns the parentNode or the host of the element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} parent\n   */\n  function getParentNode(element) {\n    if (element.nodeName === 'HTML') {\n      return element;\n    }\n    return element.parentNode || element.host;\n  }\n\n  /**\n   * Returns the scrolling parent of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} scroll parent\n   */\n  function getScrollParent(element) {\n    // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n    if (!element) {\n      return document.body;\n    }\n    switch (element.nodeName) {\n      case 'HTML':\n      case 'BODY':\n        return element.ownerDocument.body;\n      case '#document':\n        return element.body;\n    }\n\n    // Firefox want us to check `-x` and `-y` variations as well\n\n    var _getStyleComputedProp = getStyleComputedProperty(element),\n      overflow = _getStyleComputedProp.overflow,\n      overflowX = _getStyleComputedProp.overflowX,\n      overflowY = _getStyleComputedProp.overflowY;\n    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n      return element;\n    }\n    return getScrollParent(getParentNode(element));\n  }\n\n  /**\n   * Returns the reference node of the reference object, or the reference object itself.\n   * @method\n   * @memberof Popper.Utils\n   * @param {Element|Object} reference - the reference element (the popper will be relative to this)\n   * @returns {Element} parent\n   */\n  function getReferenceNode(reference) {\n    return reference && reference.referenceNode ? reference.referenceNode : reference;\n  }\n  var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\n  var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n  /**\n   * Determines if the browser is Internet Explorer\n   * @method\n   * @memberof Popper.Utils\n   * @param {Number} version to check\n   * @returns {Boolean} isIE\n   */\n  function isIE(version) {\n    if (version === 11) {\n      return isIE11;\n    }\n    if (version === 10) {\n      return isIE10;\n    }\n    return isIE11 || isIE10;\n  }\n\n  /**\n   * Returns the offset parent of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} offset parent\n   */\n  function getOffsetParent(element) {\n    if (!element) {\n      return document.documentElement;\n    }\n    var noOffsetParent = isIE(10) ? document.body : null;\n\n    // NOTE: 1 DOM access here\n    var offsetParent = element.offsetParent || null;\n    // Skip hidden elements which don't have an offsetParent\n    while (offsetParent === noOffsetParent && element.nextElementSibling) {\n      offsetParent = (element = element.nextElementSibling).offsetParent;\n    }\n    var nodeName = offsetParent && offsetParent.nodeName;\n    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n      return element ? element.ownerDocument.documentElement : document.documentElement;\n    }\n\n    // .offsetParent will return the closest TH, TD or TABLE in case\n    // no offsetParent is present, I hate this job...\n    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n      return getOffsetParent(offsetParent);\n    }\n    return offsetParent;\n  }\n  function isOffsetContainer(element) {\n    var nodeName = element.nodeName;\n    if (nodeName === 'BODY') {\n      return false;\n    }\n    return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n  }\n\n  /**\n   * Finds the root node (document, shadowDOM root) of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} node\n   * @returns {Element} root node\n   */\n  function getRoot(node) {\n    if (node.parentNode !== null) {\n      return getRoot(node.parentNode);\n    }\n    return node;\n  }\n\n  /**\n   * Finds the offset parent common to the two provided nodes\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element1\n   * @argument {Element} element2\n   * @returns {Element} common offset parent\n   */\n  function findCommonOffsetParent(element1, element2) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n      return document.documentElement;\n    }\n\n    // Here we make sure to give as \"start\" the element that comes first in the DOM\n    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n    var start = order ? element1 : element2;\n    var end = order ? element2 : element1;\n\n    // Get common ancestor container\n    var range = document.createRange();\n    range.setStart(start, 0);\n    range.setEnd(end, 0);\n    var commonAncestorContainer = range.commonAncestorContainer;\n\n    // Both nodes are inside #document\n\n    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n      if (isOffsetContainer(commonAncestorContainer)) {\n        return commonAncestorContainer;\n      }\n      return getOffsetParent(commonAncestorContainer);\n    }\n\n    // one of the nodes is inside shadowDOM, find which one\n    var element1root = getRoot(element1);\n    if (element1root.host) {\n      return findCommonOffsetParent(element1root.host, element2);\n    } else {\n      return findCommonOffsetParent(element1, getRoot(element2).host);\n    }\n  }\n\n  /**\n   * Gets the scroll value of the given element in the given side (top and left)\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @argument {String} side `top` or `left`\n   * @returns {number} amount of scrolled pixels\n   */\n  function getScroll(element) {\n    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n    var nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n      var html = element.ownerDocument.documentElement;\n      var scrollingElement = element.ownerDocument.scrollingElement || html;\n      return scrollingElement[upperSide];\n    }\n    return element[upperSide];\n  }\n\n  /*\n   * Sum or subtract the element scroll values (left and top) from a given rect object\n   * @method\n   * @memberof Popper.Utils\n   * @param {Object} rect - Rect object you want to change\n   * @param {HTMLElement} element - The element from the function reads the scroll values\n   * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n   * @return {Object} rect - The modifier rect object\n   */\n  function includeScroll(rect, element) {\n    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var scrollTop = getScroll(element, 'top');\n    var scrollLeft = getScroll(element, 'left');\n    var modifier = subtract ? -1 : 1;\n    rect.top += scrollTop * modifier;\n    rect.bottom += scrollTop * modifier;\n    rect.left += scrollLeft * modifier;\n    rect.right += scrollLeft * modifier;\n    return rect;\n  }\n\n  /*\n   * Helper to detect borders of a given element\n   * @method\n   * @memberof Popper.Utils\n   * @param {CSSStyleDeclaration} styles\n   * Result of `getStyleComputedProperty` on the given element\n   * @param {String} axis - `x` or `y`\n   * @return {number} borders - The borders size of the given axis\n   */\n\n  function getBordersSize(styles, axis) {\n    var sideA = axis === 'x' ? 'Left' : 'Top';\n    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n    return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);\n  }\n  function getSize(axis, body, html, computedStyle) {\n    return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);\n  }\n  function getWindowSizes(document) {\n    var body = document.body;\n    var html = document.documentElement;\n    var computedStyle = isIE(10) && getComputedStyle(html);\n    return {\n      height: getSize('Height', body, html, computedStyle),\n      width: getSize('Width', body, html, computedStyle)\n    };\n  }\n  var classCallCheck = function classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n  var createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n  var defineProperty = function defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  };\n  var _extends$1 = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n\n  /**\n   * Given element offsets, generate an output similar to getBoundingClientRect\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Object} offsets\n   * @returns {Object} ClientRect like output\n   */\n  function getClientRect(offsets) {\n    return _extends$1({}, offsets, {\n      right: offsets.left + offsets.width,\n      bottom: offsets.top + offsets.height\n    });\n  }\n\n  /**\n   * Get bounding client rect of given element\n   * @method\n   * @memberof Popper.Utils\n   * @param {HTMLElement} element\n   * @return {Object} client rect\n   */\n  function getBoundingClientRect(element) {\n    var rect = {};\n\n    // IE10 10 FIX: Please, don't ask, the element isn't\n    // considered in DOM in some circumstances...\n    // This isn't reproducible in IE10 compatibility mode of IE11\n    try {\n      if (isIE(10)) {\n        rect = element.getBoundingClientRect();\n        var scrollTop = getScroll(element, 'top');\n        var scrollLeft = getScroll(element, 'left');\n        rect.top += scrollTop;\n        rect.left += scrollLeft;\n        rect.bottom += scrollTop;\n        rect.right += scrollLeft;\n      } else {\n        rect = element.getBoundingClientRect();\n      }\n    } catch (e) {}\n    var result = {\n      left: rect.left,\n      top: rect.top,\n      width: rect.right - rect.left,\n      height: rect.bottom - rect.top\n    };\n\n    // subtract scrollbar size from sizes\n    var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n    var width = sizes.width || element.clientWidth || result.width;\n    var height = sizes.height || element.clientHeight || result.height;\n    var horizScrollbar = element.offsetWidth - width;\n    var vertScrollbar = element.offsetHeight - height;\n\n    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n    // we make this check conditional for performance reasons\n    if (horizScrollbar || vertScrollbar) {\n      var styles = getStyleComputedProperty(element);\n      horizScrollbar -= getBordersSize(styles, 'x');\n      vertScrollbar -= getBordersSize(styles, 'y');\n      result.width -= horizScrollbar;\n      result.height -= vertScrollbar;\n    }\n    return getClientRect(result);\n  }\n  function getOffsetRectRelativeToArbitraryNode(children, parent) {\n    var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var isIE10 = isIE(10);\n    var isHTML = parent.nodeName === 'HTML';\n    var childrenRect = getBoundingClientRect(children);\n    var parentRect = getBoundingClientRect(parent);\n    var scrollParent = getScrollParent(children);\n    var styles = getStyleComputedProperty(parent);\n    var borderTopWidth = parseFloat(styles.borderTopWidth);\n    var borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n    // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n    if (fixedPosition && isHTML) {\n      parentRect.top = Math.max(parentRect.top, 0);\n      parentRect.left = Math.max(parentRect.left, 0);\n    }\n    var offsets = getClientRect({\n      top: childrenRect.top - parentRect.top - borderTopWidth,\n      left: childrenRect.left - parentRect.left - borderLeftWidth,\n      width: childrenRect.width,\n      height: childrenRect.height\n    });\n    offsets.marginTop = 0;\n    offsets.marginLeft = 0;\n\n    // Subtract margins of documentElement in case it's being used as parent\n    // we do this only on HTML because it's the only element that behaves\n    // differently when margins are applied to it. The margins are included in\n    // the box of the documentElement, in the other cases not.\n    if (!isIE10 && isHTML) {\n      var marginTop = parseFloat(styles.marginTop);\n      var marginLeft = parseFloat(styles.marginLeft);\n      offsets.top -= borderTopWidth - marginTop;\n      offsets.bottom -= borderTopWidth - marginTop;\n      offsets.left -= borderLeftWidth - marginLeft;\n      offsets.right -= borderLeftWidth - marginLeft;\n\n      // Attach marginTop and marginLeft because in some circumstances we may need them\n      offsets.marginTop = marginTop;\n      offsets.marginLeft = marginLeft;\n    }\n    if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n      offsets = includeScroll(offsets, parent);\n    }\n    return offsets;\n  }\n  function getViewportOffsetRectRelativeToArtbitraryNode(element) {\n    var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var html = element.ownerDocument.documentElement;\n    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n    var width = Math.max(html.clientWidth, window.innerWidth || 0);\n    var height = Math.max(html.clientHeight, window.innerHeight || 0);\n    var scrollTop = !excludeScroll ? getScroll(html) : 0;\n    var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n    var offset = {\n      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n      width: width,\n      height: height\n    };\n    return getClientRect(offset);\n  }\n\n  /**\n   * Check if the given element is fixed or is inside a fixed parent\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @argument {Element} customContainer\n   * @returns {Boolean} answer to \"isFixed?\"\n   */\n  function isFixed(element) {\n    var nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n      return false;\n    }\n    if (getStyleComputedProperty(element, 'position') === 'fixed') {\n      return true;\n    }\n    var parentNode = getParentNode(element);\n    if (!parentNode) {\n      return false;\n    }\n    return isFixed(parentNode);\n  }\n\n  /**\n   * Finds the first parent of an element that has a transformed property defined\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} first transformed parent or documentElement\n   */\n\n  function getFixedPositionOffsetParent(element) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element || !element.parentElement || isIE()) {\n      return document.documentElement;\n    }\n    var el = element.parentElement;\n    while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n      el = el.parentElement;\n    }\n    return el || document.documentElement;\n  }\n\n  /**\n   * Computed the boundaries limits and return them\n   * @method\n   * @memberof Popper.Utils\n   * @param {HTMLElement} popper\n   * @param {HTMLElement} reference\n   * @param {number} padding\n   * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n   * @param {Boolean} fixedPosition - Is in fixed position mode\n   * @returns {Object} Coordinates of the boundaries\n   */\n  function getBoundaries(popper, reference, padding, boundariesElement) {\n    var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n    // NOTE: 1 DOM access here\n\n    var boundaries = {\n      top: 0,\n      left: 0\n    };\n    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n    // Handle viewport case\n    if (boundariesElement === 'viewport') {\n      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n    } else {\n      // Handle other cases based on DOM element used as boundaries\n      var boundariesNode = void 0;\n      if (boundariesElement === 'scrollParent') {\n        boundariesNode = getScrollParent(getParentNode(reference));\n        if (boundariesNode.nodeName === 'BODY') {\n          boundariesNode = popper.ownerDocument.documentElement;\n        }\n      } else if (boundariesElement === 'window') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      } else {\n        boundariesNode = boundariesElement;\n      }\n      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n\n      // In case of HTML, we need a different computation\n      if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n        var _getWindowSizes = getWindowSizes(popper.ownerDocument),\n          height = _getWindowSizes.height,\n          width = _getWindowSizes.width;\n        boundaries.top += offsets.top - offsets.marginTop;\n        boundaries.bottom = height + offsets.top;\n        boundaries.left += offsets.left - offsets.marginLeft;\n        boundaries.right = width + offsets.left;\n      } else {\n        // for all the other DOM elements, this one is good\n        boundaries = offsets;\n      }\n    }\n\n    // Add paddings\n    padding = padding || 0;\n    var isPaddingNumber = typeof padding === 'number';\n    boundaries.left += isPaddingNumber ? padding : padding.left || 0;\n    boundaries.top += isPaddingNumber ? padding : padding.top || 0;\n    boundaries.right -= isPaddingNumber ? padding : padding.right || 0;\n    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;\n    return boundaries;\n  }\n  function getArea(_ref) {\n    var width = _ref.width,\n      height = _ref.height;\n    return width * height;\n  }\n\n  /**\n   * Utility used to transform the `auto` placement to the placement with more\n   * available space.\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    if (placement.indexOf('auto') === -1) {\n      return placement;\n    }\n    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n    var rects = {\n      top: {\n        width: boundaries.width,\n        height: refRect.top - boundaries.top\n      },\n      right: {\n        width: boundaries.right - refRect.right,\n        height: boundaries.height\n      },\n      bottom: {\n        width: boundaries.width,\n        height: boundaries.bottom - refRect.bottom\n      },\n      left: {\n        width: refRect.left - boundaries.left,\n        height: boundaries.height\n      }\n    };\n    var sortedAreas = Object.keys(rects).map(function (key) {\n      return _extends$1({\n        key: key\n      }, rects[key], {\n        area: getArea(rects[key])\n      });\n    }).sort(function (a, b) {\n      return b.area - a.area;\n    });\n    var filteredAreas = sortedAreas.filter(function (_ref2) {\n      var width = _ref2.width,\n        height = _ref2.height;\n      return width >= popper.clientWidth && height >= popper.clientHeight;\n    });\n    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n    var variation = placement.split('-')[1];\n    return computedPlacement + (variation ? '-' + variation : '');\n  }\n\n  /**\n   * Get offsets to the reference element\n   * @method\n   * @memberof Popper.Utils\n   * @param {Object} state\n   * @param {Element} popper - the popper element\n   * @param {Element} reference - the reference element (the popper will be relative to this)\n   * @param {Element} fixedPosition - is in fixed position mode\n   * @returns {Object} An object containing the offsets which will be applied to the popper\n   */\n  function getReferenceOffsets(state, popper, reference) {\n    var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n  }\n\n  /**\n   * Get the outer sizes of the given element (offset size + margins)\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Object} object containing width and height properties\n   */\n  function getOuterSizes(element) {\n    var window = element.ownerDocument.defaultView;\n    var styles = window.getComputedStyle(element);\n    var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n    var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n    var result = {\n      width: element.offsetWidth + y,\n      height: element.offsetHeight + x\n    };\n    return result;\n  }\n\n  /**\n   * Get the opposite placement of the given one\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} placement\n   * @returns {String} flipped placement\n   */\n  function getOppositePlacement(placement) {\n    var hash = {\n      left: 'right',\n      right: 'left',\n      bottom: 'top',\n      top: 'bottom'\n    };\n    return placement.replace(/left|right|bottom|top/g, function (matched) {\n      return hash[matched];\n    });\n  }\n\n  /**\n   * Get offsets to the popper\n   * @method\n   * @memberof Popper.Utils\n   * @param {Object} position - CSS position the Popper will get applied\n   * @param {HTMLElement} popper - the popper element\n   * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n   * @param {String} placement - one of the valid placement options\n   * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n   */\n  function getPopperOffsets(popper, referenceOffsets, placement) {\n    placement = placement.split('-')[0];\n\n    // Get popper node sizes\n    var popperRect = getOuterSizes(popper);\n\n    // Add position, width and height to our offsets object\n    var popperOffsets = {\n      width: popperRect.width,\n      height: popperRect.height\n    };\n\n    // depending by the popper placement we have to compute its offsets slightly differently\n    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n    var mainSide = isHoriz ? 'top' : 'left';\n    var secondarySide = isHoriz ? 'left' : 'top';\n    var measurement = isHoriz ? 'height' : 'width';\n    var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n    if (placement === secondarySide) {\n      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n    } else {\n      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n    }\n    return popperOffsets;\n  }\n\n  /**\n   * Mimics the `find` method of Array\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Array} arr\n   * @argument prop\n   * @argument value\n   * @returns index or -1\n   */\n  function find(arr, check) {\n    // use native find if supported\n    if (Array.prototype.find) {\n      return arr.find(check);\n    }\n\n    // use `filter` to obtain the same behavior of `find`\n    return arr.filter(check)[0];\n  }\n\n  /**\n   * Return the index of the matching object\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Array} arr\n   * @argument prop\n   * @argument value\n   * @returns index or -1\n   */\n  function findIndex(arr, prop, value) {\n    // use native findIndex if supported\n    if (Array.prototype.findIndex) {\n      return arr.findIndex(function (cur) {\n        return cur[prop] === value;\n      });\n    }\n\n    // use `find` + `indexOf` if `findIndex` isn't supported\n    var match = find(arr, function (obj) {\n      return obj[prop] === value;\n    });\n    return arr.indexOf(match);\n  }\n\n  /**\n   * Loop trough the list of modifiers and run them in order,\n   * each of them will then edit the data object.\n   * @method\n   * @memberof Popper.Utils\n   * @param {dataObject} data\n   * @param {Array} modifiers\n   * @param {String} ends - Optional modifier name used as stopper\n   * @returns {dataObject}\n   */\n  function runModifiers(modifiers, data, ends) {\n    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n    modifiersToRun.forEach(function (modifier) {\n      if (modifier['function']) {\n        // eslint-disable-line dot-notation\n        console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n      }\n      var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation\n      if (modifier.enabled && isFunction(fn)) {\n        // Add properties to offsets to make them a complete clientRect object\n        // we do this before each modifier to make sure the previous one doesn't\n        // mess with these values\n        data.offsets.popper = getClientRect(data.offsets.popper);\n        data.offsets.reference = getClientRect(data.offsets.reference);\n        data = fn(data, modifier);\n      }\n    });\n    return data;\n  }\n\n  /**\n   * Updates the position of the popper, computing the new offsets and applying\n   * the new style.<br />\n   * Prefer `scheduleUpdate` over `update` because of performance reasons.\n   * @method\n   * @memberof Popper\n   */\n  function update() {\n    // if popper is destroyed, don't perform any further update\n    if (this.state.isDestroyed) {\n      return;\n    }\n    var data = {\n      instance: this,\n      styles: {},\n      arrowStyles: {},\n      attributes: {},\n      flipped: false,\n      offsets: {}\n    };\n\n    // compute reference element offsets\n    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);\n\n    // compute auto placement, store placement inside the data object,\n    // modifiers will be able to edit `placement` if needed\n    // and refer to originalPlacement to know the original value\n    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\n\n    // store the computed placement inside `originalPlacement`\n    data.originalPlacement = data.placement;\n    data.positionFixed = this.options.positionFixed;\n\n    // compute the popper offsets\n    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\n    data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';\n\n    // run the modifiers\n    data = runModifiers(this.modifiers, data);\n\n    // the first `update` will call `onCreate` callback\n    // the other ones will call `onUpdate` callback\n    if (!this.state.isCreated) {\n      this.state.isCreated = true;\n      this.options.onCreate(data);\n    } else {\n      this.options.onUpdate(data);\n    }\n  }\n\n  /**\n   * Helper used to know if the given modifier is enabled.\n   * @method\n   * @memberof Popper.Utils\n   * @returns {Boolean}\n   */\n  function isModifierEnabled(modifiers, modifierName) {\n    return modifiers.some(function (_ref) {\n      var name = _ref.name,\n        enabled = _ref.enabled;\n      return enabled && name === modifierName;\n    });\n  }\n\n  /**\n   * Get the prefixed supported property name\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} property (camelCase)\n   * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n   */\n  function getSupportedPropertyName(property) {\n    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n    for (var i = 0; i < prefixes.length; i++) {\n      var prefix = prefixes[i];\n      var toCheck = prefix ? '' + prefix + upperProp : property;\n      if (typeof document.body.style[toCheck] !== 'undefined') {\n        return toCheck;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Destroys the popper.\n   * @method\n   * @memberof Popper\n   */\n  function destroy() {\n    this.state.isDestroyed = true;\n\n    // touch DOM only if `applyStyle` modifier is enabled\n    if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n      this.popper.removeAttribute('x-placement');\n      this.popper.style.position = '';\n      this.popper.style.top = '';\n      this.popper.style.left = '';\n      this.popper.style.right = '';\n      this.popper.style.bottom = '';\n      this.popper.style.willChange = '';\n      this.popper.style[getSupportedPropertyName('transform')] = '';\n    }\n    this.disableEventListeners();\n\n    // remove the popper if user explicitly asked for the deletion on destroy\n    // do not use `remove` because IE11 doesn't support it\n    if (this.options.removeOnDestroy) {\n      this.popper.parentNode.removeChild(this.popper);\n    }\n    return this;\n  }\n\n  /**\n   * Get the window associated with the element\n   * @argument {Element} element\n   * @returns {Window}\n   */\n  function getWindow(element) {\n    var ownerDocument = element.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView : window;\n  }\n  function attachToScrollParents(scrollParent, event, callback, scrollParents) {\n    var isBody = scrollParent.nodeName === 'BODY';\n    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n    target.addEventListener(event, callback, {\n      passive: true\n    });\n    if (!isBody) {\n      attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n    }\n    scrollParents.push(target);\n  }\n\n  /**\n   * Setup needed event listeners used to update the popper position\n   * @method\n   * @memberof Popper.Utils\n   * @private\n   */\n  function setupEventListeners(reference, options, state, updateBound) {\n    // Resize event listener on window\n    state.updateBound = updateBound;\n    getWindow(reference).addEventListener('resize', state.updateBound, {\n      passive: true\n    });\n\n    // Scroll event listener on scroll parents\n    var scrollElement = getScrollParent(reference);\n    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n    state.scrollElement = scrollElement;\n    state.eventsEnabled = true;\n    return state;\n  }\n\n  /**\n   * It will add resize/scroll events and start recalculating\n   * position of the popper element when they are triggered.\n   * @method\n   * @memberof Popper\n   */\n  function enableEventListeners() {\n    if (!this.state.eventsEnabled) {\n      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n    }\n  }\n\n  /**\n   * Remove event listeners used to update the popper position\n   * @method\n   * @memberof Popper.Utils\n   * @private\n   */\n  function removeEventListeners(reference, state) {\n    // Remove resize event listener on window\n    getWindow(reference).removeEventListener('resize', state.updateBound);\n\n    // Remove scroll event listener on scroll parents\n    state.scrollParents.forEach(function (target) {\n      target.removeEventListener('scroll', state.updateBound);\n    });\n\n    // Reset state\n    state.updateBound = null;\n    state.scrollParents = [];\n    state.scrollElement = null;\n    state.eventsEnabled = false;\n    return state;\n  }\n\n  /**\n   * It will remove resize/scroll events and won't recalculate popper position\n   * when they are triggered. It also won't trigger `onUpdate` callback anymore,\n   * unless you call `update` method manually.\n   * @method\n   * @memberof Popper\n   */\n  function disableEventListeners() {\n    if (this.state.eventsEnabled) {\n      cancelAnimationFrame(this.scheduleUpdate);\n      this.state = removeEventListeners(this.reference, this.state);\n    }\n  }\n\n  /**\n   * Tells if a given input is a number\n   * @method\n   * @memberof Popper.Utils\n   * @param {*} input to check\n   * @return {Boolean}\n   */\n  function isNumeric(n) {\n    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  /**\n   * Set the style to the given popper\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element - Element to apply the style to\n   * @argument {Object} styles\n   * Object with a list of properties and values which will be applied to the element\n   */\n  function setStyles(element, styles) {\n    Object.keys(styles).forEach(function (prop) {\n      var unit = '';\n      // add unit if the value is numeric and is one of the following\n      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n        unit = 'px';\n      }\n      element.style[prop] = styles[prop] + unit;\n    });\n  }\n\n  /**\n   * Set the attributes to the given popper\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element - Element to apply the attributes to\n   * @argument {Object} styles\n   * Object with a list of properties and values which will be applied to the element\n   */\n  function setAttributes(element, attributes) {\n    Object.keys(attributes).forEach(function (prop) {\n      var value = attributes[prop];\n      if (value !== false) {\n        element.setAttribute(prop, attributes[prop]);\n      } else {\n        element.removeAttribute(prop);\n      }\n    });\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} data.styles - List of style properties - values to apply to popper element\n   * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The same data object\n   */\n  function applyStyle(data) {\n    // any property present in `data.styles` will be applied to the popper,\n    // in this way we can make the 3rd party modifiers add custom styles to it\n    // Be aware, modifiers could override the properties defined in the previous\n    // lines of this modifier!\n    setStyles(data.instance.popper, data.styles);\n\n    // any property present in `data.attributes` will be applied to the popper,\n    // they will be set as HTML attributes of the element\n    setAttributes(data.instance.popper, data.attributes);\n\n    // if arrowElement is defined and arrowStyles has some properties\n    if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n      setStyles(data.arrowElement, data.arrowStyles);\n    }\n    return data;\n  }\n\n  /**\n   * Set the x-placement attribute before everything else because it could be used\n   * to add margins to the popper margins needs to be calculated to get the\n   * correct popper offsets.\n   * @method\n   * @memberof Popper.modifiers\n   * @param {HTMLElement} reference - The reference element used to position the popper\n   * @param {HTMLElement} popper - The HTML element used as popper\n   * @param {Object} options - Popper.js options\n   */\n  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n    // compute reference element offsets\n    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\n\n    // compute auto placement, store placement inside the data object,\n    // modifiers will be able to edit `placement` if needed\n    // and refer to originalPlacement to know the original value\n    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n    popper.setAttribute('x-placement', placement);\n\n    // Apply `position` to popper before anything else because\n    // without the position applied we can't guarantee correct computations\n    setStyles(popper, {\n      position: options.positionFixed ? 'fixed' : 'absolute'\n    });\n    return options;\n  }\n\n  /**\n   * @function\n   * @memberof Popper.Utils\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Boolean} shouldRound - If the offsets should be rounded at all\n   * @returns {Object} The popper's position offsets rounded\n   *\n   * The tale of pixel-perfect positioning. It's still not 100% perfect, but as\n   * good as it can be within reason.\n   * Discussion here: https://github.com/FezVrasta/popper.js/pull/715\n   *\n   * Low DPI screens cause a popper to be blurry if not using full pixels (Safari\n   * as well on High DPI screens).\n   *\n   * Firefox prefers no rounding for positioning and does not have blurriness on\n   * high DPI screens.\n   *\n   * Only horizontal placement and left/right values need to be considered.\n   */\n  function getRoundedOffsets(data, shouldRound) {\n    var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n    var round = Math.round,\n      floor = Math.floor;\n    var noRound = function noRound(v) {\n      return v;\n    };\n    var referenceWidth = round(reference.width);\n    var popperWidth = round(popper.width);\n    var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;\n    var isVariation = data.placement.indexOf('-') !== -1;\n    var sameWidthParity = referenceWidth % 2 === popperWidth % 2;\n    var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;\n    var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;\n    var verticalToInteger = !shouldRound ? noRound : round;\n    return {\n      left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),\n      top: verticalToInteger(popper.top),\n      bottom: verticalToInteger(popper.bottom),\n      right: horizontalToInteger(popper.right)\n    };\n  }\n  var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function computeStyle(data, options) {\n    var x = options.x,\n      y = options.y;\n    var popper = data.offsets.popper;\n\n    // Remove this legacy support in Popper.js v2\n\n    var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {\n      return modifier.name === 'applyStyle';\n    }).gpuAcceleration;\n    if (legacyGpuAccelerationOption !== undefined) {\n      console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n    }\n    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n    var offsetParent = getOffsetParent(data.instance.popper);\n    var offsetParentRect = getBoundingClientRect(offsetParent);\n\n    // Styles\n    var styles = {\n      position: popper.position\n    };\n    var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);\n    var sideA = x === 'bottom' ? 'top' : 'bottom';\n    var sideB = y === 'right' ? 'left' : 'right';\n\n    // if gpuAcceleration is set to `true` and transform is supported,\n    //  we use `translate3d` to apply the position to the popper we\n    // automatically use the supported prefixed version if needed\n    var prefixedProperty = getSupportedPropertyName('transform');\n\n    // now, let's make a step back and look at this code closely (wtf?)\n    // If the content of the popper grows once it's been positioned, it\n    // may happen that the popper gets misplaced because of the new content\n    // overflowing its reference element\n    // To avoid this problem, we provide two options (x and y), which allow\n    // the consumer to define the offset origin.\n    // If we position a popper on top of a reference element, we can set\n    // `x` to `top` to make the popper grow towards its top instead of\n    // its bottom.\n    var left = void 0,\n      top = void 0;\n    if (sideA === 'bottom') {\n      // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)\n      // and not the bottom of the html element\n      if (offsetParent.nodeName === 'HTML') {\n        top = -offsetParent.clientHeight + offsets.bottom;\n      } else {\n        top = -offsetParentRect.height + offsets.bottom;\n      }\n    } else {\n      top = offsets.top;\n    }\n    if (sideB === 'right') {\n      if (offsetParent.nodeName === 'HTML') {\n        left = -offsetParent.clientWidth + offsets.right;\n      } else {\n        left = -offsetParentRect.width + offsets.right;\n      }\n    } else {\n      left = offsets.left;\n    }\n    if (gpuAcceleration && prefixedProperty) {\n      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n      styles[sideA] = 0;\n      styles[sideB] = 0;\n      styles.willChange = 'transform';\n    } else {\n      // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n      var invertTop = sideA === 'bottom' ? -1 : 1;\n      var invertLeft = sideB === 'right' ? -1 : 1;\n      styles[sideA] = top * invertTop;\n      styles[sideB] = left * invertLeft;\n      styles.willChange = sideA + ', ' + sideB;\n    }\n\n    // Attributes\n    var attributes = {\n      'x-placement': data.placement\n    };\n\n    // Update `data` attributes, styles and arrowStyles\n    data.attributes = _extends$1({}, attributes, data.attributes);\n    data.styles = _extends$1({}, styles, data.styles);\n    data.arrowStyles = _extends$1({}, data.offsets.arrow, data.arrowStyles);\n    return data;\n  }\n\n  /**\n   * Helper used to know if the given modifier depends from another one.<br />\n   * It checks if the needed modifier is listed and enabled.\n   * @method\n   * @memberof Popper.Utils\n   * @param {Array} modifiers - list of modifiers\n   * @param {String} requestingName - name of requesting modifier\n   * @param {String} requestedName - name of requested modifier\n   * @returns {Boolean}\n   */\n  function isModifierRequired(modifiers, requestingName, requestedName) {\n    var requesting = find(modifiers, function (_ref) {\n      var name = _ref.name;\n      return name === requestingName;\n    });\n    var isRequired = !!requesting && modifiers.some(function (modifier) {\n      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n    });\n    if (!isRequired) {\n      var _requesting = '`' + requestingName + '`';\n      var requested = '`' + requestedName + '`';\n      console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\n    }\n    return isRequired;\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function arrow(data, options) {\n    var _data$offsets$arrow;\n\n    // arrow depends on keepTogether in order to work\n    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n      return data;\n    }\n    var arrowElement = options.element;\n\n    // if arrowElement is a string, suppose it's a CSS selector\n    if (typeof arrowElement === 'string') {\n      arrowElement = data.instance.popper.querySelector(arrowElement);\n\n      // if arrowElement is not found, don't run the modifier\n      if (!arrowElement) {\n        return data;\n      }\n    } else {\n      // if the arrowElement isn't a query selector we must check that the\n      // provided DOM node is child of its popper node\n      if (!data.instance.popper.contains(arrowElement)) {\n        console.warn('WARNING: `arrow.element` must be child of its popper element!');\n        return data;\n      }\n    }\n    var placement = data.placement.split('-')[0];\n    var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n    var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n    var len = isVertical ? 'height' : 'width';\n    var sideCapitalized = isVertical ? 'Top' : 'Left';\n    var side = sideCapitalized.toLowerCase();\n    var altSide = isVertical ? 'left' : 'top';\n    var opSide = isVertical ? 'bottom' : 'right';\n    var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n    //\n    // extends keepTogether behavior making sure the popper and its\n    // reference have enough pixels in conjunction\n    //\n\n    // top/left side\n    if (reference[opSide] - arrowElementSize < popper[side]) {\n      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n    }\n    // bottom/right side\n    if (reference[side] + arrowElementSize > popper[opSide]) {\n      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n    }\n    data.offsets.popper = getClientRect(data.offsets.popper);\n\n    // compute center of the popper\n    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n    // Compute the sideValue using the updated popper offsets\n    // take popper margin in account because we don't have this info available\n    var css = getStyleComputedProperty(data.instance.popper);\n    var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);\n    var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);\n    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n    // prevent arrowElement from being placed not contiguously to its popper\n    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n    data.arrowElement = arrowElement;\n    data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\n    return data;\n  }\n\n  /**\n   * Get the opposite placement variation of the given one\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} placement variation\n   * @returns {String} flipped placement variation\n   */\n  function getOppositeVariation(variation) {\n    if (variation === 'end') {\n      return 'start';\n    } else if (variation === 'start') {\n      return 'end';\n    }\n    return variation;\n  }\n\n  /**\n   * List of accepted placements to use as values of the `placement` option.<br />\n   * Valid placements are:\n   * - `auto`\n   * - `top`\n   * - `right`\n   * - `bottom`\n   * - `left`\n   *\n   * Each placement can have a variation from this list:\n   * - `-start`\n   * - `-end`\n   *\n   * Variations are interpreted easily if you think of them as the left to right\n   * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n   * is right.<br />\n   * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n   *\n   * Some valid examples are:\n   * - `top-end` (on top of reference, right aligned)\n   * - `right-start` (on right of reference, top aligned)\n   * - `bottom` (on bottom, centered)\n   * - `auto-end` (on the side with more space available, alignment depends by placement)\n   *\n   * @static\n   * @type {Array}\n   * @enum {String}\n   * @readonly\n   * @method placements\n   * @memberof Popper\n   */\n  var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n\n  // Get rid of `auto` `auto-start` and `auto-end`\n  var validPlacements = placements.slice(3);\n\n  /**\n   * Given an initial placement, returns all the subsequent placements\n   * clockwise (or counter-clockwise).\n   *\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} placement - A valid placement (it accepts variations)\n   * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n   * @returns {Array} placements including their variations\n   */\n  function clockwise(placement) {\n    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var index = validPlacements.indexOf(placement);\n    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n    return counter ? arr.reverse() : arr;\n  }\n  var BEHAVIORS = {\n    FLIP: 'flip',\n    CLOCKWISE: 'clockwise',\n    COUNTERCLOCKWISE: 'counterclockwise'\n  };\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function flip(data, options) {\n    // if `inner` modifier is enabled, we can't use the `flip` modifier\n    if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n      return data;\n    }\n    if (data.flipped && data.placement === data.originalPlacement) {\n      // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n      return data;\n    }\n    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);\n    var placement = data.placement.split('-')[0];\n    var placementOpposite = getOppositePlacement(placement);\n    var variation = data.placement.split('-')[1] || '';\n    var flipOrder = [];\n    switch (options.behavior) {\n      case BEHAVIORS.FLIP:\n        flipOrder = [placement, placementOpposite];\n        break;\n      case BEHAVIORS.CLOCKWISE:\n        flipOrder = clockwise(placement);\n        break;\n      case BEHAVIORS.COUNTERCLOCKWISE:\n        flipOrder = clockwise(placement, true);\n        break;\n      default:\n        flipOrder = options.behavior;\n    }\n    flipOrder.forEach(function (step, index) {\n      if (placement !== step || flipOrder.length === index + 1) {\n        return data;\n      }\n      placement = data.placement.split('-')[0];\n      placementOpposite = getOppositePlacement(placement);\n      var popperOffsets = data.offsets.popper;\n      var refOffsets = data.offsets.reference;\n\n      // using floor because the reference offsets may contain decimals we are not going to consider here\n      var floor = Math.floor;\n      var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n      var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n      // flip the variation if required\n      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n\n      // flips variation if reference element overflows boundaries\n      var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n      // flips variation if popper content overflows boundaries\n      var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);\n      var flippedVariation = flippedVariationByRef || flippedVariationByContent;\n      if (overlapsRef || overflowsBoundaries || flippedVariation) {\n        // this boolean to detect any flip loop\n        data.flipped = true;\n        if (overlapsRef || overflowsBoundaries) {\n          placement = flipOrder[index + 1];\n        }\n        if (flippedVariation) {\n          variation = getOppositeVariation(variation);\n        }\n        data.placement = placement + (variation ? '-' + variation : '');\n\n        // this object contains `position`, we want to preserve it along with\n        // any additional property we may add in the future\n        data.offsets.popper = _extends$1({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n        data = runModifiers(data.instance.modifiers, data, 'flip');\n      }\n    });\n    return data;\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function keepTogether(data) {\n    var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n    var placement = data.placement.split('-')[0];\n    var floor = Math.floor;\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    var side = isVertical ? 'right' : 'bottom';\n    var opSide = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n    if (popper[side] < floor(reference[opSide])) {\n      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n    }\n    if (popper[opSide] > floor(reference[side])) {\n      data.offsets.popper[opSide] = floor(reference[side]);\n    }\n    return data;\n  }\n\n  /**\n   * Converts a string containing value + unit into a px value number\n   * @function\n   * @memberof {modifiers~offset}\n   * @private\n   * @argument {String} str - Value + unit string\n   * @argument {String} measurement - `height` or `width`\n   * @argument {Object} popperOffsets\n   * @argument {Object} referenceOffsets\n   * @returns {Number|String}\n   * Value in pixels, or original string if no values were extracted\n   */\n  function toValue(str, measurement, popperOffsets, referenceOffsets) {\n    // separate value from unit\n    var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n    var value = +split[1];\n    var unit = split[2];\n\n    // If it's not a number it's an operator, I guess\n    if (!value) {\n      return str;\n    }\n    if (unit.indexOf('%') === 0) {\n      var element = void 0;\n      switch (unit) {\n        case '%p':\n          element = popperOffsets;\n          break;\n        case '%':\n        case '%r':\n        default:\n          element = referenceOffsets;\n      }\n      var rect = getClientRect(element);\n      return rect[measurement] / 100 * value;\n    } else if (unit === 'vh' || unit === 'vw') {\n      // if is a vh or vw, we calculate the size based on the viewport\n      var size = void 0;\n      if (unit === 'vh') {\n        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n      } else {\n        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n      }\n      return size / 100 * value;\n    } else {\n      // if is an explicit pixel unit, we get rid of the unit and keep the value\n      // if is an implicit unit, it's px, and we return just the value\n      return value;\n    }\n  }\n\n  /**\n   * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n   * @function\n   * @memberof {modifiers~offset}\n   * @private\n   * @argument {String} offset\n   * @argument {Object} popperOffsets\n   * @argument {Object} referenceOffsets\n   * @argument {String} basePlacement\n   * @returns {Array} a two cells array with x and y offsets in numbers\n   */\n  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n    var offsets = [0, 0];\n\n    // Use height if placement is left or right and index is 0 otherwise use width\n    // in this way the first offset will use an axis and the second one\n    // will use the other one\n    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n    // Split the offset string to obtain a list of values and operands\n    // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n    var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n      return frag.trim();\n    });\n\n    // Detect if the offset string contains a pair of values or a single one\n    // they could be separated by comma or space\n    var divider = fragments.indexOf(find(fragments, function (frag) {\n      return frag.search(/,|\\s/) !== -1;\n    }));\n    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n      console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n    }\n\n    // If divider is found, we divide the list of values and operands to divide\n    // them by ofset X and Y.\n    var splitRegex = /\\s*,\\s*|\\s+/;\n    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\n\n    // Convert the values with units to absolute pixels to allow our computations\n    ops = ops.map(function (op, index) {\n      // Most of the units rely on the orientation of the popper\n      var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\n      var mergeWithPrevious = false;\n      return op\n      // This aggregates any `+` or `-` sign that aren't considered operators\n      // e.g.: 10 + +5 => [10, +, +5]\n      .reduce(function (a, b) {\n        if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n          a[a.length - 1] = b;\n          mergeWithPrevious = true;\n          return a;\n        } else if (mergeWithPrevious) {\n          a[a.length - 1] += b;\n          mergeWithPrevious = false;\n          return a;\n        } else {\n          return a.concat(b);\n        }\n      }, [])\n      // Here we convert the string values into number values (in px)\n      .map(function (str) {\n        return toValue(str, measurement, popperOffsets, referenceOffsets);\n      });\n    });\n\n    // Loop trough the offsets arrays and execute the operations\n    ops.forEach(function (op, index) {\n      op.forEach(function (frag, index2) {\n        if (isNumeric(frag)) {\n          offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n        }\n      });\n    });\n    return offsets;\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @argument {Number|String} options.offset=0\n   * The offset value as described in the modifier description\n   * @returns {Object} The data object, properly modified\n   */\n  function offset(data, _ref) {\n    var offset = _ref.offset;\n    var placement = data.placement,\n      _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n    var basePlacement = placement.split('-')[0];\n    var offsets = void 0;\n    if (isNumeric(+offset)) {\n      offsets = [+offset, 0];\n    } else {\n      offsets = parseOffset(offset, popper, reference, basePlacement);\n    }\n    if (basePlacement === 'left') {\n      popper.top += offsets[0];\n      popper.left -= offsets[1];\n    } else if (basePlacement === 'right') {\n      popper.top += offsets[0];\n      popper.left += offsets[1];\n    } else if (basePlacement === 'top') {\n      popper.left += offsets[0];\n      popper.top -= offsets[1];\n    } else if (basePlacement === 'bottom') {\n      popper.left += offsets[0];\n      popper.top += offsets[1];\n    }\n    data.popper = popper;\n    return data;\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function preventOverflow(data, options) {\n    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n\n    // If offsetParent is the reference element, we really want to\n    // go one step up and use the next offsetParent as reference to\n    // avoid to make this modifier completely useless and look like broken\n    if (data.instance.reference === boundariesElement) {\n      boundariesElement = getOffsetParent(boundariesElement);\n    }\n\n    // NOTE: DOM access here\n    // resets the popper's position so that the document size can be calculated excluding\n    // the size of the popper element itself\n    var transformProp = getSupportedPropertyName('transform');\n    var popperStyles = data.instance.popper.style; // assignment to help minification\n    var top = popperStyles.top,\n      left = popperStyles.left,\n      transform = popperStyles[transformProp];\n    popperStyles.top = '';\n    popperStyles.left = '';\n    popperStyles[transformProp] = '';\n    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);\n\n    // NOTE: DOM access here\n    // restores the original style properties after the offsets have been computed\n    popperStyles.top = top;\n    popperStyles.left = left;\n    popperStyles[transformProp] = transform;\n    options.boundaries = boundaries;\n    var order = options.priority;\n    var popper = data.offsets.popper;\n    var check = {\n      primary: function primary(placement) {\n        var value = popper[placement];\n        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n          value = Math.max(popper[placement], boundaries[placement]);\n        }\n        return defineProperty({}, placement, value);\n      },\n      secondary: function secondary(placement) {\n        var mainSide = placement === 'right' ? 'left' : 'top';\n        var value = popper[mainSide];\n        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n          value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n        }\n        return defineProperty({}, mainSide, value);\n      }\n    };\n    order.forEach(function (placement) {\n      var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n      popper = _extends$1({}, popper, check[side](placement));\n    });\n    data.offsets.popper = popper;\n    return data;\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function shift(data) {\n    var placement = data.placement;\n    var basePlacement = placement.split('-')[0];\n    var shiftvariation = placement.split('-')[1];\n\n    // if shift shiftvariation is specified, run the modifier\n    if (shiftvariation) {\n      var _data$offsets = data.offsets,\n        reference = _data$offsets.reference,\n        popper = _data$offsets.popper;\n      var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n      var side = isVertical ? 'left' : 'top';\n      var measurement = isVertical ? 'width' : 'height';\n      var shiftOffsets = {\n        start: defineProperty({}, side, reference[side]),\n        end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n      };\n      data.offsets.popper = _extends$1({}, popper, shiftOffsets[shiftvariation]);\n    }\n    return data;\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function hide(data) {\n    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n      return data;\n    }\n    var refRect = data.offsets.reference;\n    var bound = find(data.instance.modifiers, function (modifier) {\n      return modifier.name === 'preventOverflow';\n    }).boundaries;\n    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n      // Avoid unnecessary DOM access if visibility hasn't changed\n      if (data.hide === true) {\n        return data;\n      }\n      data.hide = true;\n      data.attributes['x-out-of-boundaries'] = '';\n    } else {\n      // Avoid unnecessary DOM access if visibility hasn't changed\n      if (data.hide === false) {\n        return data;\n      }\n      data.hide = false;\n      data.attributes['x-out-of-boundaries'] = false;\n    }\n    return data;\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function inner(data) {\n    var placement = data.placement;\n    var basePlacement = placement.split('-')[0];\n    var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n    popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n    data.placement = getOppositePlacement(placement);\n    data.offsets.popper = getClientRect(popper);\n    return data;\n  }\n\n  /**\n   * Modifier function, each modifier can have a function of this type assigned\n   * to its `fn` property.<br />\n   * These functions will be called on each update, this means that you must\n   * make sure they are performant enough to avoid performance bottlenecks.\n   *\n   * @function ModifierFn\n   * @argument {dataObject} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {dataObject} The data object, properly modified\n   */\n\n  /**\n   * Modifiers are plugins used to alter the behavior of your poppers.<br />\n   * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n   * needed by the library.\n   *\n   * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n   * All the other properties are configurations that could be tweaked.\n   * @namespace modifiers\n   */\n  var modifiers = {\n    /**\n     * Modifier used to shift the popper on the start or end of its reference\n     * element.<br />\n     * It will read the variation of the `placement` property.<br />\n     * It can be one either `-end` or `-start`.\n     * @memberof modifiers\n     * @inner\n     */\n    shift: {\n      /** @prop {number} order=100 - Index used to define the order of execution */\n      order: 100,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: shift\n    },\n    /**\n     * The `offset` modifier can shift your popper on both its axis.\n     *\n     * It accepts the following units:\n     * - `px` or unit-less, interpreted as pixels\n     * - `%` or `%r`, percentage relative to the length of the reference element\n     * - `%p`, percentage relative to the length of the popper element\n     * - `vw`, CSS viewport width unit\n     * - `vh`, CSS viewport height unit\n     *\n     * For length is intended the main axis relative to the placement of the popper.<br />\n     * This means that if the placement is `top` or `bottom`, the length will be the\n     * `width`. In case of `left` or `right`, it will be the `height`.\n     *\n     * You can provide a single value (as `Number` or `String`), or a pair of values\n     * as `String` divided by a comma or one (or more) white spaces.<br />\n     * The latter is a deprecated method because it leads to confusion and will be\n     * removed in v2.<br />\n     * Additionally, it accepts additions and subtractions between different units.\n     * Note that multiplications and divisions aren't supported.\n     *\n     * Valid examples are:\n     * ```\n     * 10\n     * '10%'\n     * '10, 10'\n     * '10%, 10'\n     * '10 + 10%'\n     * '10 - 5vh + 3%'\n     * '-10px + 5vh, 5px - 6%'\n     * ```\n     * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n     * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n     * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n     *\n     * @memberof modifiers\n     * @inner\n     */\n    offset: {\n      /** @prop {number} order=200 - Index used to define the order of execution */\n      order: 200,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: offset,\n      /** @prop {Number|String} offset=0\n       * The offset value as described in the modifier description\n       */\n      offset: 0\n    },\n    /**\n     * Modifier used to prevent the popper from being positioned outside the boundary.\n     *\n     * A scenario exists where the reference itself is not within the boundaries.<br />\n     * We can say it has \"escaped the boundaries\"  or just \"escaped\".<br />\n     * In this case we need to decide whether the popper should either:\n     *\n     * - detach from the reference and remain \"trapped\" in the boundaries, or\n     * - if it should ignore the boundary and \"escape with its reference\"\n     *\n     * When `escapeWithReference` is set to`true` and reference is completely\n     * outside its boundaries, the popper will overflow (or completely leave)\n     * the boundaries in order to remain attached to the edge of the reference.\n     *\n     * @memberof modifiers\n     * @inner\n     */\n    preventOverflow: {\n      /** @prop {number} order=300 - Index used to define the order of execution */\n      order: 300,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: preventOverflow,\n      /**\n       * @prop {Array} [priority=['left','right','top','bottom']]\n       * Popper will try to prevent overflow following these priorities by default,\n       * then, it could overflow on the left and on top of the `boundariesElement`\n       */\n      priority: ['left', 'right', 'top', 'bottom'],\n      /**\n       * @prop {number} padding=5\n       * Amount of pixel used to define a minimum distance between the boundaries\n       * and the popper. This makes sure the popper always has a little padding\n       * between the edges of its container\n       */\n      padding: 5,\n      /**\n       * @prop {String|HTMLElement} boundariesElement='scrollParent'\n       * Boundaries used by the modifier. Can be `scrollParent`, `window`,\n       * `viewport` or any DOM element.\n       */\n      boundariesElement: 'scrollParent'\n    },\n    /**\n     * Modifier used to make sure the reference and its popper stay near each other\n     * without leaving any gap between the two. Especially useful when the arrow is\n     * enabled and you want to ensure that it points to its reference element.\n     * It cares only about the first axis. You can still have poppers with margin\n     * between the popper and its reference element.\n     * @memberof modifiers\n     * @inner\n     */\n    keepTogether: {\n      /** @prop {number} order=400 - Index used to define the order of execution */\n      order: 400,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: keepTogether\n    },\n    /**\n     * This modifier is used to move the `arrowElement` of the popper to make\n     * sure it is positioned between the reference element and its popper element.\n     * It will read the outer size of the `arrowElement` node to detect how many\n     * pixels of conjunction are needed.\n     *\n     * It has no effect if no `arrowElement` is provided.\n     * @memberof modifiers\n     * @inner\n     */\n    arrow: {\n      /** @prop {number} order=500 - Index used to define the order of execution */\n      order: 500,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: arrow,\n      /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n      element: '[x-arrow]'\n    },\n    /**\n     * Modifier used to flip the popper's placement when it starts to overlap its\n     * reference element.\n     *\n     * Requires the `preventOverflow` modifier before it in order to work.\n     *\n     * **NOTE:** this modifier will interrupt the current update cycle and will\n     * restart it if it detects the need to flip the placement.\n     * @memberof modifiers\n     * @inner\n     */\n    flip: {\n      /** @prop {number} order=600 - Index used to define the order of execution */\n      order: 600,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: flip,\n      /**\n       * @prop {String|Array} behavior='flip'\n       * The behavior used to change the popper's placement. It can be one of\n       * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n       * placements (with optional variations)\n       */\n      behavior: 'flip',\n      /**\n       * @prop {number} padding=5\n       * The popper will flip if it hits the edges of the `boundariesElement`\n       */\n      padding: 5,\n      /**\n       * @prop {String|HTMLElement} boundariesElement='viewport'\n       * The element which will define the boundaries of the popper position.\n       * The popper will never be placed outside of the defined boundaries\n       * (except if `keepTogether` is enabled)\n       */\n      boundariesElement: 'viewport',\n      /**\n       * @prop {Boolean} flipVariations=false\n       * The popper will switch placement variation between `-start` and `-end` when\n       * the reference element overlaps its boundaries.\n       *\n       * The original placement should have a set variation.\n       */\n      flipVariations: false,\n      /**\n       * @prop {Boolean} flipVariationsByContent=false\n       * The popper will switch placement variation between `-start` and `-end` when\n       * the popper element overlaps its reference boundaries.\n       *\n       * The original placement should have a set variation.\n       */\n      flipVariationsByContent: false\n    },\n    /**\n     * Modifier used to make the popper flow toward the inner of the reference element.\n     * By default, when this modifier is disabled, the popper will be placed outside\n     * the reference element.\n     * @memberof modifiers\n     * @inner\n     */\n    inner: {\n      /** @prop {number} order=700 - Index used to define the order of execution */\n      order: 700,\n      /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n      enabled: false,\n      /** @prop {ModifierFn} */\n      fn: inner\n    },\n    /**\n     * Modifier used to hide the popper when its reference element is outside of the\n     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n     * be used to hide with a CSS selector the popper when its reference is\n     * out of boundaries.\n     *\n     * Requires the `preventOverflow` modifier before it in order to work.\n     * @memberof modifiers\n     * @inner\n     */\n    hide: {\n      /** @prop {number} order=800 - Index used to define the order of execution */\n      order: 800,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: hide\n    },\n    /**\n     * Computes the style that will be applied to the popper element to gets\n     * properly positioned.\n     *\n     * Note that this modifier will not touch the DOM, it just prepares the styles\n     * so that `applyStyle` modifier can apply it. This separation is useful\n     * in case you need to replace `applyStyle` with a custom implementation.\n     *\n     * This modifier has `850` as `order` value to maintain backward compatibility\n     * with previous versions of Popper.js. Expect the modifiers ordering method\n     * to change in future major versions of the library.\n     *\n     * @memberof modifiers\n     * @inner\n     */\n    computeStyle: {\n      /** @prop {number} order=850 - Index used to define the order of execution */\n      order: 850,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: computeStyle,\n      /**\n       * @prop {Boolean} gpuAcceleration=true\n       * If true, it uses the CSS 3D transformation to position the popper.\n       * Otherwise, it will use the `top` and `left` properties\n       */\n      gpuAcceleration: true,\n      /**\n       * @prop {string} [x='bottom']\n       * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n       * Change this if your popper should grow in a direction different from `bottom`\n       */\n      x: 'bottom',\n      /**\n       * @prop {string} [x='left']\n       * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n       * Change this if your popper should grow in a direction different from `right`\n       */\n      y: 'right'\n    },\n    /**\n     * Applies the computed styles to the popper element.\n     *\n     * All the DOM manipulations are limited to this modifier. This is useful in case\n     * you want to integrate Popper.js inside a framework or view library and you\n     * want to delegate all the DOM manipulations to it.\n     *\n     * Note that if you disable this modifier, you must make sure the popper element\n     * has its position set to `absolute` before Popper.js can do its work!\n     *\n     * Just disable this modifier and define your own to achieve the desired effect.\n     *\n     * @memberof modifiers\n     * @inner\n     */\n    applyStyle: {\n      /** @prop {number} order=900 - Index used to define the order of execution */\n      order: 900,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: applyStyle,\n      /** @prop {Function} */\n      onLoad: applyStyleOnLoad,\n      /**\n       * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n       * @prop {Boolean} gpuAcceleration=true\n       * If true, it uses the CSS 3D transformation to position the popper.\n       * Otherwise, it will use the `top` and `left` properties\n       */\n      gpuAcceleration: undefined\n    }\n  };\n\n  /**\n   * The `dataObject` is an object containing all the information used by Popper.js.\n   * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n   * @name dataObject\n   * @property {Object} data.instance The Popper.js instance\n   * @property {String} data.placement Placement applied to popper\n   * @property {String} data.originalPlacement Placement originally defined on init\n   * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n   * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper\n   * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n   * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)\n   * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)\n   * @property {Object} data.boundaries Offsets of the popper boundaries\n   * @property {Object} data.offsets The measurements of popper, reference and arrow elements\n   * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n   * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n   * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n   */\n\n  /**\n   * Default options provided to Popper.js constructor.<br />\n   * These can be overridden using the `options` argument of Popper.js.<br />\n   * To override an option, simply pass an object with the same\n   * structure of the `options` object, as the 3rd argument. For example:\n   * ```\n   * new Popper(ref, pop, {\n   *   modifiers: {\n   *     preventOverflow: { enabled: false }\n   *   }\n   * })\n   * ```\n   * @type {Object}\n   * @static\n   * @memberof Popper\n   */\n  var Defaults = {\n    /**\n     * Popper's placement.\n     * @prop {Popper.placements} placement='bottom'\n     */\n    placement: 'bottom',\n    /**\n     * Set this to true if you want popper to position it self in 'fixed' mode\n     * @prop {Boolean} positionFixed=false\n     */\n    positionFixed: false,\n    /**\n     * Whether events (resize, scroll) are initially enabled.\n     * @prop {Boolean} eventsEnabled=true\n     */\n    eventsEnabled: true,\n    /**\n     * Set to true if you want to automatically remove the popper when\n     * you call the `destroy` method.\n     * @prop {Boolean} removeOnDestroy=false\n     */\n    removeOnDestroy: false,\n    /**\n     * Callback called when the popper is created.<br />\n     * By default, it is set to no-op.<br />\n     * Access Popper.js instance with `data.instance`.\n     * @prop {onCreate}\n     */\n    onCreate: function onCreate() {},\n    /**\n     * Callback called when the popper is updated. This callback is not called\n     * on the initialization/creation of the popper, but only on subsequent\n     * updates.<br />\n     * By default, it is set to no-op.<br />\n     * Access Popper.js instance with `data.instance`.\n     * @prop {onUpdate}\n     */\n    onUpdate: function onUpdate() {},\n    /**\n     * List of modifiers used to modify the offsets before they are applied to the popper.\n     * They provide most of the functionalities of Popper.js.\n     * @prop {modifiers}\n     */\n    modifiers: modifiers\n  };\n\n  /**\n   * @callback onCreate\n   * @param {dataObject} data\n   */\n\n  /**\n   * @callback onUpdate\n   * @param {dataObject} data\n   */\n\n  // Utils\n  // Methods\n  var Popper = function () {\n    /**\n     * Creates a new Popper.js instance.\n     * @class Popper\n     * @param {Element|referenceObject} reference - The reference element used to position the popper\n     * @param {Element} popper - The HTML / XML element used as the popper\n     * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n     * @return {Object} instance - The generated Popper.js instance\n     */\n    function Popper(reference, popper) {\n      var _this = this;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      classCallCheck(this, Popper);\n      this.scheduleUpdate = function () {\n        return requestAnimationFrame(_this.update);\n      };\n\n      // make update() debounced, so that it only runs at most once-per-tick\n      this.update = debounce(this.update.bind(this));\n\n      // with {} we create a new object with the options inside it\n      this.options = _extends$1({}, Popper.Defaults, options);\n\n      // init state\n      this.state = {\n        isDestroyed: false,\n        isCreated: false,\n        scrollParents: []\n      };\n\n      // get reference and popper elements (allow jQuery wrappers)\n      this.reference = reference && reference.jquery ? reference[0] : reference;\n      this.popper = popper && popper.jquery ? popper[0] : popper;\n\n      // Deep merge modifiers options\n      this.options.modifiers = {};\n      Object.keys(_extends$1({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n        _this.options.modifiers[name] = _extends$1({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n      });\n\n      // Refactoring modifiers' list (Object => Array)\n      this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n        return _extends$1({\n          name: name\n        }, _this.options.modifiers[name]);\n      })\n      // sort the modifiers by order\n      .sort(function (a, b) {\n        return a.order - b.order;\n      });\n\n      // modifiers have the ability to execute arbitrary code when Popper.js get inited\n      // such code is executed in the same order of its modifier\n      // they could add new properties to their options configuration\n      // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n      this.modifiers.forEach(function (modifierOptions) {\n        if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n        }\n      });\n\n      // fire the first update to position the popper in the right place\n      this.update();\n      var eventsEnabled = this.options.eventsEnabled;\n      if (eventsEnabled) {\n        // setup event listeners, they will take care of update the position in specific situations\n        this.enableEventListeners();\n      }\n      this.state.eventsEnabled = eventsEnabled;\n    }\n\n    // We can't use class properties because they don't get listed in the\n    // class prototype and break stuff like Sinon stubs\n\n    createClass(Popper, [{\n      key: 'update',\n      value: function update$$1() {\n        return update.call(this);\n      }\n    }, {\n      key: 'destroy',\n      value: function destroy$$1() {\n        return destroy.call(this);\n      }\n    }, {\n      key: 'enableEventListeners',\n      value: function enableEventListeners$$1() {\n        return enableEventListeners.call(this);\n      }\n    }, {\n      key: 'disableEventListeners',\n      value: function disableEventListeners$$1() {\n        return disableEventListeners.call(this);\n      }\n\n      /**\n       * Schedules an update. It will run on the next UI update available.\n       * @method scheduleUpdate\n       * @memberof Popper\n       */\n\n      /**\n       * Collection of utilities useful when writing custom modifiers.\n       * Starting from version 1.7, this method is available only if you\n       * include `popper-utils.js` before `popper.js`.\n       *\n       * **DEPRECATION**: This way to access PopperUtils is deprecated\n       * and will be removed in v2! Use the PopperUtils module directly instead.\n       * Due to the high instability of the methods contained in Utils, we can't\n       * guarantee them to follow semver. Use them at your own risk!\n       * @static\n       * @private\n       * @type {Object}\n       * @deprecated since version 1.8\n       * @member Utils\n       * @memberof Popper\n       */\n    }]);\n\n    return Popper;\n  }();\n\n  /**\n   * The `referenceObject` is an object that provides an interface compatible with Popper.js\n   * and lets you use it as replacement of a real DOM node.<br />\n   * You can use this method to position a popper relatively to a set of coordinates\n   * in case you don't have a DOM node to use as reference.\n   *\n   * ```\n   * new Popper(referenceObject, popperNode);\n   * ```\n   *\n   * NB: This feature isn't supported in Internet Explorer 10.\n   * @name referenceObject\n   * @property {Function} data.getBoundingClientRect\n   * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n   * @property {number} data.clientWidth\n   * An ES6 getter that will return the width of the virtual reference element.\n   * @property {number} data.clientHeight\n   * An ES6 getter that will return the height of the virtual reference element.\n   */\n\n  Popper.Utils = (typeof window !== 'undefined' ? window : __webpack_require__.g).PopperUtils;\n  Popper.placements = placements;\n  Popper.Defaults = Defaults;\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$4 = 'dropdown';\n  var VERSION$4 = '4.6.0';\n  var DATA_KEY$4 = 'bs.dropdown';\n  var EVENT_KEY$4 = \".\" + DATA_KEY$4;\n  var DATA_API_KEY$4 = '.data-api';\n  var JQUERY_NO_CONFLICT$4 = $__default['default'].fn[NAME$4];\n  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key\n\n  var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key\n\n  var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key\n\n  var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key\n\n  var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key\n\n  var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)\n\n  var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + \"|\" + ARROW_DOWN_KEYCODE + \"|\" + ESCAPE_KEYCODE);\n  var EVENT_HIDE$1 = \"hide\" + EVENT_KEY$4;\n  var EVENT_HIDDEN$1 = \"hidden\" + EVENT_KEY$4;\n  var EVENT_SHOW$1 = \"show\" + EVENT_KEY$4;\n  var EVENT_SHOWN$1 = \"shown\" + EVENT_KEY$4;\n  var EVENT_CLICK = \"click\" + EVENT_KEY$4;\n  var EVENT_CLICK_DATA_API$4 = \"click\" + EVENT_KEY$4 + DATA_API_KEY$4;\n  var EVENT_KEYDOWN_DATA_API = \"keydown\" + EVENT_KEY$4 + DATA_API_KEY$4;\n  var EVENT_KEYUP_DATA_API = \"keyup\" + EVENT_KEY$4 + DATA_API_KEY$4;\n  var CLASS_NAME_DISABLED = 'disabled';\n  var CLASS_NAME_SHOW$2 = 'show';\n  var CLASS_NAME_DROPUP = 'dropup';\n  var CLASS_NAME_DROPRIGHT = 'dropright';\n  var CLASS_NAME_DROPLEFT = 'dropleft';\n  var CLASS_NAME_MENURIGHT = 'dropdown-menu-right';\n  var CLASS_NAME_POSITION_STATIC = 'position-static';\n  var SELECTOR_DATA_TOGGLE$2 = '[data-toggle=\"dropdown\"]';\n  var SELECTOR_FORM_CHILD = '.dropdown form';\n  var SELECTOR_MENU = '.dropdown-menu';\n  var SELECTOR_NAVBAR_NAV = '.navbar-nav';\n  var SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';\n  var PLACEMENT_TOP = 'top-start';\n  var PLACEMENT_TOPEND = 'top-end';\n  var PLACEMENT_BOTTOM = 'bottom-start';\n  var PLACEMENT_BOTTOMEND = 'bottom-end';\n  var PLACEMENT_RIGHT = 'right-start';\n  var PLACEMENT_LEFT = 'left-start';\n  var Default$2 = {\n    offset: 0,\n    flip: true,\n    boundary: 'scrollParent',\n    reference: 'toggle',\n    display: 'dynamic',\n    popperConfig: null\n  };\n  var DefaultType$2 = {\n    offset: '(number|string|function)',\n    flip: 'boolean',\n    boundary: '(string|element)',\n    reference: '(string|element)',\n    display: 'string',\n    popperConfig: '(null|object)'\n  };\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Dropdown = /*#__PURE__*/function () {\n    function Dropdown(element, config) {\n      this._element = element;\n      this._popper = null;\n      this._config = this._getConfig(config);\n      this._menu = this._getMenuElement();\n      this._inNavbar = this._detectNavbar();\n      this._addEventListeners();\n    } // Getters\n\n    var _proto = Dropdown.prototype;\n\n    // Public\n    _proto.toggle = function toggle() {\n      if (this._element.disabled || $__default['default'](this._element).hasClass(CLASS_NAME_DISABLED)) {\n        return;\n      }\n      var isActive = $__default['default'](this._menu).hasClass(CLASS_NAME_SHOW$2);\n      Dropdown._clearMenus();\n      if (isActive) {\n        return;\n      }\n      this.show(true);\n    };\n    _proto.show = function show(usePopper) {\n      if (usePopper === void 0) {\n        usePopper = false;\n      }\n      if (this._element.disabled || $__default['default'](this._element).hasClass(CLASS_NAME_DISABLED) || $__default['default'](this._menu).hasClass(CLASS_NAME_SHOW$2)) {\n        return;\n      }\n      var relatedTarget = {\n        relatedTarget: this._element\n      };\n      var showEvent = $__default['default'].Event(EVENT_SHOW$1, relatedTarget);\n      var parent = Dropdown._getParentFromElement(this._element);\n      $__default['default'](parent).trigger(showEvent);\n      if (showEvent.isDefaultPrevented()) {\n        return;\n      } // Totally disable Popper for Dropdowns in Navbar\n\n      if (!this._inNavbar && usePopper) {\n        /**\n         * Check for Popper dependency\n         * Popper - https://popper.js.org\n         */\n        if (typeof Popper === 'undefined') {\n          throw new TypeError('Bootstrap\\'s dropdowns require Popper (https://popper.js.org)');\n        }\n        var referenceElement = this._element;\n        if (this._config.reference === 'parent') {\n          referenceElement = parent;\n        } else if (Util.isElement(this._config.reference)) {\n          referenceElement = this._config.reference; // Check if it's jQuery element\n\n          if (typeof this._config.reference.jquery !== 'undefined') {\n            referenceElement = this._config.reference[0];\n          }\n        } // If boundary is not `scrollParent`, then set position to `static`\n        // to allow the menu to \"escape\" the scroll parent's boundaries\n        // https://github.com/twbs/bootstrap/issues/24251\n\n        if (this._config.boundary !== 'scrollParent') {\n          $__default['default'](parent).addClass(CLASS_NAME_POSITION_STATIC);\n        }\n        this._popper = new Popper(referenceElement, this._menu, this._getPopperConfig());\n      } // If this is a touch-enabled device we add extra\n      // empty mouseover listeners to the body's immediate children;\n      // only needed because of broken event delegation on iOS\n      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n      if ('ontouchstart' in document.documentElement && $__default['default'](parent).closest(SELECTOR_NAVBAR_NAV).length === 0) {\n        $__default['default'](document.body).children().on('mouseover', null, $__default['default'].noop);\n      }\n      this._element.focus();\n      this._element.setAttribute('aria-expanded', true);\n      $__default['default'](this._menu).toggleClass(CLASS_NAME_SHOW$2);\n      $__default['default'](parent).toggleClass(CLASS_NAME_SHOW$2).trigger($__default['default'].Event(EVENT_SHOWN$1, relatedTarget));\n    };\n    _proto.hide = function hide() {\n      if (this._element.disabled || $__default['default'](this._element).hasClass(CLASS_NAME_DISABLED) || !$__default['default'](this._menu).hasClass(CLASS_NAME_SHOW$2)) {\n        return;\n      }\n      var relatedTarget = {\n        relatedTarget: this._element\n      };\n      var hideEvent = $__default['default'].Event(EVENT_HIDE$1, relatedTarget);\n      var parent = Dropdown._getParentFromElement(this._element);\n      $__default['default'](parent).trigger(hideEvent);\n      if (hideEvent.isDefaultPrevented()) {\n        return;\n      }\n      if (this._popper) {\n        this._popper.destroy();\n      }\n      $__default['default'](this._menu).toggleClass(CLASS_NAME_SHOW$2);\n      $__default['default'](parent).toggleClass(CLASS_NAME_SHOW$2).trigger($__default['default'].Event(EVENT_HIDDEN$1, relatedTarget));\n    };\n    _proto.dispose = function dispose() {\n      $__default['default'].removeData(this._element, DATA_KEY$4);\n      $__default['default'](this._element).off(EVENT_KEY$4);\n      this._element = null;\n      this._menu = null;\n      if (this._popper !== null) {\n        this._popper.destroy();\n        this._popper = null;\n      }\n    };\n    _proto.update = function update() {\n      this._inNavbar = this._detectNavbar();\n      if (this._popper !== null) {\n        this._popper.scheduleUpdate();\n      }\n    } // Private\n    ;\n\n    _proto._addEventListeners = function _addEventListeners() {\n      var _this = this;\n      $__default['default'](this._element).on(EVENT_CLICK, function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n        _this.toggle();\n      });\n    };\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends({}, this.constructor.Default, $__default['default'](this._element).data(), config);\n      Util.typeCheckConfig(NAME$4, config, this.constructor.DefaultType);\n      return config;\n    };\n    _proto._getMenuElement = function _getMenuElement() {\n      if (!this._menu) {\n        var parent = Dropdown._getParentFromElement(this._element);\n        if (parent) {\n          this._menu = parent.querySelector(SELECTOR_MENU);\n        }\n      }\n      return this._menu;\n    };\n    _proto._getPlacement = function _getPlacement() {\n      var $parentDropdown = $__default['default'](this._element.parentNode);\n      var placement = PLACEMENT_BOTTOM; // Handle dropup\n\n      if ($parentDropdown.hasClass(CLASS_NAME_DROPUP)) {\n        placement = $__default['default'](this._menu).hasClass(CLASS_NAME_MENURIGHT) ? PLACEMENT_TOPEND : PLACEMENT_TOP;\n      } else if ($parentDropdown.hasClass(CLASS_NAME_DROPRIGHT)) {\n        placement = PLACEMENT_RIGHT;\n      } else if ($parentDropdown.hasClass(CLASS_NAME_DROPLEFT)) {\n        placement = PLACEMENT_LEFT;\n      } else if ($__default['default'](this._menu).hasClass(CLASS_NAME_MENURIGHT)) {\n        placement = PLACEMENT_BOTTOMEND;\n      }\n      return placement;\n    };\n    _proto._detectNavbar = function _detectNavbar() {\n      return $__default['default'](this._element).closest('.navbar').length > 0;\n    };\n    _proto._getOffset = function _getOffset() {\n      var _this2 = this;\n      var offset = {};\n      if (typeof this._config.offset === 'function') {\n        offset.fn = function (data) {\n          data.offsets = _extends({}, data.offsets, _this2._config.offset(data.offsets, _this2._element) || {});\n          return data;\n        };\n      } else {\n        offset.offset = this._config.offset;\n      }\n      return offset;\n    };\n    _proto._getPopperConfig = function _getPopperConfig() {\n      var popperConfig = {\n        placement: this._getPlacement(),\n        modifiers: {\n          offset: this._getOffset(),\n          flip: {\n            enabled: this._config.flip\n          },\n          preventOverflow: {\n            boundariesElement: this._config.boundary\n          }\n        }\n      }; // Disable Popper if we have a static display\n\n      if (this._config.display === 'static') {\n        popperConfig.modifiers.applyStyle = {\n          enabled: false\n        };\n      }\n      return _extends({}, popperConfig, this._config.popperConfig);\n    } // Static\n    ;\n\n    Dropdown._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $__default['default'](this).data(DATA_KEY$4);\n        var _config = _typeof(config) === 'object' ? config : null;\n        if (!data) {\n          data = new Dropdown(this, _config);\n          $__default['default'](this).data(DATA_KEY$4, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n          data[config]();\n        }\n      });\n    };\n    Dropdown._clearMenus = function _clearMenus(event) {\n      if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' && event.which !== TAB_KEYCODE)) {\n        return;\n      }\n      var toggles = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE$2));\n      for (var i = 0, len = toggles.length; i < len; i++) {\n        var parent = Dropdown._getParentFromElement(toggles[i]);\n        var context = $__default['default'](toggles[i]).data(DATA_KEY$4);\n        var relatedTarget = {\n          relatedTarget: toggles[i]\n        };\n        if (event && event.type === 'click') {\n          relatedTarget.clickEvent = event;\n        }\n        if (!context) {\n          continue;\n        }\n        var dropdownMenu = context._menu;\n        if (!$__default['default'](parent).hasClass(CLASS_NAME_SHOW$2)) {\n          continue;\n        }\n        if (event && (event.type === 'click' && /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' && event.which === TAB_KEYCODE) && $__default['default'].contains(parent, event.target)) {\n          continue;\n        }\n        var hideEvent = $__default['default'].Event(EVENT_HIDE$1, relatedTarget);\n        $__default['default'](parent).trigger(hideEvent);\n        if (hideEvent.isDefaultPrevented()) {\n          continue;\n        } // If this is a touch-enabled device we remove the extra\n        // empty mouseover listeners we added for iOS support\n\n        if ('ontouchstart' in document.documentElement) {\n          $__default['default'](document.body).children().off('mouseover', null, $__default['default'].noop);\n        }\n        toggles[i].setAttribute('aria-expanded', 'false');\n        if (context._popper) {\n          context._popper.destroy();\n        }\n        $__default['default'](dropdownMenu).removeClass(CLASS_NAME_SHOW$2);\n        $__default['default'](parent).removeClass(CLASS_NAME_SHOW$2).trigger($__default['default'].Event(EVENT_HIDDEN$1, relatedTarget));\n      }\n    };\n    Dropdown._getParentFromElement = function _getParentFromElement(element) {\n      var parent;\n      var selector = Util.getSelectorFromElement(element);\n      if (selector) {\n        parent = document.querySelector(selector);\n      }\n      return parent || element.parentNode;\n    } // eslint-disable-next-line complexity\n    ;\n\n    Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {\n      // If not input/textarea:\n      //  - And not a key in REGEXP_KEYDOWN => not a dropdown command\n      // If input/textarea:\n      //  - If space key => not a dropdown command\n      //  - If key is other than escape\n      //    - If key is not up or down => not a dropdown command\n      //    - If trigger inside the menu => not a dropdown command\n      if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE && (event.which !== ARROW_DOWN_KEYCODE && event.which !== ARROW_UP_KEYCODE || $__default['default'](event.target).closest(SELECTOR_MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {\n        return;\n      }\n      if (this.disabled || $__default['default'](this).hasClass(CLASS_NAME_DISABLED)) {\n        return;\n      }\n      var parent = Dropdown._getParentFromElement(this);\n      var isActive = $__default['default'](parent).hasClass(CLASS_NAME_SHOW$2);\n      if (!isActive && event.which === ESCAPE_KEYCODE) {\n        return;\n      }\n      event.preventDefault();\n      event.stopPropagation();\n      if (!isActive || event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE) {\n        if (event.which === ESCAPE_KEYCODE) {\n          $__default['default'](parent.querySelector(SELECTOR_DATA_TOGGLE$2)).trigger('focus');\n        }\n        $__default['default'](this).trigger('click');\n        return;\n      }\n      var items = [].slice.call(parent.querySelectorAll(SELECTOR_VISIBLE_ITEMS)).filter(function (item) {\n        return $__default['default'](item).is(':visible');\n      });\n      if (items.length === 0) {\n        return;\n      }\n      var index = items.indexOf(event.target);\n      if (event.which === ARROW_UP_KEYCODE && index > 0) {\n        // Up\n        index--;\n      }\n      if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {\n        // Down\n        index++;\n      }\n      if (index < 0) {\n        index = 0;\n      }\n      items[index].focus();\n    };\n    _createClass(Dropdown, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$4;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$2;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$2;\n      }\n    }]);\n    return Dropdown;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'](document).on(EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$2, Dropdown._dataApiKeydownHandler).on(EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown._dataApiKeydownHandler).on(EVENT_CLICK_DATA_API$4 + \" \" + EVENT_KEYUP_DATA_API, Dropdown._clearMenus).on(EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$2, function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n    Dropdown._jQueryInterface.call($__default['default'](this), 'toggle');\n  }).on(EVENT_CLICK_DATA_API$4, SELECTOR_FORM_CHILD, function (e) {\n    e.stopPropagation();\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'].fn[NAME$4] = Dropdown._jQueryInterface;\n  $__default['default'].fn[NAME$4].Constructor = Dropdown;\n  $__default['default'].fn[NAME$4].noConflict = function () {\n    $__default['default'].fn[NAME$4] = JQUERY_NO_CONFLICT$4;\n    return Dropdown._jQueryInterface;\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$5 = 'modal';\n  var VERSION$5 = '4.6.0';\n  var DATA_KEY$5 = 'bs.modal';\n  var EVENT_KEY$5 = \".\" + DATA_KEY$5;\n  var DATA_API_KEY$5 = '.data-api';\n  var JQUERY_NO_CONFLICT$5 = $__default['default'].fn[NAME$5];\n  var ESCAPE_KEYCODE$1 = 27; // KeyboardEvent.which value for Escape (Esc) key\n\n  var Default$3 = {\n    backdrop: true,\n    keyboard: true,\n    focus: true,\n    show: true\n  };\n  var DefaultType$3 = {\n    backdrop: '(boolean|string)',\n    keyboard: 'boolean',\n    focus: 'boolean',\n    show: 'boolean'\n  };\n  var EVENT_HIDE$2 = \"hide\" + EVENT_KEY$5;\n  var EVENT_HIDE_PREVENTED = \"hidePrevented\" + EVENT_KEY$5;\n  var EVENT_HIDDEN$2 = \"hidden\" + EVENT_KEY$5;\n  var EVENT_SHOW$2 = \"show\" + EVENT_KEY$5;\n  var EVENT_SHOWN$2 = \"shown\" + EVENT_KEY$5;\n  var EVENT_FOCUSIN = \"focusin\" + EVENT_KEY$5;\n  var EVENT_RESIZE = \"resize\" + EVENT_KEY$5;\n  var EVENT_CLICK_DISMISS = \"click.dismiss\" + EVENT_KEY$5;\n  var EVENT_KEYDOWN_DISMISS = \"keydown.dismiss\" + EVENT_KEY$5;\n  var EVENT_MOUSEUP_DISMISS = \"mouseup.dismiss\" + EVENT_KEY$5;\n  var EVENT_MOUSEDOWN_DISMISS = \"mousedown.dismiss\" + EVENT_KEY$5;\n  var EVENT_CLICK_DATA_API$5 = \"click\" + EVENT_KEY$5 + DATA_API_KEY$5;\n  var CLASS_NAME_SCROLLABLE = 'modal-dialog-scrollable';\n  var CLASS_NAME_SCROLLBAR_MEASURER = 'modal-scrollbar-measure';\n  var CLASS_NAME_BACKDROP = 'modal-backdrop';\n  var CLASS_NAME_OPEN = 'modal-open';\n  var CLASS_NAME_FADE$1 = 'fade';\n  var CLASS_NAME_SHOW$3 = 'show';\n  var CLASS_NAME_STATIC = 'modal-static';\n  var SELECTOR_DIALOG = '.modal-dialog';\n  var SELECTOR_MODAL_BODY = '.modal-body';\n  var SELECTOR_DATA_TOGGLE$3 = '[data-toggle=\"modal\"]';\n  var SELECTOR_DATA_DISMISS = '[data-dismiss=\"modal\"]';\n  var SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';\n  var SELECTOR_STICKY_CONTENT = '.sticky-top';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Modal = /*#__PURE__*/function () {\n    function Modal(element, config) {\n      this._config = this._getConfig(config);\n      this._element = element;\n      this._dialog = element.querySelector(SELECTOR_DIALOG);\n      this._backdrop = null;\n      this._isShown = false;\n      this._isBodyOverflowing = false;\n      this._ignoreBackdropClick = false;\n      this._isTransitioning = false;\n      this._scrollbarWidth = 0;\n    } // Getters\n\n    var _proto = Modal.prototype;\n\n    // Public\n    _proto.toggle = function toggle(relatedTarget) {\n      return this._isShown ? this.hide() : this.show(relatedTarget);\n    };\n    _proto.show = function show(relatedTarget) {\n      var _this = this;\n      if (this._isShown || this._isTransitioning) {\n        return;\n      }\n      if ($__default['default'](this._element).hasClass(CLASS_NAME_FADE$1)) {\n        this._isTransitioning = true;\n      }\n      var showEvent = $__default['default'].Event(EVENT_SHOW$2, {\n        relatedTarget: relatedTarget\n      });\n      $__default['default'](this._element).trigger(showEvent);\n      if (this._isShown || showEvent.isDefaultPrevented()) {\n        return;\n      }\n      this._isShown = true;\n      this._checkScrollbar();\n      this._setScrollbar();\n      this._adjustDialog();\n      this._setEscapeEvent();\n      this._setResizeEvent();\n      $__default['default'](this._element).on(EVENT_CLICK_DISMISS, SELECTOR_DATA_DISMISS, function (event) {\n        return _this.hide(event);\n      });\n      $__default['default'](this._dialog).on(EVENT_MOUSEDOWN_DISMISS, function () {\n        $__default['default'](_this._element).one(EVENT_MOUSEUP_DISMISS, function (event) {\n          if ($__default['default'](event.target).is(_this._element)) {\n            _this._ignoreBackdropClick = true;\n          }\n        });\n      });\n      this._showBackdrop(function () {\n        return _this._showElement(relatedTarget);\n      });\n    };\n    _proto.hide = function hide(event) {\n      var _this2 = this;\n      if (event) {\n        event.preventDefault();\n      }\n      if (!this._isShown || this._isTransitioning) {\n        return;\n      }\n      var hideEvent = $__default['default'].Event(EVENT_HIDE$2);\n      $__default['default'](this._element).trigger(hideEvent);\n      if (!this._isShown || hideEvent.isDefaultPrevented()) {\n        return;\n      }\n      this._isShown = false;\n      var transition = $__default['default'](this._element).hasClass(CLASS_NAME_FADE$1);\n      if (transition) {\n        this._isTransitioning = true;\n      }\n      this._setEscapeEvent();\n      this._setResizeEvent();\n      $__default['default'](document).off(EVENT_FOCUSIN);\n      $__default['default'](this._element).removeClass(CLASS_NAME_SHOW$3);\n      $__default['default'](this._element).off(EVENT_CLICK_DISMISS);\n      $__default['default'](this._dialog).off(EVENT_MOUSEDOWN_DISMISS);\n      if (transition) {\n        var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n        $__default['default'](this._element).one(Util.TRANSITION_END, function (event) {\n          return _this2._hideModal(event);\n        }).emulateTransitionEnd(transitionDuration);\n      } else {\n        this._hideModal();\n      }\n    };\n    _proto.dispose = function dispose() {\n      [window, this._element, this._dialog].forEach(function (htmlElement) {\n        return $__default['default'](htmlElement).off(EVENT_KEY$5);\n      });\n      /**\n       * `document` has 2 events `EVENT_FOCUSIN` and `EVENT_CLICK_DATA_API`\n       * Do not move `document` in `htmlElements` array\n       * It will remove `EVENT_CLICK_DATA_API` event that should remain\n       */\n\n      $__default['default'](document).off(EVENT_FOCUSIN);\n      $__default['default'].removeData(this._element, DATA_KEY$5);\n      this._config = null;\n      this._element = null;\n      this._dialog = null;\n      this._backdrop = null;\n      this._isShown = null;\n      this._isBodyOverflowing = null;\n      this._ignoreBackdropClick = null;\n      this._isTransitioning = null;\n      this._scrollbarWidth = null;\n    };\n    _proto.handleUpdate = function handleUpdate() {\n      this._adjustDialog();\n    } // Private\n    ;\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends({}, Default$3, config);\n      Util.typeCheckConfig(NAME$5, config, DefaultType$3);\n      return config;\n    };\n    _proto._triggerBackdropTransition = function _triggerBackdropTransition() {\n      var _this3 = this;\n      var hideEventPrevented = $__default['default'].Event(EVENT_HIDE_PREVENTED);\n      $__default['default'](this._element).trigger(hideEventPrevented);\n      if (hideEventPrevented.isDefaultPrevented()) {\n        return;\n      }\n      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n      if (!isModalOverflowing) {\n        this._element.style.overflowY = 'hidden';\n      }\n      this._element.classList.add(CLASS_NAME_STATIC);\n      var modalTransitionDuration = Util.getTransitionDurationFromElement(this._dialog);\n      $__default['default'](this._element).off(Util.TRANSITION_END);\n      $__default['default'](this._element).one(Util.TRANSITION_END, function () {\n        _this3._element.classList.remove(CLASS_NAME_STATIC);\n        if (!isModalOverflowing) {\n          $__default['default'](_this3._element).one(Util.TRANSITION_END, function () {\n            _this3._element.style.overflowY = '';\n          }).emulateTransitionEnd(_this3._element, modalTransitionDuration);\n        }\n      }).emulateTransitionEnd(modalTransitionDuration);\n      this._element.focus();\n    };\n    _proto._showElement = function _showElement(relatedTarget) {\n      var _this4 = this;\n      var transition = $__default['default'](this._element).hasClass(CLASS_NAME_FADE$1);\n      var modalBody = this._dialog ? this._dialog.querySelector(SELECTOR_MODAL_BODY) : null;\n      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {\n        // Don't move modal's DOM position\n        document.body.appendChild(this._element);\n      }\n      this._element.style.display = 'block';\n      this._element.removeAttribute('aria-hidden');\n      this._element.setAttribute('aria-modal', true);\n      this._element.setAttribute('role', 'dialog');\n      if ($__default['default'](this._dialog).hasClass(CLASS_NAME_SCROLLABLE) && modalBody) {\n        modalBody.scrollTop = 0;\n      } else {\n        this._element.scrollTop = 0;\n      }\n      if (transition) {\n        Util.reflow(this._element);\n      }\n      $__default['default'](this._element).addClass(CLASS_NAME_SHOW$3);\n      if (this._config.focus) {\n        this._enforceFocus();\n      }\n      var shownEvent = $__default['default'].Event(EVENT_SHOWN$2, {\n        relatedTarget: relatedTarget\n      });\n      var transitionComplete = function transitionComplete() {\n        if (_this4._config.focus) {\n          _this4._element.focus();\n        }\n        _this4._isTransitioning = false;\n        $__default['default'](_this4._element).trigger(shownEvent);\n      };\n      if (transition) {\n        var transitionDuration = Util.getTransitionDurationFromElement(this._dialog);\n        $__default['default'](this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);\n      } else {\n        transitionComplete();\n      }\n    };\n    _proto._enforceFocus = function _enforceFocus() {\n      var _this5 = this;\n      $__default['default'](document).off(EVENT_FOCUSIN) // Guard against infinite focus loop\n      .on(EVENT_FOCUSIN, function (event) {\n        if (document !== event.target && _this5._element !== event.target && $__default['default'](_this5._element).has(event.target).length === 0) {\n          _this5._element.focus();\n        }\n      });\n    };\n    _proto._setEscapeEvent = function _setEscapeEvent() {\n      var _this6 = this;\n      if (this._isShown) {\n        $__default['default'](this._element).on(EVENT_KEYDOWN_DISMISS, function (event) {\n          if (_this6._config.keyboard && event.which === ESCAPE_KEYCODE$1) {\n            event.preventDefault();\n            _this6.hide();\n          } else if (!_this6._config.keyboard && event.which === ESCAPE_KEYCODE$1) {\n            _this6._triggerBackdropTransition();\n          }\n        });\n      } else if (!this._isShown) {\n        $__default['default'](this._element).off(EVENT_KEYDOWN_DISMISS);\n      }\n    };\n    _proto._setResizeEvent = function _setResizeEvent() {\n      var _this7 = this;\n      if (this._isShown) {\n        $__default['default'](window).on(EVENT_RESIZE, function (event) {\n          return _this7.handleUpdate(event);\n        });\n      } else {\n        $__default['default'](window).off(EVENT_RESIZE);\n      }\n    };\n    _proto._hideModal = function _hideModal() {\n      var _this8 = this;\n      this._element.style.display = 'none';\n      this._element.setAttribute('aria-hidden', true);\n      this._element.removeAttribute('aria-modal');\n      this._element.removeAttribute('role');\n      this._isTransitioning = false;\n      this._showBackdrop(function () {\n        $__default['default'](document.body).removeClass(CLASS_NAME_OPEN);\n        _this8._resetAdjustments();\n        _this8._resetScrollbar();\n        $__default['default'](_this8._element).trigger(EVENT_HIDDEN$2);\n      });\n    };\n    _proto._removeBackdrop = function _removeBackdrop() {\n      if (this._backdrop) {\n        $__default['default'](this._backdrop).remove();\n        this._backdrop = null;\n      }\n    };\n    _proto._showBackdrop = function _showBackdrop(callback) {\n      var _this9 = this;\n      var animate = $__default['default'](this._element).hasClass(CLASS_NAME_FADE$1) ? CLASS_NAME_FADE$1 : '';\n      if (this._isShown && this._config.backdrop) {\n        this._backdrop = document.createElement('div');\n        this._backdrop.className = CLASS_NAME_BACKDROP;\n        if (animate) {\n          this._backdrop.classList.add(animate);\n        }\n        $__default['default'](this._backdrop).appendTo(document.body);\n        $__default['default'](this._element).on(EVENT_CLICK_DISMISS, function (event) {\n          if (_this9._ignoreBackdropClick) {\n            _this9._ignoreBackdropClick = false;\n            return;\n          }\n          if (event.target !== event.currentTarget) {\n            return;\n          }\n          if (_this9._config.backdrop === 'static') {\n            _this9._triggerBackdropTransition();\n          } else {\n            _this9.hide();\n          }\n        });\n        if (animate) {\n          Util.reflow(this._backdrop);\n        }\n        $__default['default'](this._backdrop).addClass(CLASS_NAME_SHOW$3);\n        if (!callback) {\n          return;\n        }\n        if (!animate) {\n          callback();\n          return;\n        }\n        var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);\n        $__default['default'](this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);\n      } else if (!this._isShown && this._backdrop) {\n        $__default['default'](this._backdrop).removeClass(CLASS_NAME_SHOW$3);\n        var callbackRemove = function callbackRemove() {\n          _this9._removeBackdrop();\n          if (callback) {\n            callback();\n          }\n        };\n        if ($__default['default'](this._element).hasClass(CLASS_NAME_FADE$1)) {\n          var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);\n          $__default['default'](this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);\n        } else {\n          callbackRemove();\n        }\n      } else if (callback) {\n        callback();\n      }\n    } // ----------------------------------------------------------------------\n    // the following methods are used to handle overflowing modals\n    // todo (fat): these should probably be refactored out of modal.js\n    // ----------------------------------------------------------------------\n    ;\n\n    _proto._adjustDialog = function _adjustDialog() {\n      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n      if (!this._isBodyOverflowing && isModalOverflowing) {\n        this._element.style.paddingLeft = this._scrollbarWidth + \"px\";\n      }\n      if (this._isBodyOverflowing && !isModalOverflowing) {\n        this._element.style.paddingRight = this._scrollbarWidth + \"px\";\n      }\n    };\n    _proto._resetAdjustments = function _resetAdjustments() {\n      this._element.style.paddingLeft = '';\n      this._element.style.paddingRight = '';\n    };\n    _proto._checkScrollbar = function _checkScrollbar() {\n      var rect = document.body.getBoundingClientRect();\n      this._isBodyOverflowing = Math.round(rect.left + rect.right) < window.innerWidth;\n      this._scrollbarWidth = this._getScrollbarWidth();\n    };\n    _proto._setScrollbar = function _setScrollbar() {\n      var _this10 = this;\n      if (this._isBodyOverflowing) {\n        // Note: DOMNode.style.paddingRight returns the actual value or '' if not set\n        //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set\n        var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));\n        var stickyContent = [].slice.call(document.querySelectorAll(SELECTOR_STICKY_CONTENT)); // Adjust fixed content padding\n\n        $__default['default'](fixedContent).each(function (index, element) {\n          var actualPadding = element.style.paddingRight;\n          var calculatedPadding = $__default['default'](element).css('padding-right');\n          $__default['default'](element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this10._scrollbarWidth + \"px\");\n        }); // Adjust sticky content margin\n\n        $__default['default'](stickyContent).each(function (index, element) {\n          var actualMargin = element.style.marginRight;\n          var calculatedMargin = $__default['default'](element).css('margin-right');\n          $__default['default'](element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this10._scrollbarWidth + \"px\");\n        }); // Adjust body padding\n\n        var actualPadding = document.body.style.paddingRight;\n        var calculatedPadding = $__default['default'](document.body).css('padding-right');\n        $__default['default'](document.body).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + \"px\");\n      }\n      $__default['default'](document.body).addClass(CLASS_NAME_OPEN);\n    };\n    _proto._resetScrollbar = function _resetScrollbar() {\n      // Restore fixed content padding\n      var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));\n      $__default['default'](fixedContent).each(function (index, element) {\n        var padding = $__default['default'](element).data('padding-right');\n        $__default['default'](element).removeData('padding-right');\n        element.style.paddingRight = padding ? padding : '';\n      }); // Restore sticky content\n\n      var elements = [].slice.call(document.querySelectorAll(\"\" + SELECTOR_STICKY_CONTENT));\n      $__default['default'](elements).each(function (index, element) {\n        var margin = $__default['default'](element).data('margin-right');\n        if (typeof margin !== 'undefined') {\n          $__default['default'](element).css('margin-right', margin).removeData('margin-right');\n        }\n      }); // Restore body padding\n\n      var padding = $__default['default'](document.body).data('padding-right');\n      $__default['default'](document.body).removeData('padding-right');\n      document.body.style.paddingRight = padding ? padding : '';\n    };\n    _proto._getScrollbarWidth = function _getScrollbarWidth() {\n      // thx d.walsh\n      var scrollDiv = document.createElement('div');\n      scrollDiv.className = CLASS_NAME_SCROLLBAR_MEASURER;\n      document.body.appendChild(scrollDiv);\n      var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;\n      document.body.removeChild(scrollDiv);\n      return scrollbarWidth;\n    } // Static\n    ;\n\n    Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {\n      return this.each(function () {\n        var data = $__default['default'](this).data(DATA_KEY$5);\n        var _config = _extends({}, Default$3, $__default['default'](this).data(), _typeof(config) === 'object' && config ? config : {});\n        if (!data) {\n          data = new Modal(this, _config);\n          $__default['default'](this).data(DATA_KEY$5, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n          data[config](relatedTarget);\n        } else if (_config.show) {\n          data.show(relatedTarget);\n        }\n      });\n    };\n    _createClass(Modal, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$5;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$3;\n      }\n    }]);\n    return Modal;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'](document).on(EVENT_CLICK_DATA_API$5, SELECTOR_DATA_TOGGLE$3, function (event) {\n    var _this11 = this;\n    var target;\n    var selector = Util.getSelectorFromElement(this);\n    if (selector) {\n      target = document.querySelector(selector);\n    }\n    var config = $__default['default'](target).data(DATA_KEY$5) ? 'toggle' : _extends({}, $__default['default'](target).data(), $__default['default'](this).data());\n    if (this.tagName === 'A' || this.tagName === 'AREA') {\n      event.preventDefault();\n    }\n    var $target = $__default['default'](target).one(EVENT_SHOW$2, function (showEvent) {\n      if (showEvent.isDefaultPrevented()) {\n        // Only register focus restorer if modal will actually get shown\n        return;\n      }\n      $target.one(EVENT_HIDDEN$2, function () {\n        if ($__default['default'](_this11).is(':visible')) {\n          _this11.focus();\n        }\n      });\n    });\n    Modal._jQueryInterface.call($__default['default'](target), config, this);\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'].fn[NAME$5] = Modal._jQueryInterface;\n  $__default['default'].fn[NAME$5].Constructor = Modal;\n  $__default['default'].fn[NAME$5].noConflict = function () {\n    $__default['default'].fn[NAME$5] = JQUERY_NO_CONFLICT$5;\n    return Modal._jQueryInterface;\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v4.6.0): tools/sanitizer.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  var uriAttrs = ['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href'];\n  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\n  var DefaultWhitelist = {\n    // Global attributes allowed on any supplied element below.\n    '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],\n    a: ['target', 'href', 'title', 'rel'],\n    area: [],\n    b: [],\n    br: [],\n    col: [],\n    code: [],\n    div: [],\n    em: [],\n    hr: [],\n    h1: [],\n    h2: [],\n    h3: [],\n    h4: [],\n    h5: [],\n    h6: [],\n    i: [],\n    img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],\n    li: [],\n    ol: [],\n    p: [],\n    pre: [],\n    s: [],\n    small: [],\n    span: [],\n    sub: [],\n    sup: [],\n    strong: [],\n    u: [],\n    ul: []\n  };\n  /**\n   * A pattern that recognizes a commonly useful subset of URLs that are safe.\n   *\n   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\n   */\n\n  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/gi;\n  /**\n   * A pattern that matches safe data URLs. Only matches image, video and audio types.\n   *\n   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\n   */\n\n  var DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i;\n  function allowedAttribute(attr, allowedAttributeList) {\n    var attrName = attr.nodeName.toLowerCase();\n    if (allowedAttributeList.indexOf(attrName) !== -1) {\n      if (uriAttrs.indexOf(attrName) !== -1) {\n        return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN));\n      }\n      return true;\n    }\n    var regExp = allowedAttributeList.filter(function (attrRegex) {\n      return attrRegex instanceof RegExp;\n    }); // Check if a regular expression validates the attribute.\n\n    for (var i = 0, len = regExp.length; i < len; i++) {\n      if (attrName.match(regExp[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function sanitizeHtml(unsafeHtml, whiteList, sanitizeFn) {\n    if (unsafeHtml.length === 0) {\n      return unsafeHtml;\n    }\n    if (sanitizeFn && typeof sanitizeFn === 'function') {\n      return sanitizeFn(unsafeHtml);\n    }\n    var domParser = new window.DOMParser();\n    var createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');\n    var whitelistKeys = Object.keys(whiteList);\n    var elements = [].slice.call(createdDocument.body.querySelectorAll('*'));\n    var _loop = function _loop(i, len) {\n      var el = elements[i];\n      var elName = el.nodeName.toLowerCase();\n      if (whitelistKeys.indexOf(el.nodeName.toLowerCase()) === -1) {\n        el.parentNode.removeChild(el);\n        return \"continue\";\n      }\n      var attributeList = [].slice.call(el.attributes);\n      var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);\n      attributeList.forEach(function (attr) {\n        if (!allowedAttribute(attr, whitelistedAttributes)) {\n          el.removeAttribute(attr.nodeName);\n        }\n      });\n    };\n    for (var i = 0, len = elements.length; i < len; i++) {\n      var _ret = _loop(i);\n      if (_ret === \"continue\") continue;\n    }\n    return createdDocument.body.innerHTML;\n  }\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$6 = 'tooltip';\n  var VERSION$6 = '4.6.0';\n  var DATA_KEY$6 = 'bs.tooltip';\n  var EVENT_KEY$6 = \".\" + DATA_KEY$6;\n  var JQUERY_NO_CONFLICT$6 = $__default['default'].fn[NAME$6];\n  var CLASS_PREFIX = 'bs-tooltip';\n  var BSCLS_PREFIX_REGEX = new RegExp(\"(^|\\\\s)\" + CLASS_PREFIX + \"\\\\S+\", 'g');\n  var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];\n  var DefaultType$4 = {\n    animation: 'boolean',\n    template: 'string',\n    title: '(string|element|function)',\n    trigger: 'string',\n    delay: '(number|object)',\n    html: 'boolean',\n    selector: '(string|boolean)',\n    placement: '(string|function)',\n    offset: '(number|string|function)',\n    container: '(string|element|boolean)',\n    fallbackPlacement: '(string|array)',\n    boundary: '(string|element)',\n    customClass: '(string|function)',\n    sanitize: 'boolean',\n    sanitizeFn: '(null|function)',\n    whiteList: 'object',\n    popperConfig: '(null|object)'\n  };\n  var AttachmentMap = {\n    AUTO: 'auto',\n    TOP: 'top',\n    RIGHT: 'right',\n    BOTTOM: 'bottom',\n    LEFT: 'left'\n  };\n  var Default$4 = {\n    animation: true,\n    template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"arrow\"></div>' + '<div class=\"tooltip-inner\"></div></div>',\n    trigger: 'hover focus',\n    title: '',\n    delay: 0,\n    html: false,\n    selector: false,\n    placement: 'top',\n    offset: 0,\n    container: false,\n    fallbackPlacement: 'flip',\n    boundary: 'scrollParent',\n    customClass: '',\n    sanitize: true,\n    sanitizeFn: null,\n    whiteList: DefaultWhitelist,\n    popperConfig: null\n  };\n  var HOVER_STATE_SHOW = 'show';\n  var HOVER_STATE_OUT = 'out';\n  var Event = {\n    HIDE: \"hide\" + EVENT_KEY$6,\n    HIDDEN: \"hidden\" + EVENT_KEY$6,\n    SHOW: \"show\" + EVENT_KEY$6,\n    SHOWN: \"shown\" + EVENT_KEY$6,\n    INSERTED: \"inserted\" + EVENT_KEY$6,\n    CLICK: \"click\" + EVENT_KEY$6,\n    FOCUSIN: \"focusin\" + EVENT_KEY$6,\n    FOCUSOUT: \"focusout\" + EVENT_KEY$6,\n    MOUSEENTER: \"mouseenter\" + EVENT_KEY$6,\n    MOUSELEAVE: \"mouseleave\" + EVENT_KEY$6\n  };\n  var CLASS_NAME_FADE$2 = 'fade';\n  var CLASS_NAME_SHOW$4 = 'show';\n  var SELECTOR_TOOLTIP_INNER = '.tooltip-inner';\n  var SELECTOR_ARROW = '.arrow';\n  var TRIGGER_HOVER = 'hover';\n  var TRIGGER_FOCUS = 'focus';\n  var TRIGGER_CLICK = 'click';\n  var TRIGGER_MANUAL = 'manual';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Tooltip = /*#__PURE__*/function () {\n    function Tooltip(element, config) {\n      if (typeof Popper === 'undefined') {\n        throw new TypeError('Bootstrap\\'s tooltips require Popper (https://popper.js.org)');\n      } // private\n\n      this._isEnabled = true;\n      this._timeout = 0;\n      this._hoverState = '';\n      this._activeTrigger = {};\n      this._popper = null; // Protected\n\n      this.element = element;\n      this.config = this._getConfig(config);\n      this.tip = null;\n      this._setListeners();\n    } // Getters\n\n    var _proto = Tooltip.prototype;\n\n    // Public\n    _proto.enable = function enable() {\n      this._isEnabled = true;\n    };\n    _proto.disable = function disable() {\n      this._isEnabled = false;\n    };\n    _proto.toggleEnabled = function toggleEnabled() {\n      this._isEnabled = !this._isEnabled;\n    };\n    _proto.toggle = function toggle(event) {\n      if (!this._isEnabled) {\n        return;\n      }\n      if (event) {\n        var dataKey = this.constructor.DATA_KEY;\n        var context = $__default['default'](event.currentTarget).data(dataKey);\n        if (!context) {\n          context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n          $__default['default'](event.currentTarget).data(dataKey, context);\n        }\n        context._activeTrigger.click = !context._activeTrigger.click;\n        if (context._isWithActiveTrigger()) {\n          context._enter(null, context);\n        } else {\n          context._leave(null, context);\n        }\n      } else {\n        if ($__default['default'](this.getTipElement()).hasClass(CLASS_NAME_SHOW$4)) {\n          this._leave(null, this);\n          return;\n        }\n        this._enter(null, this);\n      }\n    };\n    _proto.dispose = function dispose() {\n      clearTimeout(this._timeout);\n      $__default['default'].removeData(this.element, this.constructor.DATA_KEY);\n      $__default['default'](this.element).off(this.constructor.EVENT_KEY);\n      $__default['default'](this.element).closest('.modal').off('hide.bs.modal', this._hideModalHandler);\n      if (this.tip) {\n        $__default['default'](this.tip).remove();\n      }\n      this._isEnabled = null;\n      this._timeout = null;\n      this._hoverState = null;\n      this._activeTrigger = null;\n      if (this._popper) {\n        this._popper.destroy();\n      }\n      this._popper = null;\n      this.element = null;\n      this.config = null;\n      this.tip = null;\n    };\n    _proto.show = function show() {\n      var _this = this;\n      if ($__default['default'](this.element).css('display') === 'none') {\n        throw new Error('Please use show on visible elements');\n      }\n      var showEvent = $__default['default'].Event(this.constructor.Event.SHOW);\n      if (this.isWithContent() && this._isEnabled) {\n        $__default['default'](this.element).trigger(showEvent);\n        var shadowRoot = Util.findShadowRoot(this.element);\n        var isInTheDom = $__default['default'].contains(shadowRoot !== null ? shadowRoot : this.element.ownerDocument.documentElement, this.element);\n        if (showEvent.isDefaultPrevented() || !isInTheDom) {\n          return;\n        }\n        var tip = this.getTipElement();\n        var tipId = Util.getUID(this.constructor.NAME);\n        tip.setAttribute('id', tipId);\n        this.element.setAttribute('aria-describedby', tipId);\n        this.setContent();\n        if (this.config.animation) {\n          $__default['default'](tip).addClass(CLASS_NAME_FADE$2);\n        }\n        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;\n        var attachment = this._getAttachment(placement);\n        this.addAttachmentClass(attachment);\n        var container = this._getContainer();\n        $__default['default'](tip).data(this.constructor.DATA_KEY, this);\n        if (!$__default['default'].contains(this.element.ownerDocument.documentElement, this.tip)) {\n          $__default['default'](tip).appendTo(container);\n        }\n        $__default['default'](this.element).trigger(this.constructor.Event.INSERTED);\n        this._popper = new Popper(this.element, tip, this._getPopperConfig(attachment));\n        $__default['default'](tip).addClass(CLASS_NAME_SHOW$4);\n        $__default['default'](tip).addClass(this.config.customClass); // If this is a touch-enabled device we add extra\n        // empty mouseover listeners to the body's immediate children;\n        // only needed because of broken event delegation on iOS\n        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n        if ('ontouchstart' in document.documentElement) {\n          $__default['default'](document.body).children().on('mouseover', null, $__default['default'].noop);\n        }\n        var complete = function complete() {\n          if (_this.config.animation) {\n            _this._fixTransition();\n          }\n          var prevHoverState = _this._hoverState;\n          _this._hoverState = null;\n          $__default['default'](_this.element).trigger(_this.constructor.Event.SHOWN);\n          if (prevHoverState === HOVER_STATE_OUT) {\n            _this._leave(null, _this);\n          }\n        };\n        if ($__default['default'](this.tip).hasClass(CLASS_NAME_FADE$2)) {\n          var transitionDuration = Util.getTransitionDurationFromElement(this.tip);\n          $__default['default'](this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n        } else {\n          complete();\n        }\n      }\n    };\n    _proto.hide = function hide(callback) {\n      var _this2 = this;\n      var tip = this.getTipElement();\n      var hideEvent = $__default['default'].Event(this.constructor.Event.HIDE);\n      var complete = function complete() {\n        if (_this2._hoverState !== HOVER_STATE_SHOW && tip.parentNode) {\n          tip.parentNode.removeChild(tip);\n        }\n        _this2._cleanTipClass();\n        _this2.element.removeAttribute('aria-describedby');\n        $__default['default'](_this2.element).trigger(_this2.constructor.Event.HIDDEN);\n        if (_this2._popper !== null) {\n          _this2._popper.destroy();\n        }\n        if (callback) {\n          callback();\n        }\n      };\n      $__default['default'](this.element).trigger(hideEvent);\n      if (hideEvent.isDefaultPrevented()) {\n        return;\n      }\n      $__default['default'](tip).removeClass(CLASS_NAME_SHOW$4); // If this is a touch-enabled device we remove the extra\n      // empty mouseover listeners we added for iOS support\n\n      if ('ontouchstart' in document.documentElement) {\n        $__default['default'](document.body).children().off('mouseover', null, $__default['default'].noop);\n      }\n      this._activeTrigger[TRIGGER_CLICK] = false;\n      this._activeTrigger[TRIGGER_FOCUS] = false;\n      this._activeTrigger[TRIGGER_HOVER] = false;\n      if ($__default['default'](this.tip).hasClass(CLASS_NAME_FADE$2)) {\n        var transitionDuration = Util.getTransitionDurationFromElement(tip);\n        $__default['default'](tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n      this._hoverState = '';\n    };\n    _proto.update = function update() {\n      if (this._popper !== null) {\n        this._popper.scheduleUpdate();\n      }\n    } // Protected\n    ;\n\n    _proto.isWithContent = function isWithContent() {\n      return Boolean(this.getTitle());\n    };\n    _proto.addAttachmentClass = function addAttachmentClass(attachment) {\n      $__default['default'](this.getTipElement()).addClass(CLASS_PREFIX + \"-\" + attachment);\n    };\n    _proto.getTipElement = function getTipElement() {\n      this.tip = this.tip || $__default['default'](this.config.template)[0];\n      return this.tip;\n    };\n    _proto.setContent = function setContent() {\n      var tip = this.getTipElement();\n      this.setElementContent($__default['default'](tip.querySelectorAll(SELECTOR_TOOLTIP_INNER)), this.getTitle());\n      $__default['default'](tip).removeClass(CLASS_NAME_FADE$2 + \" \" + CLASS_NAME_SHOW$4);\n    };\n    _proto.setElementContent = function setElementContent($element, content) {\n      if (_typeof(content) === 'object' && (content.nodeType || content.jquery)) {\n        // Content is a DOM node or a jQuery\n        if (this.config.html) {\n          if (!$__default['default'](content).parent().is($element)) {\n            $element.empty().append(content);\n          }\n        } else {\n          $element.text($__default['default'](content).text());\n        }\n        return;\n      }\n      if (this.config.html) {\n        if (this.config.sanitize) {\n          content = sanitizeHtml(content, this.config.whiteList, this.config.sanitizeFn);\n        }\n        $element.html(content);\n      } else {\n        $element.text(content);\n      }\n    };\n    _proto.getTitle = function getTitle() {\n      var title = this.element.getAttribute('data-original-title');\n      if (!title) {\n        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;\n      }\n      return title;\n    } // Private\n    ;\n\n    _proto._getPopperConfig = function _getPopperConfig(attachment) {\n      var _this3 = this;\n      var defaultBsConfig = {\n        placement: attachment,\n        modifiers: {\n          offset: this._getOffset(),\n          flip: {\n            behavior: this.config.fallbackPlacement\n          },\n          arrow: {\n            element: SELECTOR_ARROW\n          },\n          preventOverflow: {\n            boundariesElement: this.config.boundary\n          }\n        },\n        onCreate: function onCreate(data) {\n          if (data.originalPlacement !== data.placement) {\n            _this3._handlePopperPlacementChange(data);\n          }\n        },\n        onUpdate: function onUpdate(data) {\n          return _this3._handlePopperPlacementChange(data);\n        }\n      };\n      return _extends({}, defaultBsConfig, this.config.popperConfig);\n    };\n    _proto._getOffset = function _getOffset() {\n      var _this4 = this;\n      var offset = {};\n      if (typeof this.config.offset === 'function') {\n        offset.fn = function (data) {\n          data.offsets = _extends({}, data.offsets, _this4.config.offset(data.offsets, _this4.element) || {});\n          return data;\n        };\n      } else {\n        offset.offset = this.config.offset;\n      }\n      return offset;\n    };\n    _proto._getContainer = function _getContainer() {\n      if (this.config.container === false) {\n        return document.body;\n      }\n      if (Util.isElement(this.config.container)) {\n        return $__default['default'](this.config.container);\n      }\n      return $__default['default'](document).find(this.config.container);\n    };\n    _proto._getAttachment = function _getAttachment(placement) {\n      return AttachmentMap[placement.toUpperCase()];\n    };\n    _proto._setListeners = function _setListeners() {\n      var _this5 = this;\n      var triggers = this.config.trigger.split(' ');\n      triggers.forEach(function (trigger) {\n        if (trigger === 'click') {\n          $__default['default'](_this5.element).on(_this5.constructor.Event.CLICK, _this5.config.selector, function (event) {\n            return _this5.toggle(event);\n          });\n        } else if (trigger !== TRIGGER_MANUAL) {\n          var eventIn = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSEENTER : _this5.constructor.Event.FOCUSIN;\n          var eventOut = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSELEAVE : _this5.constructor.Event.FOCUSOUT;\n          $__default['default'](_this5.element).on(eventIn, _this5.config.selector, function (event) {\n            return _this5._enter(event);\n          }).on(eventOut, _this5.config.selector, function (event) {\n            return _this5._leave(event);\n          });\n        }\n      });\n      this._hideModalHandler = function () {\n        if (_this5.element) {\n          _this5.hide();\n        }\n      };\n      $__default['default'](this.element).closest('.modal').on('hide.bs.modal', this._hideModalHandler);\n      if (this.config.selector) {\n        this.config = _extends({}, this.config, {\n          trigger: 'manual',\n          selector: ''\n        });\n      } else {\n        this._fixTitle();\n      }\n    };\n    _proto._fixTitle = function _fixTitle() {\n      var titleType = _typeof(this.element.getAttribute('data-original-title'));\n      if (this.element.getAttribute('title') || titleType !== 'string') {\n        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');\n        this.element.setAttribute('title', '');\n      }\n    };\n    _proto._enter = function _enter(event, context) {\n      var dataKey = this.constructor.DATA_KEY;\n      context = context || $__default['default'](event.currentTarget).data(dataKey);\n      if (!context) {\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n        $__default['default'](event.currentTarget).data(dataKey, context);\n      }\n      if (event) {\n        context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\n      }\n      if ($__default['default'](context.getTipElement()).hasClass(CLASS_NAME_SHOW$4) || context._hoverState === HOVER_STATE_SHOW) {\n        context._hoverState = HOVER_STATE_SHOW;\n        return;\n      }\n      clearTimeout(context._timeout);\n      context._hoverState = HOVER_STATE_SHOW;\n      if (!context.config.delay || !context.config.delay.show) {\n        context.show();\n        return;\n      }\n      context._timeout = setTimeout(function () {\n        if (context._hoverState === HOVER_STATE_SHOW) {\n          context.show();\n        }\n      }, context.config.delay.show);\n    };\n    _proto._leave = function _leave(event, context) {\n      var dataKey = this.constructor.DATA_KEY;\n      context = context || $__default['default'](event.currentTarget).data(dataKey);\n      if (!context) {\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n        $__default['default'](event.currentTarget).data(dataKey, context);\n      }\n      if (event) {\n        context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = false;\n      }\n      if (context._isWithActiveTrigger()) {\n        return;\n      }\n      clearTimeout(context._timeout);\n      context._hoverState = HOVER_STATE_OUT;\n      if (!context.config.delay || !context.config.delay.hide) {\n        context.hide();\n        return;\n      }\n      context._timeout = setTimeout(function () {\n        if (context._hoverState === HOVER_STATE_OUT) {\n          context.hide();\n        }\n      }, context.config.delay.hide);\n    };\n    _proto._isWithActiveTrigger = function _isWithActiveTrigger() {\n      for (var trigger in this._activeTrigger) {\n        if (this._activeTrigger[trigger]) {\n          return true;\n        }\n      }\n      return false;\n    };\n    _proto._getConfig = function _getConfig(config) {\n      var dataAttributes = $__default['default'](this.element).data();\n      Object.keys(dataAttributes).forEach(function (dataAttr) {\n        if (DISALLOWED_ATTRIBUTES.indexOf(dataAttr) !== -1) {\n          delete dataAttributes[dataAttr];\n        }\n      });\n      config = _extends({}, this.constructor.Default, dataAttributes, _typeof(config) === 'object' && config ? config : {});\n      if (typeof config.delay === 'number') {\n        config.delay = {\n          show: config.delay,\n          hide: config.delay\n        };\n      }\n      if (typeof config.title === 'number') {\n        config.title = config.title.toString();\n      }\n      if (typeof config.content === 'number') {\n        config.content = config.content.toString();\n      }\n      Util.typeCheckConfig(NAME$6, config, this.constructor.DefaultType);\n      if (config.sanitize) {\n        config.template = sanitizeHtml(config.template, config.whiteList, config.sanitizeFn);\n      }\n      return config;\n    };\n    _proto._getDelegateConfig = function _getDelegateConfig() {\n      var config = {};\n      if (this.config) {\n        for (var key in this.config) {\n          if (this.constructor.Default[key] !== this.config[key]) {\n            config[key] = this.config[key];\n          }\n        }\n      }\n      return config;\n    };\n    _proto._cleanTipClass = function _cleanTipClass() {\n      var $tip = $__default['default'](this.getTipElement());\n      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);\n      if (tabClass !== null && tabClass.length) {\n        $tip.removeClass(tabClass.join(''));\n      }\n    };\n    _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(popperData) {\n      this.tip = popperData.instance.popper;\n      this._cleanTipClass();\n      this.addAttachmentClass(this._getAttachment(popperData.placement));\n    };\n    _proto._fixTransition = function _fixTransition() {\n      var tip = this.getTipElement();\n      var initConfigAnimation = this.config.animation;\n      if (tip.getAttribute('x-placement') !== null) {\n        return;\n      }\n      $__default['default'](tip).removeClass(CLASS_NAME_FADE$2);\n      this.config.animation = false;\n      this.hide();\n      this.show();\n      this.config.animation = initConfigAnimation;\n    } // Static\n    ;\n\n    Tooltip._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = $__default['default'](this);\n        var data = $element.data(DATA_KEY$6);\n        var _config = _typeof(config) === 'object' && config;\n        if (!data && /dispose|hide/.test(config)) {\n          return;\n        }\n        if (!data) {\n          data = new Tooltip(this, _config);\n          $element.data(DATA_KEY$6, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n          data[config]();\n        }\n      });\n    };\n    _createClass(Tooltip, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$6;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$4;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$6;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return DATA_KEY$6;\n      }\n    }, {\n      key: \"Event\",\n      get: function get() {\n        return Event;\n      }\n    }, {\n      key: \"EVENT_KEY\",\n      get: function get() {\n        return EVENT_KEY$6;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$4;\n      }\n    }]);\n    return Tooltip;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'].fn[NAME$6] = Tooltip._jQueryInterface;\n  $__default['default'].fn[NAME$6].Constructor = Tooltip;\n  $__default['default'].fn[NAME$6].noConflict = function () {\n    $__default['default'].fn[NAME$6] = JQUERY_NO_CONFLICT$6;\n    return Tooltip._jQueryInterface;\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$7 = 'popover';\n  var VERSION$7 = '4.6.0';\n  var DATA_KEY$7 = 'bs.popover';\n  var EVENT_KEY$7 = \".\" + DATA_KEY$7;\n  var JQUERY_NO_CONFLICT$7 = $__default['default'].fn[NAME$7];\n  var CLASS_PREFIX$1 = 'bs-popover';\n  var BSCLS_PREFIX_REGEX$1 = new RegExp(\"(^|\\\\s)\" + CLASS_PREFIX$1 + \"\\\\S+\", 'g');\n  var Default$5 = _extends({}, Tooltip.Default, {\n    placement: 'right',\n    trigger: 'click',\n    content: '',\n    template: '<div class=\"popover\" role=\"tooltip\">' + '<div class=\"arrow\"></div>' + '<h3 class=\"popover-header\"></h3>' + '<div class=\"popover-body\"></div></div>'\n  });\n  var DefaultType$5 = _extends({}, Tooltip.DefaultType, {\n    content: '(string|element|function)'\n  });\n  var CLASS_NAME_FADE$3 = 'fade';\n  var CLASS_NAME_SHOW$5 = 'show';\n  var SELECTOR_TITLE = '.popover-header';\n  var SELECTOR_CONTENT = '.popover-body';\n  var Event$1 = {\n    HIDE: \"hide\" + EVENT_KEY$7,\n    HIDDEN: \"hidden\" + EVENT_KEY$7,\n    SHOW: \"show\" + EVENT_KEY$7,\n    SHOWN: \"shown\" + EVENT_KEY$7,\n    INSERTED: \"inserted\" + EVENT_KEY$7,\n    CLICK: \"click\" + EVENT_KEY$7,\n    FOCUSIN: \"focusin\" + EVENT_KEY$7,\n    FOCUSOUT: \"focusout\" + EVENT_KEY$7,\n    MOUSEENTER: \"mouseenter\" + EVENT_KEY$7,\n    MOUSELEAVE: \"mouseleave\" + EVENT_KEY$7\n  };\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Popover = /*#__PURE__*/function (_Tooltip) {\n    _inheritsLoose(Popover, _Tooltip);\n    function Popover() {\n      return _Tooltip.apply(this, arguments) || this;\n    }\n    var _proto = Popover.prototype;\n\n    // Overrides\n    _proto.isWithContent = function isWithContent() {\n      return this.getTitle() || this._getContent();\n    };\n    _proto.addAttachmentClass = function addAttachmentClass(attachment) {\n      $__default['default'](this.getTipElement()).addClass(CLASS_PREFIX$1 + \"-\" + attachment);\n    };\n    _proto.getTipElement = function getTipElement() {\n      this.tip = this.tip || $__default['default'](this.config.template)[0];\n      return this.tip;\n    };\n    _proto.setContent = function setContent() {\n      var $tip = $__default['default'](this.getTipElement()); // We use append for html objects to maintain js events\n\n      this.setElementContent($tip.find(SELECTOR_TITLE), this.getTitle());\n      var content = this._getContent();\n      if (typeof content === 'function') {\n        content = content.call(this.element);\n      }\n      this.setElementContent($tip.find(SELECTOR_CONTENT), content);\n      $tip.removeClass(CLASS_NAME_FADE$3 + \" \" + CLASS_NAME_SHOW$5);\n    } // Private\n    ;\n\n    _proto._getContent = function _getContent() {\n      return this.element.getAttribute('data-content') || this.config.content;\n    };\n    _proto._cleanTipClass = function _cleanTipClass() {\n      var $tip = $__default['default'](this.getTipElement());\n      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX$1);\n      if (tabClass !== null && tabClass.length > 0) {\n        $tip.removeClass(tabClass.join(''));\n      }\n    } // Static\n    ;\n\n    Popover._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $__default['default'](this).data(DATA_KEY$7);\n        var _config = _typeof(config) === 'object' ? config : null;\n        if (!data && /dispose|hide/.test(config)) {\n          return;\n        }\n        if (!data) {\n          data = new Popover(this, _config);\n          $__default['default'](this).data(DATA_KEY$7, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n          data[config]();\n        }\n      });\n    };\n    _createClass(Popover, null, [{\n      key: \"VERSION\",\n      // Getters\n      get: function get() {\n        return VERSION$7;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$5;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$7;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return DATA_KEY$7;\n      }\n    }, {\n      key: \"Event\",\n      get: function get() {\n        return Event$1;\n      }\n    }, {\n      key: \"EVENT_KEY\",\n      get: function get() {\n        return EVENT_KEY$7;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$5;\n      }\n    }]);\n    return Popover;\n  }(Tooltip);\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'].fn[NAME$7] = Popover._jQueryInterface;\n  $__default['default'].fn[NAME$7].Constructor = Popover;\n  $__default['default'].fn[NAME$7].noConflict = function () {\n    $__default['default'].fn[NAME$7] = JQUERY_NO_CONFLICT$7;\n    return Popover._jQueryInterface;\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$8 = 'scrollspy';\n  var VERSION$8 = '4.6.0';\n  var DATA_KEY$8 = 'bs.scrollspy';\n  var EVENT_KEY$8 = \".\" + DATA_KEY$8;\n  var DATA_API_KEY$6 = '.data-api';\n  var JQUERY_NO_CONFLICT$8 = $__default['default'].fn[NAME$8];\n  var Default$6 = {\n    offset: 10,\n    method: 'auto',\n    target: ''\n  };\n  var DefaultType$6 = {\n    offset: 'number',\n    method: 'string',\n    target: '(string|element)'\n  };\n  var EVENT_ACTIVATE = \"activate\" + EVENT_KEY$8;\n  var EVENT_SCROLL = \"scroll\" + EVENT_KEY$8;\n  var EVENT_LOAD_DATA_API$2 = \"load\" + EVENT_KEY$8 + DATA_API_KEY$6;\n  var CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';\n  var CLASS_NAME_ACTIVE$2 = 'active';\n  var SELECTOR_DATA_SPY = '[data-spy=\"scroll\"]';\n  var SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';\n  var SELECTOR_NAV_LINKS = '.nav-link';\n  var SELECTOR_NAV_ITEMS = '.nav-item';\n  var SELECTOR_LIST_ITEMS = '.list-group-item';\n  var SELECTOR_DROPDOWN = '.dropdown';\n  var SELECTOR_DROPDOWN_ITEMS = '.dropdown-item';\n  var SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';\n  var METHOD_OFFSET = 'offset';\n  var METHOD_POSITION = 'position';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var ScrollSpy = /*#__PURE__*/function () {\n    function ScrollSpy(element, config) {\n      var _this = this;\n      this._element = element;\n      this._scrollElement = element.tagName === 'BODY' ? window : element;\n      this._config = this._getConfig(config);\n      this._selector = this._config.target + \" \" + SELECTOR_NAV_LINKS + \",\" + (this._config.target + \" \" + SELECTOR_LIST_ITEMS + \",\") + (this._config.target + \" \" + SELECTOR_DROPDOWN_ITEMS);\n      this._offsets = [];\n      this._targets = [];\n      this._activeTarget = null;\n      this._scrollHeight = 0;\n      $__default['default'](this._scrollElement).on(EVENT_SCROLL, function (event) {\n        return _this._process(event);\n      });\n      this.refresh();\n      this._process();\n    } // Getters\n\n    var _proto = ScrollSpy.prototype;\n\n    // Public\n    _proto.refresh = function refresh() {\n      var _this2 = this;\n      var autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;\n      var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;\n      var offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;\n      this._offsets = [];\n      this._targets = [];\n      this._scrollHeight = this._getScrollHeight();\n      var targets = [].slice.call(document.querySelectorAll(this._selector));\n      targets.map(function (element) {\n        var target;\n        var targetSelector = Util.getSelectorFromElement(element);\n        if (targetSelector) {\n          target = document.querySelector(targetSelector);\n        }\n        if (target) {\n          var targetBCR = target.getBoundingClientRect();\n          if (targetBCR.width || targetBCR.height) {\n            // TODO (fat): remove sketch reliance on jQuery position/offset\n            return [$__default['default'](target)[offsetMethod]().top + offsetBase, targetSelector];\n          }\n        }\n        return null;\n      }).filter(function (item) {\n        return item;\n      }).sort(function (a, b) {\n        return a[0] - b[0];\n      }).forEach(function (item) {\n        _this2._offsets.push(item[0]);\n        _this2._targets.push(item[1]);\n      });\n    };\n    _proto.dispose = function dispose() {\n      $__default['default'].removeData(this._element, DATA_KEY$8);\n      $__default['default'](this._scrollElement).off(EVENT_KEY$8);\n      this._element = null;\n      this._scrollElement = null;\n      this._config = null;\n      this._selector = null;\n      this._offsets = null;\n      this._targets = null;\n      this._activeTarget = null;\n      this._scrollHeight = null;\n    } // Private\n    ;\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends({}, Default$6, _typeof(config) === 'object' && config ? config : {});\n      if (typeof config.target !== 'string' && Util.isElement(config.target)) {\n        var id = $__default['default'](config.target).attr('id');\n        if (!id) {\n          id = Util.getUID(NAME$8);\n          $__default['default'](config.target).attr('id', id);\n        }\n        config.target = \"#\" + id;\n      }\n      Util.typeCheckConfig(NAME$8, config, DefaultType$6);\n      return config;\n    };\n    _proto._getScrollTop = function _getScrollTop() {\n      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\n    };\n    _proto._getScrollHeight = function _getScrollHeight() {\n      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n    };\n    _proto._getOffsetHeight = function _getOffsetHeight() {\n      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;\n    };\n    _proto._process = function _process() {\n      var scrollTop = this._getScrollTop() + this._config.offset;\n      var scrollHeight = this._getScrollHeight();\n      var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();\n      if (this._scrollHeight !== scrollHeight) {\n        this.refresh();\n      }\n      if (scrollTop >= maxScroll) {\n        var target = this._targets[this._targets.length - 1];\n        if (this._activeTarget !== target) {\n          this._activate(target);\n        }\n        return;\n      }\n      if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {\n        this._activeTarget = null;\n        this._clear();\n        return;\n      }\n      for (var i = this._offsets.length; i--;) {\n        var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);\n        if (isActiveTarget) {\n          this._activate(this._targets[i]);\n        }\n      }\n    };\n    _proto._activate = function _activate(target) {\n      this._activeTarget = target;\n      this._clear();\n      var queries = this._selector.split(',').map(function (selector) {\n        return selector + \"[data-target=\\\"\" + target + \"\\\"],\" + selector + \"[href=\\\"\" + target + \"\\\"]\";\n      });\n      var $link = $__default['default']([].slice.call(document.querySelectorAll(queries.join(','))));\n      if ($link.hasClass(CLASS_NAME_DROPDOWN_ITEM)) {\n        $link.closest(SELECTOR_DROPDOWN).find(SELECTOR_DROPDOWN_TOGGLE).addClass(CLASS_NAME_ACTIVE$2);\n        $link.addClass(CLASS_NAME_ACTIVE$2);\n      } else {\n        // Set triggered link as active\n        $link.addClass(CLASS_NAME_ACTIVE$2); // Set triggered links parents as active\n        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n\n        $link.parents(SELECTOR_NAV_LIST_GROUP).prev(SELECTOR_NAV_LINKS + \", \" + SELECTOR_LIST_ITEMS).addClass(CLASS_NAME_ACTIVE$2); // Handle special case when .nav-link is inside .nav-item\n\n        $link.parents(SELECTOR_NAV_LIST_GROUP).prev(SELECTOR_NAV_ITEMS).children(SELECTOR_NAV_LINKS).addClass(CLASS_NAME_ACTIVE$2);\n      }\n      $__default['default'](this._scrollElement).trigger(EVENT_ACTIVATE, {\n        relatedTarget: target\n      });\n    };\n    _proto._clear = function _clear() {\n      [].slice.call(document.querySelectorAll(this._selector)).filter(function (node) {\n        return node.classList.contains(CLASS_NAME_ACTIVE$2);\n      }).forEach(function (node) {\n        return node.classList.remove(CLASS_NAME_ACTIVE$2);\n      });\n    } // Static\n    ;\n\n    ScrollSpy._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $__default['default'](this).data(DATA_KEY$8);\n        var _config = _typeof(config) === 'object' && config;\n        if (!data) {\n          data = new ScrollSpy(this, _config);\n          $__default['default'](this).data(DATA_KEY$8, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n          data[config]();\n        }\n      });\n    };\n    _createClass(ScrollSpy, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$8;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$6;\n      }\n    }]);\n    return ScrollSpy;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'](window).on(EVENT_LOAD_DATA_API$2, function () {\n    var scrollSpys = [].slice.call(document.querySelectorAll(SELECTOR_DATA_SPY));\n    var scrollSpysLength = scrollSpys.length;\n    for (var i = scrollSpysLength; i--;) {\n      var $spy = $__default['default'](scrollSpys[i]);\n      ScrollSpy._jQueryInterface.call($spy, $spy.data());\n    }\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'].fn[NAME$8] = ScrollSpy._jQueryInterface;\n  $__default['default'].fn[NAME$8].Constructor = ScrollSpy;\n  $__default['default'].fn[NAME$8].noConflict = function () {\n    $__default['default'].fn[NAME$8] = JQUERY_NO_CONFLICT$8;\n    return ScrollSpy._jQueryInterface;\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$9 = 'tab';\n  var VERSION$9 = '4.6.0';\n  var DATA_KEY$9 = 'bs.tab';\n  var EVENT_KEY$9 = \".\" + DATA_KEY$9;\n  var DATA_API_KEY$7 = '.data-api';\n  var JQUERY_NO_CONFLICT$9 = $__default['default'].fn[NAME$9];\n  var EVENT_HIDE$3 = \"hide\" + EVENT_KEY$9;\n  var EVENT_HIDDEN$3 = \"hidden\" + EVENT_KEY$9;\n  var EVENT_SHOW$3 = \"show\" + EVENT_KEY$9;\n  var EVENT_SHOWN$3 = \"shown\" + EVENT_KEY$9;\n  var EVENT_CLICK_DATA_API$6 = \"click\" + EVENT_KEY$9 + DATA_API_KEY$7;\n  var CLASS_NAME_DROPDOWN_MENU = 'dropdown-menu';\n  var CLASS_NAME_ACTIVE$3 = 'active';\n  var CLASS_NAME_DISABLED$1 = 'disabled';\n  var CLASS_NAME_FADE$4 = 'fade';\n  var CLASS_NAME_SHOW$6 = 'show';\n  var SELECTOR_DROPDOWN$1 = '.dropdown';\n  var SELECTOR_NAV_LIST_GROUP$1 = '.nav, .list-group';\n  var SELECTOR_ACTIVE$2 = '.active';\n  var SELECTOR_ACTIVE_UL = '> li > .active';\n  var SELECTOR_DATA_TOGGLE$4 = '[data-toggle=\"tab\"], [data-toggle=\"pill\"], [data-toggle=\"list\"]';\n  var SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';\n  var SELECTOR_DROPDOWN_ACTIVE_CHILD = '> .dropdown-menu .active';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Tab = /*#__PURE__*/function () {\n    function Tab(element) {\n      this._element = element;\n    } // Getters\n\n    var _proto = Tab.prototype;\n\n    // Public\n    _proto.show = function show() {\n      var _this = this;\n      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $__default['default'](this._element).hasClass(CLASS_NAME_ACTIVE$3) || $__default['default'](this._element).hasClass(CLASS_NAME_DISABLED$1)) {\n        return;\n      }\n      var target;\n      var previous;\n      var listElement = $__default['default'](this._element).closest(SELECTOR_NAV_LIST_GROUP$1)[0];\n      var selector = Util.getSelectorFromElement(this._element);\n      if (listElement) {\n        var itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE$2;\n        previous = $__default['default'].makeArray($__default['default'](listElement).find(itemSelector));\n        previous = previous[previous.length - 1];\n      }\n      var hideEvent = $__default['default'].Event(EVENT_HIDE$3, {\n        relatedTarget: this._element\n      });\n      var showEvent = $__default['default'].Event(EVENT_SHOW$3, {\n        relatedTarget: previous\n      });\n      if (previous) {\n        $__default['default'](previous).trigger(hideEvent);\n      }\n      $__default['default'](this._element).trigger(showEvent);\n      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {\n        return;\n      }\n      if (selector) {\n        target = document.querySelector(selector);\n      }\n      this._activate(this._element, listElement);\n      var complete = function complete() {\n        var hiddenEvent = $__default['default'].Event(EVENT_HIDDEN$3, {\n          relatedTarget: _this._element\n        });\n        var shownEvent = $__default['default'].Event(EVENT_SHOWN$3, {\n          relatedTarget: previous\n        });\n        $__default['default'](previous).trigger(hiddenEvent);\n        $__default['default'](_this._element).trigger(shownEvent);\n      };\n      if (target) {\n        this._activate(target, target.parentNode, complete);\n      } else {\n        complete();\n      }\n    };\n    _proto.dispose = function dispose() {\n      $__default['default'].removeData(this._element, DATA_KEY$9);\n      this._element = null;\n    } // Private\n    ;\n\n    _proto._activate = function _activate(element, container, callback) {\n      var _this2 = this;\n      var activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? $__default['default'](container).find(SELECTOR_ACTIVE_UL) : $__default['default'](container).children(SELECTOR_ACTIVE$2);\n      var active = activeElements[0];\n      var isTransitioning = callback && active && $__default['default'](active).hasClass(CLASS_NAME_FADE$4);\n      var complete = function complete() {\n        return _this2._transitionComplete(element, active, callback);\n      };\n      if (active && isTransitioning) {\n        var transitionDuration = Util.getTransitionDurationFromElement(active);\n        $__default['default'](active).removeClass(CLASS_NAME_SHOW$6).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n    };\n    _proto._transitionComplete = function _transitionComplete(element, active, callback) {\n      if (active) {\n        $__default['default'](active).removeClass(CLASS_NAME_ACTIVE$3);\n        var dropdownChild = $__default['default'](active.parentNode).find(SELECTOR_DROPDOWN_ACTIVE_CHILD)[0];\n        if (dropdownChild) {\n          $__default['default'](dropdownChild).removeClass(CLASS_NAME_ACTIVE$3);\n        }\n        if (active.getAttribute('role') === 'tab') {\n          active.setAttribute('aria-selected', false);\n        }\n      }\n      $__default['default'](element).addClass(CLASS_NAME_ACTIVE$3);\n      if (element.getAttribute('role') === 'tab') {\n        element.setAttribute('aria-selected', true);\n      }\n      Util.reflow(element);\n      if (element.classList.contains(CLASS_NAME_FADE$4)) {\n        element.classList.add(CLASS_NAME_SHOW$6);\n      }\n      if (element.parentNode && $__default['default'](element.parentNode).hasClass(CLASS_NAME_DROPDOWN_MENU)) {\n        var dropdownElement = $__default['default'](element).closest(SELECTOR_DROPDOWN$1)[0];\n        if (dropdownElement) {\n          var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(SELECTOR_DROPDOWN_TOGGLE$1));\n          $__default['default'](dropdownToggleList).addClass(CLASS_NAME_ACTIVE$3);\n        }\n        element.setAttribute('aria-expanded', true);\n      }\n      if (callback) {\n        callback();\n      }\n    } // Static\n    ;\n\n    Tab._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $this = $__default['default'](this);\n        var data = $this.data(DATA_KEY$9);\n        if (!data) {\n          data = new Tab(this);\n          $this.data(DATA_KEY$9, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n          data[config]();\n        }\n      });\n    };\n    _createClass(Tab, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$9;\n      }\n    }]);\n    return Tab;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'](document).on(EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$4, function (event) {\n    event.preventDefault();\n    Tab._jQueryInterface.call($__default['default'](this), 'show');\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'].fn[NAME$9] = Tab._jQueryInterface;\n  $__default['default'].fn[NAME$9].Constructor = Tab;\n  $__default['default'].fn[NAME$9].noConflict = function () {\n    $__default['default'].fn[NAME$9] = JQUERY_NO_CONFLICT$9;\n    return Tab._jQueryInterface;\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$a = 'toast';\n  var VERSION$a = '4.6.0';\n  var DATA_KEY$a = 'bs.toast';\n  var EVENT_KEY$a = \".\" + DATA_KEY$a;\n  var JQUERY_NO_CONFLICT$a = $__default['default'].fn[NAME$a];\n  var EVENT_CLICK_DISMISS$1 = \"click.dismiss\" + EVENT_KEY$a;\n  var EVENT_HIDE$4 = \"hide\" + EVENT_KEY$a;\n  var EVENT_HIDDEN$4 = \"hidden\" + EVENT_KEY$a;\n  var EVENT_SHOW$4 = \"show\" + EVENT_KEY$a;\n  var EVENT_SHOWN$4 = \"shown\" + EVENT_KEY$a;\n  var CLASS_NAME_FADE$5 = 'fade';\n  var CLASS_NAME_HIDE = 'hide';\n  var CLASS_NAME_SHOW$7 = 'show';\n  var CLASS_NAME_SHOWING = 'showing';\n  var DefaultType$7 = {\n    animation: 'boolean',\n    autohide: 'boolean',\n    delay: 'number'\n  };\n  var Default$7 = {\n    animation: true,\n    autohide: true,\n    delay: 500\n  };\n  var SELECTOR_DATA_DISMISS$1 = '[data-dismiss=\"toast\"]';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Toast = /*#__PURE__*/function () {\n    function Toast(element, config) {\n      this._element = element;\n      this._config = this._getConfig(config);\n      this._timeout = null;\n      this._setListeners();\n    } // Getters\n\n    var _proto = Toast.prototype;\n\n    // Public\n    _proto.show = function show() {\n      var _this = this;\n      var showEvent = $__default['default'].Event(EVENT_SHOW$4);\n      $__default['default'](this._element).trigger(showEvent);\n      if (showEvent.isDefaultPrevented()) {\n        return;\n      }\n      this._clearTimeout();\n      if (this._config.animation) {\n        this._element.classList.add(CLASS_NAME_FADE$5);\n      }\n      var complete = function complete() {\n        _this._element.classList.remove(CLASS_NAME_SHOWING);\n        _this._element.classList.add(CLASS_NAME_SHOW$7);\n        $__default['default'](_this._element).trigger(EVENT_SHOWN$4);\n        if (_this._config.autohide) {\n          _this._timeout = setTimeout(function () {\n            _this.hide();\n          }, _this._config.delay);\n        }\n      };\n      this._element.classList.remove(CLASS_NAME_HIDE);\n      Util.reflow(this._element);\n      this._element.classList.add(CLASS_NAME_SHOWING);\n      if (this._config.animation) {\n        var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n        $__default['default'](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n    };\n    _proto.hide = function hide() {\n      if (!this._element.classList.contains(CLASS_NAME_SHOW$7)) {\n        return;\n      }\n      var hideEvent = $__default['default'].Event(EVENT_HIDE$4);\n      $__default['default'](this._element).trigger(hideEvent);\n      if (hideEvent.isDefaultPrevented()) {\n        return;\n      }\n      this._close();\n    };\n    _proto.dispose = function dispose() {\n      this._clearTimeout();\n      if (this._element.classList.contains(CLASS_NAME_SHOW$7)) {\n        this._element.classList.remove(CLASS_NAME_SHOW$7);\n      }\n      $__default['default'](this._element).off(EVENT_CLICK_DISMISS$1);\n      $__default['default'].removeData(this._element, DATA_KEY$a);\n      this._element = null;\n      this._config = null;\n    } // Private\n    ;\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends({}, Default$7, $__default['default'](this._element).data(), _typeof(config) === 'object' && config ? config : {});\n      Util.typeCheckConfig(NAME$a, config, this.constructor.DefaultType);\n      return config;\n    };\n    _proto._setListeners = function _setListeners() {\n      var _this2 = this;\n      $__default['default'](this._element).on(EVENT_CLICK_DISMISS$1, SELECTOR_DATA_DISMISS$1, function () {\n        return _this2.hide();\n      });\n    };\n    _proto._close = function _close() {\n      var _this3 = this;\n      var complete = function complete() {\n        _this3._element.classList.add(CLASS_NAME_HIDE);\n        $__default['default'](_this3._element).trigger(EVENT_HIDDEN$4);\n      };\n      this._element.classList.remove(CLASS_NAME_SHOW$7);\n      if (this._config.animation) {\n        var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n        $__default['default'](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n    };\n    _proto._clearTimeout = function _clearTimeout() {\n      clearTimeout(this._timeout);\n      this._timeout = null;\n    } // Static\n    ;\n\n    Toast._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = $__default['default'](this);\n        var data = $element.data(DATA_KEY$a);\n        var _config = _typeof(config) === 'object' && config;\n        if (!data) {\n          data = new Toast(this, _config);\n          $element.data(DATA_KEY$a, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n          data[config](this);\n        }\n      });\n    };\n    _createClass(Toast, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$a;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$7;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$7;\n      }\n    }]);\n    return Toast;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'].fn[NAME$a] = Toast._jQueryInterface;\n  $__default['default'].fn[NAME$a].Constructor = Toast;\n  $__default['default'].fn[NAME$a].noConflict = function () {\n    $__default['default'].fn[NAME$a] = JQUERY_NO_CONFLICT$a;\n    return Toast._jQueryInterface;\n  };\n  exports.Alert = Alert;\n  exports.Button = Button;\n  exports.Carousel = Carousel;\n  exports.Collapse = Collapse;\n  exports.Dropdown = Dropdown;\n  exports.Modal = Modal;\n  exports.Popover = Popover;\n  exports.Scrollspy = ScrollSpy;\n  exports.Tab = Tab;\n  exports.Toast = Toast;\n  exports.Tooltip = Tooltip;\n  exports.Util = Util;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvdGhlbWVzL2Jvb3RzdHJhcC92ZW5kb3IvYm9vdHN0cmFwL2pzL2Jvb3RzdHJhcC5idW5kbGUuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBQUE7Ozs7OztFQVNBOzs7Ozs7RUFNQSxJQUFNQSxjQUFjLEdBQUcsZUFBdkI7RUFDQSxJQUFNQyxPQUFPLEdBQUcsT0FBaEI7RUFDQSxJQUFNQyx1QkFBdUIsR0FBRyxJQUFoQzs7RUFHQSxTQUFTQyxNQUFUQSxDQUFnQkMsR0FBaEIsRUFBcUI7SUFDbkIsSUFBSUEsR0FBRyxLQUFLLElBQVIsSUFBZ0IsT0FBT0EsR0FBUCxLQUFlLFdBQW5DLEVBQWdEO01BQzlDLFlBQVVBLEdBQVY7SUFDRDtJQUVELE9BQU8sR0FBR0MsUUFBSCxDQUFZQyxJQUFaLENBQWlCRixHQUFqQixFQUFzQkcsS0FBdEIsQ0FBNEIsYUFBNUIsRUFBMkMsQ0FBM0MsRUFBOENDLFdBQTlDLEVBQVA7RUFDRDtFQUVELFNBQVNDLDRCQUFUQSxDQUFBLEVBQXdDO0lBQ3RDLE9BQU87TUFDTEMsUUFBUSxFQUFFVixjQURMO01BRUxXLFlBQVksRUFBRVgsY0FGVDtNQUdMWSxNQUhLLFdBQUFBLE9BR0VDLEtBSEYsRUFHUztRQUNaLElBQUlDLFVBQUEsV0FBQyxDQUFDRCxLQUFLLENBQUNFLE1BQVAsQ0FBRCxDQUFnQkMsRUFBaEIsQ0FBbUIsSUFBbkIsQ0FBSixFQUE4QjtVQUM1QixPQUFPSCxLQUFLLENBQUNJLFNBQU4sQ0FBZ0JDLE9BQWhCLENBQXdCQyxLQUF4QixDQUE4QixJQUE5QixFQUFvQ0MsU0FBcEMsQ0FBUCxDQUQ0QjtRQUU3Qjs7UUFFRCxPQUFPQyxTQUFQO01BQ0Q7SUFUSSxDQUFQO0VBV0Q7RUFFRCxTQUFTQyxxQkFBVEEsQ0FBK0JDLFFBQS9CLEVBQXlDO0lBQUEsSUFBQUMsS0FBQTtJQUN2QyxJQUFJQyxNQUFNLEdBQUcsS0FB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QWdCdDZCLE9BQWhCLENBQVA7VUFDQXpILFFBQVEsQ0FBQ0MsSUFBVCxDQUFjOGdDLFVBQWQsRUFBd0I5Z0MsSUFBeEI7UUFDRDtRQUVELElBQUksT0FBT2pFLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0M7VUFDOUIsSUFBSSxPQUFPaUUsSUFBSSxDQUFDakUsTUFBRCxDQUFYLEtBQXdCLFdBQTVCLEVBQXlDO1lBQ3ZDLE1BQU0sSUFBSXFCLFNBQUosd0JBQWtDckIsTUFBbEMsUUFBTjtVQUNEO1VBRURpRSxJQUFJLENBQUNqRSxNQUFELENBQUosQ0FBYSxJQUFiO1FBQ0Q7TUFDRixDQWpCTSxDQUFQO0lBa0JEOzs7MEJBdEpvQjtRQUNuQixPQUFPOGtDLFNBQVA7TUFDRDs7OzBCQUV3QjtRQUN2QixPQUFPYSxhQUFQO01BQ0Q7OzswQkFFb0I7UUFDbkIsT0FBT0UsU0FBUDtNQUNEOzs7O0VBK0lIOzs7Ozs7RUFNQWhwQyxVQUFBLFdBQUMsQ0FBQ2lCLEVBQUYsQ0FBSyttQyxNQUFMLElBQWFrQixLQUFLLENBQUNqaUMsZ0JBQW5CO0VBQ0FqSCxVQUFBLFdBQUMsQ0FBQ2lCLEVBQUYsQ0FBSyttQyxNQUFMLEVBQVd2Z0MsV0FBWCxHQUF5QnloQyxLQUF6QjtFQUNBbHBDLFVBQUEsV0FBQyxDQUFDaUIsRUFBRixDQUFLK21DLE1BQUwsRUFBV3RnQyxVQUFYLEdBQXdCLFlBQU07SUFDNUIxSCxVQUFBLFdBQUMsQ0FBQ2lCLEVBQUYsQ0FBSyttQyxNQUFMLElBQWFJLG9CQUFiO0lBQ0EsT0FBT2MsS0FBSyxDQUFDamlDLGdCQUFiO0VBQ0QsQ0FIRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi8uLi9qcy9zcmMvdXRpbC5qcz8wN2E1Iiwid2VicGFjazovLy8uLi8uLi9qcy9zcmMvYWxlcnQuanM/ODc0MyIsIndlYnBhY2s6Ly8vLi4vLi4vanMvc3JjL2J1dHRvbi5qcz9jYTFhIiwid2VicGFjazovLy8uLi8uLi9qcy9zcmMvY2Fyb3VzZWwuanM/OTA0MCIsIndlYnBhY2s6Ly8vLi4vLi4vanMvc3JjL2NvbGxhcHNlLmpzPzVlN2IiLCJ3ZWJwYWNrOi8vLy4uLy4uL25vZGVfbW9kdWxlcy9wb3BwZXIuanMvZGlzdC9lc20vcG9wcGVyLmpzPzcwZmQiLCJ3ZWJwYWNrOi8vLy4uLy4uL2pzL3NyYy9kcm9wZG93bi5qcz81ODc2Iiwid2VicGFjazovLy8uLi8uLi9qcy9zcmMvbW9kYWwuanM/MTI4NyIsIndlYnBhY2s6Ly8vLi4vLi4vanMvc3JjL3Rvb2xzL3Nhbml0aXplci5qcz9iOGY5Iiwid2VicGFjazovLy8uLi8uLi9qcy9zcmMvdG9vbHRpcC5qcz84OTNlIiwid2VicGFjazovLy8uLi8uLi9qcy9zcmMvcG9wb3Zlci5qcz9iM2Q1Iiwid2VicGFjazovLy8uLi8uLi9qcy9zcmMvc2Nyb2xsc3B5LmpzP2M4MjciLCJ3ZWJwYWNrOi8vLy4uLy4uL2pzL3NyYy90YWIuanM/NDVhMiIsIndlYnBhY2s6Ly8vLi4vLi4vanMvc3JjL3RvYXN0LmpzP2EyZmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC42LjApOiB1dGlsLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogUHJpdmF0ZSBUcmFuc2l0aW9uRW5kIEhlbHBlcnNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IFRSQU5TSVRJT05fRU5EID0gJ3RyYW5zaXRpb25lbmQnXG5jb25zdCBNQVhfVUlEID0gMTAwMDAwMFxuY29uc3QgTUlMTElTRUNPTkRTX01VTFRJUExJRVIgPSAxMDAwXG5cbi8vIFNob3V0b3V0IEFuZ3VzQ3JvbGwgKGh0dHBzOi8vZ29vLmdsL3B4d1FHcClcbmZ1bmN0aW9uIHRvVHlwZShvYmopIHtcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBgJHtvYmp9YFxuICB9XG5cbiAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwob2JqKS5tYXRjaCgvXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKVxufVxuXG5mdW5jdGlvbiBnZXRTcGVjaWFsVHJhbnNpdGlvbkVuZEV2ZW50KCkge1xuICByZXR1cm4ge1xuICAgIGJpbmRUeXBlOiBUUkFOU0lUSU9OX0VORCxcbiAgICBkZWxlZ2F0ZVR5cGU6IFRSQU5TSVRJT05fRU5ELFxuICAgIGhhbmRsZShldmVudCkge1xuICAgICAgaWYgKCQoZXZlbnQudGFyZ2V0KS5pcyh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZXZlbnQuaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zaXRpb25FbmRFbXVsYXRvcihkdXJhdGlvbikge1xuICBsZXQgY2FsbGVkID0gZmFsc2VcblxuICAkKHRoaXMpLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCAoKSA9PiB7XG4gICAgY2FsbGVkID0gdHJ1ZVxuICB9KVxuXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBVdGlsLnRyaWdnZXJUcmFuc2l0aW9uRW5kKHRoaXMpXG4gICAgfVxuICB9LCBkdXJhdGlvbilcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiBzZXRUcmFuc2l0aW9uRW5kU3VwcG9ydCgpIHtcbiAgJC5mbi5lbXVsYXRlVHJhbnNpdGlvbkVuZCA9IHRyYW5zaXRpb25FbmRFbXVsYXRvclxuICAkLmV2ZW50LnNwZWNpYWxbVXRpbC5UUkFOU0lUSU9OX0VORF0gPSBnZXRTcGVjaWFsVHJhbnNpdGlvbkVuZEV2ZW50KClcbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogUHVibGljIFV0aWwgQXBpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IFV0aWwgPSB7XG4gIFRSQU5TSVRJT05fRU5EOiAnYnNUcmFuc2l0aW9uRW5kJyxcblxuICBnZXRVSUQocHJlZml4KSB7XG4gICAgZG8ge1xuICAgICAgcHJlZml4ICs9IH5+KE1hdGgucmFuZG9tKCkgKiBNQVhfVUlEKSAvLyBcIn5+XCIgYWN0cyBsaWtlIGEgZmFzdGVyIE1hdGguZmxvb3IoKSBoZXJlXG4gICAgfSB3aGlsZSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocHJlZml4KSlcblxuICAgIHJldHVybiBwcmVmaXhcbiAgfSxcblxuICBnZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpIHtcbiAgICBsZXQgc2VsZWN0b3IgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10YXJnZXQnKVxuXG4gICAgaWYgKCFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gJyMnKSB7XG4gICAgICBjb25zdCBocmVmQXR0ciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdocmVmJylcbiAgICAgIHNlbGVjdG9yID0gaHJlZkF0dHIgJiYgaHJlZkF0dHIgIT09ICcjJyA/IGhyZWZBdHRyLnRyaW0oKSA6ICcnXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSA/IHNlbGVjdG9yIDogbnVsbFxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9LFxuXG4gIGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgLy8gR2V0IHRyYW5zaXRpb24tZHVyYXRpb24gb2YgdGhlIGVsZW1lbnRcbiAgICBsZXQgdHJhbnNpdGlvbkR1cmF0aW9uID0gJChlbGVtZW50KS5jc3MoJ3RyYW5zaXRpb24tZHVyYXRpb24nKVxuICAgIGxldCB0cmFuc2l0aW9uRGVsYXkgPSAkKGVsZW1lbnQpLmNzcygndHJhbnNpdGlvbi1kZWxheScpXG5cbiAgICBjb25zdCBmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiA9IHBhcnNlRmxvYXQodHJhbnNpdGlvbkR1cmF0aW9uKVxuICAgIGNvbnN0IGZsb2F0VHJhbnNpdGlvbkRlbGF5ID0gcGFyc2VGbG9hdCh0cmFuc2l0aW9uRGVsYXkpXG5cbiAgICAvLyBSZXR1cm4gMCBpZiBlbGVtZW50IG9yIHRyYW5zaXRpb24gZHVyYXRpb24gaXMgbm90IGZvdW5kXG4gICAgaWYgKCFmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiAmJiAhZmxvYXRUcmFuc2l0aW9uRGVsYXkpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgLy8gSWYgbXVsdGlwbGUgZHVyYXRpb25zIGFyZSBkZWZpbmVkLCB0YWtlIHRoZSBmaXJzdFxuICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IHRyYW5zaXRpb25EdXJhdGlvbi5zcGxpdCgnLCcpWzBdXG4gICAgdHJhbnNpdGlvbkRlbGF5ID0gdHJhbnNpdGlvbkRlbGF5LnNwbGl0KCcsJylbMF1cblxuICAgIHJldHVybiAocGFyc2VGbG9hdCh0cmFuc2l0aW9uRHVyYXRpb24pICsgcGFyc2VGbG9hdCh0cmFuc2l0aW9uRGVsYXkpKSAqIE1JTExJU0VDT05EU19NVUxUSVBMSUVSXG4gIH0sXG5cbiAgcmVmbG93KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5vZmZzZXRIZWlnaHRcbiAgfSxcblxuICB0cmlnZ2VyVHJhbnNpdGlvbkVuZChlbGVtZW50KSB7XG4gICAgJChlbGVtZW50KS50cmlnZ2VyKFRSQU5TSVRJT05fRU5EKVxuICB9LFxuXG4gIHN1cHBvcnRzVHJhbnNpdGlvbkVuZCgpIHtcbiAgICByZXR1cm4gQm9vbGVhbihUUkFOU0lUSU9OX0VORClcbiAgfSxcblxuICBpc0VsZW1lbnQob2JqKSB7XG4gICAgcmV0dXJuIChvYmpbMF0gfHwgb2JqKS5ub2RlVHlwZVxuICB9LFxuXG4gIHR5cGVDaGVja0NvbmZpZyhjb21wb25lbnROYW1lLCBjb25maWcsIGNvbmZpZ1R5cGVzKSB7XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBjb25maWdUeXBlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25maWdUeXBlcywgcHJvcGVydHkpKSB7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBjb25maWdUeXBlc1twcm9wZXJ0eV1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBjb25maWdbcHJvcGVydHldXG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHZhbHVlICYmIFV0aWwuaXNFbGVtZW50KHZhbHVlKSA/XG4gICAgICAgICAgJ2VsZW1lbnQnIDogdG9UeXBlKHZhbHVlKVxuXG4gICAgICAgIGlmICghbmV3IFJlZ0V4cChleHBlY3RlZFR5cGVzKS50ZXN0KHZhbHVlVHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgJHtjb21wb25lbnROYW1lLnRvVXBwZXJDYXNlKCl9OiBgICtcbiAgICAgICAgICAgIGBPcHRpb24gXCIke3Byb3BlcnR5fVwiIHByb3ZpZGVkIHR5cGUgXCIke3ZhbHVlVHlwZX1cIiBgICtcbiAgICAgICAgICAgIGBidXQgZXhwZWN0ZWQgdHlwZSBcIiR7ZXhwZWN0ZWRUeXBlc31cIi5gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGZpbmRTaGFkb3dSb290KGVsZW1lbnQpIHtcbiAgICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRhY2hTaGFkb3cpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLy8gQ2FuIGZpbmQgdGhlIHNoYWRvdyByb290IG90aGVyd2lzZSBpdCdsbCByZXR1cm4gdGhlIGRvY3VtZW50XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50LmdldFJvb3ROb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCByb290ID0gZWxlbWVudC5nZXRSb290Tm9kZSgpXG4gICAgICByZXR1cm4gcm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyByb290IDogbnVsbFxuICAgIH1cblxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnRcbiAgICB9XG5cbiAgICAvLyB3aGVuIHdlIGRvbid0IGZpbmQgYSBzaGFkb3cgcm9vdFxuICAgIGlmICghZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiBVdGlsLmZpbmRTaGFkb3dSb290KGVsZW1lbnQucGFyZW50Tm9kZSlcbiAgfSxcblxuICBqUXVlcnlEZXRlY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiAkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFwncyBKYXZhU2NyaXB0IHJlcXVpcmVzIGpRdWVyeS4galF1ZXJ5IG11c3QgYmUgaW5jbHVkZWQgYmVmb3JlIEJvb3RzdHJhcFxcJ3MgSmF2YVNjcmlwdC4nKVxuICAgIH1cblxuICAgIGNvbnN0IHZlcnNpb24gPSAkLmZuLmpxdWVyeS5zcGxpdCgnICcpWzBdLnNwbGl0KCcuJylcbiAgICBjb25zdCBtaW5NYWpvciA9IDFcbiAgICBjb25zdCBsdE1ham9yID0gMlxuICAgIGNvbnN0IG1pbk1pbm9yID0gOVxuICAgIGNvbnN0IG1pblBhdGNoID0gMVxuICAgIGNvbnN0IG1heE1ham9yID0gNFxuXG4gICAgaWYgKHZlcnNpb25bMF0gPCBsdE1ham9yICYmIHZlcnNpb25bMV0gPCBtaW5NaW5vciB8fCB2ZXJzaW9uWzBdID09PSBtaW5NYWpvciAmJiB2ZXJzaW9uWzFdID09PSBtaW5NaW5vciAmJiB2ZXJzaW9uWzJdIDwgbWluUGF0Y2ggfHwgdmVyc2lvblswXSA+PSBtYXhNYWpvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb290c3RyYXBcXCdzIEphdmFTY3JpcHQgcmVxdWlyZXMgYXQgbGVhc3QgalF1ZXJ5IHYxLjkuMSBidXQgbGVzcyB0aGFuIHY0LjAuMCcpXG4gICAgfVxuICB9XG59XG5cblV0aWwualF1ZXJ5RGV0ZWN0aW9uKClcbnNldFRyYW5zaXRpb25FbmRTdXBwb3J0KClcblxuZXhwb3J0IGRlZmF1bHQgVXRpbFxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC42LjApOiBhbGVydC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSdcbmltcG9ydCBVdGlsIGZyb20gJy4vdXRpbCdcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgTkFNRSA9ICdhbGVydCdcbmNvbnN0IFZFUlNJT04gPSAnNC42LjAnXG5jb25zdCBEQVRBX0tFWSA9ICdicy5hbGVydCdcbmNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJ1xuY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltOQU1FXVxuXG5jb25zdCBTRUxFQ1RPUl9ESVNNSVNTID0gJ1tkYXRhLWRpc21pc3M9XCJhbGVydFwiXSdcblxuY29uc3QgRVZFTlRfQ0xPU0UgPSBgY2xvc2Uke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9DTE9TRUQgPSBgY2xvc2VkJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkgPSBgY2xpY2ske0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gXG5cbmNvbnN0IENMQVNTX05BTUVfQUxFUlQgPSAnYWxlcnQnXG5jb25zdCBDTEFTU19OQU1FX0ZBREUgPSAnZmFkZSdcbmNvbnN0IENMQVNTX05BTUVfU0hPVyA9ICdzaG93J1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgQWxlcnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnRcbiAgfVxuXG4gIC8vIEdldHRlcnNcblxuICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XG4gICAgcmV0dXJuIFZFUlNJT05cbiAgfVxuXG4gIC8vIFB1YmxpY1xuXG4gIGNsb3NlKGVsZW1lbnQpIHtcbiAgICBsZXQgcm9vdEVsZW1lbnQgPSB0aGlzLl9lbGVtZW50XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHJvb3RFbGVtZW50ID0gdGhpcy5fZ2V0Um9vdEVsZW1lbnQoZWxlbWVudClcbiAgICB9XG5cbiAgICBjb25zdCBjdXN0b21FdmVudCA9IHRoaXMuX3RyaWdnZXJDbG9zZUV2ZW50KHJvb3RFbGVtZW50KVxuXG4gICAgaWYgKGN1c3RvbUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9yZW1vdmVFbGVtZW50KHJvb3RFbGVtZW50KVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpXG4gICAgdGhpcy5fZWxlbWVudCA9IG51bGxcbiAgfVxuXG4gIC8vIFByaXZhdGVcblxuICBfZ2V0Um9vdEVsZW1lbnQoZWxlbWVudCkge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpXG4gICAgbGV0IHBhcmVudCA9IGZhbHNlXG5cbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIHBhcmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXG4gICAgfVxuXG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9ICQoZWxlbWVudCkuY2xvc2VzdChgLiR7Q0xBU1NfTkFNRV9BTEVSVH1gKVswXVxuICAgIH1cblxuICAgIHJldHVybiBwYXJlbnRcbiAgfVxuXG4gIF90cmlnZ2VyQ2xvc2VFdmVudChlbGVtZW50KSB7XG4gICAgY29uc3QgY2xvc2VFdmVudCA9ICQuRXZlbnQoRVZFTlRfQ0xPU0UpXG5cbiAgICAkKGVsZW1lbnQpLnRyaWdnZXIoY2xvc2VFdmVudClcbiAgICByZXR1cm4gY2xvc2VFdmVudFxuICB9XG5cbiAgX3JlbW92ZUVsZW1lbnQoZWxlbWVudCkge1xuICAgICQoZWxlbWVudCkucmVtb3ZlQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XKVxuXG4gICAgaWYgKCEkKGVsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfRkFERSkpIHtcbiAgICAgIHRoaXMuX2Rlc3Ryb3lFbGVtZW50KGVsZW1lbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KGVsZW1lbnQpXG5cbiAgICAkKGVsZW1lbnQpXG4gICAgICAub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGV2ZW50ID0+IHRoaXMuX2Rlc3Ryb3lFbGVtZW50KGVsZW1lbnQsIGV2ZW50KSlcbiAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pXG4gIH1cblxuICBfZGVzdHJveUVsZW1lbnQoZWxlbWVudCkge1xuICAgICQoZWxlbWVudClcbiAgICAgIC5kZXRhY2goKVxuICAgICAgLnRyaWdnZXIoRVZFTlRfQ0xPU0VEKVxuICAgICAgLnJlbW92ZSgpXG4gIH1cblxuICAvLyBTdGF0aWNcblxuICBzdGF0aWMgX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0ICRlbGVtZW50ID0gJCh0aGlzKVxuICAgICAgbGV0IGRhdGEgPSAkZWxlbWVudC5kYXRhKERBVEFfS0VZKVxuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBBbGVydCh0aGlzKVxuICAgICAgICAkZWxlbWVudC5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnID09PSAnY2xvc2UnKSB7XG4gICAgICAgIGRhdGFbY29uZmlnXSh0aGlzKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBzdGF0aWMgX2hhbmRsZURpc21pc3MoYWxlcnRJbnN0YW5jZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICB9XG5cbiAgICAgIGFsZXJ0SW5zdGFuY2UuY2xvc2UodGhpcylcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kKGRvY3VtZW50KS5vbihcbiAgRVZFTlRfQ0xJQ0tfREFUQV9BUEksXG4gIFNFTEVDVE9SX0RJU01JU1MsXG4gIEFsZXJ0Ll9oYW5kbGVEaXNtaXNzKG5ldyBBbGVydCgpKVxuKVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kLmZuW05BTUVdID0gQWxlcnQuX2pRdWVyeUludGVyZmFjZVxuJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IEFsZXJ0XG4kLmZuW05BTUVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XG4gICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1RcbiAgcmV0dXJuIEFsZXJ0Ll9qUXVlcnlJbnRlcmZhY2Vcbn1cblxuZXhwb3J0IGRlZmF1bHQgQWxlcnRcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuNi4wKTogYnV0dG9uLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FID0gJ2J1dHRvbidcbmNvbnN0IFZFUlNJT04gPSAnNC42LjAnXG5jb25zdCBEQVRBX0tFWSA9ICdicy5idXR0b24nXG5jb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSdcbmNvbnN0IEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV1cblxuY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUgPSAnYWN0aXZlJ1xuY29uc3QgQ0xBU1NfTkFNRV9CVVRUT04gPSAnYnRuJ1xuY29uc3QgQ0xBU1NfTkFNRV9GT0NVUyA9ICdmb2N1cydcblxuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEVfQ0FSUk9UID0gJ1tkYXRhLXRvZ2dsZV49XCJidXR0b25cIl0nXG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRVMgPSAnW2RhdGEtdG9nZ2xlPVwiYnV0dG9uc1wiXSdcbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFID0gJ1tkYXRhLXRvZ2dsZT1cImJ1dHRvblwiXSdcbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFU19CVVRUT05TID0gJ1tkYXRhLXRvZ2dsZT1cImJ1dHRvbnNcIl0gLmJ0bidcbmNvbnN0IFNFTEVDVE9SX0lOUFVUID0gJ2lucHV0Om5vdChbdHlwZT1cImhpZGRlblwiXSknXG5jb25zdCBTRUxFQ1RPUl9BQ1RJVkUgPSAnLmFjdGl2ZSdcbmNvbnN0IFNFTEVDVE9SX0JVVFRPTiA9ICcuYnRuJ1xuXG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSA9IGBjbGljayR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWBcbmNvbnN0IEVWRU5UX0ZPQ1VTX0JMVVJfREFUQV9BUEkgPSBgZm9jdXMke0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX0gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGBibHVyJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSA9IGBsb2FkJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgQnV0dG9uIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50XG4gICAgdGhpcy5zaG91bGRBdm9pZFRyaWdnZXJDaGFuZ2UgPSBmYWxzZVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gVkVSU0lPTlxuICB9XG5cbiAgLy8gUHVibGljXG5cbiAgdG9nZ2xlKCkge1xuICAgIGxldCB0cmlnZ2VyQ2hhbmdlRXZlbnQgPSB0cnVlXG4gICAgbGV0IGFkZEFyaWFQcmVzc2VkID0gdHJ1ZVxuICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gJCh0aGlzLl9lbGVtZW50KS5jbG9zZXN0KFNFTEVDVE9SX0RBVEFfVE9HR0xFUylbMF1cblxuICAgIGlmIChyb290RWxlbWVudCkge1xuICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1JfSU5QVVQpXG5cbiAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgIGlmIChpbnB1dC5jaGVja2VkICYmIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQUNUSVZFKSkge1xuICAgICAgICAgICAgdHJpZ2dlckNoYW5nZUV2ZW50ID0gZmFsc2VcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IHJvb3RFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1JfQUNUSVZFKVxuXG4gICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAkKGFjdGl2ZUVsZW1lbnQpLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfQUNUSVZFKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICAvLyBpZiBpdCdzIG5vdCBhIHJhZGlvIGJ1dHRvbiBvciBjaGVja2JveCBkb24ndCBhZGQgYSBwb2ludGxlc3MvaW52YWxpZCBjaGVja2VkIHByb3BlcnR5IHRvIHRoZSBpbnB1dFxuICAgICAgICAgIGlmIChpbnB1dC50eXBlID09PSAnY2hlY2tib3gnIHx8IGlucHV0LnR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSAhdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLnNob3VsZEF2b2lkVHJpZ2dlckNoYW5nZSkge1xuICAgICAgICAgICAgJChpbnB1dCkudHJpZ2dlcignY2hhbmdlJylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dC5mb2N1cygpXG4gICAgICAgIGFkZEFyaWFQcmVzc2VkID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoISh0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkpIHtcbiAgICAgIGlmIChhZGRBcmlhUHJlc3NlZCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1wcmVzc2VkJywgIXRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQUNUSVZFKSlcbiAgICAgIH1cblxuICAgICAgaWYgKHRyaWdnZXJDaGFuZ2VFdmVudCkge1xuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLnRvZ2dsZUNsYXNzKENMQVNTX05BTUVfQUNUSVZFKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKVxuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsXG4gIH1cblxuICAvLyBTdGF0aWNcblxuICBzdGF0aWMgX2pRdWVyeUludGVyZmFjZShjb25maWcsIGF2b2lkVHJpZ2dlckNoYW5nZSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgJGVsZW1lbnQgPSAkKHRoaXMpXG4gICAgICBsZXQgZGF0YSA9ICRlbGVtZW50LmRhdGEoREFUQV9LRVkpXG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBkYXRhID0gbmV3IEJ1dHRvbih0aGlzKVxuICAgICAgICAkZWxlbWVudC5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgfVxuXG4gICAgICBkYXRhLnNob3VsZEF2b2lkVHJpZ2dlckNoYW5nZSA9IGF2b2lkVHJpZ2dlckNoYW5nZVxuXG4gICAgICBpZiAoY29uZmlnID09PSAndG9nZ2xlJykge1xuICAgICAgICBkYXRhW2NvbmZpZ10oKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kKGRvY3VtZW50KVxuICAub24oRVZFTlRfQ0xJQ0tfREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFX0NBUlJPVCwgZXZlbnQgPT4ge1xuICAgIGxldCBidXR0b24gPSBldmVudC50YXJnZXRcbiAgICBjb25zdCBpbml0aWFsQnV0dG9uID0gYnV0dG9uXG5cbiAgICBpZiAoISQoYnV0dG9uKS5oYXNDbGFzcyhDTEFTU19OQU1FX0JVVFRPTikpIHtcbiAgICAgIGJ1dHRvbiA9ICQoYnV0dG9uKS5jbG9zZXN0KFNFTEVDVE9SX0JVVFRPTilbMF1cbiAgICB9XG5cbiAgICBpZiAoIWJ1dHRvbiB8fCBidXR0b24uaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpIHx8IGJ1dHRvbi5jbGFzc0xpc3QuY29udGFpbnMoJ2Rpc2FibGVkJykpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCkgLy8gd29yayBhcm91bmQgRmlyZWZveCBidWcgIzE1NDA5OTVcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW5wdXRCdG4gPSBidXR0b24ucXVlcnlTZWxlY3RvcihTRUxFQ1RPUl9JTlBVVClcblxuICAgICAgaWYgKGlucHV0QnRuICYmIChpbnB1dEJ0bi5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgfHwgaW5wdXRCdG4uY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3ggYnVnICMxNTQwOTk1XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoaW5pdGlhbEJ1dHRvbi50YWdOYW1lID09PSAnSU5QVVQnIHx8IGJ1dHRvbi50YWdOYW1lICE9PSAnTEFCRUwnKSB7XG4gICAgICAgIEJ1dHRvbi5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJChidXR0b24pLCAndG9nZ2xlJywgaW5pdGlhbEJ1dHRvbi50YWdOYW1lID09PSAnSU5QVVQnKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgLm9uKEVWRU5UX0ZPQ1VTX0JMVVJfREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFX0NBUlJPVCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IGJ1dHRvbiA9ICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFNFTEVDVE9SX0JVVFRPTilbMF1cbiAgICAkKGJ1dHRvbikudG9nZ2xlQ2xhc3MoQ0xBU1NfTkFNRV9GT0NVUywgL15mb2N1cyhpbik/JC8udGVzdChldmVudC50eXBlKSlcbiAgfSlcblxuJCh3aW5kb3cpLm9uKEVWRU5UX0xPQURfREFUQV9BUEksICgpID0+IHtcbiAgLy8gZW5zdXJlIGNvcnJlY3QgYWN0aXZlIGNsYXNzIGlzIHNldCB0byBtYXRjaCB0aGUgY29udHJvbHMnIGFjdHVhbCB2YWx1ZXMvc3RhdGVzXG5cbiAgLy8gZmluZCBhbGwgY2hlY2tib3hlcy9yZWFkaW8gYnV0dG9ucyBpbnNpZGUgZGF0YS10b2dnbGUgZ3JvdXBzXG4gIGxldCBidXR0b25zID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0RBVEFfVE9HR0xFU19CVVRUT05TKSlcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGJ1dHRvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBidXR0b24gPSBidXR0b25zW2ldXG4gICAgY29uc3QgaW5wdXQgPSBidXR0b24ucXVlcnlTZWxlY3RvcihTRUxFQ1RPUl9JTlBVVClcbiAgICBpZiAoaW5wdXQuY2hlY2tlZCB8fCBpbnB1dC5oYXNBdHRyaWJ1dGUoJ2NoZWNrZWQnKSkge1xuICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFKVxuICAgIH1cbiAgfVxuXG4gIC8vIGZpbmQgYWxsIGJ1dHRvbiB0b2dnbGVzXG4gIGJ1dHRvbnMgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfREFUQV9UT0dHTEUpKVxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gYnV0dG9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGJ1dHRvbiA9IGJ1dHRvbnNbaV1cbiAgICBpZiAoYnV0dG9uLmdldEF0dHJpYnV0ZSgnYXJpYS1wcmVzc2VkJykgPT09ICd0cnVlJykge1xuICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFKVxuICAgIH1cbiAgfVxufSlcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGpRdWVyeVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuJC5mbltOQU1FXSA9IEJ1dHRvbi5falF1ZXJ5SW50ZXJmYWNlXG4kLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gQnV0dG9uXG4kLmZuW05BTUVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XG4gICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1RcbiAgcmV0dXJuIEJ1dHRvbi5falF1ZXJ5SW50ZXJmYWNlXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC42LjApOiBjYXJvdXNlbC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSdcbmltcG9ydCBVdGlsIGZyb20gJy4vdXRpbCdcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgTkFNRSA9ICdjYXJvdXNlbCdcbmNvbnN0IFZFUlNJT04gPSAnNC42LjAnXG5jb25zdCBEQVRBX0tFWSA9ICdicy5jYXJvdXNlbCdcbmNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJ1xuY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltOQU1FXVxuY29uc3QgQVJST1dfTEVGVF9LRVlDT0RFID0gMzcgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgbGVmdCBhcnJvdyBrZXlcbmNvbnN0IEFSUk9XX1JJR0hUX0tFWUNPREUgPSAzOSAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciByaWdodCBhcnJvdyBrZXlcbmNvbnN0IFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgPSA1MDAgLy8gVGltZSBmb3IgbW91c2UgY29tcGF0IGV2ZW50cyB0byBmaXJlIGFmdGVyIHRvdWNoXG5jb25zdCBTV0lQRV9USFJFU0hPTEQgPSA0MFxuXG5jb25zdCBEZWZhdWx0ID0ge1xuICBpbnRlcnZhbDogNTAwMCxcbiAga2V5Ym9hcmQ6IHRydWUsXG4gIHNsaWRlOiBmYWxzZSxcbiAgcGF1c2U6ICdob3ZlcicsXG4gIHdyYXA6IHRydWUsXG4gIHRvdWNoOiB0cnVlXG59XG5cbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICBpbnRlcnZhbDogJyhudW1iZXJ8Ym9vbGVhbiknLFxuICBrZXlib2FyZDogJ2Jvb2xlYW4nLFxuICBzbGlkZTogJyhib29sZWFufHN0cmluZyknLFxuICBwYXVzZTogJyhzdHJpbmd8Ym9vbGVhbiknLFxuICB3cmFwOiAnYm9vbGVhbicsXG4gIHRvdWNoOiAnYm9vbGVhbidcbn1cblxuY29uc3QgRElSRUNUSU9OX05FWFQgPSAnbmV4dCdcbmNvbnN0IERJUkVDVElPTl9QUkVWID0gJ3ByZXYnXG5jb25zdCBESVJFQ1RJT05fTEVGVCA9ICdsZWZ0J1xuY29uc3QgRElSRUNUSU9OX1JJR0hUID0gJ3JpZ2h0J1xuXG5jb25zdCBFVkVOVF9TTElERSA9IGBzbGlkZSR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX1NMSUQgPSBgc2xpZCR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0tFWURPV04gPSBga2V5ZG93biR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX01PVVNFRU5URVIgPSBgbW91c2VlbnRlciR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX01PVVNFTEVBVkUgPSBgbW91c2VsZWF2ZSR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX1RPVUNIU1RBUlQgPSBgdG91Y2hzdGFydCR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX1RPVUNITU9WRSA9IGB0b3VjaG1vdmUke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9UT1VDSEVORCA9IGB0b3VjaGVuZCR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX1BPSU5URVJET1dOID0gYHBvaW50ZXJkb3duJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfUE9JTlRFUlVQID0gYHBvaW50ZXJ1cCR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0RSQUdfU1RBUlQgPSBgZHJhZ3N0YXJ0JHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSA9IGBsb2FkJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkgPSBgY2xpY2ske0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gXG5cbmNvbnN0IENMQVNTX05BTUVfQ0FST1VTRUwgPSAnY2Fyb3VzZWwnXG5jb25zdCBDTEFTU19OQU1FX0FDVElWRSA9ICdhY3RpdmUnXG5jb25zdCBDTEFTU19OQU1FX1NMSURFID0gJ3NsaWRlJ1xuY29uc3QgQ0xBU1NfTkFNRV9SSUdIVCA9ICdjYXJvdXNlbC1pdGVtLXJpZ2h0J1xuY29uc3QgQ0xBU1NfTkFNRV9MRUZUID0gJ2Nhcm91c2VsLWl0ZW0tbGVmdCdcbmNvbnN0IENMQVNTX05BTUVfTkVYVCA9ICdjYXJvdXNlbC1pdGVtLW5leHQnXG5jb25zdCBDTEFTU19OQU1FX1BSRVYgPSAnY2Fyb3VzZWwtaXRlbS1wcmV2J1xuY29uc3QgQ0xBU1NfTkFNRV9QT0lOVEVSX0VWRU5UID0gJ3BvaW50ZXItZXZlbnQnXG5cbmNvbnN0IFNFTEVDVE9SX0FDVElWRSA9ICcuYWN0aXZlJ1xuY29uc3QgU0VMRUNUT1JfQUNUSVZFX0lURU0gPSAnLmFjdGl2ZS5jYXJvdXNlbC1pdGVtJ1xuY29uc3QgU0VMRUNUT1JfSVRFTSA9ICcuY2Fyb3VzZWwtaXRlbSdcbmNvbnN0IFNFTEVDVE9SX0lURU1fSU1HID0gJy5jYXJvdXNlbC1pdGVtIGltZydcbmNvbnN0IFNFTEVDVE9SX05FWFRfUFJFViA9ICcuY2Fyb3VzZWwtaXRlbS1uZXh0LCAuY2Fyb3VzZWwtaXRlbS1wcmV2J1xuY29uc3QgU0VMRUNUT1JfSU5ESUNBVE9SUyA9ICcuY2Fyb3VzZWwtaW5kaWNhdG9ycydcbmNvbnN0IFNFTEVDVE9SX0RBVEFfU0xJREUgPSAnW2RhdGEtc2xpZGVdLCBbZGF0YS1zbGlkZS10b10nXG5jb25zdCBTRUxFQ1RPUl9EQVRBX1JJREUgPSAnW2RhdGEtcmlkZT1cImNhcm91c2VsXCJdJ1xuXG5jb25zdCBQb2ludGVyVHlwZSA9IHtcbiAgVE9VQ0g6ICd0b3VjaCcsXG4gIFBFTjogJ3Blbidcbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5jbGFzcyBDYXJvdXNlbCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIHRoaXMuX2l0ZW1zID0gbnVsbFxuICAgIHRoaXMuX2ludGVydmFsID0gbnVsbFxuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsXG4gICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZVxuICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlXG4gICAgdGhpcy50b3VjaFRpbWVvdXQgPSBudWxsXG4gICAgdGhpcy50b3VjaFN0YXJ0WCA9IDBcbiAgICB0aGlzLnRvdWNoRGVsdGFYID0gMFxuXG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZylcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudFxuICAgIHRoaXMuX2luZGljYXRvcnNFbGVtZW50ID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKFNFTEVDVE9SX0lORElDQVRPUlMpXG4gICAgdGhpcy5fdG91Y2hTdXBwb3J0ZWQgPSAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMFxuICAgIHRoaXMuX3BvaW50ZXJFdmVudCA9IEJvb2xlYW4od2luZG93LlBvaW50ZXJFdmVudCB8fCB3aW5kb3cuTVNQb2ludGVyRXZlbnQpXG5cbiAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpXG4gIH1cblxuICAvLyBHZXR0ZXJzXG5cbiAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgIHJldHVybiBWRVJTSU9OXG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRcbiAgfVxuXG4gIC8vIFB1YmxpY1xuXG4gIG5leHQoKSB7XG4gICAgaWYgKCF0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgIHRoaXMuX3NsaWRlKERJUkVDVElPTl9ORVhUKVxuICAgIH1cbiAgfVxuXG4gIG5leHRXaGVuVmlzaWJsZSgpIHtcbiAgICBjb25zdCAkZWxlbWVudCA9ICQodGhpcy5fZWxlbWVudClcbiAgICAvLyBEb24ndCBjYWxsIG5leHQgd2hlbiB0aGUgcGFnZSBpc24ndCB2aXNpYmxlXG4gICAgLy8gb3IgdGhlIGNhcm91c2VsIG9yIGl0cyBwYXJlbnQgaXNuJ3QgdmlzaWJsZVxuICAgIGlmICghZG9jdW1lbnQuaGlkZGVuICYmXG4gICAgICAoJGVsZW1lbnQuaXMoJzp2aXNpYmxlJykgJiYgJGVsZW1lbnQuY3NzKCd2aXNpYmlsaXR5JykgIT09ICdoaWRkZW4nKSkge1xuICAgICAgdGhpcy5uZXh0KClcbiAgICB9XG4gIH1cblxuICBwcmV2KCkge1xuICAgIGlmICghdGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICB0aGlzLl9zbGlkZShESVJFQ1RJT05fUFJFVilcbiAgICB9XG4gIH1cblxuICBwYXVzZShldmVudCkge1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1JfTkVYVF9QUkVWKSkge1xuICAgICAgVXRpbC50cmlnZ2VyVHJhbnNpdGlvbkVuZCh0aGlzLl9lbGVtZW50KVxuICAgICAgdGhpcy5jeWNsZSh0cnVlKVxuICAgIH1cblxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpXG4gICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsXG4gIH1cblxuICBjeWNsZShldmVudCkge1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpXG4gICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY29uZmlnLmludGVydmFsICYmICF0aGlzLl9pc1BhdXNlZCkge1xuICAgICAgdGhpcy5fdXBkYXRlSW50ZXJ2YWwoKVxuXG4gICAgICB0aGlzLl9pbnRlcnZhbCA9IHNldEludGVydmFsKFxuICAgICAgICAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID8gdGhpcy5uZXh0V2hlblZpc2libGUgOiB0aGlzLm5leHQpLmJpbmQodGhpcyksXG4gICAgICAgIHRoaXMuX2NvbmZpZy5pbnRlcnZhbFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHRvKGluZGV4KSB7XG4gICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcihTRUxFQ1RPUl9BQ1RJVkVfSVRFTSlcblxuICAgIGNvbnN0IGFjdGl2ZUluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KHRoaXMuX2FjdGl2ZUVsZW1lbnQpXG5cbiAgICBpZiAoaW5kZXggPiB0aGlzLl9pdGVtcy5sZW5ndGggLSAxIHx8IGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbmUoRVZFTlRfU0xJRCwgKCkgPT4gdGhpcy50byhpbmRleCkpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoYWN0aXZlSW5kZXggPT09IGluZGV4KSB7XG4gICAgICB0aGlzLnBhdXNlKClcbiAgICAgIHRoaXMuY3ljbGUoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZGlyZWN0aW9uID0gaW5kZXggPiBhY3RpdmVJbmRleCA/XG4gICAgICBESVJFQ1RJT05fTkVYVCA6XG4gICAgICBESVJFQ1RJT05fUFJFVlxuXG4gICAgdGhpcy5fc2xpZGUoZGlyZWN0aW9uLCB0aGlzLl9pdGVtc1tpbmRleF0pXG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgICQodGhpcy5fZWxlbWVudCkub2ZmKEVWRU5UX0tFWSlcbiAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpXG5cbiAgICB0aGlzLl9pdGVtcyA9IG51bGxcbiAgICB0aGlzLl9jb25maWcgPSBudWxsXG4gICAgdGhpcy5fZWxlbWVudCA9IG51bGxcbiAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGxcbiAgICB0aGlzLl9pc1BhdXNlZCA9IG51bGxcbiAgICB0aGlzLl9pc1NsaWRpbmcgPSBudWxsXG4gICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IG51bGxcbiAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9IG51bGxcbiAgfVxuXG4gIC8vIFByaXZhdGVcblxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IHtcbiAgICAgIC4uLkRlZmF1bHQsXG4gICAgICAuLi5jb25maWdcbiAgICB9XG4gICAgVXRpbC50eXBlQ2hlY2tDb25maWcoTkFNRSwgY29uZmlnLCBEZWZhdWx0VHlwZSlcbiAgICByZXR1cm4gY29uZmlnXG4gIH1cblxuICBfaGFuZGxlU3dpcGUoKSB7XG4gICAgY29uc3QgYWJzRGVsdGF4ID0gTWF0aC5hYnModGhpcy50b3VjaERlbHRhWClcblxuICAgIGlmIChhYnNEZWx0YXggPD0gU1dJUEVfVEhSRVNIT0xEKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBkaXJlY3Rpb24gPSBhYnNEZWx0YXggLyB0aGlzLnRvdWNoRGVsdGFYXG5cbiAgICB0aGlzLnRvdWNoRGVsdGFYID0gMFxuXG4gICAgLy8gc3dpcGUgbGVmdFxuICAgIGlmIChkaXJlY3Rpb24gPiAwKSB7XG4gICAgICB0aGlzLnByZXYoKVxuICAgIH1cblxuICAgIC8vIHN3aXBlIHJpZ2h0XG4gICAgaWYgKGRpcmVjdGlvbiA8IDApIHtcbiAgICAgIHRoaXMubmV4dCgpXG4gICAgfVxuICB9XG5cbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLl9jb25maWcua2V5Ym9hcmQpIHtcbiAgICAgICQodGhpcy5fZWxlbWVudCkub24oRVZFTlRfS0VZRE9XTiwgZXZlbnQgPT4gdGhpcy5fa2V5ZG93bihldmVudCkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5wYXVzZSA9PT0gJ2hvdmVyJykge1xuICAgICAgJCh0aGlzLl9lbGVtZW50KVxuICAgICAgICAub24oRVZFTlRfTU9VU0VFTlRFUiwgZXZlbnQgPT4gdGhpcy5wYXVzZShldmVudCkpXG4gICAgICAgIC5vbihFVkVOVF9NT1VTRUxFQVZFLCBldmVudCA9PiB0aGlzLmN5Y2xlKGV2ZW50KSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY29uZmlnLnRvdWNoKSB7XG4gICAgICB0aGlzLl9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKClcbiAgICB9XG4gIH1cblxuICBfYWRkVG91Y2hFdmVudExpc3RlbmVycygpIHtcbiAgICBpZiAoIXRoaXMuX3RvdWNoU3VwcG9ydGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBzdGFydCA9IGV2ZW50ID0+IHtcbiAgICAgIGlmICh0aGlzLl9wb2ludGVyRXZlbnQgJiYgUG9pbnRlclR5cGVbZXZlbnQub3JpZ2luYWxFdmVudC5wb2ludGVyVHlwZS50b1VwcGVyQ2FzZSgpXSkge1xuICAgICAgICB0aGlzLnRvdWNoU3RhcnRYID0gZXZlbnQub3JpZ2luYWxFdmVudC5jbGllbnRYXG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9wb2ludGVyRXZlbnQpIHtcbiAgICAgICAgdGhpcy50b3VjaFN0YXJ0WCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXS5jbGllbnRYXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbW92ZSA9IGV2ZW50ID0+IHtcbiAgICAgIC8vIGVuc3VyZSBzd2lwaW5nIHdpdGggb25lIHRvdWNoIGFuZCBub3QgcGluY2hpbmdcbiAgICAgIGlmIChldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXMgJiYgZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy50b3VjaERlbHRhWCA9IDBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudG91Y2hEZWx0YVggPSBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCAtIHRoaXMudG91Y2hTdGFydFhcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBlbmQgPSBldmVudCA9PiB7XG4gICAgICBpZiAodGhpcy5fcG9pbnRlckV2ZW50ICYmIFBvaW50ZXJUeXBlW2V2ZW50Lm9yaWdpbmFsRXZlbnQucG9pbnRlclR5cGUudG9VcHBlckNhc2UoKV0pIHtcbiAgICAgICAgdGhpcy50b3VjaERlbHRhWCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQuY2xpZW50WCAtIHRoaXMudG91Y2hTdGFydFhcbiAgICAgIH1cblxuICAgICAgdGhpcy5faGFuZGxlU3dpcGUoKVxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5wYXVzZSA9PT0gJ2hvdmVyJykge1xuICAgICAgICAvLyBJZiBpdCdzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2UsIG1vdXNlZW50ZXIvbGVhdmUgYXJlIGZpcmVkIGFzXG4gICAgICAgIC8vIHBhcnQgb2YgdGhlIG1vdXNlIGNvbXBhdGliaWxpdHkgZXZlbnRzIG9uIGZpcnN0IHRhcCAtIHRoZSBjYXJvdXNlbFxuICAgICAgICAvLyB3b3VsZCBzdG9wIGN5Y2xpbmcgdW50aWwgdXNlciB0YXBwZWQgb3V0IG9mIGl0O1xuICAgICAgICAvLyBoZXJlLCB3ZSBsaXN0ZW4gZm9yIHRvdWNoZW5kLCBleHBsaWNpdGx5IHBhdXNlIHRoZSBjYXJvdXNlbFxuICAgICAgICAvLyAoYXMgaWYgaXQncyB0aGUgc2Vjb25kIHRpbWUgd2UgdGFwIG9uIGl0LCBtb3VzZWVudGVyIGNvbXBhdCBldmVudFxuICAgICAgICAvLyBpcyBOT1QgZmlyZWQpIGFuZCBhZnRlciBhIHRpbWVvdXQgKHRvIGFsbG93IGZvciBtb3VzZSBjb21wYXRpYmlsaXR5XG4gICAgICAgIC8vIGV2ZW50cyB0byBmaXJlKSB3ZSBleHBsaWNpdGx5IHJlc3RhcnQgY3ljbGluZ1xuXG4gICAgICAgIHRoaXMucGF1c2UoKVxuICAgICAgICBpZiAodGhpcy50b3VjaFRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50b3VjaFRpbWVvdXQpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRvdWNoVGltZW91dCA9IHNldFRpbWVvdXQoZXZlbnQgPT4gdGhpcy5jeWNsZShldmVudCksIFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgKyB0aGlzLl9jb25maWcuaW50ZXJ2YWwpXG4gICAgICB9XG4gICAgfVxuXG4gICAgJCh0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfSVRFTV9JTUcpKVxuICAgICAgLm9uKEVWRU5UX0RSQUdfU1RBUlQsIGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpKVxuXG4gICAgaWYgKHRoaXMuX3BvaW50ZXJFdmVudCkge1xuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFVkVOVF9QT0lOVEVSRE9XTiwgZXZlbnQgPT4gc3RhcnQoZXZlbnQpKVxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFVkVOVF9QT0lOVEVSVVAsIGV2ZW50ID0+IGVuZChldmVudCkpXG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQpXG4gICAgfSBlbHNlIHtcbiAgICAgICQodGhpcy5fZWxlbWVudCkub24oRVZFTlRfVE9VQ0hTVEFSVCwgZXZlbnQgPT4gc3RhcnQoZXZlbnQpKVxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFVkVOVF9UT1VDSE1PVkUsIGV2ZW50ID0+IG1vdmUoZXZlbnQpKVxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFVkVOVF9UT1VDSEVORCwgZXZlbnQgPT4gZW5kKGV2ZW50KSlcbiAgICB9XG4gIH1cblxuICBfa2V5ZG93bihldmVudCkge1xuICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc3dpdGNoIChldmVudC53aGljaCkge1xuICAgICAgY2FzZSBBUlJPV19MRUZUX0tFWUNPREU6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgdGhpcy5wcmV2KClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgQVJST1dfUklHSFRfS0VZQ09ERTpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICB0aGlzLm5leHQoKVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICBfZ2V0SXRlbUluZGV4KGVsZW1lbnQpIHtcbiAgICB0aGlzLl9pdGVtcyA9IGVsZW1lbnQgJiYgZWxlbWVudC5wYXJlbnROb2RlID9cbiAgICAgIFtdLnNsaWNlLmNhbGwoZWxlbWVudC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfSVRFTSkpIDpcbiAgICAgIFtdXG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmluZGV4T2YoZWxlbWVudClcbiAgfVxuXG4gIF9nZXRJdGVtQnlEaXJlY3Rpb24oZGlyZWN0aW9uLCBhY3RpdmVFbGVtZW50KSB7XG4gICAgY29uc3QgaXNOZXh0RGlyZWN0aW9uID0gZGlyZWN0aW9uID09PSBESVJFQ1RJT05fTkVYVFxuICAgIGNvbnN0IGlzUHJldkRpcmVjdGlvbiA9IGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX1BSRVZcbiAgICBjb25zdCBhY3RpdmVJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleChhY3RpdmVFbGVtZW50KVxuICAgIGNvbnN0IGxhc3RJdGVtSW5kZXggPSB0aGlzLl9pdGVtcy5sZW5ndGggLSAxXG4gICAgY29uc3QgaXNHb2luZ1RvV3JhcCA9IGlzUHJldkRpcmVjdGlvbiAmJiBhY3RpdmVJbmRleCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTmV4dERpcmVjdGlvbiAmJiBhY3RpdmVJbmRleCA9PT0gbGFzdEl0ZW1JbmRleFxuXG4gICAgaWYgKGlzR29pbmdUb1dyYXAgJiYgIXRoaXMuX2NvbmZpZy53cmFwKSB7XG4gICAgICByZXR1cm4gYWN0aXZlRWxlbWVudFxuICAgIH1cblxuICAgIGNvbnN0IGRlbHRhID0gZGlyZWN0aW9uID09PSBESVJFQ1RJT05fUFJFViA/IC0xIDogMVxuICAgIGNvbnN0IGl0ZW1JbmRleCA9IChhY3RpdmVJbmRleCArIGRlbHRhKSAlIHRoaXMuX2l0ZW1zLmxlbmd0aFxuXG4gICAgcmV0dXJuIGl0ZW1JbmRleCA9PT0gLTEgP1xuICAgICAgdGhpcy5faXRlbXNbdGhpcy5faXRlbXMubGVuZ3RoIC0gMV0gOiB0aGlzLl9pdGVtc1tpdGVtSW5kZXhdXG4gIH1cblxuICBfdHJpZ2dlclNsaWRlRXZlbnQocmVsYXRlZFRhcmdldCwgZXZlbnREaXJlY3Rpb25OYW1lKSB7XG4gICAgY29uc3QgdGFyZ2V0SW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgocmVsYXRlZFRhcmdldClcbiAgICBjb25zdCBmcm9tSW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgodGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKFNFTEVDVE9SX0FDVElWRV9JVEVNKSlcbiAgICBjb25zdCBzbGlkZUV2ZW50ID0gJC5FdmVudChFVkVOVF9TTElERSwge1xuICAgICAgcmVsYXRlZFRhcmdldCxcbiAgICAgIGRpcmVjdGlvbjogZXZlbnREaXJlY3Rpb25OYW1lLFxuICAgICAgZnJvbTogZnJvbUluZGV4LFxuICAgICAgdG86IHRhcmdldEluZGV4XG4gICAgfSlcblxuICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzbGlkZUV2ZW50KVxuXG4gICAgcmV0dXJuIHNsaWRlRXZlbnRcbiAgfVxuXG4gIF9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGluZGljYXRvcnMgPSBbXS5zbGljZS5jYWxsKHRoaXMuX2luZGljYXRvcnNFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfQUNUSVZFKSlcbiAgICAgICQoaW5kaWNhdG9ycykucmVtb3ZlQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUpXG5cbiAgICAgIGNvbnN0IG5leHRJbmRpY2F0b3IgPSB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudC5jaGlsZHJlbltcbiAgICAgICAgdGhpcy5fZ2V0SXRlbUluZGV4KGVsZW1lbnQpXG4gICAgICBdXG5cbiAgICAgIGlmIChuZXh0SW5kaWNhdG9yKSB7XG4gICAgICAgICQobmV4dEluZGljYXRvcikuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUludGVydmFsKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9hY3RpdmVFbGVtZW50IHx8IHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcihTRUxFQ1RPUl9BQ1RJVkVfSVRFTSlcblxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZWxlbWVudEludGVydmFsID0gcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW50ZXJ2YWwnKSwgMTApXG5cbiAgICBpZiAoZWxlbWVudEludGVydmFsKSB7XG4gICAgICB0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsID0gdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuaW50ZXJ2YWxcbiAgICAgIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCA9IGVsZW1lbnRJbnRlcnZhbFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jb25maWcuaW50ZXJ2YWwgPSB0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsIHx8IHRoaXMuX2NvbmZpZy5pbnRlcnZhbFxuICAgIH1cbiAgfVxuXG4gIF9zbGlkZShkaXJlY3Rpb24sIGVsZW1lbnQpIHtcbiAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKFNFTEVDVE9SX0FDVElWRV9JVEVNKVxuICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnRJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleChhY3RpdmVFbGVtZW50KVxuICAgIGNvbnN0IG5leHRFbGVtZW50ID0gZWxlbWVudCB8fCBhY3RpdmVFbGVtZW50ICYmXG4gICAgICB0aGlzLl9nZXRJdGVtQnlEaXJlY3Rpb24oZGlyZWN0aW9uLCBhY3RpdmVFbGVtZW50KVxuICAgIGNvbnN0IG5leHRFbGVtZW50SW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgobmV4dEVsZW1lbnQpXG4gICAgY29uc3QgaXNDeWNsaW5nID0gQm9vbGVhbih0aGlzLl9pbnRlcnZhbClcblxuICAgIGxldCBkaXJlY3Rpb25hbENsYXNzTmFtZVxuICAgIGxldCBvcmRlckNsYXNzTmFtZVxuICAgIGxldCBldmVudERpcmVjdGlvbk5hbWVcblxuICAgIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTl9ORVhUKSB7XG4gICAgICBkaXJlY3Rpb25hbENsYXNzTmFtZSA9IENMQVNTX05BTUVfTEVGVFxuICAgICAgb3JkZXJDbGFzc05hbWUgPSBDTEFTU19OQU1FX05FWFRcbiAgICAgIGV2ZW50RGlyZWN0aW9uTmFtZSA9IERJUkVDVElPTl9MRUZUXG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcmVjdGlvbmFsQ2xhc3NOYW1lID0gQ0xBU1NfTkFNRV9SSUdIVFxuICAgICAgb3JkZXJDbGFzc05hbWUgPSBDTEFTU19OQU1FX1BSRVZcbiAgICAgIGV2ZW50RGlyZWN0aW9uTmFtZSA9IERJUkVDVElPTl9SSUdIVFxuICAgIH1cblxuICAgIGlmIChuZXh0RWxlbWVudCAmJiAkKG5leHRFbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX0FDVElWRSkpIHtcbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBzbGlkZUV2ZW50ID0gdGhpcy5fdHJpZ2dlclNsaWRlRXZlbnQobmV4dEVsZW1lbnQsIGV2ZW50RGlyZWN0aW9uTmFtZSlcbiAgICBpZiAoc2xpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFhY3RpdmVFbGVtZW50IHx8ICFuZXh0RWxlbWVudCkge1xuICAgICAgLy8gU29tZSB3ZWlyZG5lc3MgaXMgaGFwcGVuaW5nLCBzbyB3ZSBiYWlsXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9pc1NsaWRpbmcgPSB0cnVlXG5cbiAgICBpZiAoaXNDeWNsaW5nKSB7XG4gICAgICB0aGlzLnBhdXNlKClcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KG5leHRFbGVtZW50KVxuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBuZXh0RWxlbWVudFxuXG4gICAgY29uc3Qgc2xpZEV2ZW50ID0gJC5FdmVudChFVkVOVF9TTElELCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiBuZXh0RWxlbWVudCxcbiAgICAgIGRpcmVjdGlvbjogZXZlbnREaXJlY3Rpb25OYW1lLFxuICAgICAgZnJvbTogYWN0aXZlRWxlbWVudEluZGV4LFxuICAgICAgdG86IG5leHRFbGVtZW50SW5kZXhcbiAgICB9KVxuXG4gICAgaWYgKCQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9TTElERSkpIHtcbiAgICAgICQobmV4dEVsZW1lbnQpLmFkZENsYXNzKG9yZGVyQ2xhc3NOYW1lKVxuXG4gICAgICBVdGlsLnJlZmxvdyhuZXh0RWxlbWVudClcblxuICAgICAgJChhY3RpdmVFbGVtZW50KS5hZGRDbGFzcyhkaXJlY3Rpb25hbENsYXNzTmFtZSlcbiAgICAgICQobmV4dEVsZW1lbnQpLmFkZENsYXNzKGRpcmVjdGlvbmFsQ2xhc3NOYW1lKVxuXG4gICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KGFjdGl2ZUVsZW1lbnQpXG5cbiAgICAgICQoYWN0aXZlRWxlbWVudClcbiAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCAoKSA9PiB7XG4gICAgICAgICAgJChuZXh0RWxlbWVudClcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhgJHtkaXJlY3Rpb25hbENsYXNzTmFtZX0gJHtvcmRlckNsYXNzTmFtZX1gKVxuICAgICAgICAgICAgLmFkZENsYXNzKENMQVNTX05BTUVfQUNUSVZFKVxuXG4gICAgICAgICAgJChhY3RpdmVFbGVtZW50KS5yZW1vdmVDbGFzcyhgJHtDTEFTU19OQU1FX0FDVElWRX0gJHtvcmRlckNsYXNzTmFtZX0gJHtkaXJlY3Rpb25hbENsYXNzTmFtZX1gKVxuXG4gICAgICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2VcblxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNsaWRFdmVudCksIDApXG4gICAgICAgIH0pXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgICQoYWN0aXZlRWxlbWVudCkucmVtb3ZlQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgICAkKG5leHRFbGVtZW50KS5hZGRDbGFzcyhDTEFTU19OQU1FX0FDVElWRSlcblxuICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2VcbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzbGlkRXZlbnQpXG4gICAgfVxuXG4gICAgaWYgKGlzQ3ljbGluZykge1xuICAgICAgdGhpcy5jeWNsZSgpXG4gICAgfVxuICB9XG5cbiAgLy8gU3RhdGljXG5cbiAgc3RhdGljIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgZGF0YSA9ICQodGhpcykuZGF0YShEQVRBX0tFWSlcbiAgICAgIGxldCBfY29uZmlnID0ge1xuICAgICAgICAuLi5EZWZhdWx0LFxuICAgICAgICAuLi4kKHRoaXMpLmRhdGEoKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgX2NvbmZpZyA9IHtcbiAgICAgICAgICAuLi5fY29uZmlnLFxuICAgICAgICAgIC4uLmNvbmZpZ1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFjdGlvbiA9IHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnID8gY29uZmlnIDogX2NvbmZpZy5zbGlkZVxuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBDYXJvdXNlbCh0aGlzLCBfY29uZmlnKVxuICAgICAgICAkKHRoaXMpLmRhdGEoREFUQV9LRVksIGRhdGEpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnbnVtYmVyJykge1xuICAgICAgICBkYXRhLnRvKGNvbmZpZylcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2FjdGlvbl0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHthY3Rpb259XCJgKVxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVthY3Rpb25dKClcbiAgICAgIH0gZWxzZSBpZiAoX2NvbmZpZy5pbnRlcnZhbCAmJiBfY29uZmlnLnJpZGUpIHtcbiAgICAgICAgZGF0YS5wYXVzZSgpXG4gICAgICAgIGRhdGEuY3ljbGUoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBzdGF0aWMgX2RhdGFBcGlDbGlja0hhbmRsZXIoZXZlbnQpIHtcbiAgICBjb25zdCBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0aGlzKVxuXG4gICAgaWYgKCFzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gJChzZWxlY3RvcilbMF1cblxuICAgIGlmICghdGFyZ2V0IHx8ICEkKHRhcmdldCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9DQVJPVVNFTCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIC4uLiQodGFyZ2V0KS5kYXRhKCksXG4gICAgICAuLi4kKHRoaXMpLmRhdGEoKVxuICAgIH1cbiAgICBjb25zdCBzbGlkZUluZGV4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xpZGUtdG8nKVxuXG4gICAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICAgIGNvbmZpZy5pbnRlcnZhbCA9IGZhbHNlXG4gICAgfVxuXG4gICAgQ2Fyb3VzZWwuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGFyZ2V0KSwgY29uZmlnKVxuXG4gICAgaWYgKHNsaWRlSW5kZXgpIHtcbiAgICAgICQodGFyZ2V0KS5kYXRhKERBVEFfS0VZKS50byhzbGlkZUluZGV4KVxuICAgIH1cblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbiQoZG9jdW1lbnQpLm9uKEVWRU5UX0NMSUNLX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1NMSURFLCBDYXJvdXNlbC5fZGF0YUFwaUNsaWNrSGFuZGxlcilcblxuJCh3aW5kb3cpLm9uKEVWRU5UX0xPQURfREFUQV9BUEksICgpID0+IHtcbiAgY29uc3QgY2Fyb3VzZWxzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0RBVEFfUklERSkpXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjYXJvdXNlbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCAkY2Fyb3VzZWwgPSAkKGNhcm91c2Vsc1tpXSlcbiAgICBDYXJvdXNlbC5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJGNhcm91c2VsLCAkY2Fyb3VzZWwuZGF0YSgpKVxuICB9XG59KVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kLmZuW05BTUVdID0gQ2Fyb3VzZWwuX2pRdWVyeUludGVyZmFjZVxuJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IENhcm91c2VsXG4kLmZuW05BTUVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XG4gICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1RcbiAgcmV0dXJuIENhcm91c2VsLl9qUXVlcnlJbnRlcmZhY2Vcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2Fyb3VzZWxcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuNi4wKTogY29sbGFwc2UuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknXG5pbXBvcnQgVXRpbCBmcm9tICcuL3V0aWwnXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUgPSAnY29sbGFwc2UnXG5jb25zdCBWRVJTSU9OID0gJzQuNi4wJ1xuY29uc3QgREFUQV9LRVkgPSAnYnMuY29sbGFwc2UnXG5jb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSdcbmNvbnN0IEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV1cblxuY29uc3QgRGVmYXVsdCA9IHtcbiAgdG9nZ2xlOiB0cnVlLFxuICBwYXJlbnQ6ICcnXG59XG5cbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICB0b2dnbGU6ICdib29sZWFuJyxcbiAgcGFyZW50OiAnKHN0cmluZ3xlbGVtZW50KSdcbn1cblxuY29uc3QgRVZFTlRfU0hPVyA9IGBzaG93JHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0hPV04gPSBgc2hvd24ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9ISURFID0gYGhpZGUke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9ISURERU4gPSBgaGlkZGVuJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkgPSBgY2xpY2ske0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gXG5cbmNvbnN0IENMQVNTX05BTUVfU0hPVyA9ICdzaG93J1xuY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTRSA9ICdjb2xsYXBzZSdcbmNvbnN0IENMQVNTX05BTUVfQ09MTEFQU0lORyA9ICdjb2xsYXBzaW5nJ1xuY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTRUQgPSAnY29sbGFwc2VkJ1xuXG5jb25zdCBESU1FTlNJT05fV0lEVEggPSAnd2lkdGgnXG5jb25zdCBESU1FTlNJT05fSEVJR0hUID0gJ2hlaWdodCdcblxuY29uc3QgU0VMRUNUT1JfQUNUSVZFUyA9ICcuc2hvdywgLmNvbGxhcHNpbmcnXG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSA9ICdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXSdcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNsYXNzIENvbGxhcHNlIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2VcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudFxuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpXG4gICAgdGhpcy5fdHJpZ2dlckFycmF5ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgYFtkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdW2hyZWY9XCIjJHtlbGVtZW50LmlkfVwiXSxgICtcbiAgICAgIGBbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtkYXRhLXRhcmdldD1cIiMke2VsZW1lbnQuaWR9XCJdYFxuICAgICkpXG5cbiAgICBjb25zdCB0b2dnbGVMaXN0ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0RBVEFfVE9HR0xFKSlcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdG9nZ2xlTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgZWxlbSA9IHRvZ2dsZUxpc3RbaV1cbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW0pXG4gICAgICBjb25zdCBmaWx0ZXJFbGVtZW50ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlcbiAgICAgICAgLmZpbHRlcihmb3VuZEVsZW0gPT4gZm91bmRFbGVtID09PSBlbGVtZW50KVxuXG4gICAgICBpZiAoc2VsZWN0b3IgIT09IG51bGwgJiYgZmlsdGVyRWxlbWVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdG9yID0gc2VsZWN0b3JcbiAgICAgICAgdGhpcy5fdHJpZ2dlckFycmF5LnB1c2goZWxlbSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9jb25maWcucGFyZW50ID8gdGhpcy5fZ2V0UGFyZW50KCkgOiBudWxsXG5cbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcbiAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl90cmlnZ2VyQXJyYXkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy50b2dnbGUpIHtcbiAgICAgIHRoaXMudG9nZ2xlKClcbiAgICB9XG4gIH1cblxuICAvLyBHZXR0ZXJzXG5cbiAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgIHJldHVybiBWRVJTSU9OXG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRcbiAgfVxuXG4gIC8vIFB1YmxpY1xuXG4gIHRvZ2dsZSgpIHtcbiAgICBpZiAoJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX1NIT1cpKSB7XG4gICAgICB0aGlzLmhpZGUoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3coKVxuICAgIH1cbiAgfVxuXG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fFxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX1NIT1cpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgYWN0aXZlc1xuICAgIGxldCBhY3RpdmVzRGF0YVxuXG4gICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgYWN0aXZlcyA9IFtdLnNsaWNlLmNhbGwodGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfQUNUSVZFUykpXG4gICAgICAgIC5maWx0ZXIoZWxlbSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jb25maWcucGFyZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCdkYXRhLXBhcmVudCcpID09PSB0aGlzLl9jb25maWcucGFyZW50XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQ09MTEFQU0UpXG4gICAgICAgIH0pXG5cbiAgICAgIGlmIChhY3RpdmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhY3RpdmVzID0gbnVsbFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhY3RpdmVzKSB7XG4gICAgICBhY3RpdmVzRGF0YSA9ICQoYWN0aXZlcykubm90KHRoaXMuX3NlbGVjdG9yKS5kYXRhKERBVEFfS0VZKVxuICAgICAgaWYgKGFjdGl2ZXNEYXRhICYmIGFjdGl2ZXNEYXRhLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRFdmVudCA9ICQuRXZlbnQoRVZFTlRfU0hPVylcbiAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc3RhcnRFdmVudClcbiAgICBpZiAoc3RhcnRFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGFjdGl2ZXMpIHtcbiAgICAgIENvbGxhcHNlLl9qUXVlcnlJbnRlcmZhY2UuY2FsbCgkKGFjdGl2ZXMpLm5vdCh0aGlzLl9zZWxlY3RvciksICdoaWRlJylcbiAgICAgIGlmICghYWN0aXZlc0RhdGEpIHtcbiAgICAgICAgJChhY3RpdmVzKS5kYXRhKERBVEFfS0VZLCBudWxsKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuX2dldERpbWVuc2lvbigpXG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpXG4gICAgICAucmVtb3ZlQ2xhc3MoQ0xBU1NfTkFNRV9DT0xMQVBTRSlcbiAgICAgIC5hZGRDbGFzcyhDTEFTU19OQU1FX0NPTExBUFNJTkcpXG5cbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAwXG5cbiAgICBpZiAodGhpcy5fdHJpZ2dlckFycmF5Lmxlbmd0aCkge1xuICAgICAgJCh0aGlzLl90cmlnZ2VyQXJyYXkpXG4gICAgICAgIC5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX0NPTExBUFNFRClcbiAgICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKVxuICAgIH1cblxuICAgIHRoaXMuc2V0VHJhbnNpdGlvbmluZyh0cnVlKVxuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpXG4gICAgICAgIC5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX0NPTExBUFNJTkcpXG4gICAgICAgIC5hZGRDbGFzcyhgJHtDTEFTU19OQU1FX0NPTExBUFNFfSAke0NMQVNTX05BTUVfU0hPV31gKVxuXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAnJ1xuXG4gICAgICB0aGlzLnNldFRyYW5zaXRpb25pbmcoZmFsc2UpXG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihFVkVOVF9TSE9XTilcbiAgICB9XG5cbiAgICBjb25zdCBjYXBpdGFsaXplZERpbWVuc2lvbiA9IGRpbWVuc2lvblswXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKDEpXG4gICAgY29uc3Qgc2Nyb2xsU2l6ZSA9IGBzY3JvbGwke2NhcGl0YWxpemVkRGltZW5zaW9ufWBcbiAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpXG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpXG4gICAgICAub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNvbXBsZXRlKVxuICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbilcblxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IGAke3RoaXMuX2VsZW1lbnRbc2Nyb2xsU2l6ZV19cHhgXG4gIH1cblxuICBoaWRlKCkge1xuICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHxcbiAgICAgICEkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfU0hPVykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSAkLkV2ZW50KEVWRU5UX0hJREUpXG4gICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHN0YXJ0RXZlbnQpXG4gICAgaWYgKHN0YXJ0RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuX2dldERpbWVuc2lvbigpXG5cbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSBgJHt0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2RpbWVuc2lvbl19cHhgXG5cbiAgICBVdGlsLnJlZmxvdyh0aGlzLl9lbGVtZW50KVxuXG4gICAgJCh0aGlzLl9lbGVtZW50KVxuICAgICAgLmFkZENsYXNzKENMQVNTX05BTUVfQ09MTEFQU0lORylcbiAgICAgIC5yZW1vdmVDbGFzcyhgJHtDTEFTU19OQU1FX0NPTExBUFNFfSAke0NMQVNTX05BTUVfU0hPV31gKVxuXG4gICAgY29uc3QgdHJpZ2dlckFycmF5TGVuZ3RoID0gdGhpcy5fdHJpZ2dlckFycmF5Lmxlbmd0aFxuICAgIGlmICh0cmlnZ2VyQXJyYXlMZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyaWdnZXJBcnJheUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRyaWdnZXIgPSB0aGlzLl90cmlnZ2VyQXJyYXlbaV1cbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodHJpZ2dlcilcblxuICAgICAgICBpZiAoc2VsZWN0b3IgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCAkZWxlbSA9ICQoW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSkpXG4gICAgICAgICAgaWYgKCEkZWxlbS5oYXNDbGFzcyhDTEFTU19OQU1FX1NIT1cpKSB7XG4gICAgICAgICAgICAkKHRyaWdnZXIpLmFkZENsYXNzKENMQVNTX05BTUVfQ09MTEFQU0VEKVxuICAgICAgICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0VHJhbnNpdGlvbmluZyh0cnVlKVxuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLnNldFRyYW5zaXRpb25pbmcoZmFsc2UpXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpXG4gICAgICAgIC5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX0NPTExBUFNJTkcpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19OQU1FX0NPTExBUFNFKVxuICAgICAgICAudHJpZ2dlcihFVkVOVF9ISURERU4pXG4gICAgfVxuXG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJydcbiAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpXG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpXG4gICAgICAub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNvbXBsZXRlKVxuICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbilcbiAgfVxuXG4gIHNldFRyYW5zaXRpb25pbmcoaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gaXNUcmFuc2l0aW9uaW5nXG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgICQucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBEQVRBX0tFWSlcblxuICAgIHRoaXMuX2NvbmZpZyA9IG51bGxcbiAgICB0aGlzLl9wYXJlbnQgPSBudWxsXG4gICAgdGhpcy5fZWxlbWVudCA9IG51bGxcbiAgICB0aGlzLl90cmlnZ2VyQXJyYXkgPSBudWxsXG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gbnVsbFxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0ge1xuICAgICAgLi4uRGVmYXVsdCxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH1cbiAgICBjb25maWcudG9nZ2xlID0gQm9vbGVhbihjb25maWcudG9nZ2xlKSAvLyBDb2VyY2Ugc3RyaW5nIHZhbHVlc1xuICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUsIGNvbmZpZywgRGVmYXVsdFR5cGUpXG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9XG5cbiAgX2dldERpbWVuc2lvbigpIHtcbiAgICBjb25zdCBoYXNXaWR0aCA9ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoRElNRU5TSU9OX1dJRFRIKVxuICAgIHJldHVybiBoYXNXaWR0aCA/IERJTUVOU0lPTl9XSURUSCA6IERJTUVOU0lPTl9IRUlHSFRcbiAgfVxuXG4gIF9nZXRQYXJlbnQoKSB7XG4gICAgbGV0IHBhcmVudFxuXG4gICAgaWYgKFV0aWwuaXNFbGVtZW50KHRoaXMuX2NvbmZpZy5wYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSB0aGlzLl9jb25maWcucGFyZW50XG5cbiAgICAgIC8vIEl0J3MgYSBqUXVlcnkgb2JqZWN0XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZy5wYXJlbnQuanF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwYXJlbnQgPSB0aGlzLl9jb25maWcucGFyZW50WzBdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5fY29uZmlnLnBhcmVudClcbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3RvciA9IGBbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtkYXRhLXBhcmVudD1cIiR7dGhpcy5fY29uZmlnLnBhcmVudH1cIl1gXG4gICAgY29uc3QgY2hpbGRyZW4gPSBbXS5zbGljZS5jYWxsKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlcblxuICAgICQoY2hpbGRyZW4pLmVhY2goKGksIGVsZW1lbnQpID0+IHtcbiAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhcbiAgICAgICAgQ29sbGFwc2UuX2dldFRhcmdldEZyb21FbGVtZW50KGVsZW1lbnQpLFxuICAgICAgICBbZWxlbWVudF1cbiAgICAgIClcbiAgICB9KVxuXG4gICAgcmV0dXJuIHBhcmVudFxuICB9XG5cbiAgX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhlbGVtZW50LCB0cmlnZ2VyQXJyYXkpIHtcbiAgICBjb25zdCBpc09wZW4gPSAkKGVsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfU0hPVylcblxuICAgIGlmICh0cmlnZ2VyQXJyYXkubGVuZ3RoKSB7XG4gICAgICAkKHRyaWdnZXJBcnJheSlcbiAgICAgICAgLnRvZ2dsZUNsYXNzKENMQVNTX05BTUVfQ09MTEFQU0VELCAhaXNPcGVuKVxuICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGlzT3BlbilcbiAgICB9XG4gIH1cblxuICAvLyBTdGF0aWNcblxuICBzdGF0aWMgX2dldFRhcmdldEZyb21FbGVtZW50KGVsZW1lbnQpIHtcbiAgICBjb25zdCBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtZW50KVxuICAgIHJldHVybiBzZWxlY3RvciA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpIDogbnVsbFxuICB9XG5cbiAgc3RhdGljIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCAkZWxlbWVudCA9ICQodGhpcylcbiAgICAgIGxldCBkYXRhID0gJGVsZW1lbnQuZGF0YShEQVRBX0tFWSlcbiAgICAgIGNvbnN0IF9jb25maWcgPSB7XG4gICAgICAgIC4uLkRlZmF1bHQsXG4gICAgICAgIC4uLiRlbGVtZW50LmRhdGEoKSxcbiAgICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9KVxuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEgJiYgX2NvbmZpZy50b2dnbGUgJiYgdHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycgJiYgL3Nob3d8aGlkZS8udGVzdChjb25maWcpKSB7XG4gICAgICAgIF9jb25maWcudG9nZ2xlID0gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgQ29sbGFwc2UodGhpcywgX2NvbmZpZylcbiAgICAgICAgJGVsZW1lbnQuZGF0YShEQVRBX0tFWSwgZGF0YSlcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFbY29uZmlnXSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbiQoZG9jdW1lbnQpLm9uKEVWRU5UX0NMSUNLX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIHByZXZlbnREZWZhdWx0IG9ubHkgZm9yIDxhPiBlbGVtZW50cyAod2hpY2ggY2hhbmdlIHRoZSBVUkwpIG5vdCBpbnNpZGUgdGhlIGNvbGxhcHNpYmxlIGVsZW1lbnRcbiAgaWYgKGV2ZW50LmN1cnJlbnRUYXJnZXQudGFnTmFtZSA9PT0gJ0EnKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICB9XG5cbiAgY29uc3QgJHRyaWdnZXIgPSAkKHRoaXMpXG4gIGNvbnN0IHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KHRoaXMpXG4gIGNvbnN0IHNlbGVjdG9ycyA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpXG5cbiAgJChzZWxlY3RvcnMpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0ICR0YXJnZXQgPSAkKHRoaXMpXG4gICAgY29uc3QgZGF0YSA9ICR0YXJnZXQuZGF0YShEQVRBX0tFWSlcbiAgICBjb25zdCBjb25maWcgPSBkYXRhID8gJ3RvZ2dsZScgOiAkdHJpZ2dlci5kYXRhKClcbiAgICBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJHRhcmdldCwgY29uZmlnKVxuICB9KVxufSlcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGpRdWVyeVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuJC5mbltOQU1FXSA9IENvbGxhcHNlLl9qUXVlcnlJbnRlcmZhY2VcbiQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBDb2xsYXBzZVxuJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUXG4gIHJldHVybiBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlXG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbGxhcHNlXG4iLCIvKiohXG4gKiBAZmlsZU92ZXJ2aWV3IEtpY2thc3MgbGlicmFyeSB0byBjcmVhdGUgYW5kIHBsYWNlIHBvcHBlcnMgbmVhciB0aGVpciByZWZlcmVuY2UgZWxlbWVudHMuXG4gKiBAdmVyc2lvbiAxLjE2LjFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRmVkZXJpY28gWml2b2xvIGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJztcblxudmFyIHRpbWVvdXREdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxvbmdlclRpbWVvdXRCcm93c2VycyA9IFsnRWRnZScsICdUcmlkZW50JywgJ0ZpcmVmb3gnXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb25nZXJUaW1lb3V0QnJvd3NlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoaXNCcm93c2VyICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihsb25nZXJUaW1lb3V0QnJvd3NlcnNbaV0pID49IDApIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn0oKTtcblxuZnVuY3Rpb24gbWljcm90YXNrRGVib3VuY2UoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB3aW5kb3cuUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIGZuKCk7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRhc2tEZWJvdW5jZShmbikge1xuICB2YXIgc2NoZWR1bGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIGZuKCk7XG4gICAgICB9LCB0aW1lb3V0RHVyYXRpb24pO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHN1cHBvcnRzTWljcm9UYXNrcyA9IGlzQnJvd3NlciAmJiB3aW5kb3cuUHJvbWlzZTtcblxuLyoqXG4qIENyZWF0ZSBhIGRlYm91bmNlZCB2ZXJzaW9uIG9mIGEgbWV0aG9kLCB0aGF0J3MgYXN5bmNocm9ub3VzbHkgZGVmZXJyZWRcbiogYnV0IGNhbGxlZCBpbiB0aGUgbWluaW11bSB0aW1lIHBvc3NpYmxlLlxuKlxuKiBAbWV0aG9kXG4qIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiogQGFyZ3VtZW50IHtGdW5jdGlvbn0gZm5cbiogQHJldHVybnMge0Z1bmN0aW9ufVxuKi9cbnZhciBkZWJvdW5jZSA9IHN1cHBvcnRzTWljcm9UYXNrcyA/IG1pY3JvdGFza0RlYm91bmNlIDogdGFza0RlYm91bmNlO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FueX0gZnVuY3Rpb25Ub0NoZWNrIC0gdmFyaWFibGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBhbnN3ZXIgdG86IGlzIGEgZnVuY3Rpb24/XG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuY3Rpb25Ub0NoZWNrKSB7XG4gIHZhciBnZXRUeXBlID0ge307XG4gIHJldHVybiBmdW5jdGlvblRvQ2hlY2sgJiYgZ2V0VHlwZS50b1N0cmluZy5jYWxsKGZ1bmN0aW9uVG9DaGVjaykgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogR2V0IENTUyBjb21wdXRlZCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgdmFyIHdpbmRvdyA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgdmFyIGNzcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICByZXR1cm4gcHJvcGVydHkgPyBjc3NbcHJvcGVydHldIDogY3NzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhcmVudE5vZGUgb3IgdGhlIGhvc3Qgb2YgdGhlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHJldHVybiBlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudC5ob3N0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNjcm9sbGluZyBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHNjcm9sbCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gUmV0dXJuIGJvZHksIGBnZXRTY3JvbGxgIHdpbGwgdGFrZSBjYXJlIHRvIGdldCB0aGUgY29ycmVjdCBgc2Nyb2xsVG9wYCBmcm9tIGl0XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgc3dpdGNoIChlbGVtZW50Lm5vZGVOYW1lKSB7XG4gICAgY2FzZSAnSFRNTCc6XG4gICAgY2FzZSAnQk9EWSc6XG4gICAgICByZXR1cm4gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgIHJldHVybiBlbGVtZW50LmJvZHk7XG4gIH1cblxuICAvLyBGaXJlZm94IHdhbnQgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcblxuICB2YXIgX2dldFN0eWxlQ29tcHV0ZWRQcm9wID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3csXG4gICAgICBvdmVyZmxvd1ggPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WTtcblxuICBpZiAoLyhhdXRvfHNjcm9sbHxvdmVybGF5KS8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVmZXJlbmNlIG5vZGUgb2YgdGhlIHJlZmVyZW5jZSBvYmplY3QsIG9yIHRoZSByZWZlcmVuY2Ugb2JqZWN0IGl0c2VsZi5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IHJlZmVyZW5jZSAtIHRoZSByZWZlcmVuY2UgZWxlbWVudCAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSB7XG4gIHJldHVybiByZWZlcmVuY2UgJiYgcmVmZXJlbmNlLnJlZmVyZW5jZU5vZGUgPyByZWZlcmVuY2UucmVmZXJlbmNlTm9kZSA6IHJlZmVyZW5jZTtcbn1cblxudmFyIGlzSUUxMSA9IGlzQnJvd3NlciAmJiAhISh3aW5kb3cuTVNJbnB1dE1ldGhvZENvbnRleHQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTtcbnZhciBpc0lFMTAgPSBpc0Jyb3dzZXIgJiYgL01TSUUgMTAvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgYnJvd3NlciBpcyBJbnRlcm5ldCBFeHBsb3JlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtOdW1iZXJ9IHZlcnNpb24gdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBpc0lFXG4gKi9cbmZ1bmN0aW9uIGlzSUUodmVyc2lvbikge1xuICBpZiAodmVyc2lvbiA9PT0gMTEpIHtcbiAgICByZXR1cm4gaXNJRTExO1xuICB9XG4gIGlmICh2ZXJzaW9uID09PSAxMCkge1xuICAgIHJldHVybiBpc0lFMTA7XG4gIH1cbiAgcmV0dXJuIGlzSUUxMSB8fCBpc0lFMTA7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb2Zmc2V0IHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gb2Zmc2V0IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgdmFyIG5vT2Zmc2V0UGFyZW50ID0gaXNJRSgxMCkgPyBkb2N1bWVudC5ib2R5IDogbnVsbDtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgb2Zmc2V0UGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQgfHwgbnVsbDtcbiAgLy8gU2tpcCBoaWRkZW4gZWxlbWVudHMgd2hpY2ggZG9uJ3QgaGF2ZSBhbiBvZmZzZXRQYXJlbnRcbiAgd2hpbGUgKG9mZnNldFBhcmVudCA9PT0gbm9PZmZzZXRQYXJlbnQgJiYgZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSAoZWxlbWVudCA9IGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKS5vZmZzZXRQYXJlbnQ7XG4gIH1cblxuICB2YXIgbm9kZU5hbWUgPSBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50Lm5vZGVOYW1lO1xuXG4gIGlmICghbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gLm9mZnNldFBhcmVudCB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBUSCwgVEQgb3IgVEFCTEUgaW4gY2FzZVxuICAvLyBubyBvZmZzZXRQYXJlbnQgaXMgcHJlc2VudCwgSSBoYXRlIHRoaXMgam9iLi4uXG4gIGlmIChbJ1RIJywgJ1REJywgJ1RBQkxFJ10uaW5kZXhPZihvZmZzZXRQYXJlbnQubm9kZU5hbWUpICE9PSAtMSAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkob2Zmc2V0UGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50O1xufVxuXG5mdW5jdGlvbiBpc09mZnNldENvbnRhaW5lcihlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnSFRNTCcgfHwgZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBlbGVtZW50O1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSByb290IG5vZGUgKGRvY3VtZW50LCBzaGFkb3dET00gcm9vdCkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge0VsZW1lbnR9IHJvb3Qgbm9kZVxuICovXG5mdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnZXRSb290KG5vZGUucGFyZW50Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgb2Zmc2V0IHBhcmVudCBjb21tb24gdG8gdGhlIHR3byBwcm92aWRlZCBub2Rlc1xuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MVxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MlxuICogQHJldHVybnMge0VsZW1lbnR9IGNvbW1vbiBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGVsZW1lbnQyKSB7XG4gIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICBpZiAoIWVsZW1lbnQxIHx8ICFlbGVtZW50MS5ub2RlVHlwZSB8fCAhZWxlbWVudDIgfHwgIWVsZW1lbnQyLm5vZGVUeXBlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIEhlcmUgd2UgbWFrZSBzdXJlIHRvIGdpdmUgYXMgXCJzdGFydFwiIHRoZSBlbGVtZW50IHRoYXQgY29tZXMgZmlyc3QgaW4gdGhlIERPTVxuICB2YXIgb3JkZXIgPSBlbGVtZW50MS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50MikgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcbiAgdmFyIHN0YXJ0ID0gb3JkZXIgPyBlbGVtZW50MSA6IGVsZW1lbnQyO1xuICB2YXIgZW5kID0gb3JkZXIgPyBlbGVtZW50MiA6IGVsZW1lbnQxO1xuXG4gIC8vIEdldCBjb21tb24gYW5jZXN0b3IgY29udGFpbmVyXG4gIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIHJhbmdlLnNldFN0YXJ0KHN0YXJ0LCAwKTtcbiAgcmFuZ2Uuc2V0RW5kKGVuZCwgMCk7XG4gIHZhciBjb21tb25BbmNlc3RvckNvbnRhaW5lciA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuXG4gIC8vIEJvdGggbm9kZXMgYXJlIGluc2lkZSAjZG9jdW1lbnRcblxuICBpZiAoZWxlbWVudDEgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyICYmIGVsZW1lbnQyICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciB8fCBzdGFydC5jb250YWlucyhlbmQpKSB7XG4gICAgaWYgKGlzT2Zmc2V0Q29udGFpbmVyKGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgICAgcmV0dXJuIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQoY29tbW9uQW5jZXN0b3JDb250YWluZXIpO1xuICB9XG5cbiAgLy8gb25lIG9mIHRoZSBub2RlcyBpcyBpbnNpZGUgc2hhZG93RE9NLCBmaW5kIHdoaWNoIG9uZVxuICB2YXIgZWxlbWVudDFyb290ID0gZ2V0Um9vdChlbGVtZW50MSk7XG4gIGlmIChlbGVtZW50MXJvb3QuaG9zdCkge1xuICAgIHJldHVybiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxcm9vdC5ob3N0LCBlbGVtZW50Mik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGdldFJvb3QoZWxlbWVudDIpLmhvc3QpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50IGluIHRoZSBnaXZlbiBzaWRlICh0b3AgYW5kIGxlZnQpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzaWRlIGB0b3BgIG9yIGBsZWZ0YFxuICogQHJldHVybnMge251bWJlcn0gYW1vdW50IG9mIHNjcm9sbGVkIHBpeGVsc1xuICovXG5mdW5jdGlvbiBnZXRTY3JvbGwoZWxlbWVudCkge1xuICB2YXIgc2lkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3RvcCc7XG5cbiAgdmFyIHVwcGVyU2lkZSA9IHNpZGUgPT09ICd0b3AnID8gJ3Njcm9sbFRvcCcgOiAnc2Nyb2xsTGVmdCc7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgc2Nyb2xsaW5nRWxlbWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGh0bWw7XG4gICAgcmV0dXJuIHNjcm9sbGluZ0VsZW1lbnRbdXBwZXJTaWRlXTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50W3VwcGVyU2lkZV07XG59XG5cbi8qXG4gKiBTdW0gb3Igc3VidHJhY3QgdGhlIGVsZW1lbnQgc2Nyb2xsIHZhbHVlcyAobGVmdCBhbmQgdG9wKSBmcm9tIGEgZ2l2ZW4gcmVjdCBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IC0gUmVjdCBvYmplY3QgeW91IHdhbnQgdG8gY2hhbmdlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgZnJvbSB0aGUgZnVuY3Rpb24gcmVhZHMgdGhlIHNjcm9sbCB2YWx1ZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3VidHJhY3QgLSBzZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBzdWJ0cmFjdCB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHJldHVybiB7T2JqZWN0fSByZWN0IC0gVGhlIG1vZGlmaWVyIHJlY3Qgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVTY3JvbGwocmVjdCwgZWxlbWVudCkge1xuICB2YXIgc3VidHJhY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICB2YXIgbW9kaWZpZXIgPSBzdWJ0cmFjdCA/IC0xIDogMTtcbiAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbi8qXG4gKiBIZWxwZXIgdG8gZGV0ZWN0IGJvcmRlcnMgb2YgYSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xuICogUmVzdWx0IG9mIGBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHlgIG9uIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gYXhpcyAtIGB4YCBvciBgeWBcbiAqIEByZXR1cm4ge251bWJlcn0gYm9yZGVycyAtIFRoZSBib3JkZXJzIHNpemUgb2YgdGhlIGdpdmVuIGF4aXNcbiAqL1xuXG5mdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsIGF4aXMpIHtcbiAgdmFyIHNpZGVBID0gYXhpcyA9PT0gJ3gnID8gJ0xlZnQnIDogJ1RvcCc7XG4gIHZhciBzaWRlQiA9IHNpZGVBID09PSAnTGVmdCcgPyAnUmlnaHQnIDogJ0JvdHRvbSc7XG5cbiAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGVzWydib3JkZXInICsgc2lkZUEgKyAnV2lkdGgnXSkgKyBwYXJzZUZsb2F0KHN0eWxlc1snYm9yZGVyJyArIHNpZGVCICsgJ1dpZHRoJ10pO1xufVxuXG5mdW5jdGlvbiBnZXRTaXplKGF4aXMsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KGJvZHlbJ29mZnNldCcgKyBheGlzXSwgYm9keVsnc2Nyb2xsJyArIGF4aXNdLCBodG1sWydjbGllbnQnICsgYXhpc10sIGh0bWxbJ29mZnNldCcgKyBheGlzXSwgaHRtbFsnc2Nyb2xsJyArIGF4aXNdLCBpc0lFKDEwKSA/IHBhcnNlSW50KGh0bWxbJ29mZnNldCcgKyBheGlzXSkgKyBwYXJzZUludChjb21wdXRlZFN0eWxlWydtYXJnaW4nICsgKGF4aXMgPT09ICdIZWlnaHQnID8gJ1RvcCcgOiAnTGVmdCcpXSkgKyBwYXJzZUludChjb21wdXRlZFN0eWxlWydtYXJnaW4nICsgKGF4aXMgPT09ICdIZWlnaHQnID8gJ0JvdHRvbScgOiAnUmlnaHQnKV0pIDogMCk7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1NpemVzKGRvY3VtZW50KSB7XG4gIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgdmFyIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBjb21wdXRlZFN0eWxlID0gaXNJRSgxMCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShodG1sKTtcblxuICByZXR1cm4ge1xuICAgIGhlaWdodDogZ2V0U2l6ZSgnSGVpZ2h0JywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSksXG4gICAgd2lkdGg6IGdldFNpemUoJ1dpZHRoJywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSlcbiAgfTtcbn1cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG5cblxuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEdpdmVuIGVsZW1lbnQgb2Zmc2V0cywgZ2VuZXJhdGUgYW4gb3V0cHV0IHNpbWlsYXIgdG8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gb2Zmc2V0c1xuICogQHJldHVybnMge09iamVjdH0gQ2xpZW50UmVjdCBsaWtlIG91dHB1dFxuICovXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0KG9mZnNldHMpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBvZmZzZXRzLCB7XG4gICAgcmlnaHQ6IG9mZnNldHMubGVmdCArIG9mZnNldHMud2lkdGgsXG4gICAgYm90dG9tOiBvZmZzZXRzLnRvcCArIG9mZnNldHMuaGVpZ2h0XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCBib3VuZGluZyBjbGllbnQgcmVjdCBvZiBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtPYmplY3R9IGNsaWVudCByZWN0XG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0ge307XG5cbiAgLy8gSUUxMCAxMCBGSVg6IFBsZWFzZSwgZG9uJ3QgYXNrLCB0aGUgZWxlbWVudCBpc24ndFxuICAvLyBjb25zaWRlcmVkIGluIERPTSBpbiBzb21lIGNpcmN1bXN0YW5jZXMuLi5cbiAgLy8gVGhpcyBpc24ndCByZXByb2R1Y2libGUgaW4gSUUxMCBjb21wYXRpYmlsaXR5IG1vZGUgb2YgSUUxMVxuICB0cnkge1xuICAgIGlmIChpc0lFKDEwKSkge1xuICAgICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICd0b3AnKTtcbiAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gICAgICByZWN0LnRvcCArPSBzY3JvbGxUb3A7XG4gICAgICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdDtcbiAgICAgIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSB7XG4gICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgIHRvcDogcmVjdC50b3AsXG4gICAgd2lkdGg6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gIH07XG5cbiAgLy8gc3VidHJhY3Qgc2Nyb2xsYmFyIHNpemUgZnJvbSBzaXplc1xuICB2YXIgc2l6ZXMgPSBlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcgPyBnZXRXaW5kb3dTaXplcyhlbGVtZW50Lm93bmVyRG9jdW1lbnQpIDoge307XG4gIHZhciB3aWR0aCA9IHNpemVzLndpZHRoIHx8IGVsZW1lbnQuY2xpZW50V2lkdGggfHwgcmVzdWx0LndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gc2l6ZXMuaGVpZ2h0IHx8IGVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IHJlc3VsdC5oZWlnaHQ7XG5cbiAgdmFyIGhvcml6U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRXaWR0aCAtIHdpZHRoO1xuICB2YXIgdmVydFNjcm9sbGJhciA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IC0gaGVpZ2h0O1xuXG4gIC8vIGlmIGFuIGh5cG90aGV0aWNhbCBzY3JvbGxiYXIgaXMgZGV0ZWN0ZWQsIHdlIG11c3QgYmUgc3VyZSBpdCdzIG5vdCBhIGBib3JkZXJgXG4gIC8vIHdlIG1ha2UgdGhpcyBjaGVjayBjb25kaXRpb25hbCBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICBpZiAoaG9yaXpTY3JvbGxiYXIgfHwgdmVydFNjcm9sbGJhcikge1xuICAgIHZhciBzdHlsZXMgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCk7XG4gICAgaG9yaXpTY3JvbGxiYXIgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAneCcpO1xuICAgIHZlcnRTY3JvbGxiYXIgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAneScpO1xuXG4gICAgcmVzdWx0LndpZHRoIC09IGhvcml6U2Nyb2xsYmFyO1xuICAgIHJlc3VsdC5oZWlnaHQgLT0gdmVydFNjcm9sbGJhcjtcbiAgfVxuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShjaGlsZHJlbiwgcGFyZW50KSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICB2YXIgaXNJRTEwID0gaXNJRSgxMCk7XG4gIHZhciBpc0hUTUwgPSBwYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJztcbiAgdmFyIGNoaWxkcmVuUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChjaGlsZHJlbik7XG4gIHZhciBwYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHBhcmVudCk7XG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoY2hpbGRyZW4pO1xuXG4gIHZhciBzdHlsZXMgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkocGFyZW50KTtcbiAgdmFyIGJvcmRlclRvcFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyVG9wV2lkdGgpO1xuICB2YXIgYm9yZGVyTGVmdFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoKTtcblxuICAvLyBJbiBjYXNlcyB3aGVyZSB0aGUgcGFyZW50IGlzIGZpeGVkLCB3ZSBtdXN0IGlnbm9yZSBuZWdhdGl2ZSBzY3JvbGwgaW4gb2Zmc2V0IGNhbGNcbiAgaWYgKGZpeGVkUG9zaXRpb24gJiYgaXNIVE1MKSB7XG4gICAgcGFyZW50UmVjdC50b3AgPSBNYXRoLm1heChwYXJlbnRSZWN0LnRvcCwgMCk7XG4gICAgcGFyZW50UmVjdC5sZWZ0ID0gTWF0aC5tYXgocGFyZW50UmVjdC5sZWZ0LCAwKTtcbiAgfVxuICB2YXIgb2Zmc2V0cyA9IGdldENsaWVudFJlY3Qoe1xuICAgIHRvcDogY2hpbGRyZW5SZWN0LnRvcCAtIHBhcmVudFJlY3QudG9wIC0gYm9yZGVyVG9wV2lkdGgsXG4gICAgbGVmdDogY2hpbGRyZW5SZWN0LmxlZnQgLSBwYXJlbnRSZWN0LmxlZnQgLSBib3JkZXJMZWZ0V2lkdGgsXG4gICAgd2lkdGg6IGNoaWxkcmVuUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IGNoaWxkcmVuUmVjdC5oZWlnaHRcbiAgfSk7XG4gIG9mZnNldHMubWFyZ2luVG9wID0gMDtcbiAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gMDtcblxuICAvLyBTdWJ0cmFjdCBtYXJnaW5zIG9mIGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGl0J3MgYmVpbmcgdXNlZCBhcyBwYXJlbnRcbiAgLy8gd2UgZG8gdGhpcyBvbmx5IG9uIEhUTUwgYmVjYXVzZSBpdCdzIHRoZSBvbmx5IGVsZW1lbnQgdGhhdCBiZWhhdmVzXG4gIC8vIGRpZmZlcmVudGx5IHdoZW4gbWFyZ2lucyBhcmUgYXBwbGllZCB0byBpdC4gVGhlIG1hcmdpbnMgYXJlIGluY2x1ZGVkIGluXG4gIC8vIHRoZSBib3ggb2YgdGhlIGRvY3VtZW50RWxlbWVudCwgaW4gdGhlIG90aGVyIGNhc2VzIG5vdC5cbiAgaWYgKCFpc0lFMTAgJiYgaXNIVE1MKSB7XG4gICAgdmFyIG1hcmdpblRvcCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCk7XG4gICAgdmFyIG1hcmdpbkxlZnQgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5MZWZ0KTtcblxuICAgIG9mZnNldHMudG9wIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMuYm90dG9tIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubGVmdCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuICAgIG9mZnNldHMucmlnaHQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcblxuICAgIC8vIEF0dGFjaCBtYXJnaW5Ub3AgYW5kIG1hcmdpbkxlZnQgYmVjYXVzZSBpbiBzb21lIGNpcmN1bXN0YW5jZXMgd2UgbWF5IG5lZWQgdGhlbVxuICAgIG9mZnNldHMubWFyZ2luVG9wID0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubWFyZ2luTGVmdCA9IG1hcmdpbkxlZnQ7XG4gIH1cblxuICBpZiAoaXNJRTEwICYmICFmaXhlZFBvc2l0aW9uID8gcGFyZW50LmNvbnRhaW5zKHNjcm9sbFBhcmVudCkgOiBwYXJlbnQgPT09IHNjcm9sbFBhcmVudCAmJiBzY3JvbGxQYXJlbnQubm9kZU5hbWUgIT09ICdCT0RZJykge1xuICAgIG9mZnNldHMgPSBpbmNsdWRlU2Nyb2xsKG9mZnNldHMsIHBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKGVsZW1lbnQpIHtcbiAgdmFyIGV4Y2x1ZGVTY3JvbGwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIHJlbGF0aXZlT2Zmc2V0ID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGVsZW1lbnQsIGh0bWwpO1xuICB2YXIgd2lkdGggPSBNYXRoLm1heChodG1sLmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgdmFyIGhlaWdodCA9IE1hdGgubWF4KGh0bWwuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG5cbiAgdmFyIHNjcm9sbFRvcCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwpIDogMDtcbiAgdmFyIHNjcm9sbExlZnQgPSAhZXhjbHVkZVNjcm9sbCA/IGdldFNjcm9sbChodG1sLCAnbGVmdCcpIDogMDtcblxuICB2YXIgb2Zmc2V0ID0ge1xuICAgIHRvcDogc2Nyb2xsVG9wIC0gcmVsYXRpdmVPZmZzZXQudG9wICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luVG9wLFxuICAgIGxlZnQ6IHNjcm9sbExlZnQgLSByZWxhdGl2ZU9mZnNldC5sZWZ0ICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luTGVmdCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChvZmZzZXQpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGZpeGVkIG9yIGlzIGluc2lkZSBhIGZpeGVkIHBhcmVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGN1c3RvbUNvbnRhaW5lclxuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0byBcImlzRml4ZWQ/XCJcbiAqL1xuZnVuY3Rpb24gaXNGaXhlZChlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCAncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpeGVkKHBhcmVudE5vZGUpO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBwYXJlbnQgb2YgYW4gZWxlbWVudCB0aGF0IGhhcyBhIHRyYW5zZm9ybWVkIHByb3BlcnR5IGRlZmluZWRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IGZpcnN0IHRyYW5zZm9ybWVkIHBhcmVudCBvciBkb2N1bWVudEVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5wYXJlbnRFbGVtZW50IHx8IGlzSUUoKSkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cbiAgdmFyIGVsID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICB3aGlsZSAoZWwgJiYgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsLCAndHJhbnNmb3JtJykgPT09ICdub25lJykge1xuICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWwgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xufVxuXG4vKipcbiAqIENvbXB1dGVkIHRoZSBib3VuZGFyaWVzIGxpbWl0cyBhbmQgcmV0dXJuIHRoZW1cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZ1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQgLSBFbGVtZW50IHVzZWQgdG8gZGVmaW5lIHRoZSBib3VuZGFyaWVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZpeGVkUG9zaXRpb24gLSBJcyBpbiBmaXhlZCBwb3NpdGlvbiBtb2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgYm91bmRhcmllc1xuICovXG5mdW5jdGlvbiBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG5cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcblxuICB2YXIgYm91bmRhcmllcyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSk7XG5cbiAgLy8gSGFuZGxlIHZpZXdwb3J0IGNhc2VcbiAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAndmlld3BvcnQnKSB7XG4gICAgYm91bmRhcmllcyA9IGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIEhhbmRsZSBvdGhlciBjYXNlcyBiYXNlZCBvbiBET00gZWxlbWVudCB1c2VkIGFzIGJvdW5kYXJpZXNcbiAgICB2YXIgYm91bmRhcmllc05vZGUgPSB2b2lkIDA7XG4gICAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnc2Nyb2xsUGFyZW50Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShyZWZlcmVuY2UpKTtcbiAgICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd3aW5kb3cnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IHBvcHBlci5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBib3VuZGFyaWVzRWxlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0cyA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShib3VuZGFyaWVzTm9kZSwgb2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcblxuICAgIC8vIEluIGNhc2Ugb2YgSFRNTCwgd2UgbmVlZCBhIGRpZmZlcmVudCBjb21wdXRhdGlvblxuICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0hUTUwnICYmICFpc0ZpeGVkKG9mZnNldFBhcmVudCkpIHtcbiAgICAgIHZhciBfZ2V0V2luZG93U2l6ZXMgPSBnZXRXaW5kb3dTaXplcyhwb3BwZXIub3duZXJEb2N1bWVudCksXG4gICAgICAgICAgaGVpZ2h0ID0gX2dldFdpbmRvd1NpemVzLmhlaWdodCxcbiAgICAgICAgICB3aWR0aCA9IF9nZXRXaW5kb3dTaXplcy53aWR0aDtcblxuICAgICAgYm91bmRhcmllcy50b3AgKz0gb2Zmc2V0cy50b3AgLSBvZmZzZXRzLm1hcmdpblRvcDtcbiAgICAgIGJvdW5kYXJpZXMuYm90dG9tID0gaGVpZ2h0ICsgb2Zmc2V0cy50b3A7XG4gICAgICBib3VuZGFyaWVzLmxlZnQgKz0gb2Zmc2V0cy5sZWZ0IC0gb2Zmc2V0cy5tYXJnaW5MZWZ0O1xuICAgICAgYm91bmRhcmllcy5yaWdodCA9IHdpZHRoICsgb2Zmc2V0cy5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3IgYWxsIHRoZSBvdGhlciBET00gZWxlbWVudHMsIHRoaXMgb25lIGlzIGdvb2RcbiAgICAgIGJvdW5kYXJpZXMgPSBvZmZzZXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBwYWRkaW5nc1xuICBwYWRkaW5nID0gcGFkZGluZyB8fCAwO1xuICB2YXIgaXNQYWRkaW5nTnVtYmVyID0gdHlwZW9mIHBhZGRpbmcgPT09ICdudW1iZXInO1xuICBib3VuZGFyaWVzLmxlZnQgKz0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcubGVmdCB8fCAwO1xuICBib3VuZGFyaWVzLnRvcCArPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy50b3AgfHwgMDtcbiAgYm91bmRhcmllcy5yaWdodCAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5yaWdodCB8fCAwO1xuICBib3VuZGFyaWVzLmJvdHRvbSAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5ib3R0b20gfHwgMDtcblxuICByZXR1cm4gYm91bmRhcmllcztcbn1cblxuZnVuY3Rpb24gZ2V0QXJlYShfcmVmKSB7XG4gIHZhciB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodDtcblxuICByZXR1cm4gd2lkdGggKiBoZWlnaHQ7XG59XG5cbi8qKlxuICogVXRpbGl0eSB1c2VkIHRvIHRyYW5zZm9ybSB0aGUgYGF1dG9gIHBsYWNlbWVudCB0byB0aGUgcGxhY2VtZW50IHdpdGggbW9yZVxuICogYXZhaWxhYmxlIHNwYWNlLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQocGxhY2VtZW50LCByZWZSZWN0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDA7XG5cbiAgaWYgKHBsYWNlbWVudC5pbmRleE9mKCdhdXRvJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHBsYWNlbWVudDtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhwb3BwZXIsIHJlZmVyZW5jZSwgcGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpO1xuXG4gIHZhciByZWN0cyA9IHtcbiAgICB0b3A6IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWZSZWN0LnRvcCAtIGJvdW5kYXJpZXMudG9wXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMucmlnaHQgLSByZWZSZWN0LnJpZ2h0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH0sXG4gICAgYm90dG9tOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5ib3R0b20gLSByZWZSZWN0LmJvdHRvbVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgd2lkdGg6IHJlZlJlY3QubGVmdCAtIGJvdW5kYXJpZXMubGVmdCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5oZWlnaHRcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNvcnRlZEFyZWFzID0gT2JqZWN0LmtleXMocmVjdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleToga2V5XG4gICAgfSwgcmVjdHNba2V5XSwge1xuICAgICAgYXJlYTogZ2V0QXJlYShyZWN0c1trZXldKVxuICAgIH0pO1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuYXJlYSAtIGEuYXJlYTtcbiAgfSk7XG5cbiAgdmFyIGZpbHRlcmVkQXJlYXMgPSBzb3J0ZWRBcmVhcy5maWx0ZXIoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIHdpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodDtcbiAgICByZXR1cm4gd2lkdGggPj0gcG9wcGVyLmNsaWVudFdpZHRoICYmIGhlaWdodCA+PSBwb3BwZXIuY2xpZW50SGVpZ2h0O1xuICB9KTtcblxuICB2YXIgY29tcHV0ZWRQbGFjZW1lbnQgPSBmaWx0ZXJlZEFyZWFzLmxlbmd0aCA+IDAgPyBmaWx0ZXJlZEFyZWFzWzBdLmtleSA6IHNvcnRlZEFyZWFzWzBdLmtleTtcblxuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgcmV0dXJuIGNvbXB1dGVkUGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/ICctJyArIHZhcmlhdGlvbiA6ICcnKTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gcmVmZXJlbmNlIC0gdGhlIHJlZmVyZW5jZSBlbGVtZW50ICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7RWxlbWVudH0gZml4ZWRQb3NpdGlvbiAtIGlzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlKSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHZhciBjb21tb25PZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSk7XG4gIHJldHVybiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUocmVmZXJlbmNlLCBjb21tb25PZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3V0ZXIgc2l6ZXMgb2YgdGhlIGdpdmVuIGVsZW1lbnQgKG9mZnNldCBzaXplICsgbWFyZ2lucylcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgd2lkdGggYW5kIGhlaWdodCBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVyU2l6ZXMoZWxlbWVudCkge1xuICB2YXIgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHZhciB4ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wIHx8IDApICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luQm90dG9tIHx8IDApO1xuICB2YXIgeSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQgfHwgMCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5SaWdodCB8fCAwKTtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCArIHksXG4gICAgaGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodCArIHhcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudFxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgdmFyIGhhc2ggPSB7IGxlZnQ6ICdyaWdodCcsIHJpZ2h0OiAnbGVmdCcsIGJvdHRvbTogJ3RvcCcsIHRvcDogJ2JvdHRvbScgfTtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIC0gQ1NTIHBvc2l0aW9uIHRoZSBQb3BwZXIgd2lsbCBnZXQgYXBwbGllZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0cyAtIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhY2VtZW50IC0gb25lIG9mIHRoZSB2YWxpZCBwbGFjZW1lbnQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gcG9wcGVyT2Zmc2V0cyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFBvcHBlck9mZnNldHMocG9wcGVyLCByZWZlcmVuY2VPZmZzZXRzLCBwbGFjZW1lbnQpIHtcbiAgcGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgLy8gR2V0IHBvcHBlciBub2RlIHNpemVzXG4gIHZhciBwb3BwZXJSZWN0ID0gZ2V0T3V0ZXJTaXplcyhwb3BwZXIpO1xuXG4gIC8vIEFkZCBwb3NpdGlvbiwgd2lkdGggYW5kIGhlaWdodCB0byBvdXIgb2Zmc2V0cyBvYmplY3RcbiAgdmFyIHBvcHBlck9mZnNldHMgPSB7XG4gICAgd2lkdGg6IHBvcHBlclJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBwb3BwZXJSZWN0LmhlaWdodFxuICB9O1xuXG4gIC8vIGRlcGVuZGluZyBieSB0aGUgcG9wcGVyIHBsYWNlbWVudCB3ZSBoYXZlIHRvIGNvbXB1dGUgaXRzIG9mZnNldHMgc2xpZ2h0bHkgZGlmZmVyZW50bHlcbiAgdmFyIGlzSG9yaXogPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgbWFpblNpZGUgPSBpc0hvcml6ID8gJ3RvcCcgOiAnbGVmdCc7XG4gIHZhciBzZWNvbmRhcnlTaWRlID0gaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICB2YXIgc2Vjb25kYXJ5TWVhc3VyZW1lbnQgPSAhaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBwb3BwZXJPZmZzZXRzW21haW5TaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbbWFpblNpZGVdICsgcmVmZXJlbmNlT2Zmc2V0c1ttZWFzdXJlbWVudF0gLyAyIC0gcG9wcGVyUmVjdFttZWFzdXJlbWVudF0gLyAyO1xuICBpZiAocGxhY2VtZW50ID09PSBzZWNvbmRhcnlTaWRlKSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gLSBwb3BwZXJSZWN0W3NlY29uZGFyeU1lYXN1cmVtZW50XTtcbiAgfSBlbHNlIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tnZXRPcHBvc2l0ZVBsYWNlbWVudChzZWNvbmRhcnlTaWRlKV07XG4gIH1cblxuICByZXR1cm4gcG9wcGVyT2Zmc2V0cztcbn1cblxuLyoqXG4gKiBNaW1pY3MgdGhlIGBmaW5kYCBtZXRob2Qgb2YgQXJyYXlcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZChhcnIsIGNoZWNrKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gICAgcmV0dXJuIGFyci5maW5kKGNoZWNrKTtcbiAgfVxuXG4gIC8vIHVzZSBgZmlsdGVyYCB0byBvYnRhaW4gdGhlIHNhbWUgYmVoYXZpb3Igb2YgYGZpbmRgXG4gIHJldHVybiBhcnIuZmlsdGVyKGNoZWNrKVswXTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBtYXRjaGluZyBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFyciwgcHJvcCwgdmFsdWUpIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kSW5kZXggaWYgc3VwcG9ydGVkXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSB7XG4gICAgcmV0dXJuIGFyci5maW5kSW5kZXgoZnVuY3Rpb24gKGN1cikge1xuICAgICAgcmV0dXJuIGN1cltwcm9wXSA9PT0gdmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICAvLyB1c2UgYGZpbmRgICsgYGluZGV4T2ZgIGlmIGBmaW5kSW5kZXhgIGlzbid0IHN1cHBvcnRlZFxuICB2YXIgbWF0Y2ggPSBmaW5kKGFyciwgZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmpbcHJvcF0gPT09IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIGFyci5pbmRleE9mKG1hdGNoKTtcbn1cblxuLyoqXG4gKiBMb29wIHRyb3VnaCB0aGUgbGlzdCBvZiBtb2RpZmllcnMgYW5kIHJ1biB0aGVtIGluIG9yZGVyLFxuICogZWFjaCBvZiB0aGVtIHdpbGwgdGhlbiBlZGl0IHRoZSBkYXRhIG9iamVjdC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5kcyAtIE9wdGlvbmFsIG1vZGlmaWVyIG5hbWUgdXNlZCBhcyBzdG9wcGVyXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH1cbiAqL1xuZnVuY3Rpb24gcnVuTW9kaWZpZXJzKG1vZGlmaWVycywgZGF0YSwgZW5kcykge1xuICB2YXIgbW9kaWZpZXJzVG9SdW4gPSBlbmRzID09PSB1bmRlZmluZWQgPyBtb2RpZmllcnMgOiBtb2RpZmllcnMuc2xpY2UoMCwgZmluZEluZGV4KG1vZGlmaWVycywgJ25hbWUnLCBlbmRzKSk7XG5cbiAgbW9kaWZpZXJzVG9SdW4uZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAobW9kaWZpZXJbJ2Z1bmN0aW9uJ10pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgICBjb25zb2xlLndhcm4oJ2Btb2RpZmllci5mdW5jdGlvbmAgaXMgZGVwcmVjYXRlZCwgdXNlIGBtb2RpZmllci5mbmAhJyk7XG4gICAgfVxuICAgIHZhciBmbiA9IG1vZGlmaWVyWydmdW5jdGlvbiddIHx8IG1vZGlmaWVyLmZuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIGlmIChtb2RpZmllci5lbmFibGVkICYmIGlzRnVuY3Rpb24oZm4pKSB7XG4gICAgICAvLyBBZGQgcHJvcGVydGllcyB0byBvZmZzZXRzIHRvIG1ha2UgdGhlbSBhIGNvbXBsZXRlIGNsaWVudFJlY3Qgb2JqZWN0XG4gICAgICAvLyB3ZSBkbyB0aGlzIGJlZm9yZSBlYWNoIG1vZGlmaWVyIHRvIG1ha2Ugc3VyZSB0aGUgcHJldmlvdXMgb25lIGRvZXNuJ3RcbiAgICAgIC8vIG1lc3Mgd2l0aCB0aGVzZSB2YWx1ZXNcbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuICAgICAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSk7XG5cbiAgICAgIGRhdGEgPSBmbihkYXRhLCBtb2RpZmllcik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyLCBjb21wdXRpbmcgdGhlIG5ldyBvZmZzZXRzIGFuZCBhcHBseWluZ1xuICogdGhlIG5ldyBzdHlsZS48YnIgLz5cbiAqIFByZWZlciBgc2NoZWR1bGVVcGRhdGVgIG92ZXIgYHVwZGF0ZWAgYmVjYXVzZSBvZiBwZXJmb3JtYW5jZSByZWFzb25zLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiB1cGRhdGUoKSB7XG4gIC8vIGlmIHBvcHBlciBpcyBkZXN0cm95ZWQsIGRvbid0IHBlcmZvcm0gYW55IGZ1cnRoZXIgdXBkYXRlXG4gIGlmICh0aGlzLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRhdGEgPSB7XG4gICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgc3R5bGVzOiB7fSxcbiAgICBhcnJvd1N0eWxlczoge30sXG4gICAgYXR0cmlidXRlczoge30sXG4gICAgZmxpcHBlZDogZmFsc2UsXG4gICAgb2Zmc2V0czoge31cbiAgfTtcblxuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldFJlZmVyZW5jZU9mZnNldHModGhpcy5zdGF0ZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCk7XG5cbiAgLy8gY29tcHV0ZSBhdXRvIHBsYWNlbWVudCwgc3RvcmUgcGxhY2VtZW50IGluc2lkZSB0aGUgZGF0YSBvYmplY3QsXG4gIC8vIG1vZGlmaWVycyB3aWxsIGJlIGFibGUgdG8gZWRpdCBgcGxhY2VtZW50YCBpZiBuZWVkZWRcbiAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gIGRhdGEucGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQodGhpcy5vcHRpb25zLnBsYWNlbWVudCwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICAvLyBzdG9yZSB0aGUgY29tcHV0ZWQgcGxhY2VtZW50IGluc2lkZSBgb3JpZ2luYWxQbGFjZW1lbnRgXG4gIGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcblxuICBkYXRhLnBvc2l0aW9uRml4ZWQgPSB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZDtcblxuICAvLyBjb21wdXRlIHRoZSBwb3BwZXIgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0UG9wcGVyT2Zmc2V0cyh0aGlzLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpO1xuXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIucG9zaXRpb24gPSB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnO1xuXG4gIC8vIHJ1biB0aGUgbW9kaWZpZXJzXG4gIGRhdGEgPSBydW5Nb2RpZmllcnModGhpcy5tb2RpZmllcnMsIGRhdGEpO1xuXG4gIC8vIHRoZSBmaXJzdCBgdXBkYXRlYCB3aWxsIGNhbGwgYG9uQ3JlYXRlYCBjYWxsYmFja1xuICAvLyB0aGUgb3RoZXIgb25lcyB3aWxsIGNhbGwgYG9uVXBkYXRlYCBjYWxsYmFja1xuICBpZiAoIXRoaXMuc3RhdGUuaXNDcmVhdGVkKSB7XG4gICAgdGhpcy5zdGF0ZS5pc0NyZWF0ZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucy5vbkNyZWF0ZShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMub25VcGRhdGUoZGF0YSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBpcyBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJFbmFibGVkKG1vZGlmaWVycywgbW9kaWZpZXJOYW1lKSB7XG4gIHJldHVybiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICBlbmFibGVkID0gX3JlZi5lbmFibGVkO1xuICAgIHJldHVybiBlbmFibGVkICYmIG5hbWUgPT09IG1vZGlmaWVyTmFtZTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcmVmaXhlZCBzdXBwb3J0ZWQgcHJvcGVydHkgbmFtZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5IChjYW1lbENhc2UpXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBwcmVmaXhlZCBwcm9wZXJ0eSAoY2FtZWxDYXNlIG9yIFBhc2NhbENhc2UsIGRlcGVuZGluZyBvbiB0aGUgdmVuZG9yIHByZWZpeClcbiAqL1xuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKHByb3BlcnR5KSB7XG4gIHZhciBwcmVmaXhlcyA9IFtmYWxzZSwgJ21zJywgJ1dlYmtpdCcsICdNb3onLCAnTyddO1xuICB2YXIgdXBwZXJQcm9wID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByZWZpeCA9IHByZWZpeGVzW2ldO1xuICAgIHZhciB0b0NoZWNrID0gcHJlZml4ID8gJycgKyBwcmVmaXggKyB1cHBlclByb3AgOiBwcm9wZXJ0eTtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50LmJvZHkuc3R5bGVbdG9DaGVja10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdG9DaGVjaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIHBvcHBlci5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgdGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgLy8gdG91Y2ggRE9NIG9ubHkgaWYgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGlzIGVuYWJsZWRcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKHRoaXMubW9kaWZpZXJzLCAnYXBwbHlTdHlsZScpKSB7XG4gICAgdGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnBvc2l0aW9uID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUudG9wID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUubGVmdCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlW2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyldID0gJyc7XG4gIH1cblxuICB0aGlzLmRpc2FibGVFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIHJlbW92ZSB0aGUgcG9wcGVyIGlmIHVzZXIgZXhwbGljaXRseSBhc2tlZCBmb3IgdGhlIGRlbGV0aW9uIG9uIGRlc3Ryb3lcbiAgLy8gZG8gbm90IHVzZSBgcmVtb3ZlYCBiZWNhdXNlIElFMTEgZG9lc24ndCBzdXBwb3J0IGl0XG4gIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlT25EZXN0cm95KSB7XG4gICAgdGhpcy5wb3BwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHBlcik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogR2V0IHRoZSB3aW5kb3cgYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtXaW5kb3d9XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyhlbGVtZW50KSB7XG4gIHZhciBvd25lckRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICByZXR1cm4gb3duZXJEb2N1bWVudCA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiB3aW5kb3c7XG59XG5cbmZ1bmN0aW9uIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxQYXJlbnQsIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cykge1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50Lm5vZGVOYW1lID09PSAnQk9EWSc7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBzY3JvbGxQYXJlbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHNjcm9sbFBhcmVudDtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgaWYgKCFpc0JvZHkpIHtcbiAgICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoZ2V0U2Nyb2xsUGFyZW50KHRhcmdldC5wYXJlbnROb2RlKSwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKTtcbiAgfVxuICBzY3JvbGxQYXJlbnRzLnB1c2godGFyZ2V0KTtcbn1cblxuLyoqXG4gKiBTZXR1cCBuZWVkZWQgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldHVwRXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBvcHRpb25zLCBzdGF0ZSwgdXBkYXRlQm91bmQpIHtcbiAgLy8gUmVzaXplIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvd1xuICBzdGF0ZS51cGRhdGVCb3VuZCA9IHVwZGF0ZUJvdW5kO1xuICBnZXRXaW5kb3cocmVmZXJlbmNlKS5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gIC8vIFNjcm9sbCBldmVudCBsaXN0ZW5lciBvbiBzY3JvbGwgcGFyZW50c1xuICB2YXIgc2Nyb2xsRWxlbWVudCA9IGdldFNjcm9sbFBhcmVudChyZWZlcmVuY2UpO1xuICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoc2Nyb2xsRWxlbWVudCwgJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kLCBzdGF0ZS5zY3JvbGxQYXJlbnRzKTtcbiAgc3RhdGUuc2Nyb2xsRWxlbWVudCA9IHNjcm9sbEVsZW1lbnQ7XG4gIHN0YXRlLmV2ZW50c0VuYWJsZWQgPSB0cnVlO1xuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIGFkZCByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgc3RhcnQgcmVjYWxjdWxhdGluZ1xuICogcG9zaXRpb24gb2YgdGhlIHBvcHBlciBlbGVtZW50IHdoZW4gdGhleSBhcmUgdHJpZ2dlcmVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKCF0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICB0aGlzLnN0YXRlID0gc2V0dXBFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLCB0aGlzLnN0YXRlLCB0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBzdGF0ZSkge1xuICAvLyBSZW1vdmUgcmVzaXplIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvd1xuICBnZXRXaW5kb3cocmVmZXJlbmNlKS5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG5cbiAgLy8gUmVtb3ZlIHNjcm9sbCBldmVudCBsaXN0ZW5lciBvbiBzY3JvbGwgcGFyZW50c1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG4gIH0pO1xuXG4gIC8vIFJlc2V0IHN0YXRlXG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gbnVsbDtcbiAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IFtdO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGZhbHNlO1xuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogSXQgd2lsbCByZW1vdmUgcmVzaXplL3Njcm9sbCBldmVudHMgYW5kIHdvbid0IHJlY2FsY3VsYXRlIHBvcHBlciBwb3NpdGlvblxuICogd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuIEl0IGFsc28gd29uJ3QgdHJpZ2dlciBgb25VcGRhdGVgIGNhbGxiYWNrIGFueW1vcmUsXG4gKiB1bmxlc3MgeW91IGNhbGwgYHVwZGF0ZWAgbWV0aG9kIG1hbnVhbGx5LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgICB0aGlzLnN0YXRlID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMuc3RhdGUpO1xuICB9XG59XG5cbi8qKlxuICogVGVsbHMgaWYgYSBnaXZlbiBpbnB1dCBpcyBhIG51bWJlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHsqfSBpbnB1dCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcbiAgcmV0dXJuIG4gIT09ICcnICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHN0eWxlIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHN0eWxlIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRTdHlsZXMoZWxlbWVudCwgc3R5bGVzKSB7XG4gIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB1bml0ID0gJyc7XG4gICAgLy8gYWRkIHVuaXQgaWYgdGhlIHZhbHVlIGlzIG51bWVyaWMgYW5kIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nXG4gICAgaWYgKFsnd2lkdGgnLCAnaGVpZ2h0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLmluZGV4T2YocHJvcCkgIT09IC0xICYmIGlzTnVtZXJpYyhzdHlsZXNbcHJvcF0pKSB7XG4gICAgICB1bml0ID0gJ3B4JztcbiAgICB9XG4gICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXSArIHVuaXQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgYXR0cmlidXRlcyB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBhdHRyaWJ1dGVzIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUocHJvcCwgYXR0cmlidXRlc1twcm9wXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5zdHlsZXMgLSBMaXN0IG9mIHN0eWxlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLmF0dHJpYnV0ZXMgLSBMaXN0IG9mIGF0dHJpYnV0ZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc2FtZSBkYXRhIG9iamVjdFxuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlKGRhdGEpIHtcbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuc3R5bGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gaW4gdGhpcyB3YXkgd2UgY2FuIG1ha2UgdGhlIDNyZCBwYXJ0eSBtb2RpZmllcnMgYWRkIGN1c3RvbSBzdHlsZXMgdG8gaXRcbiAgLy8gQmUgYXdhcmUsIG1vZGlmaWVycyBjb3VsZCBvdmVycmlkZSB0aGUgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoZSBwcmV2aW91c1xuICAvLyBsaW5lcyBvZiB0aGlzIG1vZGlmaWVyIVxuICBzZXRTdHlsZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuc3R5bGVzKTtcblxuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5hdHRyaWJ1dGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gdGhleSB3aWxsIGJlIHNldCBhcyBIVE1MIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnRcbiAgc2V0QXR0cmlidXRlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5hdHRyaWJ1dGVzKTtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgZGVmaW5lZCBhbmQgYXJyb3dTdHlsZXMgaGFzIHNvbWUgcHJvcGVydGllc1xuICBpZiAoZGF0YS5hcnJvd0VsZW1lbnQgJiYgT2JqZWN0LmtleXMoZGF0YS5hcnJvd1N0eWxlcykubGVuZ3RoKSB7XG4gICAgc2V0U3R5bGVzKGRhdGEuYXJyb3dFbGVtZW50LCBkYXRhLmFycm93U3R5bGVzKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFNldCB0aGUgeC1wbGFjZW1lbnQgYXR0cmlidXRlIGJlZm9yZSBldmVyeXRoaW5nIGVsc2UgYmVjYXVzZSBpdCBjb3VsZCBiZSB1c2VkXG4gKiB0byBhZGQgbWFyZ2lucyB0byB0aGUgcG9wcGVyIG1hcmdpbnMgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZCB0byBnZXQgdGhlXG4gKiBjb3JyZWN0IHBvcHBlciBvZmZzZXRzLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5tb2RpZmllcnNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUG9wcGVyLmpzIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZU9uTG9hZChyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBzdGF0ZSkge1xuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgdmFyIHJlZmVyZW5jZU9mZnNldHMgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgdmFyIHBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KG9wdGlvbnMucGxhY2VtZW50LCByZWZlcmVuY2VPZmZzZXRzLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICBwb3BwZXIuc2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcsIHBsYWNlbWVudCk7XG5cbiAgLy8gQXBwbHkgYHBvc2l0aW9uYCB0byBwb3BwZXIgYmVmb3JlIGFueXRoaW5nIGVsc2UgYmVjYXVzZVxuICAvLyB3aXRob3V0IHRoZSBwb3NpdGlvbiBhcHBsaWVkIHdlIGNhbid0IGd1YXJhbnRlZSBjb3JyZWN0IGNvbXB1dGF0aW9uc1xuICBzZXRTdHlsZXMocG9wcGVyLCB7IHBvc2l0aW9uOiBvcHRpb25zLnBvc2l0aW9uRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJyB9KTtcblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7Qm9vbGVhbn0gc2hvdWxkUm91bmQgLSBJZiB0aGUgb2Zmc2V0cyBzaG91bGQgYmUgcm91bmRlZCBhdCBhbGxcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwb3BwZXIncyBwb3NpdGlvbiBvZmZzZXRzIHJvdW5kZWRcbiAqXG4gKiBUaGUgdGFsZSBvZiBwaXhlbC1wZXJmZWN0IHBvc2l0aW9uaW5nLiBJdCdzIHN0aWxsIG5vdCAxMDAlIHBlcmZlY3QsIGJ1dCBhc1xuICogZ29vZCBhcyBpdCBjYW4gYmUgd2l0aGluIHJlYXNvbi5cbiAqIERpc2N1c3Npb24gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvcHVsbC83MTVcbiAqXG4gKiBMb3cgRFBJIHNjcmVlbnMgY2F1c2UgYSBwb3BwZXIgdG8gYmUgYmx1cnJ5IGlmIG5vdCB1c2luZyBmdWxsIHBpeGVscyAoU2FmYXJpXG4gKiBhcyB3ZWxsIG9uIEhpZ2ggRFBJIHNjcmVlbnMpLlxuICpcbiAqIEZpcmVmb3ggcHJlZmVycyBubyByb3VuZGluZyBmb3IgcG9zaXRpb25pbmcgYW5kIGRvZXMgbm90IGhhdmUgYmx1cnJpbmVzcyBvblxuICogaGlnaCBEUEkgc2NyZWVucy5cbiAqXG4gKiBPbmx5IGhvcml6b250YWwgcGxhY2VtZW50IGFuZCBsZWZ0L3JpZ2h0IHZhbHVlcyBuZWVkIHRvIGJlIGNvbnNpZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIGdldFJvdW5kZWRPZmZzZXRzKGRhdGEsIHNob3VsZFJvdW5kKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZCxcbiAgICAgIGZsb29yID0gTWF0aC5mbG9vcjtcblxuICB2YXIgbm9Sb3VuZCA9IGZ1bmN0aW9uIG5vUm91bmQodikge1xuICAgIHJldHVybiB2O1xuICB9O1xuXG4gIHZhciByZWZlcmVuY2VXaWR0aCA9IHJvdW5kKHJlZmVyZW5jZS53aWR0aCk7XG4gIHZhciBwb3BwZXJXaWR0aCA9IHJvdW5kKHBvcHBlci53aWR0aCk7XG5cbiAgdmFyIGlzVmVydGljYWwgPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGRhdGEucGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBpc1ZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LmluZGV4T2YoJy0nKSAhPT0gLTE7XG4gIHZhciBzYW1lV2lkdGhQYXJpdHkgPSByZWZlcmVuY2VXaWR0aCAlIDIgPT09IHBvcHBlcldpZHRoICUgMjtcbiAgdmFyIGJvdGhPZGRXaWR0aCA9IHJlZmVyZW5jZVdpZHRoICUgMiA9PT0gMSAmJiBwb3BwZXJXaWR0aCAlIDIgPT09IDE7XG5cbiAgdmFyIGhvcml6b250YWxUb0ludGVnZXIgPSAhc2hvdWxkUm91bmQgPyBub1JvdW5kIDogaXNWZXJ0aWNhbCB8fCBpc1ZhcmlhdGlvbiB8fCBzYW1lV2lkdGhQYXJpdHkgPyByb3VuZCA6IGZsb29yO1xuICB2YXIgdmVydGljYWxUb0ludGVnZXIgPSAhc2hvdWxkUm91bmQgPyBub1JvdW5kIDogcm91bmQ7XG5cbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBob3Jpem9udGFsVG9JbnRlZ2VyKGJvdGhPZGRXaWR0aCAmJiAhaXNWYXJpYXRpb24gJiYgc2hvdWxkUm91bmQgPyBwb3BwZXIubGVmdCAtIDEgOiBwb3BwZXIubGVmdCksXG4gICAgdG9wOiB2ZXJ0aWNhbFRvSW50ZWdlcihwb3BwZXIudG9wKSxcbiAgICBib3R0b206IHZlcnRpY2FsVG9JbnRlZ2VyKHBvcHBlci5ib3R0b20pLFxuICAgIHJpZ2h0OiBob3Jpem9udGFsVG9JbnRlZ2VyKHBvcHBlci5yaWdodClcbiAgfTtcbn1cblxudmFyIGlzRmlyZWZveCA9IGlzQnJvd3NlciAmJiAvRmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZShkYXRhLCBvcHRpb25zKSB7XG4gIHZhciB4ID0gb3B0aW9ucy54LFxuICAgICAgeSA9IG9wdGlvbnMueTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgLy8gUmVtb3ZlIHRoaXMgbGVnYWN5IHN1cHBvcnQgaW4gUG9wcGVyLmpzIHYyXG5cbiAgdmFyIGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA9IGZpbmQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSAnYXBwbHlTdHlsZSc7XG4gIH0pLmdwdUFjY2VsZXJhdGlvbjtcbiAgaWYgKGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgZ3B1QWNjZWxlcmF0aW9uYCBvcHRpb24gbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXIgYW5kIHdpbGwgbm90IGJlIHN1cHBvcnRlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgUG9wcGVyLmpzIScpO1xuICB9XG4gIHZhciBncHVBY2NlbGVyYXRpb24gPSBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZCA/IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA6IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uO1xuXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgb2Zmc2V0UGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuXG4gIC8vIFN0eWxlc1xuICB2YXIgc3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiBwb3BwZXIucG9zaXRpb25cbiAgfTtcblxuICB2YXIgb2Zmc2V0cyA9IGdldFJvdW5kZWRPZmZzZXRzKGRhdGEsIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDwgMiB8fCAhaXNGaXJlZm94KTtcblxuICB2YXIgc2lkZUEgPSB4ID09PSAnYm90dG9tJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gIHZhciBzaWRlQiA9IHkgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuXG4gIC8vIGlmIGdwdUFjY2VsZXJhdGlvbiBpcyBzZXQgdG8gYHRydWVgIGFuZCB0cmFuc2Zvcm0gaXMgc3VwcG9ydGVkLFxuICAvLyAgd2UgdXNlIGB0cmFuc2xhdGUzZGAgdG8gYXBwbHkgdGhlIHBvc2l0aW9uIHRvIHRoZSBwb3BwZXIgd2VcbiAgLy8gYXV0b21hdGljYWxseSB1c2UgdGhlIHN1cHBvcnRlZCBwcmVmaXhlZCB2ZXJzaW9uIGlmIG5lZWRlZFxuICB2YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyk7XG5cbiAgLy8gbm93LCBsZXQncyBtYWtlIGEgc3RlcCBiYWNrIGFuZCBsb29rIGF0IHRoaXMgY29kZSBjbG9zZWx5ICh3dGY/KVxuICAvLyBJZiB0aGUgY29udGVudCBvZiB0aGUgcG9wcGVyIGdyb3dzIG9uY2UgaXQncyBiZWVuIHBvc2l0aW9uZWQsIGl0XG4gIC8vIG1heSBoYXBwZW4gdGhhdCB0aGUgcG9wcGVyIGdldHMgbWlzcGxhY2VkIGJlY2F1c2Ugb2YgdGhlIG5ldyBjb250ZW50XG4gIC8vIG92ZXJmbG93aW5nIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUbyBhdm9pZCB0aGlzIHByb2JsZW0sIHdlIHByb3ZpZGUgdHdvIG9wdGlvbnMgKHggYW5kIHkpLCB3aGljaCBhbGxvd1xuICAvLyB0aGUgY29uc3VtZXIgdG8gZGVmaW5lIHRoZSBvZmZzZXQgb3JpZ2luLlxuICAvLyBJZiB3ZSBwb3NpdGlvbiBhIHBvcHBlciBvbiB0b3Agb2YgYSByZWZlcmVuY2UgZWxlbWVudCwgd2UgY2FuIHNldFxuICAvLyBgeGAgdG8gYHRvcGAgdG8gbWFrZSB0aGUgcG9wcGVyIGdyb3cgdG93YXJkcyBpdHMgdG9wIGluc3RlYWQgb2ZcbiAgLy8gaXRzIGJvdHRvbS5cbiAgdmFyIGxlZnQgPSB2b2lkIDAsXG4gICAgICB0b3AgPSB2b2lkIDA7XG4gIGlmIChzaWRlQSA9PT0gJ2JvdHRvbScpIHtcbiAgICAvLyB3aGVuIG9mZnNldFBhcmVudCBpcyA8aHRtbD4gdGhlIHBvc2l0aW9uaW5nIGlzIHJlbGF0aXZlIHRvIHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbiAoZXhjbHVkaW5nIHRoZSBzY3JvbGxiYXIpXG4gICAgLy8gYW5kIG5vdCB0aGUgYm90dG9tIG9mIHRoZSBodG1sIGVsZW1lbnRcbiAgICBpZiAob2Zmc2V0UGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIHRvcCA9IC1vZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcCA9IC1vZmZzZXRQYXJlbnRSZWN0LmhlaWdodCArIG9mZnNldHMuYm90dG9tO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0b3AgPSBvZmZzZXRzLnRvcDtcbiAgfVxuICBpZiAoc2lkZUIgPT09ICdyaWdodCcpIHtcbiAgICBpZiAob2Zmc2V0UGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIGxlZnQgPSAtb2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IC1vZmZzZXRQYXJlbnRSZWN0LndpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGVmdCA9IG9mZnNldHMubGVmdDtcbiAgfVxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uICYmIHByZWZpeGVkUHJvcGVydHkpIHtcbiAgICBzdHlsZXNbcHJlZml4ZWRQcm9wZXJ0eV0gPSAndHJhbnNsYXRlM2QoJyArIGxlZnQgKyAncHgsICcgKyB0b3AgKyAncHgsIDApJztcbiAgICBzdHlsZXNbc2lkZUFdID0gMDtcbiAgICBzdHlsZXNbc2lkZUJdID0gMDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9ICd0cmFuc2Zvcm0nO1xuICB9IGVsc2Uge1xuICAgIC8vIG90aHdlcmlzZSwgd2UgdXNlIHRoZSBzdGFuZGFyZCBgdG9wYCwgYGxlZnRgLCBgYm90dG9tYCBhbmQgYHJpZ2h0YCBwcm9wZXJ0aWVzXG4gICAgdmFyIGludmVydFRvcCA9IHNpZGVBID09PSAnYm90dG9tJyA/IC0xIDogMTtcbiAgICB2YXIgaW52ZXJ0TGVmdCA9IHNpZGVCID09PSAncmlnaHQnID8gLTEgOiAxO1xuICAgIHN0eWxlc1tzaWRlQV0gPSB0b3AgKiBpbnZlcnRUb3A7XG4gICAgc3R5bGVzW3NpZGVCXSA9IGxlZnQgKiBpbnZlcnRMZWZ0O1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gc2lkZUEgKyAnLCAnICsgc2lkZUI7XG4gIH1cblxuICAvLyBBdHRyaWJ1dGVzXG4gIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICd4LXBsYWNlbWVudCc6IGRhdGEucGxhY2VtZW50XG4gIH07XG5cbiAgLy8gVXBkYXRlIGBkYXRhYCBhdHRyaWJ1dGVzLCBzdHlsZXMgYW5kIGFycm93U3R5bGVzXG4gIGRhdGEuYXR0cmlidXRlcyA9IF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCBkYXRhLmF0dHJpYnV0ZXMpO1xuICBkYXRhLnN0eWxlcyA9IF9leHRlbmRzKHt9LCBzdHlsZXMsIGRhdGEuc3R5bGVzKTtcbiAgZGF0YS5hcnJvd1N0eWxlcyA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMuYXJyb3csIGRhdGEuYXJyb3dTdHlsZXMpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGRlcGVuZHMgZnJvbSBhbm90aGVyIG9uZS48YnIgLz5cbiAqIEl0IGNoZWNrcyBpZiB0aGUgbmVlZGVkIG1vZGlmaWVyIGlzIGxpc3RlZCBhbmQgZW5hYmxlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVycyAtIGxpc3Qgb2YgbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGluZ05hbWUgLSBuYW1lIG9mIHJlcXVlc3RpbmcgbW9kaWZpZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0ZWROYW1lIC0gbmFtZSBvZiByZXF1ZXN0ZWQgbW9kaWZpZXJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vZGlmaWVyUmVxdWlyZWQobW9kaWZpZXJzLCByZXF1ZXN0aW5nTmFtZSwgcmVxdWVzdGVkTmFtZSkge1xuICB2YXIgcmVxdWVzdGluZyA9IGZpbmQobW9kaWZpZXJzLCBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgIHJldHVybiBuYW1lID09PSByZXF1ZXN0aW5nTmFtZTtcbiAgfSk7XG5cbiAgdmFyIGlzUmVxdWlyZWQgPSAhIXJlcXVlc3RpbmcgJiYgbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09IHJlcXVlc3RlZE5hbWUgJiYgbW9kaWZpZXIuZW5hYmxlZCAmJiBtb2RpZmllci5vcmRlciA8IHJlcXVlc3Rpbmcub3JkZXI7XG4gIH0pO1xuXG4gIGlmICghaXNSZXF1aXJlZCkge1xuICAgIHZhciBfcmVxdWVzdGluZyA9ICdgJyArIHJlcXVlc3RpbmdOYW1lICsgJ2AnO1xuICAgIHZhciByZXF1ZXN0ZWQgPSAnYCcgKyByZXF1ZXN0ZWROYW1lICsgJ2AnO1xuICAgIGNvbnNvbGUud2FybihyZXF1ZXN0ZWQgKyAnIG1vZGlmaWVyIGlzIHJlcXVpcmVkIGJ5ICcgKyBfcmVxdWVzdGluZyArICcgbW9kaWZpZXIgaW4gb3JkZXIgdG8gd29yaywgYmUgc3VyZSB0byBpbmNsdWRlIGl0IGJlZm9yZSAnICsgX3JlcXVlc3RpbmcgKyAnIScpO1xuICB9XG4gIHJldHVybiBpc1JlcXVpcmVkO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gYXJyb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyRhcnJvdztcblxuICAvLyBhcnJvdyBkZXBlbmRzIG9uIGtlZXBUb2dldGhlciBpbiBvcmRlciB0byB3b3JrXG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnYXJyb3cnLCAna2VlcFRvZ2V0aGVyJykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBhcnJvd0VsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG5cbiAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGEgc3RyaW5nLCBzdXBwb3NlIGl0J3MgYSBDU1Mgc2VsZWN0b3JcbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIG5vdCBmb3VuZCwgZG9uJ3QgcnVuIHRoZSBtb2RpZmllclxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgdGhlIGFycm93RWxlbWVudCBpc24ndCBhIHF1ZXJ5IHNlbGVjdG9yIHdlIG11c3QgY2hlY2sgdGhhdCB0aGVcbiAgICAvLyBwcm92aWRlZCBET00gbm9kZSBpcyBjaGlsZCBvZiBpdHMgcG9wcGVyIG5vZGVcbiAgICBpZiAoIWRhdGEuaW5zdGFuY2UucG9wcGVyLmNvbnRhaW5zKGFycm93RWxlbWVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogYGFycm93LmVsZW1lbnRgIG11c3QgYmUgY2hpbGQgb2YgaXRzIHBvcHBlciBlbGVtZW50IScpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgaXNWZXJ0aWNhbCA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzaWRlQ2FwaXRhbGl6ZWQgPSBpc1ZlcnRpY2FsID8gJ1RvcCcgOiAnTGVmdCc7XG4gIHZhciBzaWRlID0gc2lkZUNhcGl0YWxpemVkLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBhbHRTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgdmFyIGFycm93RWxlbWVudFNpemUgPSBnZXRPdXRlclNpemVzKGFycm93RWxlbWVudClbbGVuXTtcblxuICAvL1xuICAvLyBleHRlbmRzIGtlZXBUb2dldGhlciBiZWhhdmlvciBtYWtpbmcgc3VyZSB0aGUgcG9wcGVyIGFuZCBpdHNcbiAgLy8gcmVmZXJlbmNlIGhhdmUgZW5vdWdoIHBpeGVscyBpbiBjb25qdW5jdGlvblxuICAvL1xuXG4gIC8vIHRvcC9sZWZ0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSA8IHBvcHBlcltzaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLT0gcG9wcGVyW3NpZGVdIC0gKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSk7XG4gIH1cbiAgLy8gYm90dG9tL3JpZ2h0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgPiBwb3BwZXJbb3BTaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gKz0gcmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSAtIHBvcHBlcltvcFNpZGVdO1xuICB9XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuXG4gIC8vIGNvbXB1dGUgY2VudGVyIG9mIHRoZSBwb3BwZXJcbiAgdmFyIGNlbnRlciA9IHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVtsZW5dIC8gMiAtIGFycm93RWxlbWVudFNpemUgLyAyO1xuXG4gIC8vIENvbXB1dGUgdGhlIHNpZGVWYWx1ZSB1c2luZyB0aGUgdXBkYXRlZCBwb3BwZXIgb2Zmc2V0c1xuICAvLyB0YWtlIHBvcHBlciBtYXJnaW4gaW4gYWNjb3VudCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgdGhpcyBpbmZvIGF2YWlsYWJsZVxuICB2YXIgY3NzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgdmFyIHBvcHBlck1hcmdpblNpZGUgPSBwYXJzZUZsb2F0KGNzc1snbWFyZ2luJyArIHNpZGVDYXBpdGFsaXplZF0pO1xuICB2YXIgcG9wcGVyQm9yZGVyU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydib3JkZXInICsgc2lkZUNhcGl0YWxpemVkICsgJ1dpZHRoJ10pO1xuICB2YXIgc2lkZVZhbHVlID0gY2VudGVyIC0gZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtIHBvcHBlck1hcmdpblNpZGUgLSBwb3BwZXJCb3JkZXJTaWRlO1xuXG4gIC8vIHByZXZlbnQgYXJyb3dFbGVtZW50IGZyb20gYmVpbmcgcGxhY2VkIG5vdCBjb250aWd1b3VzbHkgdG8gaXRzIHBvcHBlclxuICBzaWRlVmFsdWUgPSBNYXRoLm1heChNYXRoLm1pbihwb3BwZXJbbGVuXSAtIGFycm93RWxlbWVudFNpemUsIHNpZGVWYWx1ZSksIDApO1xuXG4gIGRhdGEuYXJyb3dFbGVtZW50ID0gYXJyb3dFbGVtZW50O1xuICBkYXRhLm9mZnNldHMuYXJyb3cgPSAoX2RhdGEkb2Zmc2V0cyRhcnJvdyA9IHt9LCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBzaWRlLCBNYXRoLnJvdW5kKHNpZGVWYWx1ZSkpLCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBhbHRTaWRlLCAnJyksIF9kYXRhJG9mZnNldHMkYXJyb3cpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IHZhcmlhdGlvbiBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IHZhcmlhdGlvblxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uKHZhcmlhdGlvbikge1xuICBpZiAodmFyaWF0aW9uID09PSAnZW5kJykge1xuICAgIHJldHVybiAnc3RhcnQnO1xuICB9IGVsc2UgaWYgKHZhcmlhdGlvbiA9PT0gJ3N0YXJ0Jykge1xuICAgIHJldHVybiAnZW5kJztcbiAgfVxuICByZXR1cm4gdmFyaWF0aW9uO1xufVxuXG4vKipcbiAqIExpc3Qgb2YgYWNjZXB0ZWQgcGxhY2VtZW50cyB0byB1c2UgYXMgdmFsdWVzIG9mIHRoZSBgcGxhY2VtZW50YCBvcHRpb24uPGJyIC8+XG4gKiBWYWxpZCBwbGFjZW1lbnRzIGFyZTpcbiAqIC0gYGF1dG9gXG4gKiAtIGB0b3BgXG4gKiAtIGByaWdodGBcbiAqIC0gYGJvdHRvbWBcbiAqIC0gYGxlZnRgXG4gKlxuICogRWFjaCBwbGFjZW1lbnQgY2FuIGhhdmUgYSB2YXJpYXRpb24gZnJvbSB0aGlzIGxpc3Q6XG4gKiAtIGAtc3RhcnRgXG4gKiAtIGAtZW5kYFxuICpcbiAqIFZhcmlhdGlvbnMgYXJlIGludGVycHJldGVkIGVhc2lseSBpZiB5b3UgdGhpbmsgb2YgdGhlbSBhcyB0aGUgbGVmdCB0byByaWdodFxuICogd3JpdHRlbiBsYW5ndWFnZXMuIEhvcml6b250YWxseSAoYHRvcGAgYW5kIGBib3R0b21gKSwgYHN0YXJ0YCBpcyBsZWZ0IGFuZCBgZW5kYFxuICogaXMgcmlnaHQuPGJyIC8+XG4gKiBWZXJ0aWNhbGx5IChgbGVmdGAgYW5kIGByaWdodGApLCBgc3RhcnRgIGlzIHRvcCBhbmQgYGVuZGAgaXMgYm90dG9tLlxuICpcbiAqIFNvbWUgdmFsaWQgZXhhbXBsZXMgYXJlOlxuICogLSBgdG9wLWVuZGAgKG9uIHRvcCBvZiByZWZlcmVuY2UsIHJpZ2h0IGFsaWduZWQpXG4gKiAtIGByaWdodC1zdGFydGAgKG9uIHJpZ2h0IG9mIHJlZmVyZW5jZSwgdG9wIGFsaWduZWQpXG4gKiAtIGBib3R0b21gIChvbiBib3R0b20sIGNlbnRlcmVkKVxuICogLSBgYXV0by1lbmRgIChvbiB0aGUgc2lkZSB3aXRoIG1vcmUgc3BhY2UgYXZhaWxhYmxlLCBhbGlnbm1lbnQgZGVwZW5kcyBieSBwbGFjZW1lbnQpXG4gKlxuICogQHN0YXRpY1xuICogQHR5cGUge0FycmF5fVxuICogQGVudW0ge1N0cmluZ31cbiAqIEByZWFkb25seVxuICogQG1ldGhvZCBwbGFjZW1lbnRzXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbnZhciBwbGFjZW1lbnRzID0gWydhdXRvLXN0YXJ0JywgJ2F1dG8nLCAnYXV0by1lbmQnLCAndG9wLXN0YXJ0JywgJ3RvcCcsICd0b3AtZW5kJywgJ3JpZ2h0LXN0YXJ0JywgJ3JpZ2h0JywgJ3JpZ2h0LWVuZCcsICdib3R0b20tZW5kJywgJ2JvdHRvbScsICdib3R0b20tc3RhcnQnLCAnbGVmdC1lbmQnLCAnbGVmdCcsICdsZWZ0LXN0YXJ0J107XG5cbi8vIEdldCByaWQgb2YgYGF1dG9gIGBhdXRvLXN0YXJ0YCBhbmQgYGF1dG8tZW5kYFxudmFyIHZhbGlkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMuc2xpY2UoMyk7XG5cbi8qKlxuICogR2l2ZW4gYW4gaW5pdGlhbCBwbGFjZW1lbnQsIHJldHVybnMgYWxsIHRoZSBzdWJzZXF1ZW50IHBsYWNlbWVudHNcbiAqIGNsb2Nrd2lzZSAob3IgY291bnRlci1jbG9ja3dpc2UpLlxuICpcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgLSBBIHZhbGlkIHBsYWNlbWVudCAoaXQgYWNjZXB0cyB2YXJpYXRpb25zKVxuICogQGFyZ3VtZW50IHtCb29sZWFufSBjb3VudGVyIC0gU2V0IHRvIHRydWUgdG8gd2FsayB0aGUgcGxhY2VtZW50cyBjb3VudGVyY2xvY2t3aXNlXG4gKiBAcmV0dXJucyB7QXJyYXl9IHBsYWNlbWVudHMgaW5jbHVkaW5nIHRoZWlyIHZhcmlhdGlvbnNcbiAqL1xuZnVuY3Rpb24gY2xvY2t3aXNlKHBsYWNlbWVudCkge1xuICB2YXIgY291bnRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGluZGV4ID0gdmFsaWRQbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KTtcbiAgdmFyIGFyciA9IHZhbGlkUGxhY2VtZW50cy5zbGljZShpbmRleCArIDEpLmNvbmNhdCh2YWxpZFBsYWNlbWVudHMuc2xpY2UoMCwgaW5kZXgpKTtcbiAgcmV0dXJuIGNvdW50ZXIgPyBhcnIucmV2ZXJzZSgpIDogYXJyO1xufVxuXG52YXIgQkVIQVZJT1JTID0ge1xuICBGTElQOiAnZmxpcCcsXG4gIENMT0NLV0lTRTogJ2Nsb2Nrd2lzZScsXG4gIENPVU5URVJDTE9DS1dJU0U6ICdjb3VudGVyY2xvY2t3aXNlJ1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGZsaXAoZGF0YSwgb3B0aW9ucykge1xuICAvLyBpZiBgaW5uZXJgIG1vZGlmaWVyIGlzIGVuYWJsZWQsIHdlIGNhbid0IHVzZSB0aGUgYGZsaXBgIG1vZGlmaWVyXG4gIGlmIChpc01vZGlmaWVyRW5hYmxlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2lubmVyJykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGlmIChkYXRhLmZsaXBwZWQgJiYgZGF0YS5wbGFjZW1lbnQgPT09IGRhdGEub3JpZ2luYWxQbGFjZW1lbnQpIHtcbiAgICAvLyBzZWVtcyBsaWtlIGZsaXAgaXMgdHJ5aW5nIHRvIGxvb3AsIHByb2JhYmx5IHRoZXJlJ3Mgbm90IGVub3VnaCBzcGFjZSBvbiBhbnkgb2YgdGhlIGZsaXBwYWJsZSBzaWRlc1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50LCBkYXRhLnBvc2l0aW9uRml4ZWQpO1xuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVsxXSB8fCAnJztcblxuICB2YXIgZmxpcE9yZGVyID0gW107XG5cbiAgc3dpdGNoIChvcHRpb25zLmJlaGF2aW9yKSB7XG4gICAgY2FzZSBCRUhBVklPUlMuRkxJUDpcbiAgICAgIGZsaXBPcmRlciA9IFtwbGFjZW1lbnQsIHBsYWNlbWVudE9wcG9zaXRlXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ09VTlRFUkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQsIHRydWUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGZsaXBPcmRlciA9IG9wdGlvbnMuYmVoYXZpb3I7XG4gIH1cblxuICBmbGlwT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAoc3RlcCwgaW5kZXgpIHtcbiAgICBpZiAocGxhY2VtZW50ICE9PSBzdGVwIHx8IGZsaXBPcmRlci5sZW5ndGggPT09IGluZGV4ICsgMSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgICBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG4gICAgdmFyIHJlZk9mZnNldHMgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuXG4gICAgLy8gdXNpbmcgZmxvb3IgYmVjYXVzZSB0aGUgcmVmZXJlbmNlIG9mZnNldHMgbWF5IGNvbnRhaW4gZGVjaW1hbHMgd2UgYXJlIG5vdCBnb2luZyB0byBjb25zaWRlciBoZXJlXG4gICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgb3ZlcmxhcHNSZWYgPSBwbGFjZW1lbnQgPT09ICdsZWZ0JyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKHJlZk9mZnNldHMubGVmdCkgfHwgcGxhY2VtZW50ID09PSAncmlnaHQnICYmIGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihyZWZPZmZzZXRzLnJpZ2h0KSB8fCBwbGFjZW1lbnQgPT09ICd0b3AnICYmIGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKHJlZk9mZnNldHMudG9wKSB8fCBwbGFjZW1lbnQgPT09ICdib3R0b20nICYmIGZsb29yKHBvcHBlck9mZnNldHMudG9wKSA8IGZsb29yKHJlZk9mZnNldHMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NMZWZ0ID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKGJvdW5kYXJpZXMubGVmdCk7XG4gICAgdmFyIG92ZXJmbG93c1JpZ2h0ID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihib3VuZGFyaWVzLnJpZ2h0KTtcbiAgICB2YXIgb3ZlcmZsb3dzVG9wID0gZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IoYm91bmRhcmllcy50b3ApO1xuICAgIHZhciBvdmVyZmxvd3NCb3R0b20gPSBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihib3VuZGFyaWVzLmJvdHRvbSk7XG5cbiAgICB2YXIgb3ZlcmZsb3dzQm91bmRhcmllcyA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIG92ZXJmbG93c0xlZnQgfHwgcGxhY2VtZW50ID09PSAncmlnaHQnICYmIG92ZXJmbG93c1JpZ2h0IHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgb3ZlcmZsb3dzVG9wIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgb3ZlcmZsb3dzQm90dG9tO1xuXG4gICAgLy8gZmxpcCB0aGUgdmFyaWF0aW9uIGlmIHJlcXVpcmVkXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgLy8gZmxpcHMgdmFyaWF0aW9uIGlmIHJlZmVyZW5jZSBlbGVtZW50IG92ZXJmbG93cyBib3VuZGFyaWVzXG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb25CeVJlZiA9ICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyAmJiAoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c1RvcCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c0JvdHRvbSk7XG5cbiAgICAvLyBmbGlwcyB2YXJpYXRpb24gaWYgcG9wcGVyIGNvbnRlbnQgb3ZlcmZsb3dzIGJvdW5kYXJpZXNcbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbkJ5Q29udGVudCA9ICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9uc0J5Q29udGVudCAmJiAoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c0xlZnQgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c0JvdHRvbSB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1RvcCk7XG5cbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbiA9IGZsaXBwZWRWYXJpYXRpb25CeVJlZiB8fCBmbGlwcGVkVmFyaWF0aW9uQnlDb250ZW50O1xuXG4gICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMgfHwgZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgLy8gdGhpcyBib29sZWFuIHRvIGRldGVjdCBhbnkgZmxpcCBsb29wXG4gICAgICBkYXRhLmZsaXBwZWQgPSB0cnVlO1xuXG4gICAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcykge1xuICAgICAgICBwbGFjZW1lbnQgPSBmbGlwT3JkZXJbaW5kZXggKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgICAgdmFyaWF0aW9uID0gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5wbGFjZW1lbnQgPSBwbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xuXG4gICAgICAvLyB0aGlzIG9iamVjdCBjb250YWlucyBgcG9zaXRpb25gLCB3ZSB3YW50IHRvIHByZXNlcnZlIGl0IGFsb25nIHdpdGhcbiAgICAgIC8vIGFueSBhZGRpdGlvbmFsIHByb3BlcnR5IHdlIG1heSBhZGQgaW4gdGhlIGZ1dHVyZVxuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMucG9wcGVyLCBnZXRQb3BwZXJPZmZzZXRzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCkpO1xuXG4gICAgICBkYXRhID0gcnVuTW9kaWZpZXJzKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBkYXRhLCAnZmxpcCcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24ga2VlcFRvZ2V0aGVyKGRhdGEpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdyaWdodCcgOiAnYm90dG9tJztcbiAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICBpZiAocG9wcGVyW3NpZGVdIDwgZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pIC0gcG9wcGVyW21lYXN1cmVtZW50XTtcbiAgfVxuICBpZiAocG9wcGVyW29wU2lkZV0gPiBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW3NpZGVdKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGNvbnRhaW5pbmcgdmFsdWUgKyB1bml0IGludG8gYSBweCB2YWx1ZSBudW1iZXJcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzdHIgLSBWYWx1ZSArIHVuaXQgc3RyaW5nXG4gKiBAYXJndW1lbnQge1N0cmluZ30gbWVhc3VyZW1lbnQgLSBgaGVpZ2h0YCBvciBgd2lkdGhgXG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEByZXR1cm5zIHtOdW1iZXJ8U3RyaW5nfVxuICogVmFsdWUgaW4gcGl4ZWxzLCBvciBvcmlnaW5hbCBzdHJpbmcgaWYgbm8gdmFsdWVzIHdlcmUgZXh0cmFjdGVkXG4gKi9cbmZ1bmN0aW9uIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cykge1xuICAvLyBzZXBhcmF0ZSB2YWx1ZSBmcm9tIHVuaXRcbiAgdmFyIHNwbGl0ID0gc3RyLm1hdGNoKC8oKD86XFwtfFxcKyk/XFxkKlxcLj9cXGQqKSguKikvKTtcbiAgdmFyIHZhbHVlID0gK3NwbGl0WzFdO1xuICB2YXIgdW5pdCA9IHNwbGl0WzJdO1xuXG4gIC8vIElmIGl0J3Mgbm90IGEgbnVtYmVyIGl0J3MgYW4gb3BlcmF0b3IsIEkgZ3Vlc3NcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBpZiAodW5pdC5pbmRleE9mKCclJykgPT09IDApIHtcbiAgICB2YXIgZWxlbWVudCA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgIGNhc2UgJyVwJzpcbiAgICAgICAgZWxlbWVudCA9IHBvcHBlck9mZnNldHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnJSc6XG4gICAgICBjYXNlICclcic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBlbGVtZW50ID0gcmVmZXJlbmNlT2Zmc2V0cztcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3QoZWxlbWVudCk7XG4gICAgcmV0dXJuIHJlY3RbbWVhc3VyZW1lbnRdIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3ZoJyB8fCB1bml0ID09PSAndncnKSB7XG4gICAgLy8gaWYgaXMgYSB2aCBvciB2dywgd2UgY2FsY3VsYXRlIHRoZSBzaXplIGJhc2VkIG9uIHRoZSB2aWV3cG9ydFxuICAgIHZhciBzaXplID0gdm9pZCAwO1xuICAgIGlmICh1bml0ID09PSAndmgnKSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemUgLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBpcyBhbiBleHBsaWNpdCBwaXhlbCB1bml0LCB3ZSBnZXQgcmlkIG9mIHRoZSB1bml0IGFuZCBrZWVwIHRoZSB2YWx1ZVxuICAgIC8vIGlmIGlzIGFuIGltcGxpY2l0IHVuaXQsIGl0J3MgcHgsIGFuZCB3ZSByZXR1cm4ganVzdCB0aGUgdmFsdWVcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBgb2Zmc2V0YCBzdHJpbmcgdG8gZXh0cmFwb2xhdGUgYHhgIGFuZCBgeWAgbnVtZXJpYyBvZmZzZXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IG9mZnNldFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gYmFzZVBsYWNlbWVudFxuICogQHJldHVybnMge0FycmF5fSBhIHR3byBjZWxscyBhcnJheSB3aXRoIHggYW5kIHkgb2Zmc2V0cyBpbiBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cywgYmFzZVBsYWNlbWVudCkge1xuICB2YXIgb2Zmc2V0cyA9IFswLCAwXTtcblxuICAvLyBVc2UgaGVpZ2h0IGlmIHBsYWNlbWVudCBpcyBsZWZ0IG9yIHJpZ2h0IGFuZCBpbmRleCBpcyAwIG90aGVyd2lzZSB1c2Ugd2lkdGhcbiAgLy8gaW4gdGhpcyB3YXkgdGhlIGZpcnN0IG9mZnNldCB3aWxsIHVzZSBhbiBheGlzIGFuZCB0aGUgc2Vjb25kIG9uZVxuICAvLyB3aWxsIHVzZSB0aGUgb3RoZXIgb25lXG4gIHZhciB1c2VIZWlnaHQgPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAvLyBTcGxpdCB0aGUgb2Zmc2V0IHN0cmluZyB0byBvYnRhaW4gYSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHNcbiAgLy8gVGhlIHJlZ2V4IGFkZHJlc3NlcyB2YWx1ZXMgd2l0aCB0aGUgcGx1cyBvciBtaW51cyBzaWduIGluIGZyb250ICgrMTAsIC0yMCwgZXRjKVxuICB2YXIgZnJhZ21lbnRzID0gb2Zmc2V0LnNwbGl0KC8oXFwrfFxcLSkvKS5tYXAoZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy50cmltKCk7XG4gIH0pO1xuXG4gIC8vIERldGVjdCBpZiB0aGUgb2Zmc2V0IHN0cmluZyBjb250YWlucyBhIHBhaXIgb2YgdmFsdWVzIG9yIGEgc2luZ2xlIG9uZVxuICAvLyB0aGV5IGNvdWxkIGJlIHNlcGFyYXRlZCBieSBjb21tYSBvciBzcGFjZVxuICB2YXIgZGl2aWRlciA9IGZyYWdtZW50cy5pbmRleE9mKGZpbmQoZnJhZ21lbnRzLCBmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnNlYXJjaCgvLHxcXHMvKSAhPT0gLTE7XG4gIH0pKTtcblxuICBpZiAoZnJhZ21lbnRzW2RpdmlkZXJdICYmIGZyYWdtZW50c1tkaXZpZGVyXS5pbmRleE9mKCcsJykgPT09IC0xKSB7XG4gICAgY29uc29sZS53YXJuKCdPZmZzZXRzIHNlcGFyYXRlZCBieSB3aGl0ZSBzcGFjZShzKSBhcmUgZGVwcmVjYXRlZCwgdXNlIGEgY29tbWEgKCwpIGluc3RlYWQuJyk7XG4gIH1cblxuICAvLyBJZiBkaXZpZGVyIGlzIGZvdW5kLCB3ZSBkaXZpZGUgdGhlIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kcyB0byBkaXZpZGVcbiAgLy8gdGhlbSBieSBvZnNldCBYIGFuZCBZLlxuICB2YXIgc3BsaXRSZWdleCA9IC9cXHMqLFxccyp8XFxzKy87XG4gIHZhciBvcHMgPSBkaXZpZGVyICE9PSAtMSA/IFtmcmFnbWVudHMuc2xpY2UoMCwgZGl2aWRlcikuY29uY2F0KFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMF1dKSwgW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVsxXV0uY29uY2F0KGZyYWdtZW50cy5zbGljZShkaXZpZGVyICsgMSkpXSA6IFtmcmFnbWVudHNdO1xuXG4gIC8vIENvbnZlcnQgdGhlIHZhbHVlcyB3aXRoIHVuaXRzIHRvIGFic29sdXRlIHBpeGVscyB0byBhbGxvdyBvdXIgY29tcHV0YXRpb25zXG4gIG9wcyA9IG9wcy5tYXAoZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIC8vIE1vc3Qgb2YgdGhlIHVuaXRzIHJlbHkgb24gdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBwb3BwZXJcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSAoaW5kZXggPT09IDEgPyAhdXNlSGVpZ2h0IDogdXNlSGVpZ2h0KSA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICByZXR1cm4gb3BcbiAgICAvLyBUaGlzIGFnZ3JlZ2F0ZXMgYW55IGArYCBvciBgLWAgc2lnbiB0aGF0IGFyZW4ndCBjb25zaWRlcmVkIG9wZXJhdG9yc1xuICAgIC8vIGUuZy46IDEwICsgKzUgPT4gWzEwLCArLCArNV1cbiAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYVthLmxlbmd0aCAtIDFdID09PSAnJyAmJiBbJysnLCAnLSddLmluZGV4T2YoYikgIT09IC0xKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSA9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2UgaWYgKG1lcmdlV2l0aFByZXZpb3VzKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSArPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICAgIH1cbiAgICB9LCBbXSlcbiAgICAvLyBIZXJlIHdlIGNvbnZlcnQgdGhlIHN0cmluZyB2YWx1ZXMgaW50byBudW1iZXIgdmFsdWVzIChpbiBweClcbiAgICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBMb29wIHRyb3VnaCB0aGUgb2Zmc2V0cyBhcnJheXMgYW5kIGV4ZWN1dGUgdGhlIG9wZXJhdGlvbnNcbiAgb3BzLmZvckVhY2goZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIG9wLmZvckVhY2goZnVuY3Rpb24gKGZyYWcsIGluZGV4Mikge1xuICAgICAgaWYgKGlzTnVtZXJpYyhmcmFnKSkge1xuICAgICAgICBvZmZzZXRzW2luZGV4XSArPSBmcmFnICogKG9wW2luZGV4MiAtIDFdID09PSAnLScgPyAtMSA6IDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQGFyZ3VtZW50IHtOdW1iZXJ8U3RyaW5nfSBvcHRpb25zLm9mZnNldD0wXG4gKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gb2Zmc2V0KGRhdGEsIF9yZWYpIHtcbiAgdmFyIG9mZnNldCA9IF9yZWYub2Zmc2V0O1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQsXG4gICAgICBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIHZhciBvZmZzZXRzID0gdm9pZCAwO1xuICBpZiAoaXNOdW1lcmljKCtvZmZzZXQpKSB7XG4gICAgb2Zmc2V0cyA9IFsrb2Zmc2V0LCAwXTtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXRzID0gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYmFzZVBsYWNlbWVudCk7XG4gIH1cblxuICBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0IC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3JpZ2h0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICd0b3AnKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wIC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2JvdHRvbScpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1sxXTtcbiAgfVxuXG4gIGRhdGEucG9wcGVyID0gcG9wcGVyO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGJvdW5kYXJpZXNFbGVtZW50ID0gb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCB8fCBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuXG4gIC8vIElmIG9mZnNldFBhcmVudCBpcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIHJlYWxseSB3YW50IHRvXG4gIC8vIGdvIG9uZSBzdGVwIHVwIGFuZCB1c2UgdGhlIG5leHQgb2Zmc2V0UGFyZW50IGFzIHJlZmVyZW5jZSB0b1xuICAvLyBhdm9pZCB0byBtYWtlIHRoaXMgbW9kaWZpZXIgY29tcGxldGVseSB1c2VsZXNzIGFuZCBsb29rIGxpa2UgYnJva2VuXG4gIGlmIChkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSA9PT0gYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgICBib3VuZGFyaWVzRWxlbWVudCA9IGdldE9mZnNldFBhcmVudChib3VuZGFyaWVzRWxlbWVudCk7XG4gIH1cblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzZXRzIHRoZSBwb3BwZXIncyBwb3NpdGlvbiBzbyB0aGF0IHRoZSBkb2N1bWVudCBzaXplIGNhbiBiZSBjYWxjdWxhdGVkIGV4Y2x1ZGluZ1xuICAvLyB0aGUgc2l6ZSBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgaXRzZWxmXG4gIHZhciB0cmFuc2Zvcm1Qcm9wID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcbiAgdmFyIHBvcHBlclN0eWxlcyA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnN0eWxlOyAvLyBhc3NpZ25tZW50IHRvIGhlbHAgbWluaWZpY2F0aW9uXG4gIHZhciB0b3AgPSBwb3BwZXJTdHlsZXMudG9wLFxuICAgICAgbGVmdCA9IHBvcHBlclN0eWxlcy5sZWZ0LFxuICAgICAgdHJhbnNmb3JtID0gcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdO1xuXG4gIHBvcHBlclN0eWxlcy50b3AgPSAnJztcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSAnJztcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gJyc7XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCwgZGF0YS5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzdG9yZXMgdGhlIG9yaWdpbmFsIHN0eWxlIHByb3BlcnRpZXMgYWZ0ZXIgdGhlIG9mZnNldHMgaGF2ZSBiZWVuIGNvbXB1dGVkXG4gIHBvcHBlclN0eWxlcy50b3AgPSB0b3A7XG4gIHBvcHBlclN0eWxlcy5sZWZ0ID0gbGVmdDtcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtO1xuXG4gIG9wdGlvbnMuYm91bmRhcmllcyA9IGJvdW5kYXJpZXM7XG5cbiAgdmFyIG9yZGVyID0gb3B0aW9ucy5wcmlvcml0eTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgdmFyIGNoZWNrID0ge1xuICAgIHByaW1hcnk6IGZ1bmN0aW9uIHByaW1hcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbcGxhY2VtZW50XTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA8IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5tYXgocG9wcGVyW3BsYWNlbWVudF0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIHBsYWNlbWVudCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2Vjb25kYXJ5OiBmdW5jdGlvbiBzZWNvbmRhcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgbWFpblNpZGUgPSBwbGFjZW1lbnQgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlclttYWluU2lkZV07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPiBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWluKHBvcHBlclttYWluU2lkZV0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSAtIChwbGFjZW1lbnQgPT09ICdyaWdodCcgPyBwb3BwZXIud2lkdGggOiBwb3BwZXIuaGVpZ2h0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIG1haW5TaWRlLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHZhciBzaWRlID0gWydsZWZ0JywgJ3RvcCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTEgPyAncHJpbWFyeScgOiAnc2Vjb25kYXJ5JztcbiAgICBwb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBjaGVja1tzaWRlXShwbGFjZW1lbnQpKTtcbiAgfSk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IHBvcHBlcjtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gc2hpZnQoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBzaGlmdHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIC8vIGlmIHNoaWZ0IHNoaWZ0dmFyaWF0aW9uIGlzIHNwZWNpZmllZCwgcnVuIHRoZSBtb2RpZmllclxuICBpZiAoc2hpZnR2YXJpYXRpb24pIHtcbiAgICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyO1xuXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ2JvdHRvbScsICd0b3AnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gICAgdmFyIHNoaWZ0T2Zmc2V0cyA9IHtcbiAgICAgIHN0YXJ0OiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdKSxcbiAgICAgIGVuZDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVttZWFzdXJlbWVudF0gLSBwb3BwZXJbbWVhc3VyZW1lbnRdKVxuICAgIH07XG5cbiAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgc2hpZnRPZmZzZXRzW3NoaWZ0dmFyaWF0aW9uXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGhpZGUoZGF0YSkge1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2hpZGUnLCAncHJldmVudE92ZXJmbG93JykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciByZWZSZWN0ID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIGJvdW5kID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdwcmV2ZW50T3ZlcmZsb3cnO1xuICB9KS5ib3VuZGFyaWVzO1xuXG4gIGlmIChyZWZSZWN0LmJvdHRvbSA8IGJvdW5kLnRvcCB8fCByZWZSZWN0LmxlZnQgPiBib3VuZC5yaWdodCB8fCByZWZSZWN0LnRvcCA+IGJvdW5kLmJvdHRvbSB8fCByZWZSZWN0LnJpZ2h0IDwgYm91bmQubGVmdCkge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IHRydWU7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gZmFsc2U7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBpbm5lcihkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc0hvcml6ID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIHN1YnRyYWN0TGVuZ3RoID0gWyd0b3AnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPT09IC0xO1xuXG4gIHBvcHBlcltpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCddID0gcmVmZXJlbmNlW2Jhc2VQbGFjZW1lbnRdIC0gKHN1YnRyYWN0TGVuZ3RoID8gcG9wcGVyW2lzSG9yaXogPyAnd2lkdGgnIDogJ2hlaWdodCddIDogMCk7XG5cbiAgZGF0YS5wbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChwb3BwZXIpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIE1vZGlmaWVyIGZ1bmN0aW9uLCBlYWNoIG1vZGlmaWVyIGNhbiBoYXZlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIGFzc2lnbmVkXG4gKiB0byBpdHMgYGZuYCBwcm9wZXJ0eS48YnIgLz5cbiAqIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZSwgdGhpcyBtZWFucyB0aGF0IHlvdSBtdXN0XG4gKiBtYWtlIHN1cmUgdGhleSBhcmUgcGVyZm9ybWFudCBlbm91Z2ggdG8gYXZvaWQgcGVyZm9ybWFuY2UgYm90dGxlbmVja3MuXG4gKlxuICogQGZ1bmN0aW9uIE1vZGlmaWVyRm5cbiAqIEBhcmd1bWVudCB7ZGF0YU9iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5cbi8qKlxuICogTW9kaWZpZXJzIGFyZSBwbHVnaW5zIHVzZWQgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHlvdXIgcG9wcGVycy48YnIgLz5cbiAqIFBvcHBlci5qcyB1c2VzIGEgc2V0IG9mIDkgbW9kaWZpZXJzIHRvIHByb3ZpZGUgYWxsIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXRpZXNcbiAqIG5lZWRlZCBieSB0aGUgbGlicmFyeS5cbiAqXG4gKiBVc3VhbGx5IHlvdSBkb24ndCB3YW50IHRvIG92ZXJyaWRlIHRoZSBgb3JkZXJgLCBgZm5gIGFuZCBgb25Mb2FkYCBwcm9wcy5cbiAqIEFsbCB0aGUgb3RoZXIgcHJvcGVydGllcyBhcmUgY29uZmlndXJhdGlvbnMgdGhhdCBjb3VsZCBiZSB0d2Vha2VkLlxuICogQG5hbWVzcGFjZSBtb2RpZmllcnNcbiAqL1xudmFyIG1vZGlmaWVycyA9IHtcbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gc2hpZnQgdGhlIHBvcHBlciBvbiB0aGUgc3RhcnQgb3IgZW5kIG9mIGl0cyByZWZlcmVuY2VcbiAgICogZWxlbWVudC48YnIgLz5cbiAgICogSXQgd2lsbCByZWFkIHRoZSB2YXJpYXRpb24gb2YgdGhlIGBwbGFjZW1lbnRgIHByb3BlcnR5LjxiciAvPlxuICAgKiBJdCBjYW4gYmUgb25lIGVpdGhlciBgLWVuZGAgb3IgYC1zdGFydGAuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBzaGlmdDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0xMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDEwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHNoaWZ0XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBgb2Zmc2V0YCBtb2RpZmllciBjYW4gc2hpZnQgeW91ciBwb3BwZXIgb24gYm90aCBpdHMgYXhpcy5cbiAgICpcbiAgICogSXQgYWNjZXB0cyB0aGUgZm9sbG93aW5nIHVuaXRzOlxuICAgKiAtIGBweGAgb3IgdW5pdC1sZXNzLCBpbnRlcnByZXRlZCBhcyBwaXhlbHNcbiAgICogLSBgJWAgb3IgYCVyYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICAgKiAtIGAlcGAsIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogLSBgdndgLCBDU1Mgdmlld3BvcnQgd2lkdGggdW5pdFxuICAgKiAtIGB2aGAsIENTUyB2aWV3cG9ydCBoZWlnaHQgdW5pdFxuICAgKlxuICAgKiBGb3IgbGVuZ3RoIGlzIGludGVuZGVkIHRoZSBtYWluIGF4aXMgcmVsYXRpdmUgdG8gdGhlIHBsYWNlbWVudCBvZiB0aGUgcG9wcGVyLjxiciAvPlxuICAgKiBUaGlzIG1lYW5zIHRoYXQgaWYgdGhlIHBsYWNlbWVudCBpcyBgdG9wYCBvciBgYm90dG9tYCwgdGhlIGxlbmd0aCB3aWxsIGJlIHRoZVxuICAgKiBgd2lkdGhgLiBJbiBjYXNlIG9mIGBsZWZ0YCBvciBgcmlnaHRgLCBpdCB3aWxsIGJlIHRoZSBgaGVpZ2h0YC5cbiAgICpcbiAgICogWW91IGNhbiBwcm92aWRlIGEgc2luZ2xlIHZhbHVlIChhcyBgTnVtYmVyYCBvciBgU3RyaW5nYCksIG9yIGEgcGFpciBvZiB2YWx1ZXNcbiAgICogYXMgYFN0cmluZ2AgZGl2aWRlZCBieSBhIGNvbW1hIG9yIG9uZSAob3IgbW9yZSkgd2hpdGUgc3BhY2VzLjxiciAvPlxuICAgKiBUaGUgbGF0dGVyIGlzIGEgZGVwcmVjYXRlZCBtZXRob2QgYmVjYXVzZSBpdCBsZWFkcyB0byBjb25mdXNpb24gYW5kIHdpbGwgYmVcbiAgICogcmVtb3ZlZCBpbiB2Mi48YnIgLz5cbiAgICogQWRkaXRpb25hbGx5LCBpdCBhY2NlcHRzIGFkZGl0aW9ucyBhbmQgc3VidHJhY3Rpb25zIGJldHdlZW4gZGlmZmVyZW50IHVuaXRzLlxuICAgKiBOb3RlIHRoYXQgbXVsdGlwbGljYXRpb25zIGFuZCBkaXZpc2lvbnMgYXJlbid0IHN1cHBvcnRlZC5cbiAgICpcbiAgICogVmFsaWQgZXhhbXBsZXMgYXJlOlxuICAgKiBgYGBcbiAgICogMTBcbiAgICogJzEwJSdcbiAgICogJzEwLCAxMCdcbiAgICogJzEwJSwgMTAnXG4gICAqICcxMCArIDEwJSdcbiAgICogJzEwIC0gNXZoICsgMyUnXG4gICAqICctMTBweCArIDV2aCwgNXB4IC0gNiUnXG4gICAqIGBgYFxuICAgKiA+ICoqTkIqKjogSWYgeW91IGRlc2lyZSB0byBhcHBseSBvZmZzZXRzIHRvIHlvdXIgcG9wcGVycyBpbiBhIHdheSB0aGF0IG1heSBtYWtlIHRoZW0gb3ZlcmxhcFxuICAgKiA+IHdpdGggdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnQsIHVuZm9ydHVuYXRlbHksIHlvdSB3aWxsIGhhdmUgdG8gZGlzYWJsZSB0aGUgYGZsaXBgIG1vZGlmaWVyLlxuICAgKiA+IFlvdSBjYW4gcmVhZCBtb3JlIG9uIHRoaXMgYXQgdGhpcyBbaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9GZXpWcmFzdGEvcG9wcGVyLmpzL2lzc3Vlcy8zNzMpLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgb2Zmc2V0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTIwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogb2Zmc2V0LFxuICAgIC8qKiBAcHJvcCB7TnVtYmVyfFN0cmluZ30gb2Zmc2V0PTBcbiAgICAgKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBvZmZzZXQ6IDBcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBwcmV2ZW50IHRoZSBwb3BwZXIgZnJvbSBiZWluZyBwb3NpdGlvbmVkIG91dHNpZGUgdGhlIGJvdW5kYXJ5LlxuICAgKlxuICAgKiBBIHNjZW5hcmlvIGV4aXN0cyB3aGVyZSB0aGUgcmVmZXJlbmNlIGl0c2VsZiBpcyBub3Qgd2l0aGluIHRoZSBib3VuZGFyaWVzLjxiciAvPlxuICAgKiBXZSBjYW4gc2F5IGl0IGhhcyBcImVzY2FwZWQgdGhlIGJvdW5kYXJpZXNcIiDigJQgb3IganVzdCBcImVzY2FwZWRcIi48YnIgLz5cbiAgICogSW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHBvcHBlciBzaG91bGQgZWl0aGVyOlxuICAgKlxuICAgKiAtIGRldGFjaCBmcm9tIHRoZSByZWZlcmVuY2UgYW5kIHJlbWFpbiBcInRyYXBwZWRcIiBpbiB0aGUgYm91bmRhcmllcywgb3JcbiAgICogLSBpZiBpdCBzaG91bGQgaWdub3JlIHRoZSBib3VuZGFyeSBhbmQgXCJlc2NhcGUgd2l0aCBpdHMgcmVmZXJlbmNlXCJcbiAgICpcbiAgICogV2hlbiBgZXNjYXBlV2l0aFJlZmVyZW5jZWAgaXMgc2V0IHRvYHRydWVgIGFuZCByZWZlcmVuY2UgaXMgY29tcGxldGVseVxuICAgKiBvdXRzaWRlIGl0cyBib3VuZGFyaWVzLCB0aGUgcG9wcGVyIHdpbGwgb3ZlcmZsb3cgKG9yIGNvbXBsZXRlbHkgbGVhdmUpXG4gICAqIHRoZSBib3VuZGFyaWVzIGluIG9yZGVyIHRvIHJlbWFpbiBhdHRhY2hlZCB0byB0aGUgZWRnZSBvZiB0aGUgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgcHJldmVudE92ZXJmbG93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTMwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogcHJldmVudE92ZXJmbG93LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtBcnJheX0gW3ByaW9yaXR5PVsnbGVmdCcsJ3JpZ2h0JywndG9wJywnYm90dG9tJ11dXG4gICAgICogUG9wcGVyIHdpbGwgdHJ5IHRvIHByZXZlbnQgb3ZlcmZsb3cgZm9sbG93aW5nIHRoZXNlIHByaW9yaXRpZXMgYnkgZGVmYXVsdCxcbiAgICAgKiB0aGVuLCBpdCBjb3VsZCBvdmVyZmxvdyBvbiB0aGUgbGVmdCBhbmQgb24gdG9wIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcHJpb3JpdHk6IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ10sXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogQW1vdW50IG9mIHBpeGVsIHVzZWQgdG8gZGVmaW5lIGEgbWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib3VuZGFyaWVzXG4gICAgICogYW5kIHRoZSBwb3BwZXIuIFRoaXMgbWFrZXMgc3VyZSB0aGUgcG9wcGVyIGFsd2F5cyBoYXMgYSBsaXR0bGUgcGFkZGluZ1xuICAgICAqIGJldHdlZW4gdGhlIGVkZ2VzIG9mIGl0cyBjb250YWluZXJcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSdzY3JvbGxQYXJlbnQnXG4gICAgICogQm91bmRhcmllcyB1c2VkIGJ5IHRoZSBtb2RpZmllci4gQ2FuIGJlIGBzY3JvbGxQYXJlbnRgLCBgd2luZG93YCxcbiAgICAgKiBgdmlld3BvcnRgIG9yIGFueSBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3Njcm9sbFBhcmVudCdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHN1cmUgdGhlIHJlZmVyZW5jZSBhbmQgaXRzIHBvcHBlciBzdGF5IG5lYXIgZWFjaCBvdGhlclxuICAgKiB3aXRob3V0IGxlYXZpbmcgYW55IGdhcCBiZXR3ZWVuIHRoZSB0d28uIEVzcGVjaWFsbHkgdXNlZnVsIHdoZW4gdGhlIGFycm93IGlzXG4gICAqIGVuYWJsZWQgYW5kIHlvdSB3YW50IHRvIGVuc3VyZSB0aGF0IGl0IHBvaW50cyB0byBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEl0IGNhcmVzIG9ubHkgYWJvdXQgdGhlIGZpcnN0IGF4aXMuIFlvdSBjYW4gc3RpbGwgaGF2ZSBwb3BwZXJzIHdpdGggbWFyZ2luXG4gICAqIGJldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAga2VlcFRvZ2V0aGVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTQwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNDAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjoga2VlcFRvZ2V0aGVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgbW9kaWZpZXIgaXMgdXNlZCB0byBtb3ZlIHRoZSBgYXJyb3dFbGVtZW50YCBvZiB0aGUgcG9wcGVyIHRvIG1ha2VcbiAgICogc3VyZSBpdCBpcyBwb3NpdGlvbmVkIGJldHdlZW4gdGhlIHJlZmVyZW5jZSBlbGVtZW50IGFuZCBpdHMgcG9wcGVyIGVsZW1lbnQuXG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgb3V0ZXIgc2l6ZSBvZiB0aGUgYGFycm93RWxlbWVudGAgbm9kZSB0byBkZXRlY3QgaG93IG1hbnlcbiAgICogcGl4ZWxzIG9mIGNvbmp1bmN0aW9uIGFyZSBuZWVkZWQuXG4gICAqXG4gICAqIEl0IGhhcyBubyBlZmZlY3QgaWYgbm8gYGFycm93RWxlbWVudGAgaXMgcHJvdmlkZWQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcnJvdzoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj01MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDUwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFycm93LFxuICAgIC8qKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBlbGVtZW50PSdbeC1hcnJvd10nIC0gU2VsZWN0b3Igb3Igbm9kZSB1c2VkIGFzIGFycm93ICovXG4gICAgZWxlbWVudDogJ1t4LWFycm93XSdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBmbGlwIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQgd2hlbiBpdCBzdGFydHMgdG8gb3ZlcmxhcCBpdHNcbiAgICogcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICpcbiAgICogKipOT1RFOioqIHRoaXMgbW9kaWZpZXIgd2lsbCBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlIGFuZCB3aWxsXG4gICAqIHJlc3RhcnQgaXQgaWYgaXQgZGV0ZWN0cyB0aGUgbmVlZCB0byBmbGlwIHRoZSBwbGFjZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBmbGlwOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTYwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogZmxpcCxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEFycmF5fSBiZWhhdmlvcj0nZmxpcCdcbiAgICAgKiBUaGUgYmVoYXZpb3IgdXNlZCB0byBjaGFuZ2UgdGhlIHBvcHBlcidzIHBsYWNlbWVudC4gSXQgY2FuIGJlIG9uZSBvZlxuICAgICAqIGBmbGlwYCwgYGNsb2Nrd2lzZWAsIGBjb3VudGVyY2xvY2t3aXNlYCBvciBhbiBhcnJheSB3aXRoIGEgbGlzdCBvZiB2YWxpZFxuICAgICAqIHBsYWNlbWVudHMgKHdpdGggb3B0aW9uYWwgdmFyaWF0aW9ucylcbiAgICAgKi9cbiAgICBiZWhhdmlvcjogJ2ZsaXAnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBmbGlwIGlmIGl0IGhpdHMgdGhlIGVkZ2VzIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0ndmlld3BvcnQnXG4gICAgICogVGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBkZWZpbmUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHBvcHBlciBwb3NpdGlvbi5cbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgbmV2ZXIgYmUgcGxhY2VkIG91dHNpZGUgb2YgdGhlIGRlZmluZWQgYm91bmRhcmllc1xuICAgICAqIChleGNlcHQgaWYgYGtlZXBUb2dldGhlcmAgaXMgZW5hYmxlZClcbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3ZpZXdwb3J0JyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZmxpcFZhcmlhdGlvbnM9ZmFsc2VcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgc3dpdGNoIHBsYWNlbWVudCB2YXJpYXRpb24gYmV0d2VlbiBgLXN0YXJ0YCBhbmQgYC1lbmRgIHdoZW5cbiAgICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgb3ZlcmxhcHMgaXRzIGJvdW5kYXJpZXMuXG4gICAgICpcbiAgICAgKiBUaGUgb3JpZ2luYWwgcGxhY2VtZW50IHNob3VsZCBoYXZlIGEgc2V0IHZhcmlhdGlvbi5cbiAgICAgKi9cbiAgICBmbGlwVmFyaWF0aW9uczogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGZsaXBWYXJpYXRpb25zQnlDb250ZW50PWZhbHNlXG4gICAgICogVGhlIHBvcHBlciB3aWxsIHN3aXRjaCBwbGFjZW1lbnQgdmFyaWF0aW9uIGJldHdlZW4gYC1zdGFydGAgYW5kIGAtZW5kYCB3aGVuXG4gICAgICogdGhlIHBvcHBlciBlbGVtZW50IG92ZXJsYXBzIGl0cyByZWZlcmVuY2UgYm91bmRhcmllcy5cbiAgICAgKlxuICAgICAqIFRoZSBvcmlnaW5hbCBwbGFjZW1lbnQgc2hvdWxkIGhhdmUgYSBzZXQgdmFyaWF0aW9uLlxuICAgICAqL1xuICAgIGZsaXBWYXJpYXRpb25zQnlDb250ZW50OiBmYWxzZVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2UgdGhlIHBvcHBlciBmbG93IHRvd2FyZCB0aGUgaW5uZXIgb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBCeSBkZWZhdWx0LCB3aGVuIHRoaXMgbW9kaWZpZXIgaXMgZGlzYWJsZWQsIHRoZSBwb3BwZXIgd2lsbCBiZSBwbGFjZWQgb3V0c2lkZVxuICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBpbm5lcjoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj03MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDcwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9ZmFsc2UgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaW5uZXJcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBoaWRlIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0c2lkZSBvZiB0aGVcbiAgICogcG9wcGVyIGJvdW5kYXJpZXMuIEl0IHdpbGwgc2V0IGEgYHgtb3V0LW9mLWJvdW5kYXJpZXNgIGF0dHJpYnV0ZSB3aGljaCBjYW5cbiAgICogYmUgdXNlZCB0byBoaWRlIHdpdGggYSBDU1Mgc2VsZWN0b3IgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgaXNcbiAgICogb3V0IG9mIGJvdW5kYXJpZXMuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGhpZGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBoaWRlXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBzdHlsZSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGVsZW1lbnQgdG8gZ2V0c1xuICAgKiBwcm9wZXJseSBwb3NpdGlvbmVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBtb2RpZmllciB3aWxsIG5vdCB0b3VjaCB0aGUgRE9NLCBpdCBqdXN0IHByZXBhcmVzIHRoZSBzdHlsZXNcbiAgICogc28gdGhhdCBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgY2FuIGFwcGx5IGl0LiBUaGlzIHNlcGFyYXRpb24gaXMgdXNlZnVsXG4gICAqIGluIGNhc2UgeW91IG5lZWQgdG8gcmVwbGFjZSBgYXBwbHlTdHlsZWAgd2l0aCBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtb2RpZmllciBoYXMgYDg1MGAgYXMgYG9yZGVyYCB2YWx1ZSB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAqIHdpdGggcHJldmlvdXMgdmVyc2lvbnMgb2YgUG9wcGVyLmpzLiBFeHBlY3QgdGhlIG1vZGlmaWVycyBvcmRlcmluZyBtZXRob2RcbiAgICogdG8gY2hhbmdlIGluIGZ1dHVyZSBtYWpvciB2ZXJzaW9ucyBvZiB0aGUgbGlicmFyeS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGNvbXB1dGVTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04NTAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDg1MCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGNvbXB1dGVTdHlsZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM0QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHRydWUsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2JvdHRvbSddXG4gICAgICogV2hlcmUgdG8gYW5jaG9yIHRoZSBYIGF4aXMgKGBib3R0b21gIG9yIGB0b3BgKS4gQUtBIFggb2Zmc2V0IG9yaWdpbi5cbiAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgYm90dG9tYFxuICAgICAqL1xuICAgIHg6ICdib3R0b20nLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdsZWZ0J11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFkgYXhpcyAoYGxlZnRgIG9yIGByaWdodGApLiBBS0EgWSBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGByaWdodGBcbiAgICAgKi9cbiAgICB5OiAncmlnaHQnXG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGNvbXB1dGVkIHN0eWxlcyB0byB0aGUgcG9wcGVyIGVsZW1lbnQuXG4gICAqXG4gICAqIEFsbCB0aGUgRE9NIG1hbmlwdWxhdGlvbnMgYXJlIGxpbWl0ZWQgdG8gdGhpcyBtb2RpZmllci4gVGhpcyBpcyB1c2VmdWwgaW4gY2FzZVxuICAgKiB5b3Ugd2FudCB0byBpbnRlZ3JhdGUgUG9wcGVyLmpzIGluc2lkZSBhIGZyYW1ld29yayBvciB2aWV3IGxpYnJhcnkgYW5kIHlvdVxuICAgKiB3YW50IHRvIGRlbGVnYXRlIGFsbCB0aGUgRE9NIG1hbmlwdWxhdGlvbnMgdG8gaXQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpZiB5b3UgZGlzYWJsZSB0aGlzIG1vZGlmaWVyLCB5b3UgbXVzdCBtYWtlIHN1cmUgdGhlIHBvcHBlciBlbGVtZW50XG4gICAqIGhhcyBpdHMgcG9zaXRpb24gc2V0IHRvIGBhYnNvbHV0ZWAgYmVmb3JlIFBvcHBlci5qcyBjYW4gZG8gaXRzIHdvcmshXG4gICAqXG4gICAqIEp1c3QgZGlzYWJsZSB0aGlzIG1vZGlmaWVyIGFuZCBkZWZpbmUgeW91ciBvd24gdG8gYWNoaWV2ZSB0aGUgZGVzaXJlZCBlZmZlY3QuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcHBseVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTkwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogOTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXBwbHlTdHlsZSxcbiAgICAvKiogQHByb3Age0Z1bmN0aW9ufSAqL1xuICAgIG9uTG9hZDogYXBwbHlTdHlsZU9uTG9hZCxcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMTAuMCwgdGhlIHByb3BlcnR5IG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNEIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiB1bmRlZmluZWRcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgYGRhdGFPYmplY3RgIGlzIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgaW5mb3JtYXRpb24gdXNlZCBieSBQb3BwZXIuanMuXG4gKiBUaGlzIG9iamVjdCBpcyBwYXNzZWQgdG8gbW9kaWZpZXJzIGFuZCB0byB0aGUgYG9uQ3JlYXRlYCBhbmQgYG9uVXBkYXRlYCBjYWxsYmFja3MuXG4gKiBAbmFtZSBkYXRhT2JqZWN0XG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5pbnN0YW5jZSBUaGUgUG9wcGVyLmpzIGluc3RhbmNlXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5wbGFjZW1lbnQgUGxhY2VtZW50IGFwcGxpZWQgdG8gcG9wcGVyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCBQbGFjZW1lbnQgb3JpZ2luYWxseSBkZWZpbmVkIG9uIGluaXRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5mbGlwcGVkIFRydWUgaWYgcG9wcGVyIGhhcyBiZWVuIGZsaXBwZWQgYnkgZmxpcCBtb2RpZmllclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmhpZGUgVHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0IG9mIGJvdW5kYXJpZXMsIHVzZWZ1bCB0byBrbm93IHdoZW4gdG8gaGlkZSB0aGUgcG9wcGVyXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBkYXRhLmFycm93RWxlbWVudCBOb2RlIHVzZWQgYXMgYXJyb3cgYnkgYXJyb3cgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLnN0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci4gSXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmFycm93U3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGFycm93LiBJdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYm91bmRhcmllcyBPZmZzZXRzIG9mIHRoZSBwb3BwZXIgYm91bmRhcmllc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cyBUaGUgbWVhc3VyZW1lbnRzIG9mIHBvcHBlciwgcmVmZXJlbmNlIGFuZCBhcnJvdyBlbGVtZW50c1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5wb3BwZXIgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMuYXJyb3ddIGB0b3BgIGFuZCBgbGVmdGAgb2Zmc2V0cywgb25seSBvbmUgb2YgdGhlbSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIDBcbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBwcm92aWRlZCB0byBQb3BwZXIuanMgY29uc3RydWN0b3IuPGJyIC8+XG4gKiBUaGVzZSBjYW4gYmUgb3ZlcnJpZGRlbiB1c2luZyB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50IG9mIFBvcHBlci5qcy48YnIgLz5cbiAqIFRvIG92ZXJyaWRlIGFuIG9wdGlvbiwgc2ltcGx5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWVcbiAqIHN0cnVjdHVyZSBvZiB0aGUgYG9wdGlvbnNgIG9iamVjdCwgYXMgdGhlIDNyZCBhcmd1bWVudC4gRm9yIGV4YW1wbGU6XG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmLCBwb3AsIHtcbiAqICAgbW9kaWZpZXJzOiB7XG4gKiAgICAgcHJldmVudE92ZXJmbG93OiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICogQHR5cGUge09iamVjdH1cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIERlZmF1bHRzID0ge1xuICAvKipcbiAgICogUG9wcGVyJ3MgcGxhY2VtZW50LlxuICAgKiBAcHJvcCB7UG9wcGVyLnBsYWNlbWVudHN9IHBsYWNlbWVudD0nYm90dG9tJ1xuICAgKi9cbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcblxuICAvKipcbiAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3Ugd2FudCBwb3BwZXIgdG8gcG9zaXRpb24gaXQgc2VsZiBpbiAnZml4ZWQnIG1vZGVcbiAgICogQHByb3Age0Jvb2xlYW59IHBvc2l0aW9uRml4ZWQ9ZmFsc2VcbiAgICovXG4gIHBvc2l0aW9uRml4ZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGV2ZW50cyAocmVzaXplLCBzY3JvbGwpIGFyZSBpbml0aWFsbHkgZW5hYmxlZC5cbiAgICogQHByb3Age0Jvb2xlYW59IGV2ZW50c0VuYWJsZWQ9dHJ1ZVxuICAgKi9cbiAgZXZlbnRzRW5hYmxlZDogdHJ1ZSxcblxuICAvKipcbiAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSByZW1vdmUgdGhlIHBvcHBlciB3aGVuXG4gICAqIHlvdSBjYWxsIHRoZSBgZGVzdHJveWAgbWV0aG9kLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcmVtb3ZlT25EZXN0cm95PWZhbHNlXG4gICAqL1xuICByZW1vdmVPbkRlc3Ryb3k6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIGNyZWF0ZWQuPGJyIC8+XG4gICAqIEJ5IGRlZmF1bHQsIGl0IGlzIHNldCB0byBuby1vcC48YnIgLz5cbiAgICogQWNjZXNzIFBvcHBlci5qcyBpbnN0YW5jZSB3aXRoIGBkYXRhLmluc3RhbmNlYC5cbiAgICogQHByb3Age29uQ3JlYXRlfVxuICAgKi9cbiAgb25DcmVhdGU6IGZ1bmN0aW9uIG9uQ3JlYXRlKCkge30sXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgdXBkYXRlZC4gVGhpcyBjYWxsYmFjayBpcyBub3QgY2FsbGVkXG4gICAqIG9uIHRoZSBpbml0aWFsaXphdGlvbi9jcmVhdGlvbiBvZiB0aGUgcG9wcGVyLCBidXQgb25seSBvbiBzdWJzZXF1ZW50XG4gICAqIHVwZGF0ZXMuPGJyIC8+XG4gICAqIEJ5IGRlZmF1bHQsIGl0IGlzIHNldCB0byBuby1vcC48YnIgLz5cbiAgICogQWNjZXNzIFBvcHBlci5qcyBpbnN0YW5jZSB3aXRoIGBkYXRhLmluc3RhbmNlYC5cbiAgICogQHByb3Age29uVXBkYXRlfVxuICAgKi9cbiAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKCkge30sXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgbW9kaWZpZXJzIHVzZWQgdG8gbW9kaWZ5IHRoZSBvZmZzZXRzIGJlZm9yZSB0aGV5IGFyZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIuXG4gICAqIFRoZXkgcHJvdmlkZSBtb3N0IG9mIHRoZSBmdW5jdGlvbmFsaXRpZXMgb2YgUG9wcGVyLmpzLlxuICAgKiBAcHJvcCB7bW9kaWZpZXJzfVxuICAgKi9cbiAgbW9kaWZpZXJzOiBtb2RpZmllcnNcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIG9uQ3JlYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBvblVwZGF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLy8gVXRpbHNcbi8vIE1ldGhvZHNcbnZhciBQb3BwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFBvcHBlci5qcyBpbnN0YW5jZS5cbiAgICogQGNsYXNzIFBvcHBlclxuICAgKiBAcGFyYW0ge0VsZW1lbnR8cmVmZXJlbmNlT2JqZWN0fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgLyBYTUwgZWxlbWVudCB1c2VkIGFzIHRoZSBwb3BwZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBZb3VyIGN1c3RvbSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBvbmVzIGRlZmluZWQgaW4gW0RlZmF1bHRzXSgjZGVmYXVsdHMpXG4gICAqIEByZXR1cm4ge09iamVjdH0gaW5zdGFuY2UgLSBUaGUgZ2VuZXJhdGVkIFBvcHBlci5qcyBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQb3BwZXIpO1xuXG4gICAgdGhpcy5zY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3RoaXMudXBkYXRlKTtcbiAgICB9O1xuXG4gICAgLy8gbWFrZSB1cGRhdGUoKSBkZWJvdW5jZWQsIHNvIHRoYXQgaXQgb25seSBydW5zIGF0IG1vc3Qgb25jZS1wZXItdGlja1xuICAgIHRoaXMudXBkYXRlID0gZGVib3VuY2UodGhpcy51cGRhdGUuYmluZCh0aGlzKSk7XG5cbiAgICAvLyB3aXRoIHt9IHdlIGNyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgb3B0aW9ucyBpbnNpZGUgaXRcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgIC8vIGluaXQgc3RhdGVcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaXNEZXN0cm95ZWQ6IGZhbHNlLFxuICAgICAgaXNDcmVhdGVkOiBmYWxzZSxcbiAgICAgIHNjcm9sbFBhcmVudHM6IFtdXG4gICAgfTtcblxuICAgIC8vIGdldCByZWZlcmVuY2UgYW5kIHBvcHBlciBlbGVtZW50cyAoYWxsb3cgalF1ZXJ5IHdyYXBwZXJzKVxuICAgIHRoaXMucmVmZXJlbmNlID0gcmVmZXJlbmNlICYmIHJlZmVyZW5jZS5qcXVlcnkgPyByZWZlcmVuY2VbMF0gOiByZWZlcmVuY2U7XG4gICAgdGhpcy5wb3BwZXIgPSBwb3BwZXIgJiYgcG9wcGVyLmpxdWVyeSA/IHBvcHBlclswXSA6IHBvcHBlcjtcblxuICAgIC8vIERlZXAgbWVyZ2UgbW9kaWZpZXJzIG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMubW9kaWZpZXJzID0ge307XG4gICAgT2JqZWN0LmtleXMoX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnMsIG9wdGlvbnMubW9kaWZpZXJzKSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gPSBfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLm1vZGlmaWVyc1tuYW1lXSB8fCB7fSwgb3B0aW9ucy5tb2RpZmllcnMgPyBvcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA6IHt9KTtcbiAgICB9KTtcblxuICAgIC8vIFJlZmFjdG9yaW5nIG1vZGlmaWVycycgbGlzdCAoT2JqZWN0ID0+IEFycmF5KVxuICAgIHRoaXMubW9kaWZpZXJzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zLm1vZGlmaWVycykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9LCBfdGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSk7XG4gICAgfSlcbiAgICAvLyBzb3J0IHRoZSBtb2RpZmllcnMgYnkgb3JkZXJcbiAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEub3JkZXIgLSBiLm9yZGVyO1xuICAgIH0pO1xuXG4gICAgLy8gbW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSB3aGVuIFBvcHBlci5qcyBnZXQgaW5pdGVkXG4gICAgLy8gc3VjaCBjb2RlIGlzIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIG9mIGl0cyBtb2RpZmllclxuICAgIC8vIHRoZXkgY291bGQgYWRkIG5ldyBwcm9wZXJ0aWVzIHRvIHRoZWlyIG9wdGlvbnMgY29uZmlndXJhdGlvblxuICAgIC8vIEJFIEFXQVJFOiBkb24ndCBhZGQgb3B0aW9ucyB0byBgb3B0aW9ucy5tb2RpZmllcnMubmFtZWAgYnV0IHRvIGBtb2RpZmllck9wdGlvbnNgIVxuICAgIHRoaXMubW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyT3B0aW9ucykge1xuICAgICAgaWYgKG1vZGlmaWVyT3B0aW9ucy5lbmFibGVkICYmIGlzRnVuY3Rpb24obW9kaWZpZXJPcHRpb25zLm9uTG9hZCkpIHtcbiAgICAgICAgbW9kaWZpZXJPcHRpb25zLm9uTG9hZChfdGhpcy5yZWZlcmVuY2UsIF90aGlzLnBvcHBlciwgX3RoaXMub3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBfdGhpcy5zdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBmaXJlIHRoZSBmaXJzdCB1cGRhdGUgdG8gcG9zaXRpb24gdGhlIHBvcHBlciBpbiB0aGUgcmlnaHQgcGxhY2VcbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgdmFyIGV2ZW50c0VuYWJsZWQgPSB0aGlzLm9wdGlvbnMuZXZlbnRzRW5hYmxlZDtcbiAgICBpZiAoZXZlbnRzRW5hYmxlZCkge1xuICAgICAgLy8gc2V0dXAgZXZlbnQgbGlzdGVuZXJzLCB0aGV5IHdpbGwgdGFrZSBjYXJlIG9mIHVwZGF0ZSB0aGUgcG9zaXRpb24gaW4gc3BlY2lmaWMgc2l0dWF0aW9uc1xuICAgICAgdGhpcy5lbmFibGVFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGV2ZW50c0VuYWJsZWQ7XG4gIH1cblxuICAvLyBXZSBjYW4ndCB1c2UgY2xhc3MgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgZG9uJ3QgZ2V0IGxpc3RlZCBpbiB0aGVcbiAgLy8gY2xhc3MgcHJvdG90eXBlIGFuZCBicmVhayBzdHVmZiBsaWtlIFNpbm9uIHN0dWJzXG5cblxuICBjcmVhdGVDbGFzcyhQb3BwZXIsIFt7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlJCQxKCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95JCQxKCkge1xuICAgICAgcmV0dXJuIGRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbmFibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzJCQxKCkge1xuICAgICAgcmV0dXJuIGVuYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGlzYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZUV2ZW50TGlzdGVuZXJzJCQxKCkge1xuICAgICAgcmV0dXJuIGRpc2FibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhbiB1cGRhdGUuIEl0IHdpbGwgcnVuIG9uIHRoZSBuZXh0IFVJIHVwZGF0ZSBhdmFpbGFibGUuXG4gICAgICogQG1ldGhvZCBzY2hlZHVsZVVwZGF0ZVxuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgICogQ29sbGVjdGlvbiBvZiB1dGlsaXRpZXMgdXNlZnVsIHdoZW4gd3JpdGluZyBjdXN0b20gbW9kaWZpZXJzLlxuICAgICAqIFN0YXJ0aW5nIGZyb20gdmVyc2lvbiAxLjcsIHRoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBvbmx5IGlmIHlvdVxuICAgICAqIGluY2x1ZGUgYHBvcHBlci11dGlscy5qc2AgYmVmb3JlIGBwb3BwZXIuanNgLlxuICAgICAqXG4gICAgICogKipERVBSRUNBVElPTioqOiBUaGlzIHdheSB0byBhY2Nlc3MgUG9wcGVyVXRpbHMgaXMgZGVwcmVjYXRlZFxuICAgICAqIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjIhIFVzZSB0aGUgUG9wcGVyVXRpbHMgbW9kdWxlIGRpcmVjdGx5IGluc3RlYWQuXG4gICAgICogRHVlIHRvIHRoZSBoaWdoIGluc3RhYmlsaXR5IG9mIHRoZSBtZXRob2RzIGNvbnRhaW5lZCBpbiBVdGlscywgd2UgY2FuJ3RcbiAgICAgKiBndWFyYW50ZWUgdGhlbSB0byBmb2xsb3cgc2VtdmVyLiBVc2UgdGhlbSBhdCB5b3VyIG93biByaXNrIVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjhcbiAgICAgKiBAbWVtYmVyIFV0aWxzXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG4gIH1dKTtcbiAgcmV0dXJuIFBvcHBlcjtcbn0oKTtcblxuLyoqXG4gKiBUaGUgYHJlZmVyZW5jZU9iamVjdGAgaXMgYW4gb2JqZWN0IHRoYXQgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGNvbXBhdGlibGUgd2l0aCBQb3BwZXIuanNcbiAqIGFuZCBsZXRzIHlvdSB1c2UgaXQgYXMgcmVwbGFjZW1lbnQgb2YgYSByZWFsIERPTSBub2RlLjxiciAvPlxuICogWW91IGNhbiB1c2UgdGhpcyBtZXRob2QgdG8gcG9zaXRpb24gYSBwb3BwZXIgcmVsYXRpdmVseSB0byBhIHNldCBvZiBjb29yZGluYXRlc1xuICogaW4gY2FzZSB5b3UgZG9uJ3QgaGF2ZSBhIERPTSBub2RlIHRvIHVzZSBhcyByZWZlcmVuY2UuXG4gKlxuICogYGBgXG4gKiBuZXcgUG9wcGVyKHJlZmVyZW5jZU9iamVjdCwgcG9wcGVyTm9kZSk7XG4gKiBgYGBcbiAqXG4gKiBOQjogVGhpcyBmZWF0dXJlIGlzbid0IHN1cHBvcnRlZCBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMC5cbiAqIEBuYW1lIHJlZmVyZW5jZU9iamVjdFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZGF0YS5nZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2V0IG9mIGNvb3JkaW5hdGVzIGNvbXBhdGlibGUgd2l0aCB0aGUgbmF0aXZlIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgIG1ldGhvZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudFdpZHRoXG4gKiBBbiBFUzYgZ2V0dGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGEuY2xpZW50SGVpZ2h0XG4gKiBBbiBFUzYgZ2V0dGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIGhlaWdodCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqL1xuXG5cblBvcHBlci5VdGlscyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCkuUG9wcGVyVXRpbHM7XG5Qb3BwZXIucGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG5Qb3BwZXIuRGVmYXVsdHMgPSBEZWZhdWx0cztcblxuZXhwb3J0IGRlZmF1bHQgUG9wcGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9wcGVyLmpzLm1hcFxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC42LjApOiBkcm9wZG93bi5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSdcbmltcG9ydCBQb3BwZXIgZnJvbSAncG9wcGVyLmpzJ1xuaW1wb3J0IFV0aWwgZnJvbSAnLi91dGlsJ1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FID0gJ2Ryb3Bkb3duJ1xuY29uc3QgVkVSU0lPTiA9ICc0LjYuMCdcbmNvbnN0IERBVEFfS0VZID0gJ2JzLmRyb3Bkb3duJ1xuY29uc3QgRVZFTlRfS0VZID0gYC4ke0RBVEFfS0VZfWBcbmNvbnN0IERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknXG5jb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdXG5jb25zdCBFU0NBUEVfS0VZQ09ERSA9IDI3IC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIEVzY2FwZSAoRXNjKSBrZXlcbmNvbnN0IFNQQUNFX0tFWUNPREUgPSAzMiAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBzcGFjZSBrZXlcbmNvbnN0IFRBQl9LRVlDT0RFID0gOSAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciB0YWIga2V5XG5jb25zdCBBUlJPV19VUF9LRVlDT0RFID0gMzggLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgdXAgYXJyb3cga2V5XG5jb25zdCBBUlJPV19ET1dOX0tFWUNPREUgPSA0MCAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBkb3duIGFycm93IGtleVxuY29uc3QgUklHSFRfTU9VU0VfQlVUVE9OX1dISUNIID0gMyAvLyBNb3VzZUV2ZW50LndoaWNoIHZhbHVlIGZvciB0aGUgcmlnaHQgYnV0dG9uIChhc3N1bWluZyBhIHJpZ2h0LWhhbmRlZCBtb3VzZSlcbmNvbnN0IFJFR0VYUF9LRVlET1dOID0gbmV3IFJlZ0V4cChgJHtBUlJPV19VUF9LRVlDT0RFfXwke0FSUk9XX0RPV05fS0VZQ09ERX18JHtFU0NBUEVfS0VZQ09ERX1gKVxuXG5jb25zdCBFVkVOVF9ISURFID0gYGhpZGUke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9ISURERU4gPSBgaGlkZGVuJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0hPVyA9IGBzaG93JHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0hPV04gPSBgc2hvd24ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9DTElDSyA9IGBjbGljayR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gYGNsaWNrJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuY29uc3QgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSA9IGBrZXlkb3duJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuY29uc3QgRVZFTlRfS0VZVVBfREFUQV9BUEkgPSBga2V5dXAke0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gXG5cbmNvbnN0IENMQVNTX05BTUVfRElTQUJMRUQgPSAnZGlzYWJsZWQnXG5jb25zdCBDTEFTU19OQU1FX1NIT1cgPSAnc2hvdydcbmNvbnN0IENMQVNTX05BTUVfRFJPUFVQID0gJ2Ryb3B1cCdcbmNvbnN0IENMQVNTX05BTUVfRFJPUFJJR0hUID0gJ2Ryb3ByaWdodCdcbmNvbnN0IENMQVNTX05BTUVfRFJPUExFRlQgPSAnZHJvcGxlZnQnXG5jb25zdCBDTEFTU19OQU1FX01FTlVSSUdIVCA9ICdkcm9wZG93bi1tZW51LXJpZ2h0J1xuY29uc3QgQ0xBU1NfTkFNRV9QT1NJVElPTl9TVEFUSUMgPSAncG9zaXRpb24tc3RhdGljJ1xuXG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSA9ICdbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXSdcbmNvbnN0IFNFTEVDVE9SX0ZPUk1fQ0hJTEQgPSAnLmRyb3Bkb3duIGZvcm0nXG5jb25zdCBTRUxFQ1RPUl9NRU5VID0gJy5kcm9wZG93bi1tZW51J1xuY29uc3QgU0VMRUNUT1JfTkFWQkFSX05BViA9ICcubmF2YmFyLW5hdidcbmNvbnN0IFNFTEVDVE9SX1ZJU0lCTEVfSVRFTVMgPSAnLmRyb3Bkb3duLW1lbnUgLmRyb3Bkb3duLWl0ZW06bm90KC5kaXNhYmxlZCk6bm90KDpkaXNhYmxlZCknXG5cbmNvbnN0IFBMQUNFTUVOVF9UT1AgPSAndG9wLXN0YXJ0J1xuY29uc3QgUExBQ0VNRU5UX1RPUEVORCA9ICd0b3AtZW5kJ1xuY29uc3QgUExBQ0VNRU5UX0JPVFRPTSA9ICdib3R0b20tc3RhcnQnXG5jb25zdCBQTEFDRU1FTlRfQk9UVE9NRU5EID0gJ2JvdHRvbS1lbmQnXG5jb25zdCBQTEFDRU1FTlRfUklHSFQgPSAncmlnaHQtc3RhcnQnXG5jb25zdCBQTEFDRU1FTlRfTEVGVCA9ICdsZWZ0LXN0YXJ0J1xuXG5jb25zdCBEZWZhdWx0ID0ge1xuICBvZmZzZXQ6IDAsXG4gIGZsaXA6IHRydWUsXG4gIGJvdW5kYXJ5OiAnc2Nyb2xsUGFyZW50JyxcbiAgcmVmZXJlbmNlOiAndG9nZ2xlJyxcbiAgZGlzcGxheTogJ2R5bmFtaWMnLFxuICBwb3BwZXJDb25maWc6IG51bGxcbn1cblxuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIG9mZnNldDogJyhudW1iZXJ8c3RyaW5nfGZ1bmN0aW9uKScsXG4gIGZsaXA6ICdib29sZWFuJyxcbiAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcbiAgcmVmZXJlbmNlOiAnKHN0cmluZ3xlbGVtZW50KScsXG4gIGRpc3BsYXk6ICdzdHJpbmcnLFxuICBwb3BwZXJDb25maWc6ICcobnVsbHxvYmplY3QpJ1xufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgRHJvcGRvd24ge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudFxuICAgIHRoaXMuX3BvcHBlciA9IG51bGxcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKVxuICAgIHRoaXMuX21lbnUgPSB0aGlzLl9nZXRNZW51RWxlbWVudCgpXG4gICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKVxuXG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gVkVSU0lPTlxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0XG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZVxuICB9XG5cbiAgLy8gUHVibGljXG5cbiAgdG9nZ2xlKCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50LmRpc2FibGVkIHx8ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9ESVNBQkxFRCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGlzQWN0aXZlID0gJCh0aGlzLl9tZW51KS5oYXNDbGFzcyhDTEFTU19OQU1FX1NIT1cpXG5cbiAgICBEcm9wZG93bi5fY2xlYXJNZW51cygpXG5cbiAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuc2hvdyh0cnVlKVxuICB9XG5cbiAgc2hvdyh1c2VQb3BwZXIgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50LmRpc2FibGVkIHx8ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9ESVNBQkxFRCkgfHwgJCh0aGlzLl9tZW51KS5oYXNDbGFzcyhDTEFTU19OQU1FX1NIT1cpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xuICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgIH1cbiAgICBjb25zdCBzaG93RXZlbnQgPSAkLkV2ZW50KEVWRU5UX1NIT1csIHJlbGF0ZWRUYXJnZXQpXG4gICAgY29uc3QgcGFyZW50ID0gRHJvcGRvd24uX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpXG5cbiAgICAkKHBhcmVudCkudHJpZ2dlcihzaG93RXZlbnQpXG5cbiAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBUb3RhbGx5IGRpc2FibGUgUG9wcGVyIGZvciBEcm9wZG93bnMgaW4gTmF2YmFyXG4gICAgaWYgKCF0aGlzLl9pbk5hdmJhciAmJiB1c2VQb3BwZXIpIHtcbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2sgZm9yIFBvcHBlciBkZXBlbmRlbmN5XG4gICAgICAgKiBQb3BwZXIgLSBodHRwczovL3BvcHBlci5qcy5vcmdcbiAgICAgICAqL1xuICAgICAgaWYgKHR5cGVvZiBQb3BwZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Jvb3RzdHJhcFxcJ3MgZHJvcGRvd25zIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcpJylcbiAgICAgIH1cblxuICAgICAgbGV0IHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9lbGVtZW50XG5cbiAgICAgIGlmICh0aGlzLl9jb25maWcucmVmZXJlbmNlID09PSAncGFyZW50Jykge1xuICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gcGFyZW50XG4gICAgICB9IGVsc2UgaWYgKFV0aWwuaXNFbGVtZW50KHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpKSB7XG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9jb25maWcucmVmZXJlbmNlXG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBqUXVlcnkgZWxlbWVudFxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UuanF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9jb25maWcucmVmZXJlbmNlWzBdXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgYm91bmRhcnkgaXMgbm90IGBzY3JvbGxQYXJlbnRgLCB0aGVuIHNldCBwb3NpdGlvbiB0byBgc3RhdGljYFxuICAgICAgLy8gdG8gYWxsb3cgdGhlIG1lbnUgdG8gXCJlc2NhcGVcIiB0aGUgc2Nyb2xsIHBhcmVudCdzIGJvdW5kYXJpZXNcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9pc3N1ZXMvMjQyNTFcbiAgICAgIGlmICh0aGlzLl9jb25maWcuYm91bmRhcnkgIT09ICdzY3JvbGxQYXJlbnQnKSB7XG4gICAgICAgICQocGFyZW50KS5hZGRDbGFzcyhDTEFTU19OQU1FX1BPU0lUSU9OX1NUQVRJQylcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcG9wcGVyID0gbmV3IFBvcHBlcihyZWZlcmVuY2VFbGVtZW50LCB0aGlzLl9tZW51LCB0aGlzLl9nZXRQb3BwZXJDb25maWcoKSlcbiAgICB9XG5cbiAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgYWRkIGV4dHJhXG4gICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB0byB0aGUgYm9keSdzIGltbWVkaWF0ZSBjaGlsZHJlbjtcbiAgICAvLyBvbmx5IG5lZWRlZCBiZWNhdXNlIG9mIGJyb2tlbiBldmVudCBkZWxlZ2F0aW9uIG9uIGlPU1xuICAgIC8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxNC8wMi9tb3VzZV9ldmVudF9idWIuaHRtbFxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiZcbiAgICAgICAgJChwYXJlbnQpLmNsb3Nlc3QoU0VMRUNUT1JfTkFWQkFSX05BVikubGVuZ3RoID09PSAwKSB7XG4gICAgICAkKGRvY3VtZW50LmJvZHkpLmNoaWxkcmVuKCkub24oJ21vdXNlb3ZlcicsIG51bGwsICQubm9vcClcbiAgICB9XG5cbiAgICB0aGlzLl9lbGVtZW50LmZvY3VzKClcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpXG5cbiAgICAkKHRoaXMuX21lbnUpLnRvZ2dsZUNsYXNzKENMQVNTX05BTUVfU0hPVylcbiAgICAkKHBhcmVudClcbiAgICAgIC50b2dnbGVDbGFzcyhDTEFTU19OQU1FX1NIT1cpXG4gICAgICAudHJpZ2dlcigkLkV2ZW50KEVWRU5UX1NIT1dOLCByZWxhdGVkVGFyZ2V0KSlcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuZGlzYWJsZWQgfHwgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX0RJU0FCTEVEKSB8fCAhJCh0aGlzLl9tZW51KS5oYXNDbGFzcyhDTEFTU19OQU1FX1NIT1cpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xuICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgIH1cbiAgICBjb25zdCBoaWRlRXZlbnQgPSAkLkV2ZW50KEVWRU5UX0hJREUsIHJlbGF0ZWRUYXJnZXQpXG4gICAgY29uc3QgcGFyZW50ID0gRHJvcGRvd24uX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpXG5cbiAgICAkKHBhcmVudCkudHJpZ2dlcihoaWRlRXZlbnQpXG5cbiAgICBpZiAoaGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgJCh0aGlzLl9tZW51KS50b2dnbGVDbGFzcyhDTEFTU19OQU1FX1NIT1cpXG4gICAgJChwYXJlbnQpXG4gICAgICAudG9nZ2xlQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XKVxuICAgICAgLnRyaWdnZXIoJC5FdmVudChFVkVOVF9ISURERU4sIHJlbGF0ZWRUYXJnZXQpKVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpXG4gICAgJCh0aGlzLl9lbGVtZW50KS5vZmYoRVZFTlRfS0VZKVxuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsXG4gICAgdGhpcy5fbWVudSA9IG51bGxcbiAgICBpZiAodGhpcy5fcG9wcGVyICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpXG4gICAgICB0aGlzLl9wb3BwZXIgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKClcbiAgICBpZiAodGhpcy5fcG9wcGVyICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9wb3BwZXIuc2NoZWR1bGVVcGRhdGUoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFByaXZhdGVcblxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgJCh0aGlzLl9lbGVtZW50KS5vbihFVkVOVF9DTElDSywgZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgIHRoaXMudG9nZ2xlKClcbiAgICB9KVxuICB9XG5cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSB7XG4gICAgICAuLi50aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsXG4gICAgICAuLi4kKHRoaXMuX2VsZW1lbnQpLmRhdGEoKSxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH1cblxuICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKFxuICAgICAgTkFNRSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGVcbiAgICApXG5cbiAgICByZXR1cm4gY29uZmlnXG4gIH1cblxuICBfZ2V0TWVudUVsZW1lbnQoKSB7XG4gICAgaWYgKCF0aGlzLl9tZW51KSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudClcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICB0aGlzLl9tZW51ID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1JfTUVOVSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fbWVudVxuICB9XG5cbiAgX2dldFBsYWNlbWVudCgpIHtcbiAgICBjb25zdCAkcGFyZW50RHJvcGRvd24gPSAkKHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSlcbiAgICBsZXQgcGxhY2VtZW50ID0gUExBQ0VNRU5UX0JPVFRPTVxuXG4gICAgLy8gSGFuZGxlIGRyb3B1cFxuICAgIGlmICgkcGFyZW50RHJvcGRvd24uaGFzQ2xhc3MoQ0xBU1NfTkFNRV9EUk9QVVApKSB7XG4gICAgICBwbGFjZW1lbnQgPSAkKHRoaXMuX21lbnUpLmhhc0NsYXNzKENMQVNTX05BTUVfTUVOVVJJR0hUKSA/XG4gICAgICAgIFBMQUNFTUVOVF9UT1BFTkQgOlxuICAgICAgICBQTEFDRU1FTlRfVE9QXG4gICAgfSBlbHNlIGlmICgkcGFyZW50RHJvcGRvd24uaGFzQ2xhc3MoQ0xBU1NfTkFNRV9EUk9QUklHSFQpKSB7XG4gICAgICBwbGFjZW1lbnQgPSBQTEFDRU1FTlRfUklHSFRcbiAgICB9IGVsc2UgaWYgKCRwYXJlbnREcm9wZG93bi5oYXNDbGFzcyhDTEFTU19OQU1FX0RST1BMRUZUKSkge1xuICAgICAgcGxhY2VtZW50ID0gUExBQ0VNRU5UX0xFRlRcbiAgICB9IGVsc2UgaWYgKCQodGhpcy5fbWVudSkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9NRU5VUklHSFQpKSB7XG4gICAgICBwbGFjZW1lbnQgPSBQTEFDRU1FTlRfQk9UVE9NRU5EXG4gICAgfVxuXG4gICAgcmV0dXJuIHBsYWNlbWVudFxuICB9XG5cbiAgX2RldGVjdE5hdmJhcigpIHtcbiAgICByZXR1cm4gJCh0aGlzLl9lbGVtZW50KS5jbG9zZXN0KCcubmF2YmFyJykubGVuZ3RoID4gMFxuICB9XG5cbiAgX2dldE9mZnNldCgpIHtcbiAgICBjb25zdCBvZmZzZXQgPSB7fVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9jb25maWcub2Zmc2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvZmZzZXQuZm4gPSBkYXRhID0+IHtcbiAgICAgICAgZGF0YS5vZmZzZXRzID0ge1xuICAgICAgICAgIC4uLmRhdGEub2Zmc2V0cyxcbiAgICAgICAgICAuLi4odGhpcy5fY29uZmlnLm9mZnNldChkYXRhLm9mZnNldHMsIHRoaXMuX2VsZW1lbnQpIHx8IHt9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0Lm9mZnNldCA9IHRoaXMuX2NvbmZpZy5vZmZzZXRcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0XG4gIH1cblxuICBfZ2V0UG9wcGVyQ29uZmlnKCkge1xuICAgIGNvbnN0IHBvcHBlckNvbmZpZyA9IHtcbiAgICAgIHBsYWNlbWVudDogdGhpcy5fZ2V0UGxhY2VtZW50KCksXG4gICAgICBtb2RpZmllcnM6IHtcbiAgICAgICAgb2Zmc2V0OiB0aGlzLl9nZXRPZmZzZXQoKSxcbiAgICAgICAgZmxpcDoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRoaXMuX2NvbmZpZy5mbGlwXG4gICAgICAgIH0sXG4gICAgICAgIHByZXZlbnRPdmVyZmxvdzoge1xuICAgICAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERpc2FibGUgUG9wcGVyIGlmIHdlIGhhdmUgYSBzdGF0aWMgZGlzcGxheVxuICAgIGlmICh0aGlzLl9jb25maWcuZGlzcGxheSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgIHBvcHBlckNvbmZpZy5tb2RpZmllcnMuYXBwbHlTdHlsZSA9IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4ucG9wcGVyQ29uZmlnLFxuICAgICAgLi4udGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZ1xuICAgIH1cbiAgfVxuXG4gIC8vIFN0YXRpY1xuXG4gIHN0YXRpYyBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgbGV0IGRhdGEgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkpXG4gICAgICBjb25zdCBfY29uZmlnID0gdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgPyBjb25maWcgOiBudWxsXG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBkYXRhID0gbmV3IERyb3Bkb3duKHRoaXMsIF9jb25maWcpXG4gICAgICAgICQodGhpcykuZGF0YShEQVRBX0tFWSwgZGF0YSlcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFbY29uZmlnXSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHN0YXRpYyBfY2xlYXJNZW51cyhldmVudCkge1xuICAgIGlmIChldmVudCAmJiAoZXZlbnQud2hpY2ggPT09IFJJR0hUX01PVVNFX0JVVFRPTl9XSElDSCB8fFxuICAgICAgZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC53aGljaCAhPT0gVEFCX0tFWUNPREUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB0b2dnbGVzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0RBVEFfVE9HR0xFKSlcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0b2dnbGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodG9nZ2xlc1tpXSlcbiAgICAgIGNvbnN0IGNvbnRleHQgPSAkKHRvZ2dsZXNbaV0pLmRhdGEoREFUQV9LRVkpXG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0b2dnbGVzW2ldXG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudCAmJiBldmVudC50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQuY2xpY2tFdmVudCA9IGV2ZW50XG4gICAgICB9XG5cbiAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBkcm9wZG93bk1lbnUgPSBjb250ZXh0Ll9tZW51XG4gICAgICBpZiAoISQocGFyZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX1NIT1cpKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ2NsaWNrJyAmJlxuICAgICAgICAgIC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQud2hpY2ggPT09IFRBQl9LRVlDT0RFKSAmJlxuICAgICAgICAgICQuY29udGFpbnMocGFyZW50LCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9ICQuRXZlbnQoRVZFTlRfSElERSwgcmVsYXRlZFRhcmdldClcbiAgICAgICQocGFyZW50KS50cmlnZ2VyKGhpZGVFdmVudClcbiAgICAgIGlmIChoaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIHJlbW92ZSB0aGUgZXh0cmFcbiAgICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgd2UgYWRkZWQgZm9yIGlPUyBzdXBwb3J0XG4gICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICQoZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4oKS5vZmYoJ21vdXNlb3ZlcicsIG51bGwsICQubm9vcClcbiAgICAgIH1cblxuICAgICAgdG9nZ2xlc1tpXS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKVxuXG4gICAgICBpZiAoY29udGV4dC5fcG9wcGVyKSB7XG4gICAgICAgIGNvbnRleHQuX3BvcHBlci5kZXN0cm95KClcbiAgICAgIH1cblxuICAgICAgJChkcm9wZG93bk1lbnUpLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfU0hPVylcbiAgICAgICQocGFyZW50KVxuICAgICAgICAucmVtb3ZlQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XKVxuICAgICAgICAudHJpZ2dlcigkLkV2ZW50KEVWRU5UX0hJRERFTiwgcmVsYXRlZFRhcmdldCkpXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIF9nZXRQYXJlbnRGcm9tRWxlbWVudChlbGVtZW50KSB7XG4gICAgbGV0IHBhcmVudFxuICAgIGNvbnN0IHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpXG5cbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIHBhcmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudCB8fCBlbGVtZW50LnBhcmVudE5vZGVcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIHN0YXRpYyBfZGF0YUFwaUtleWRvd25IYW5kbGVyKGV2ZW50KSB7XG4gICAgLy8gSWYgbm90IGlucHV0L3RleHRhcmVhOlxuICAgIC8vICAtIEFuZCBub3QgYSBrZXkgaW4gUkVHRVhQX0tFWURPV04gPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuICAgIC8vIElmIGlucHV0L3RleHRhcmVhOlxuICAgIC8vICAtIElmIHNwYWNlIGtleSA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXG4gICAgLy8gIC0gSWYga2V5IGlzIG90aGVyIHRoYW4gZXNjYXBlXG4gICAgLy8gICAgLSBJZiBrZXkgaXMgbm90IHVwIG9yIGRvd24gPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuICAgIC8vICAgIC0gSWYgdHJpZ2dlciBpbnNpZGUgdGhlIG1lbnUgPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSA/XG4gICAgICBldmVudC53aGljaCA9PT0gU1BBQ0VfS0VZQ09ERSB8fCBldmVudC53aGljaCAhPT0gRVNDQVBFX0tFWUNPREUgJiZcbiAgICAgIChldmVudC53aGljaCAhPT0gQVJST1dfRE9XTl9LRVlDT0RFICYmIGV2ZW50LndoaWNoICE9PSBBUlJPV19VUF9LRVlDT0RFIHx8XG4gICAgICAgICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFNFTEVDVE9SX01FTlUpLmxlbmd0aCkgOiAhUkVHRVhQX0tFWURPV04udGVzdChldmVudC53aGljaCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLmRpc2FibGVkIHx8ICQodGhpcykuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9ESVNBQkxFRCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudCA9IERyb3Bkb3duLl9nZXRQYXJlbnRGcm9tRWxlbWVudCh0aGlzKVxuICAgIGNvbnN0IGlzQWN0aXZlID0gJChwYXJlbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfU0hPVylcblxuICAgIGlmICghaXNBY3RpdmUgJiYgZXZlbnQud2hpY2ggPT09IEVTQ0FQRV9LRVlDT0RFKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcblxuICAgIGlmICghaXNBY3RpdmUgfHwgKGV2ZW50LndoaWNoID09PSBFU0NBUEVfS0VZQ09ERSB8fCBldmVudC53aGljaCA9PT0gU1BBQ0VfS0VZQ09ERSkpIHtcbiAgICAgIGlmIChldmVudC53aGljaCA9PT0gRVNDQVBFX0tFWUNPREUpIHtcbiAgICAgICAgJChwYXJlbnQucXVlcnlTZWxlY3RvcihTRUxFQ1RPUl9EQVRBX1RPR0dMRSkpLnRyaWdnZXIoJ2ZvY3VzJylcbiAgICAgIH1cblxuICAgICAgJCh0aGlzKS50cmlnZ2VyKCdjbGljaycpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBpdGVtcyA9IFtdLnNsaWNlLmNhbGwocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfVklTSUJMRV9JVEVNUykpXG4gICAgICAuZmlsdGVyKGl0ZW0gPT4gJChpdGVtKS5pcygnOnZpc2libGUnKSlcblxuICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBpbmRleCA9IGl0ZW1zLmluZGV4T2YoZXZlbnQudGFyZ2V0KVxuXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSBBUlJPV19VUF9LRVlDT0RFICYmIGluZGV4ID4gMCkgeyAvLyBVcFxuICAgICAgaW5kZXgtLVxuICAgIH1cblxuICAgIGlmIChldmVudC53aGljaCA9PT0gQVJST1dfRE9XTl9LRVlDT0RFICYmIGluZGV4IDwgaXRlbXMubGVuZ3RoIC0gMSkgeyAvLyBEb3duXG4gICAgICBpbmRleCsrXG4gICAgfVxuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgaW5kZXggPSAwXG4gICAgfVxuXG4gICAgaXRlbXNbaW5kZXhdLmZvY3VzKClcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbiQoZG9jdW1lbnQpXG4gIC5vbihFVkVOVF9LRVlET1dOX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSwgRHJvcGRvd24uX2RhdGFBcGlLZXlkb3duSGFuZGxlcilcbiAgLm9uKEVWRU5UX0tFWURPV05fREFUQV9BUEksIFNFTEVDVE9SX01FTlUsIERyb3Bkb3duLl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIpXG4gIC5vbihgJHtFVkVOVF9DTElDS19EQVRBX0FQSX0gJHtFVkVOVF9LRVlVUF9EQVRBX0FQSX1gLCBEcm9wZG93bi5fY2xlYXJNZW51cylcbiAgLm9uKEVWRU5UX0NMSUNLX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgRHJvcGRvd24uX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGhpcyksICd0b2dnbGUnKVxuICB9KVxuICAub24oRVZFTlRfQ0xJQ0tfREFUQV9BUEksIFNFTEVDVE9SX0ZPUk1fQ0hJTEQsIGUgPT4ge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgfSlcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGpRdWVyeVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuJC5mbltOQU1FXSA9IERyb3Bkb3duLl9qUXVlcnlJbnRlcmZhY2VcbiQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBEcm9wZG93blxuJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUXG4gIHJldHVybiBEcm9wZG93bi5falF1ZXJ5SW50ZXJmYWNlXG59XG5cbmV4cG9ydCBkZWZhdWx0IERyb3Bkb3duXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjYuMCk6IG1vZGFsLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuaW1wb3J0IFV0aWwgZnJvbSAnLi91dGlsJ1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FID0gJ21vZGFsJ1xuY29uc3QgVkVSU0lPTiA9ICc0LjYuMCdcbmNvbnN0IERBVEFfS0VZID0gJ2JzLm1vZGFsJ1xuY29uc3QgRVZFTlRfS0VZID0gYC4ke0RBVEFfS0VZfWBcbmNvbnN0IERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknXG5jb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdXG5jb25zdCBFU0NBUEVfS0VZQ09ERSA9IDI3IC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIEVzY2FwZSAoRXNjKSBrZXlcblxuY29uc3QgRGVmYXVsdCA9IHtcbiAgYmFja2Ryb3A6IHRydWUsXG4gIGtleWJvYXJkOiB0cnVlLFxuICBmb2N1czogdHJ1ZSxcbiAgc2hvdzogdHJ1ZVxufVxuXG5jb25zdCBEZWZhdWx0VHlwZSA9IHtcbiAgYmFja2Ryb3A6ICcoYm9vbGVhbnxzdHJpbmcpJyxcbiAga2V5Ym9hcmQ6ICdib29sZWFuJyxcbiAgZm9jdXM6ICdib29sZWFuJyxcbiAgc2hvdzogJ2Jvb2xlYW4nXG59XG5cbmNvbnN0IEVWRU5UX0hJREUgPSBgaGlkZSR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0hJREVfUFJFVkVOVEVEID0gYGhpZGVQcmV2ZW50ZWQke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9ISURERU4gPSBgaGlkZGVuJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0hPVyA9IGBzaG93JHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0hPV04gPSBgc2hvd24ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9GT0NVU0lOID0gYGZvY3VzaW4ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9SRVNJWkUgPSBgcmVzaXplJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfQ0xJQ0tfRElTTUlTUyA9IGBjbGljay5kaXNtaXNzJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfS0VZRE9XTl9ESVNNSVNTID0gYGtleWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX01PVVNFVVBfRElTTUlTUyA9IGBtb3VzZXVwLmRpc21pc3Mke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9NT1VTRURPV05fRElTTUlTUyA9IGBtb3VzZWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gYGNsaWNrJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuXG5jb25zdCBDTEFTU19OQU1FX1NDUk9MTEFCTEUgPSAnbW9kYWwtZGlhbG9nLXNjcm9sbGFibGUnXG5jb25zdCBDTEFTU19OQU1FX1NDUk9MTEJBUl9NRUFTVVJFUiA9ICdtb2RhbC1zY3JvbGxiYXItbWVhc3VyZSdcbmNvbnN0IENMQVNTX05BTUVfQkFDS0RST1AgPSAnbW9kYWwtYmFja2Ryb3AnXG5jb25zdCBDTEFTU19OQU1FX09QRU4gPSAnbW9kYWwtb3BlbidcbmNvbnN0IENMQVNTX05BTUVfRkFERSA9ICdmYWRlJ1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XID0gJ3Nob3cnXG5jb25zdCBDTEFTU19OQU1FX1NUQVRJQyA9ICdtb2RhbC1zdGF0aWMnXG5cbmNvbnN0IFNFTEVDVE9SX0RJQUxPRyA9ICcubW9kYWwtZGlhbG9nJ1xuY29uc3QgU0VMRUNUT1JfTU9EQUxfQk9EWSA9ICcubW9kYWwtYm9keSdcbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFID0gJ1tkYXRhLXRvZ2dsZT1cIm1vZGFsXCJdJ1xuY29uc3QgU0VMRUNUT1JfREFUQV9ESVNNSVNTID0gJ1tkYXRhLWRpc21pc3M9XCJtb2RhbFwiXSdcbmNvbnN0IFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQgPSAnLmZpeGVkLXRvcCwgLmZpeGVkLWJvdHRvbSwgLmlzLWZpeGVkLCAuc3RpY2t5LXRvcCdcbmNvbnN0IFNFTEVDVE9SX1NUSUNLWV9DT05URU5UID0gJy5zdGlja3ktdG9wJ1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgTW9kYWwge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKVxuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50XG4gICAgdGhpcy5fZGlhbG9nID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKFNFTEVDVE9SX0RJQUxPRylcbiAgICB0aGlzLl9iYWNrZHJvcCA9IG51bGxcbiAgICB0aGlzLl9pc1Nob3duID0gZmFsc2VcbiAgICB0aGlzLl9pc0JvZHlPdmVyZmxvd2luZyA9IGZhbHNlXG4gICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IGZhbHNlXG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2VcbiAgICB0aGlzLl9zY3JvbGxiYXJXaWR0aCA9IDBcbiAgfVxuXG4gIC8vIEdldHRlcnNcblxuICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XG4gICAgcmV0dXJuIFZFUlNJT05cbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFxuICB9XG5cbiAgLy8gUHVibGljXG5cbiAgdG9nZ2xlKHJlbGF0ZWRUYXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHJlbGF0ZWRUYXJnZXQpXG4gIH1cblxuICBzaG93KHJlbGF0ZWRUYXJnZXQpIHtcbiAgICBpZiAodGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICgkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfRkFERSkpIHtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBzaG93RXZlbnQgPSAkLkV2ZW50KEVWRU5UX1NIT1csIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICB9KVxuXG4gICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNob3dFdmVudClcblxuICAgIGlmICh0aGlzLl9pc1Nob3duIHx8IHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5faXNTaG93biA9IHRydWVcblxuICAgIHRoaXMuX2NoZWNrU2Nyb2xsYmFyKClcbiAgICB0aGlzLl9zZXRTY3JvbGxiYXIoKVxuXG4gICAgdGhpcy5fYWRqdXN0RGlhbG9nKClcblxuICAgIHRoaXMuX3NldEVzY2FwZUV2ZW50KClcbiAgICB0aGlzLl9zZXRSZXNpemVFdmVudCgpXG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpLm9uKFxuICAgICAgRVZFTlRfQ0xJQ0tfRElTTUlTUyxcbiAgICAgIFNFTEVDVE9SX0RBVEFfRElTTUlTUyxcbiAgICAgIGV2ZW50ID0+IHRoaXMuaGlkZShldmVudClcbiAgICApXG5cbiAgICAkKHRoaXMuX2RpYWxvZykub24oRVZFTlRfTU9VU0VET1dOX0RJU01JU1MsICgpID0+IHtcbiAgICAgICQodGhpcy5fZWxlbWVudCkub25lKEVWRU5UX01PVVNFVVBfRElTTUlTUywgZXZlbnQgPT4ge1xuICAgICAgICBpZiAoJChldmVudC50YXJnZXQpLmlzKHRoaXMuX2VsZW1lbnQpKSB7XG4gICAgICAgICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5fc2hvd0JhY2tkcm9wKCgpID0+IHRoaXMuX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpKVxuICB9XG5cbiAgaGlkZShldmVudCkge1xuICAgIGlmIChldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIH1cblxuICAgIGlmICghdGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGhpZGVFdmVudCA9ICQuRXZlbnQoRVZFTlRfSElERSlcblxuICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihoaWRlRXZlbnQpXG5cbiAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgaGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9pc1Nob3duID0gZmFsc2VcbiAgICBjb25zdCB0cmFuc2l0aW9uID0gJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX0ZBREUpXG5cbiAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZVxuICAgIH1cblxuICAgIHRoaXMuX3NldEVzY2FwZUV2ZW50KClcbiAgICB0aGlzLl9zZXRSZXNpemVFdmVudCgpXG5cbiAgICAkKGRvY3VtZW50KS5vZmYoRVZFTlRfRk9DVVNJTilcblxuICAgICQodGhpcy5fZWxlbWVudCkucmVtb3ZlQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XKVxuXG4gICAgJCh0aGlzLl9lbGVtZW50KS5vZmYoRVZFTlRfQ0xJQ0tfRElTTUlTUylcbiAgICAkKHRoaXMuX2RpYWxvZykub2ZmKEVWRU5UX01PVVNFRE9XTl9ESVNNSVNTKVxuXG4gICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudClcblxuICAgICAgJCh0aGlzLl9lbGVtZW50KVxuICAgICAgICAub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGV2ZW50ID0+IHRoaXMuX2hpZGVNb2RhbChldmVudCkpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hpZGVNb2RhbCgpXG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICBbd2luZG93LCB0aGlzLl9lbGVtZW50LCB0aGlzLl9kaWFsb2ddXG4gICAgICAuZm9yRWFjaChodG1sRWxlbWVudCA9PiAkKGh0bWxFbGVtZW50KS5vZmYoRVZFTlRfS0VZKSlcblxuICAgIC8qKlxuICAgICAqIGBkb2N1bWVudGAgaGFzIDIgZXZlbnRzIGBFVkVOVF9GT0NVU0lOYCBhbmQgYEVWRU5UX0NMSUNLX0RBVEFfQVBJYFxuICAgICAqIERvIG5vdCBtb3ZlIGBkb2N1bWVudGAgaW4gYGh0bWxFbGVtZW50c2AgYXJyYXlcbiAgICAgKiBJdCB3aWxsIHJlbW92ZSBgRVZFTlRfQ0xJQ0tfREFUQV9BUElgIGV2ZW50IHRoYXQgc2hvdWxkIHJlbWFpblxuICAgICAqL1xuICAgICQoZG9jdW1lbnQpLm9mZihFVkVOVF9GT0NVU0lOKVxuXG4gICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKVxuXG4gICAgdGhpcy5fY29uZmlnID0gbnVsbFxuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsXG4gICAgdGhpcy5fZGlhbG9nID0gbnVsbFxuICAgIHRoaXMuX2JhY2tkcm9wID0gbnVsbFxuICAgIHRoaXMuX2lzU2hvd24gPSBudWxsXG4gICAgdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgPSBudWxsXG4gICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IG51bGxcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBudWxsXG4gICAgdGhpcy5fc2Nyb2xsYmFyV2lkdGggPSBudWxsXG4gIH1cblxuICBoYW5kbGVVcGRhdGUoKSB7XG4gICAgdGhpcy5fYWRqdXN0RGlhbG9nKClcbiAgfVxuXG4gIC8vIFByaXZhdGVcblxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IHtcbiAgICAgIC4uLkRlZmF1bHQsXG4gICAgICAuLi5jb25maWdcbiAgICB9XG4gICAgVXRpbC50eXBlQ2hlY2tDb25maWcoTkFNRSwgY29uZmlnLCBEZWZhdWx0VHlwZSlcbiAgICByZXR1cm4gY29uZmlnXG4gIH1cblxuICBfdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpIHtcbiAgICBjb25zdCBoaWRlRXZlbnRQcmV2ZW50ZWQgPSAkLkV2ZW50KEVWRU5UX0hJREVfUFJFVkVOVEVEKVxuXG4gICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKGhpZGVFdmVudFByZXZlbnRlZClcbiAgICBpZiAoaGlkZUV2ZW50UHJldmVudGVkLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBpc01vZGFsT3ZlcmZsb3dpbmcgPSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcblxuICAgIGlmICghaXNNb2RhbE92ZXJmbG93aW5nKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9ICdoaWRkZW4nXG4gICAgfVxuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU1RBVElDKVxuXG4gICAgY29uc3QgbW9kYWxUcmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2RpYWxvZylcbiAgICAkKHRoaXMuX2VsZW1lbnQpLm9mZihVdGlsLlRSQU5TSVRJT05fRU5EKVxuXG4gICAgJCh0aGlzLl9lbGVtZW50KS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU1RBVElDKVxuICAgICAgaWYgKCFpc01vZGFsT3ZlcmZsb3dpbmcpIHtcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3dZID0gJydcbiAgICAgICAgfSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQodGhpcy5fZWxlbWVudCwgbW9kYWxUcmFuc2l0aW9uRHVyYXRpb24pXG4gICAgICB9XG4gICAgfSlcbiAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChtb2RhbFRyYW5zaXRpb25EdXJhdGlvbilcbiAgICB0aGlzLl9lbGVtZW50LmZvY3VzKClcbiAgfVxuXG4gIF9zaG93RWxlbWVudChyZWxhdGVkVGFyZ2V0KSB7XG4gICAgY29uc3QgdHJhbnNpdGlvbiA9ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9GQURFKVxuICAgIGNvbnN0IG1vZGFsQm9keSA9IHRoaXMuX2RpYWxvZyA/IHRoaXMuX2RpYWxvZy5xdWVyeVNlbGVjdG9yKFNFTEVDVE9SX01PREFMX0JPRFkpIDogbnVsbFxuXG4gICAgaWYgKCF0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUgfHxcbiAgICAgICAgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgLy8gRG9uJ3QgbW92ZSBtb2RhbCdzIERPTSBwb3NpdGlvblxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50KVxuICAgIH1cblxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKVxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgdHJ1ZSlcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKVxuXG4gICAgaWYgKCQodGhpcy5fZGlhbG9nKS5oYXNDbGFzcyhDTEFTU19OQU1FX1NDUk9MTEFCTEUpICYmIG1vZGFsQm9keSkge1xuICAgICAgbW9kYWxCb2R5LnNjcm9sbFRvcCA9IDBcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZWxlbWVudC5zY3JvbGxUb3AgPSAwXG4gICAgfVxuXG4gICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgIFV0aWwucmVmbG93KHRoaXMuX2VsZW1lbnQpXG4gICAgfVxuXG4gICAgJCh0aGlzLl9lbGVtZW50KS5hZGRDbGFzcyhDTEFTU19OQU1FX1NIT1cpXG5cbiAgICBpZiAodGhpcy5fY29uZmlnLmZvY3VzKSB7XG4gICAgICB0aGlzLl9lbmZvcmNlRm9jdXMoKVxuICAgIH1cblxuICAgIGNvbnN0IHNob3duRXZlbnQgPSAkLkV2ZW50KEVWRU5UX1NIT1dOLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0XG4gICAgfSlcblxuICAgIGNvbnN0IHRyYW5zaXRpb25Db21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9jb25maWcuZm9jdXMpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5mb2N1cygpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2hvd25FdmVudClcbiAgICB9XG5cbiAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9kaWFsb2cpXG5cbiAgICAgICQodGhpcy5fZGlhbG9nKVxuICAgICAgICAub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIHRyYW5zaXRpb25Db21wbGV0ZSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNpdGlvbkNvbXBsZXRlKClcbiAgICB9XG4gIH1cblxuICBfZW5mb3JjZUZvY3VzKCkge1xuICAgICQoZG9jdW1lbnQpXG4gICAgICAub2ZmKEVWRU5UX0ZPQ1VTSU4pIC8vIEd1YXJkIGFnYWluc3QgaW5maW5pdGUgZm9jdXMgbG9vcFxuICAgICAgLm9uKEVWRU5UX0ZPQ1VTSU4sIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGRvY3VtZW50ICE9PSBldmVudC50YXJnZXQgJiZcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQgIT09IGV2ZW50LnRhcmdldCAmJlxuICAgICAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5oYXMoZXZlbnQudGFyZ2V0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgfVxuXG4gIF9zZXRFc2NhcGVFdmVudCgpIHtcbiAgICBpZiAodGhpcy5faXNTaG93bikge1xuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFVkVOVF9LRVlET1dOX0RJU01JU1MsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCAmJiBldmVudC53aGljaCA9PT0gRVNDQVBFX0tFWUNPREUpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgdGhpcy5oaWRlKClcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY29uZmlnLmtleWJvYXJkICYmIGV2ZW50LndoaWNoID09PSBFU0NBUEVfS0VZQ09ERSkge1xuICAgICAgICAgIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzU2hvd24pIHtcbiAgICAgICQodGhpcy5fZWxlbWVudCkub2ZmKEVWRU5UX0tFWURPV05fRElTTUlTUylcbiAgICB9XG4gIH1cblxuICBfc2V0UmVzaXplRXZlbnQoKSB7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgICQod2luZG93KS5vbihFVkVOVF9SRVNJWkUsIGV2ZW50ID0+IHRoaXMuaGFuZGxlVXBkYXRlKGV2ZW50KSlcbiAgICB9IGVsc2Uge1xuICAgICAgJCh3aW5kb3cpLm9mZihFVkVOVF9SRVNJWkUpXG4gICAgfVxuICB9XG5cbiAgX2hpZGVNb2RhbCgpIHtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKVxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLW1vZGFsJylcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpXG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2VcbiAgICB0aGlzLl9zaG93QmFja2Ryb3AoKCkgPT4ge1xuICAgICAgJChkb2N1bWVudC5ib2R5KS5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX09QRU4pXG4gICAgICB0aGlzLl9yZXNldEFkanVzdG1lbnRzKClcbiAgICAgIHRoaXMuX3Jlc2V0U2Nyb2xsYmFyKClcbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihFVkVOVF9ISURERU4pXG4gICAgfSlcbiAgfVxuXG4gIF9yZW1vdmVCYWNrZHJvcCgpIHtcbiAgICBpZiAodGhpcy5fYmFja2Ryb3ApIHtcbiAgICAgICQodGhpcy5fYmFja2Ryb3ApLnJlbW92ZSgpXG4gICAgICB0aGlzLl9iYWNrZHJvcCA9IG51bGxcbiAgICB9XG4gIH1cblxuICBfc2hvd0JhY2tkcm9wKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgYW5pbWF0ZSA9ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9GQURFKSA/XG4gICAgICBDTEFTU19OQU1FX0ZBREUgOiAnJ1xuXG4gICAgaWYgKHRoaXMuX2lzU2hvd24gJiYgdGhpcy5fY29uZmlnLmJhY2tkcm9wKSB7XG4gICAgICB0aGlzLl9iYWNrZHJvcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICB0aGlzLl9iYWNrZHJvcC5jbGFzc05hbWUgPSBDTEFTU19OQU1FX0JBQ0tEUk9QXG5cbiAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgIHRoaXMuX2JhY2tkcm9wLmNsYXNzTGlzdC5hZGQoYW5pbWF0ZSlcbiAgICAgIH1cblxuICAgICAgJCh0aGlzLl9iYWNrZHJvcCkuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSlcblxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFVkVOVF9DTElDS19ESVNNSVNTLCBldmVudCA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrKSB7XG4gICAgICAgICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IGZhbHNlXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSBldmVudC5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSAnc3RhdGljJykge1xuICAgICAgICAgIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaGlkZSgpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGlmIChhbmltYXRlKSB7XG4gICAgICAgIFV0aWwucmVmbG93KHRoaXMuX2JhY2tkcm9wKVxuICAgICAgfVxuXG4gICAgICAkKHRoaXMuX2JhY2tkcm9wKS5hZGRDbGFzcyhDTEFTU19OQU1FX1NIT1cpXG5cbiAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICghYW5pbWF0ZSkge1xuICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCBiYWNrZHJvcFRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fYmFja2Ryb3ApXG5cbiAgICAgICQodGhpcy5fYmFja2Ryb3ApXG4gICAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY2FsbGJhY2spXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZChiYWNrZHJvcFRyYW5zaXRpb25EdXJhdGlvbilcbiAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc1Nob3duICYmIHRoaXMuX2JhY2tkcm9wKSB7XG4gICAgICAkKHRoaXMuX2JhY2tkcm9wKS5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX1NIT1cpXG5cbiAgICAgIGNvbnN0IGNhbGxiYWNrUmVtb3ZlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9yZW1vdmVCYWNrZHJvcCgpXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX0ZBREUpKSB7XG4gICAgICAgIGNvbnN0IGJhY2tkcm9wVHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9iYWNrZHJvcClcblxuICAgICAgICAkKHRoaXMuX2JhY2tkcm9wKVxuICAgICAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY2FsbGJhY2tSZW1vdmUpXG4gICAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGJhY2tkcm9wVHJhbnNpdGlvbkR1cmF0aW9uKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2tSZW1vdmUoKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHRoZSBmb2xsb3dpbmcgbWV0aG9kcyBhcmUgdXNlZCB0byBoYW5kbGUgb3ZlcmZsb3dpbmcgbW9kYWxzXG4gIC8vIHRvZG8gKGZhdCk6IHRoZXNlIHNob3VsZCBwcm9iYWJseSBiZSByZWZhY3RvcmVkIG91dCBvZiBtb2RhbC5qc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgX2FkanVzdERpYWxvZygpIHtcbiAgICBjb25zdCBpc01vZGFsT3ZlcmZsb3dpbmcgPSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcblxuICAgIGlmICghdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgJiYgaXNNb2RhbE92ZXJmbG93aW5nKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gYCR7dGhpcy5fc2Nyb2xsYmFyV2lkdGh9cHhgXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzQm9keU92ZXJmbG93aW5nICYmICFpc01vZGFsT3ZlcmZsb3dpbmcpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gYCR7dGhpcy5fc2Nyb2xsYmFyV2lkdGh9cHhgXG4gICAgfVxuICB9XG5cbiAgX3Jlc2V0QWRqdXN0bWVudHMoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9ICcnXG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSAnJ1xuICB9XG5cbiAgX2NoZWNrU2Nyb2xsYmFyKCkge1xuICAgIGNvbnN0IHJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgPSBNYXRoLnJvdW5kKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIDwgd2luZG93LmlubmVyV2lkdGhcbiAgICB0aGlzLl9zY3JvbGxiYXJXaWR0aCA9IHRoaXMuX2dldFNjcm9sbGJhcldpZHRoKClcbiAgfVxuXG4gIF9zZXRTY3JvbGxiYXIoKSB7XG4gICAgaWYgKHRoaXMuX2lzQm9keU92ZXJmbG93aW5nKSB7XG4gICAgICAvLyBOb3RlOiBET01Ob2RlLnN0eWxlLnBhZGRpbmdSaWdodCByZXR1cm5zIHRoZSBhY3R1YWwgdmFsdWUgb3IgJycgaWYgbm90IHNldFxuICAgICAgLy8gICB3aGlsZSAkKERPTU5vZGUpLmNzcygncGFkZGluZy1yaWdodCcpIHJldHVybnMgdGhlIGNhbGN1bGF0ZWQgdmFsdWUgb3IgMCBpZiBub3Qgc2V0XG4gICAgICBjb25zdCBmaXhlZENvbnRlbnQgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfRklYRURfQ09OVEVOVCkpXG4gICAgICBjb25zdCBzdGlja3lDb250ZW50ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX1NUSUNLWV9DT05URU5UKSlcblxuICAgICAgLy8gQWRqdXN0IGZpeGVkIGNvbnRlbnQgcGFkZGluZ1xuICAgICAgJChmaXhlZENvbnRlbnQpLmVhY2goKGluZGV4LCBlbGVtZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGFjdHVhbFBhZGRpbmcgPSBlbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodFxuICAgICAgICBjb25zdCBjYWxjdWxhdGVkUGFkZGluZyA9ICQoZWxlbWVudCkuY3NzKCdwYWRkaW5nLXJpZ2h0JylcbiAgICAgICAgJChlbGVtZW50KVxuICAgICAgICAgIC5kYXRhKCdwYWRkaW5nLXJpZ2h0JywgYWN0dWFsUGFkZGluZylcbiAgICAgICAgICAuY3NzKCdwYWRkaW5nLXJpZ2h0JywgYCR7cGFyc2VGbG9hdChjYWxjdWxhdGVkUGFkZGluZykgKyB0aGlzLl9zY3JvbGxiYXJXaWR0aH1weGApXG4gICAgICB9KVxuXG4gICAgICAvLyBBZGp1c3Qgc3RpY2t5IGNvbnRlbnQgbWFyZ2luXG4gICAgICAkKHN0aWNreUNvbnRlbnQpLmVhY2goKGluZGV4LCBlbGVtZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGFjdHVhbE1hcmdpbiA9IGVsZW1lbnQuc3R5bGUubWFyZ2luUmlnaHRcbiAgICAgICAgY29uc3QgY2FsY3VsYXRlZE1hcmdpbiA9ICQoZWxlbWVudCkuY3NzKCdtYXJnaW4tcmlnaHQnKVxuICAgICAgICAkKGVsZW1lbnQpXG4gICAgICAgICAgLmRhdGEoJ21hcmdpbi1yaWdodCcsIGFjdHVhbE1hcmdpbilcbiAgICAgICAgICAuY3NzKCdtYXJnaW4tcmlnaHQnLCBgJHtwYXJzZUZsb2F0KGNhbGN1bGF0ZWRNYXJnaW4pIC0gdGhpcy5fc2Nyb2xsYmFyV2lkdGh9cHhgKVxuICAgICAgfSlcblxuICAgICAgLy8gQWRqdXN0IGJvZHkgcGFkZGluZ1xuICAgICAgY29uc3QgYWN0dWFsUGFkZGluZyA9IGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0XG4gICAgICBjb25zdCBjYWxjdWxhdGVkUGFkZGluZyA9ICQoZG9jdW1lbnQuYm9keSkuY3NzKCdwYWRkaW5nLXJpZ2h0JylcbiAgICAgICQoZG9jdW1lbnQuYm9keSlcbiAgICAgICAgLmRhdGEoJ3BhZGRpbmctcmlnaHQnLCBhY3R1YWxQYWRkaW5nKVxuICAgICAgICAuY3NzKCdwYWRkaW5nLXJpZ2h0JywgYCR7cGFyc2VGbG9hdChjYWxjdWxhdGVkUGFkZGluZykgKyB0aGlzLl9zY3JvbGxiYXJXaWR0aH1weGApXG4gICAgfVxuXG4gICAgJChkb2N1bWVudC5ib2R5KS5hZGRDbGFzcyhDTEFTU19OQU1FX09QRU4pXG4gIH1cblxuICBfcmVzZXRTY3JvbGxiYXIoKSB7XG4gICAgLy8gUmVzdG9yZSBmaXhlZCBjb250ZW50IHBhZGRpbmdcbiAgICBjb25zdCBmaXhlZENvbnRlbnQgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfRklYRURfQ09OVEVOVCkpXG4gICAgJChmaXhlZENvbnRlbnQpLmVhY2goKGluZGV4LCBlbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCBwYWRkaW5nID0gJChlbGVtZW50KS5kYXRhKCdwYWRkaW5nLXJpZ2h0JylcbiAgICAgICQoZWxlbWVudCkucmVtb3ZlRGF0YSgncGFkZGluZy1yaWdodCcpXG4gICAgICBlbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IHBhZGRpbmcgPyBwYWRkaW5nIDogJydcbiAgICB9KVxuXG4gICAgLy8gUmVzdG9yZSBzdGlja3kgY29udGVudFxuICAgIGNvbnN0IGVsZW1lbnRzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGAke1NFTEVDVE9SX1NUSUNLWV9DT05URU5UfWApKVxuICAgICQoZWxlbWVudHMpLmVhY2goKGluZGV4LCBlbGVtZW50KSA9PiB7XG4gICAgICBjb25zdCBtYXJnaW4gPSAkKGVsZW1lbnQpLmRhdGEoJ21hcmdpbi1yaWdodCcpXG4gICAgICBpZiAodHlwZW9mIG1hcmdpbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgJChlbGVtZW50KS5jc3MoJ21hcmdpbi1yaWdodCcsIG1hcmdpbikucmVtb3ZlRGF0YSgnbWFyZ2luLXJpZ2h0JylcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gUmVzdG9yZSBib2R5IHBhZGRpbmdcbiAgICBjb25zdCBwYWRkaW5nID0gJChkb2N1bWVudC5ib2R5KS5kYXRhKCdwYWRkaW5nLXJpZ2h0JylcbiAgICAkKGRvY3VtZW50LmJvZHkpLnJlbW92ZURhdGEoJ3BhZGRpbmctcmlnaHQnKVxuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gcGFkZGluZyA/IHBhZGRpbmcgOiAnJ1xuICB9XG5cbiAgX2dldFNjcm9sbGJhcldpZHRoKCkgeyAvLyB0aHggZC53YWxzaFxuICAgIGNvbnN0IHNjcm9sbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgc2Nyb2xsRGl2LmNsYXNzTmFtZSA9IENMQVNTX05BTUVfU0NST0xMQkFSX01FQVNVUkVSXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JvbGxEaXYpXG4gICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSBzY3JvbGxEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSBzY3JvbGxEaXYuY2xpZW50V2lkdGhcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHNjcm9sbERpdilcbiAgICByZXR1cm4gc2Nyb2xsYmFyV2lkdGhcbiAgfVxuXG4gIC8vIFN0YXRpY1xuXG4gIHN0YXRpYyBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZywgcmVsYXRlZFRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgbGV0IGRhdGEgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkpXG4gICAgICBjb25zdCBfY29uZmlnID0ge1xuICAgICAgICAuLi5EZWZhdWx0LFxuICAgICAgICAuLi4kKHRoaXMpLmRhdGEoKSxcbiAgICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9KVxuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBNb2RhbCh0aGlzLCBfY29uZmlnKVxuICAgICAgICAkKHRoaXMpLmRhdGEoREFUQV9LRVksIGRhdGEpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApXG4gICAgICAgIH1cblxuICAgICAgICBkYXRhW2NvbmZpZ10ocmVsYXRlZFRhcmdldClcbiAgICAgIH0gZWxzZSBpZiAoX2NvbmZpZy5zaG93KSB7XG4gICAgICAgIGRhdGEuc2hvdyhyZWxhdGVkVGFyZ2V0KVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kKGRvY3VtZW50KS5vbihFVkVOVF9DTElDS19EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUsIGZ1bmN0aW9uIChldmVudCkge1xuICBsZXQgdGFyZ2V0XG4gIGNvbnN0IHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KHRoaXMpXG5cbiAgaWYgKHNlbGVjdG9yKSB7XG4gICAgdGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcilcbiAgfVxuXG4gIGNvbnN0IGNvbmZpZyA9ICQodGFyZ2V0KS5kYXRhKERBVEFfS0VZKSA/XG4gICAgJ3RvZ2dsZScgOiB7XG4gICAgICAuLi4kKHRhcmdldCkuZGF0YSgpLFxuICAgICAgLi4uJCh0aGlzKS5kYXRhKClcbiAgICB9XG5cbiAgaWYgKHRoaXMudGFnTmFtZSA9PT0gJ0EnIHx8IHRoaXMudGFnTmFtZSA9PT0gJ0FSRUEnKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICB9XG5cbiAgY29uc3QgJHRhcmdldCA9ICQodGFyZ2V0KS5vbmUoRVZFTlRfU0hPVywgc2hvd0V2ZW50ID0+IHtcbiAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAvLyBPbmx5IHJlZ2lzdGVyIGZvY3VzIHJlc3RvcmVyIGlmIG1vZGFsIHdpbGwgYWN0dWFsbHkgZ2V0IHNob3duXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAkdGFyZ2V0Lm9uZShFVkVOVF9ISURERU4sICgpID0+IHtcbiAgICAgIGlmICgkKHRoaXMpLmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgIHRoaXMuZm9jdXMoKVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG5cbiAgTW9kYWwuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGFyZ2V0KSwgY29uZmlnLCB0aGlzKVxufSlcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGpRdWVyeVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuJC5mbltOQU1FXSA9IE1vZGFsLl9qUXVlcnlJbnRlcmZhY2VcbiQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBNb2RhbFxuJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUXG4gIHJldHVybiBNb2RhbC5falF1ZXJ5SW50ZXJmYWNlXG59XG5cbmV4cG9ydCBkZWZhdWx0IE1vZGFsXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjYuMCk6IHRvb2xzL3Nhbml0aXplci5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IHVyaUF0dHJzID0gW1xuICAnYmFja2dyb3VuZCcsXG4gICdjaXRlJyxcbiAgJ2hyZWYnLFxuICAnaXRlbXR5cGUnLFxuICAnbG9uZ2Rlc2MnLFxuICAncG9zdGVyJyxcbiAgJ3NyYycsXG4gICd4bGluazpocmVmJ1xuXVxuXG5jb25zdCBBUklBX0FUVFJJQlVURV9QQVRURVJOID0gL15hcmlhLVtcXHctXSokL2lcblxuZXhwb3J0IGNvbnN0IERlZmF1bHRXaGl0ZWxpc3QgPSB7XG4gIC8vIEdsb2JhbCBhdHRyaWJ1dGVzIGFsbG93ZWQgb24gYW55IHN1cHBsaWVkIGVsZW1lbnQgYmVsb3cuXG4gICcqJzogWydjbGFzcycsICdkaXInLCAnaWQnLCAnbGFuZycsICdyb2xlJywgQVJJQV9BVFRSSUJVVEVfUEFUVEVSTl0sXG4gIGE6IFsndGFyZ2V0JywgJ2hyZWYnLCAndGl0bGUnLCAncmVsJ10sXG4gIGFyZWE6IFtdLFxuICBiOiBbXSxcbiAgYnI6IFtdLFxuICBjb2w6IFtdLFxuICBjb2RlOiBbXSxcbiAgZGl2OiBbXSxcbiAgZW06IFtdLFxuICBocjogW10sXG4gIGgxOiBbXSxcbiAgaDI6IFtdLFxuICBoMzogW10sXG4gIGg0OiBbXSxcbiAgaDU6IFtdLFxuICBoNjogW10sXG4gIGk6IFtdLFxuICBpbWc6IFsnc3JjJywgJ3NyY3NldCcsICdhbHQnLCAndGl0bGUnLCAnd2lkdGgnLCAnaGVpZ2h0J10sXG4gIGxpOiBbXSxcbiAgb2w6IFtdLFxuICBwOiBbXSxcbiAgcHJlOiBbXSxcbiAgczogW10sXG4gIHNtYWxsOiBbXSxcbiAgc3BhbjogW10sXG4gIHN1YjogW10sXG4gIHN1cDogW10sXG4gIHN0cm9uZzogW10sXG4gIHU6IFtdLFxuICB1bDogW11cbn1cblxuLyoqXG4gKiBBIHBhdHRlcm4gdGhhdCByZWNvZ25pemVzIGEgY29tbW9ubHkgdXNlZnVsIHN1YnNldCBvZiBVUkxzIHRoYXQgYXJlIHNhZmUuXG4gKlxuICogU2hvdXRvdXQgdG8gQW5ndWxhciA3IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi83LjIuNC9wYWNrYWdlcy9jb3JlL3NyYy9zYW5pdGl6YXRpb24vdXJsX3Nhbml0aXplci50c1xuICovXG5jb25zdCBTQUZFX1VSTF9QQVRURVJOID0gL14oPzooPzpodHRwcz98bWFpbHRvfGZ0cHx0ZWx8ZmlsZSk6fFteIyYvOj9dKig/OlsjLz9dfCQpKS9naVxuXG4vKipcbiAqIEEgcGF0dGVybiB0aGF0IG1hdGNoZXMgc2FmZSBkYXRhIFVSTHMuIE9ubHkgbWF0Y2hlcyBpbWFnZSwgdmlkZW8gYW5kIGF1ZGlvIHR5cGVzLlxuICpcbiAqIFNob3V0b3V0IHRvIEFuZ3VsYXIgNyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvNy4yLjQvcGFja2FnZXMvY29yZS9zcmMvc2FuaXRpemF0aW9uL3VybF9zYW5pdGl6ZXIudHNcbiAqL1xuY29uc3QgREFUQV9VUkxfUEFUVEVSTiA9IC9eZGF0YTooPzppbWFnZVxcLyg/OmJtcHxnaWZ8anBlZ3xqcGd8cG5nfHRpZmZ8d2VicCl8dmlkZW9cXC8oPzptcGVnfG1wNHxvZ2d8d2VibSl8YXVkaW9cXC8oPzptcDN8b2dhfG9nZ3xvcHVzKSk7YmFzZTY0LFtcXGQrL2Etel0rPSokL2lcblxuZnVuY3Rpb24gYWxsb3dlZEF0dHJpYnV0ZShhdHRyLCBhbGxvd2VkQXR0cmlidXRlTGlzdCkge1xuICBjb25zdCBhdHRyTmFtZSA9IGF0dHIubm9kZU5hbWUudG9Mb3dlckNhc2UoKVxuXG4gIGlmIChhbGxvd2VkQXR0cmlidXRlTGlzdC5pbmRleE9mKGF0dHJOYW1lKSAhPT0gLTEpIHtcbiAgICBpZiAodXJpQXR0cnMuaW5kZXhPZihhdHRyTmFtZSkgIT09IC0xKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbihhdHRyLm5vZGVWYWx1ZS5tYXRjaChTQUZFX1VSTF9QQVRURVJOKSB8fCBhdHRyLm5vZGVWYWx1ZS5tYXRjaChEQVRBX1VSTF9QQVRURVJOKSlcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3QgcmVnRXhwID0gYWxsb3dlZEF0dHJpYnV0ZUxpc3QuZmlsdGVyKGF0dHJSZWdleCA9PiBhdHRyUmVnZXggaW5zdGFuY2VvZiBSZWdFeHApXG5cbiAgLy8gQ2hlY2sgaWYgYSByZWd1bGFyIGV4cHJlc3Npb24gdmFsaWRhdGVzIHRoZSBhdHRyaWJ1dGUuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSByZWdFeHAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoYXR0ck5hbWUubWF0Y2gocmVnRXhwW2ldKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhbml0aXplSHRtbCh1bnNhZmVIdG1sLCB3aGl0ZUxpc3QsIHNhbml0aXplRm4pIHtcbiAgaWYgKHVuc2FmZUh0bWwubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVuc2FmZUh0bWxcbiAgfVxuXG4gIGlmIChzYW5pdGl6ZUZuICYmIHR5cGVvZiBzYW5pdGl6ZUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHNhbml0aXplRm4odW5zYWZlSHRtbClcbiAgfVxuXG4gIGNvbnN0IGRvbVBhcnNlciA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKClcbiAgY29uc3QgY3JlYXRlZERvY3VtZW50ID0gZG9tUGFyc2VyLnBhcnNlRnJvbVN0cmluZyh1bnNhZmVIdG1sLCAndGV4dC9odG1sJylcbiAgY29uc3Qgd2hpdGVsaXN0S2V5cyA9IE9iamVjdC5rZXlzKHdoaXRlTGlzdClcbiAgY29uc3QgZWxlbWVudHMgPSBbXS5zbGljZS5jYWxsKGNyZWF0ZWREb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSlcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBlbCA9IGVsZW1lbnRzW2ldXG4gICAgY29uc3QgZWxOYW1lID0gZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKVxuXG4gICAgaWYgKHdoaXRlbGlzdEtleXMuaW5kZXhPZihlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpIHtcbiAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpXG5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgY29uc3QgYXR0cmlidXRlTGlzdCA9IFtdLnNsaWNlLmNhbGwoZWwuYXR0cmlidXRlcylcbiAgICBjb25zdCB3aGl0ZWxpc3RlZEF0dHJpYnV0ZXMgPSBbXS5jb25jYXQod2hpdGVMaXN0WycqJ10gfHwgW10sIHdoaXRlTGlzdFtlbE5hbWVdIHx8IFtdKVxuXG4gICAgYXR0cmlidXRlTGlzdC5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgaWYgKCFhbGxvd2VkQXR0cmlidXRlKGF0dHIsIHdoaXRlbGlzdGVkQXR0cmlidXRlcykpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIubm9kZU5hbWUpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVkRG9jdW1lbnQuYm9keS5pbm5lckhUTUxcbn1cbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuNi4wKTogdG9vbHRpcC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCB7XG4gIERlZmF1bHRXaGl0ZWxpc3QsXG4gIHNhbml0aXplSHRtbFxufSBmcm9tICcuL3Rvb2xzL3Nhbml0aXplcidcbmltcG9ydCAkIGZyb20gJ2pxdWVyeSdcbmltcG9ydCBQb3BwZXIgZnJvbSAncG9wcGVyLmpzJ1xuaW1wb3J0IFV0aWwgZnJvbSAnLi91dGlsJ1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FID0gJ3Rvb2x0aXAnXG5jb25zdCBWRVJTSU9OID0gJzQuNi4wJ1xuY29uc3QgREFUQV9LRVkgPSAnYnMudG9vbHRpcCdcbmNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdXG5jb25zdCBDTEFTU19QUkVGSVggPSAnYnMtdG9vbHRpcCdcbmNvbnN0IEJTQ0xTX1BSRUZJWF9SRUdFWCA9IG5ldyBSZWdFeHAoYChefFxcXFxzKSR7Q0xBU1NfUFJFRklYfVxcXFxTK2AsICdnJylcbmNvbnN0IERJU0FMTE9XRURfQVRUUklCVVRFUyA9IFsnc2FuaXRpemUnLCAnd2hpdGVMaXN0JywgJ3Nhbml0aXplRm4nXVxuXG5jb25zdCBEZWZhdWx0VHlwZSA9IHtcbiAgYW5pbWF0aW9uOiAnYm9vbGVhbicsXG4gIHRlbXBsYXRlOiAnc3RyaW5nJyxcbiAgdGl0bGU6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pJyxcbiAgdHJpZ2dlcjogJ3N0cmluZycsXG4gIGRlbGF5OiAnKG51bWJlcnxvYmplY3QpJyxcbiAgaHRtbDogJ2Jvb2xlYW4nLFxuICBzZWxlY3RvcjogJyhzdHJpbmd8Ym9vbGVhbiknLFxuICBwbGFjZW1lbnQ6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXG4gIG9mZnNldDogJyhudW1iZXJ8c3RyaW5nfGZ1bmN0aW9uKScsXG4gIGNvbnRhaW5lcjogJyhzdHJpbmd8ZWxlbWVudHxib29sZWFuKScsXG4gIGZhbGxiYWNrUGxhY2VtZW50OiAnKHN0cmluZ3xhcnJheSknLFxuICBib3VuZGFyeTogJyhzdHJpbmd8ZWxlbWVudCknLFxuICBjdXN0b21DbGFzczogJyhzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgc2FuaXRpemU6ICdib29sZWFuJyxcbiAgc2FuaXRpemVGbjogJyhudWxsfGZ1bmN0aW9uKScsXG4gIHdoaXRlTGlzdDogJ29iamVjdCcsXG4gIHBvcHBlckNvbmZpZzogJyhudWxsfG9iamVjdCknXG59XG5cbmNvbnN0IEF0dGFjaG1lbnRNYXAgPSB7XG4gIEFVVE86ICdhdXRvJyxcbiAgVE9QOiAndG9wJyxcbiAgUklHSFQ6ICdyaWdodCcsXG4gIEJPVFRPTTogJ2JvdHRvbScsXG4gIExFRlQ6ICdsZWZ0J1xufVxuXG5jb25zdCBEZWZhdWx0ID0ge1xuICBhbmltYXRpb246IHRydWUsXG4gIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPicgK1xuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImFycm93XCI+PC9kaXY+JyArXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwidG9vbHRpcC1pbm5lclwiPjwvZGl2PjwvZGl2PicsXG4gIHRyaWdnZXI6ICdob3ZlciBmb2N1cycsXG4gIHRpdGxlOiAnJyxcbiAgZGVsYXk6IDAsXG4gIGh0bWw6IGZhbHNlLFxuICBzZWxlY3RvcjogZmFsc2UsXG4gIHBsYWNlbWVudDogJ3RvcCcsXG4gIG9mZnNldDogMCxcbiAgY29udGFpbmVyOiBmYWxzZSxcbiAgZmFsbGJhY2tQbGFjZW1lbnQ6ICdmbGlwJyxcbiAgYm91bmRhcnk6ICdzY3JvbGxQYXJlbnQnLFxuICBjdXN0b21DbGFzczogJycsXG4gIHNhbml0aXplOiB0cnVlLFxuICBzYW5pdGl6ZUZuOiBudWxsLFxuICB3aGl0ZUxpc3Q6IERlZmF1bHRXaGl0ZWxpc3QsXG4gIHBvcHBlckNvbmZpZzogbnVsbFxufVxuXG5jb25zdCBIT1ZFUl9TVEFURV9TSE9XID0gJ3Nob3cnXG5jb25zdCBIT1ZFUl9TVEFURV9PVVQgPSAnb3V0J1xuXG5jb25zdCBFdmVudCA9IHtcbiAgSElERTogYGhpZGUke0VWRU5UX0tFWX1gLFxuICBISURERU46IGBoaWRkZW4ke0VWRU5UX0tFWX1gLFxuICBTSE9XOiBgc2hvdyR7RVZFTlRfS0VZfWAsXG4gIFNIT1dOOiBgc2hvd24ke0VWRU5UX0tFWX1gLFxuICBJTlNFUlRFRDogYGluc2VydGVkJHtFVkVOVF9LRVl9YCxcbiAgQ0xJQ0s6IGBjbGljayR7RVZFTlRfS0VZfWAsXG4gIEZPQ1VTSU46IGBmb2N1c2luJHtFVkVOVF9LRVl9YCxcbiAgRk9DVVNPVVQ6IGBmb2N1c291dCR7RVZFTlRfS0VZfWAsXG4gIE1PVVNFRU5URVI6IGBtb3VzZWVudGVyJHtFVkVOVF9LRVl9YCxcbiAgTU9VU0VMRUFWRTogYG1vdXNlbGVhdmUke0VWRU5UX0tFWX1gXG59XG5cbmNvbnN0IENMQVNTX05BTUVfRkFERSA9ICdmYWRlJ1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XID0gJ3Nob3cnXG5cbmNvbnN0IFNFTEVDVE9SX1RPT0xUSVBfSU5ORVIgPSAnLnRvb2x0aXAtaW5uZXInXG5jb25zdCBTRUxFQ1RPUl9BUlJPVyA9ICcuYXJyb3cnXG5cbmNvbnN0IFRSSUdHRVJfSE9WRVIgPSAnaG92ZXInXG5jb25zdCBUUklHR0VSX0ZPQ1VTID0gJ2ZvY3VzJ1xuY29uc3QgVFJJR0dFUl9DTElDSyA9ICdjbGljaydcbmNvbnN0IFRSSUdHRVJfTUFOVUFMID0gJ21hbnVhbCdcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNsYXNzIFRvb2x0aXAge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBpZiAodHlwZW9mIFBvcHBlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Jvb3RzdHJhcFxcJ3MgdG9vbHRpcHMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZyknKVxuICAgIH1cblxuICAgIC8vIHByaXZhdGVcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlXG4gICAgdGhpcy5fdGltZW91dCA9IDBcbiAgICB0aGlzLl9ob3ZlclN0YXRlID0gJydcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyID0ge31cbiAgICB0aGlzLl9wb3BwZXIgPSBudWxsXG5cbiAgICAvLyBQcm90ZWN0ZWRcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50XG4gICAgdGhpcy5jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKVxuICAgIHRoaXMudGlwID0gbnVsbFxuXG4gICAgdGhpcy5fc2V0TGlzdGVuZXJzKClcbiAgfVxuXG4gIC8vIEdldHRlcnNcblxuICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XG4gICAgcmV0dXJuIFZFUlNJT05cbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFxuICB9XG5cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FXG4gIH1cblxuICBzdGF0aWMgZ2V0IERBVEFfS0VZKCkge1xuICAgIHJldHVybiBEQVRBX0tFWVxuICB9XG5cbiAgc3RhdGljIGdldCBFdmVudCgpIHtcbiAgICByZXR1cm4gRXZlbnRcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRVZFTlRfS0VZKCkge1xuICAgIHJldHVybiBFVkVOVF9LRVlcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlXG4gIH1cblxuICAvLyBQdWJsaWNcblxuICBlbmFibGUoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZVxuICB9XG5cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZVxuICB9XG5cbiAgdG9nZ2xlRW5hYmxlZCgpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSAhdGhpcy5faXNFbmFibGVkXG4gIH1cblxuICB0b2dnbGUoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBjb25zdCBkYXRhS2V5ID0gdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWVxuICAgICAgbGV0IGNvbnRleHQgPSAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSlcblxuICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihcbiAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKClcbiAgICAgICAgKVxuICAgICAgICAkKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSwgY29udGV4dClcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlci5jbGljayA9ICFjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyLmNsaWNrXG5cbiAgICAgIGlmIChjb250ZXh0Ll9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcbiAgICAgICAgY29udGV4dC5fZW50ZXIobnVsbCwgY29udGV4dClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuX2xlYXZlKG51bGwsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKS5oYXNDbGFzcyhDTEFTU19OQU1FX1NIT1cpKSB7XG4gICAgICAgIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbnRlcihudWxsLCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpXG5cbiAgICAkLnJlbW92ZURhdGEodGhpcy5lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZKVxuXG4gICAgJCh0aGlzLmVsZW1lbnQpLm9mZih0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0tFWSlcbiAgICAkKHRoaXMuZWxlbWVudCkuY2xvc2VzdCgnLm1vZGFsJykub2ZmKCdoaWRlLmJzLm1vZGFsJywgdGhpcy5faGlkZU1vZGFsSGFuZGxlcilcblxuICAgIGlmICh0aGlzLnRpcCkge1xuICAgICAgJCh0aGlzLnRpcCkucmVtb3ZlKClcbiAgICB9XG5cbiAgICB0aGlzLl9pc0VuYWJsZWQgPSBudWxsXG4gICAgdGhpcy5fdGltZW91dCA9IG51bGxcbiAgICB0aGlzLl9ob3ZlclN0YXRlID0gbnVsbFxuICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXIgPSBudWxsXG4gICAgaWYgKHRoaXMuX3BvcHBlcikge1xuICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKVxuICAgIH1cblxuICAgIHRoaXMuX3BvcHBlciA9IG51bGxcbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsXG4gICAgdGhpcy5jb25maWcgPSBudWxsXG4gICAgdGhpcy50aXAgPSBudWxsXG4gIH1cblxuICBzaG93KCkge1xuICAgIGlmICgkKHRoaXMuZWxlbWVudCkuY3NzKCdkaXNwbGF5JykgPT09ICdub25lJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgdXNlIHNob3cgb24gdmlzaWJsZSBlbGVtZW50cycpXG4gICAgfVxuXG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gJC5FdmVudCh0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LlNIT1cpXG4gICAgaWYgKHRoaXMuaXNXaXRoQ29udGVudCgpICYmIHRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgJCh0aGlzLmVsZW1lbnQpLnRyaWdnZXIoc2hvd0V2ZW50KVxuXG4gICAgICBjb25zdCBzaGFkb3dSb290ID0gVXRpbC5maW5kU2hhZG93Um9vdCh0aGlzLmVsZW1lbnQpXG4gICAgICBjb25zdCBpc0luVGhlRG9tID0gJC5jb250YWlucyhcbiAgICAgICAgc2hhZG93Um9vdCAhPT0gbnVsbCA/IHNoYWRvd1Jvb3QgOiB0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgIHRoaXMuZWxlbWVudFxuICAgICAgKVxuXG4gICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8ICFpc0luVGhlRG9tKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCB0aXAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKVxuICAgICAgY29uc3QgdGlwSWQgPSBVdGlsLmdldFVJRCh0aGlzLmNvbnN0cnVjdG9yLk5BTUUpXG5cbiAgICAgIHRpcC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGlwSWQpXG4gICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JywgdGlwSWQpXG5cbiAgICAgIHRoaXMuc2V0Q29udGVudCgpXG5cbiAgICAgIGlmICh0aGlzLmNvbmZpZy5hbmltYXRpb24pIHtcbiAgICAgICAgJCh0aXApLmFkZENsYXNzKENMQVNTX05BTUVfRkFERSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGxhY2VtZW50ID0gdHlwZW9mIHRoaXMuY29uZmlnLnBsYWNlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIHRoaXMuY29uZmlnLnBsYWNlbWVudC5jYWxsKHRoaXMsIHRpcCwgdGhpcy5lbGVtZW50KSA6XG4gICAgICAgIHRoaXMuY29uZmlnLnBsYWNlbWVudFxuXG4gICAgICBjb25zdCBhdHRhY2htZW50ID0gdGhpcy5fZ2V0QXR0YWNobWVudChwbGFjZW1lbnQpXG4gICAgICB0aGlzLmFkZEF0dGFjaG1lbnRDbGFzcyhhdHRhY2htZW50KVxuXG4gICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLl9nZXRDb250YWluZXIoKVxuICAgICAgJCh0aXApLmRhdGEodGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSwgdGhpcylcblxuICAgICAgaWYgKCEkLmNvbnRhaW5zKHRoaXMuZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgdGhpcy50aXApKSB7XG4gICAgICAgICQodGlwKS5hcHBlbmRUbyhjb250YWluZXIpXG4gICAgICB9XG5cbiAgICAgICQodGhpcy5lbGVtZW50KS50cmlnZ2VyKHRoaXMuY29uc3RydWN0b3IuRXZlbnQuSU5TRVJURUQpXG5cbiAgICAgIHRoaXMuX3BvcHBlciA9IG5ldyBQb3BwZXIodGhpcy5lbGVtZW50LCB0aXAsIHRoaXMuX2dldFBvcHBlckNvbmZpZyhhdHRhY2htZW50KSlcblxuICAgICAgJCh0aXApLmFkZENsYXNzKENMQVNTX05BTUVfU0hPVylcbiAgICAgICQodGlwKS5hZGRDbGFzcyh0aGlzLmNvbmZpZy5jdXN0b21DbGFzcylcblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIGFkZCBleHRyYVxuICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB0byB0aGUgYm9keSdzIGltbWVkaWF0ZSBjaGlsZHJlbjtcbiAgICAgIC8vIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYnJva2VuIGV2ZW50IGRlbGVnYXRpb24gb24gaU9TXG4gICAgICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTQvMDIvbW91c2VfZXZlbnRfYnViLmh0bWxcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgJChkb2N1bWVudC5ib2R5KS5jaGlsZHJlbigpLm9uKCdtb3VzZW92ZXInLCBudWxsLCAkLm5vb3ApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5fZml4VHJhbnNpdGlvbigpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcmV2SG92ZXJTdGF0ZSA9IHRoaXMuX2hvdmVyU3RhdGVcbiAgICAgICAgdGhpcy5faG92ZXJTdGF0ZSA9IG51bGxcblxuICAgICAgICAkKHRoaXMuZWxlbWVudCkudHJpZ2dlcih0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LlNIT1dOKVxuXG4gICAgICAgIGlmIChwcmV2SG92ZXJTdGF0ZSA9PT0gSE9WRVJfU1RBVEVfT1VUKSB7XG4gICAgICAgICAgdGhpcy5fbGVhdmUobnVsbCwgdGhpcylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoJCh0aGlzLnRpcCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9GQURFKSkge1xuICAgICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMudGlwKVxuXG4gICAgICAgICQodGhpcy50aXApXG4gICAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGxldGUoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhpZGUoY2FsbGJhY2spIHtcbiAgICBjb25zdCB0aXAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKVxuICAgIGNvbnN0IGhpZGVFdmVudCA9ICQuRXZlbnQodGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5ISURFKVxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2hvdmVyU3RhdGUgIT09IEhPVkVSX1NUQVRFX1NIT1cgJiYgdGlwLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGlwLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGlwKVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9jbGVhblRpcENsYXNzKClcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKVxuICAgICAgJCh0aGlzLmVsZW1lbnQpLnRyaWdnZXIodGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5ISURERU4pXG4gICAgICBpZiAodGhpcy5fcG9wcGVyICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KClcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAkKHRoaXMuZWxlbWVudCkudHJpZ2dlcihoaWRlRXZlbnQpXG5cbiAgICBpZiAoaGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAkKHRpcCkucmVtb3ZlQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XKVxuXG4gICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIHJlbW92ZSB0aGUgZXh0cmFcbiAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHdlIGFkZGVkIGZvciBpT1Mgc3VwcG9ydFxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICQoZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4oKS5vZmYoJ21vdXNlb3ZlcicsIG51bGwsICQubm9vcClcbiAgICB9XG5cbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfQ0xJQ0tdID0gZmFsc2VcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfRk9DVVNdID0gZmFsc2VcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfSE9WRVJdID0gZmFsc2VcblxuICAgIGlmICgkKHRoaXMudGlwKS5oYXNDbGFzcyhDTEFTU19OQU1FX0ZBREUpKSB7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRpcClcblxuICAgICAgJCh0aXApXG4gICAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBsZXRlKClcbiAgICB9XG5cbiAgICB0aGlzLl9ob3ZlclN0YXRlID0gJydcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fcG9wcGVyICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9wb3BwZXIuc2NoZWR1bGVVcGRhdGUoKVxuICAgIH1cbiAgfVxuXG4gIC8vIFByb3RlY3RlZFxuXG4gIGlzV2l0aENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5nZXRUaXRsZSgpKVxuICB9XG5cbiAgYWRkQXR0YWNobWVudENsYXNzKGF0dGFjaG1lbnQpIHtcbiAgICAkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKS5hZGRDbGFzcyhgJHtDTEFTU19QUkVGSVh9LSR7YXR0YWNobWVudH1gKVxuICB9XG5cbiAgZ2V0VGlwRWxlbWVudCgpIHtcbiAgICB0aGlzLnRpcCA9IHRoaXMudGlwIHx8ICQodGhpcy5jb25maWcudGVtcGxhdGUpWzBdXG4gICAgcmV0dXJuIHRoaXMudGlwXG4gIH1cblxuICBzZXRDb250ZW50KCkge1xuICAgIGNvbnN0IHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpXG4gICAgdGhpcy5zZXRFbGVtZW50Q29udGVudCgkKHRpcC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX1RPT0xUSVBfSU5ORVIpKSwgdGhpcy5nZXRUaXRsZSgpKVxuICAgICQodGlwKS5yZW1vdmVDbGFzcyhgJHtDTEFTU19OQU1FX0ZBREV9ICR7Q0xBU1NfTkFNRV9TSE9XfWApXG4gIH1cblxuICBzZXRFbGVtZW50Q29udGVudCgkZWxlbWVudCwgY29udGVudCkge1xuICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ29iamVjdCcgJiYgKGNvbnRlbnQubm9kZVR5cGUgfHwgY29udGVudC5qcXVlcnkpKSB7XG4gICAgICAvLyBDb250ZW50IGlzIGEgRE9NIG5vZGUgb3IgYSBqUXVlcnlcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5odG1sKSB7XG4gICAgICAgIGlmICghJChjb250ZW50KS5wYXJlbnQoKS5pcygkZWxlbWVudCkpIHtcbiAgICAgICAgICAkZWxlbWVudC5lbXB0eSgpLmFwcGVuZChjb250ZW50KVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkZWxlbWVudC50ZXh0KCQoY29udGVudCkudGV4dCgpKVxuICAgICAgfVxuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb25maWcuaHRtbCkge1xuICAgICAgaWYgKHRoaXMuY29uZmlnLnNhbml0aXplKSB7XG4gICAgICAgIGNvbnRlbnQgPSBzYW5pdGl6ZUh0bWwoY29udGVudCwgdGhpcy5jb25maWcud2hpdGVMaXN0LCB0aGlzLmNvbmZpZy5zYW5pdGl6ZUZuKVxuICAgICAgfVxuXG4gICAgICAkZWxlbWVudC5odG1sKGNvbnRlbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgICRlbGVtZW50LnRleHQoY29udGVudClcbiAgICB9XG4gIH1cblxuICBnZXRUaXRsZSgpIHtcbiAgICBsZXQgdGl0bGUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRpdGxlJylcblxuICAgIGlmICghdGl0bGUpIHtcbiAgICAgIHRpdGxlID0gdHlwZW9mIHRoaXMuY29uZmlnLnRpdGxlID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgdGhpcy5jb25maWcudGl0bGUuY2FsbCh0aGlzLmVsZW1lbnQpIDpcbiAgICAgICAgdGhpcy5jb25maWcudGl0bGVcbiAgICB9XG5cbiAgICByZXR1cm4gdGl0bGVcbiAgfVxuXG4gIC8vIFByaXZhdGVcblxuICBfZ2V0UG9wcGVyQ29uZmlnKGF0dGFjaG1lbnQpIHtcbiAgICBjb25zdCBkZWZhdWx0QnNDb25maWcgPSB7XG4gICAgICBwbGFjZW1lbnQ6IGF0dGFjaG1lbnQsXG4gICAgICBtb2RpZmllcnM6IHtcbiAgICAgICAgb2Zmc2V0OiB0aGlzLl9nZXRPZmZzZXQoKSxcbiAgICAgICAgZmxpcDoge1xuICAgICAgICAgIGJlaGF2aW9yOiB0aGlzLmNvbmZpZy5mYWxsYmFja1BsYWNlbWVudFxuICAgICAgICB9LFxuICAgICAgICBhcnJvdzoge1xuICAgICAgICAgIGVsZW1lbnQ6IFNFTEVDVE9SX0FSUk9XXG4gICAgICAgIH0sXG4gICAgICAgIHByZXZlbnRPdmVyZmxvdzoge1xuICAgICAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiB0aGlzLmNvbmZpZy5ib3VuZGFyeVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25DcmVhdGU6IGRhdGEgPT4ge1xuICAgICAgICBpZiAoZGF0YS5vcmlnaW5hbFBsYWNlbWVudCAhPT0gZGF0YS5wbGFjZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UoZGF0YSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uVXBkYXRlOiBkYXRhID0+IHRoaXMuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShkYXRhKVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi5kZWZhdWx0QnNDb25maWcsXG4gICAgICAuLi50aGlzLmNvbmZpZy5wb3BwZXJDb25maWdcbiAgICB9XG4gIH1cblxuICBfZ2V0T2Zmc2V0KCkge1xuICAgIGNvbnN0IG9mZnNldCA9IHt9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMuY29uZmlnLm9mZnNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb2Zmc2V0LmZuID0gZGF0YSA9PiB7XG4gICAgICAgIGRhdGEub2Zmc2V0cyA9IHtcbiAgICAgICAgICAuLi5kYXRhLm9mZnNldHMsXG4gICAgICAgICAgLi4uKHRoaXMuY29uZmlnLm9mZnNldChkYXRhLm9mZnNldHMsIHRoaXMuZWxlbWVudCkgfHwge30pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQub2Zmc2V0ID0gdGhpcy5jb25maWcub2Zmc2V0XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldFxuICB9XG5cbiAgX2dldENvbnRhaW5lcigpIHtcbiAgICBpZiAodGhpcy5jb25maWcuY29udGFpbmVyID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHlcbiAgICB9XG5cbiAgICBpZiAoVXRpbC5pc0VsZW1lbnQodGhpcy5jb25maWcuY29udGFpbmVyKSkge1xuICAgICAgcmV0dXJuICQodGhpcy5jb25maWcuY29udGFpbmVyKVxuICAgIH1cblxuICAgIHJldHVybiAkKGRvY3VtZW50KS5maW5kKHRoaXMuY29uZmlnLmNvbnRhaW5lcilcbiAgfVxuXG4gIF9nZXRBdHRhY2htZW50KHBsYWNlbWVudCkge1xuICAgIHJldHVybiBBdHRhY2htZW50TWFwW3BsYWNlbWVudC50b1VwcGVyQ2FzZSgpXVxuICB9XG5cbiAgX3NldExpc3RlbmVycygpIHtcbiAgICBjb25zdCB0cmlnZ2VycyA9IHRoaXMuY29uZmlnLnRyaWdnZXIuc3BsaXQoJyAnKVxuXG4gICAgdHJpZ2dlcnMuZm9yRWFjaCh0cmlnZ2VyID0+IHtcbiAgICAgIGlmICh0cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICAgICQodGhpcy5lbGVtZW50KS5vbihcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkNMSUNLLFxuICAgICAgICAgIHRoaXMuY29uZmlnLnNlbGVjdG9yLFxuICAgICAgICAgIGV2ZW50ID0+IHRoaXMudG9nZ2xlKGV2ZW50KVxuICAgICAgICApXG4gICAgICB9IGVsc2UgaWYgKHRyaWdnZXIgIT09IFRSSUdHRVJfTUFOVUFMKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50SW4gPSB0cmlnZ2VyID09PSBUUklHR0VSX0hPVkVSID9cbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50Lk1PVVNFRU5URVIgOlxuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNJTlxuICAgICAgICBjb25zdCBldmVudE91dCA9IHRyaWdnZXIgPT09IFRSSUdHRVJfSE9WRVIgP1xuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VMRUFWRSA6XG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU09VVFxuXG4gICAgICAgICQodGhpcy5lbGVtZW50KVxuICAgICAgICAgIC5vbihldmVudEluLCB0aGlzLmNvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4gdGhpcy5fZW50ZXIoZXZlbnQpKVxuICAgICAgICAgIC5vbihldmVudE91dCwgdGhpcy5jb25maWcuc2VsZWN0b3IsIGV2ZW50ID0+IHRoaXMuX2xlYXZlKGV2ZW50KSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5faGlkZU1vZGFsSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5oaWRlKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAkKHRoaXMuZWxlbWVudCkuY2xvc2VzdCgnLm1vZGFsJykub24oJ2hpZGUuYnMubW9kYWwnLCB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyKVxuXG4gICAgaWYgKHRoaXMuY29uZmlnLnNlbGVjdG9yKSB7XG4gICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICBzZWxlY3RvcjogJydcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZml4VGl0bGUoKVxuICAgIH1cbiAgfVxuXG4gIF9maXhUaXRsZSgpIHtcbiAgICBjb25zdCB0aXRsZVR5cGUgPSB0eXBlb2YgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScpXG5cbiAgICBpZiAodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgndGl0bGUnKSB8fCB0aXRsZVR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFxuICAgICAgICAnZGF0YS1vcmlnaW5hbC10aXRsZScsXG4gICAgICAgIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJykgfHwgJydcbiAgICAgIClcblxuICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnJylcbiAgICB9XG4gIH1cblxuICBfZW50ZXIoZXZlbnQsIGNvbnRleHQpIHtcbiAgICBjb25zdCBkYXRhS2V5ID0gdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWVxuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8ICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5KVxuXG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICBjb250ZXh0ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoXG4gICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICAgIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKClcbiAgICAgIClcbiAgICAgICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5LCBjb250ZXh0KVxuICAgIH1cblxuICAgIGlmIChldmVudCkge1xuICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltcbiAgICAgICAgZXZlbnQudHlwZSA9PT0gJ2ZvY3VzaW4nID8gVFJJR0dFUl9GT0NVUyA6IFRSSUdHRVJfSE9WRVJcbiAgICAgIF0gPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKCQoY29udGV4dC5nZXRUaXBFbGVtZW50KCkpLmhhc0NsYXNzKENMQVNTX05BTUVfU0hPVykgfHwgY29udGV4dC5faG92ZXJTdGF0ZSA9PT0gSE9WRVJfU1RBVEVfU0hPVykge1xuICAgICAgY29udGV4dC5faG92ZXJTdGF0ZSA9IEhPVkVSX1NUQVRFX1NIT1dcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNsZWFyVGltZW91dChjb250ZXh0Ll90aW1lb3V0KVxuXG4gICAgY29udGV4dC5faG92ZXJTdGF0ZSA9IEhPVkVSX1NUQVRFX1NIT1dcblxuICAgIGlmICghY29udGV4dC5jb25maWcuZGVsYXkgfHwgIWNvbnRleHQuY29uZmlnLmRlbGF5LnNob3cpIHtcbiAgICAgIGNvbnRleHQuc2hvdygpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb250ZXh0Ll90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoY29udGV4dC5faG92ZXJTdGF0ZSA9PT0gSE9WRVJfU1RBVEVfU0hPVykge1xuICAgICAgICBjb250ZXh0LnNob3coKVxuICAgICAgfVxuICAgIH0sIGNvbnRleHQuY29uZmlnLmRlbGF5LnNob3cpXG4gIH1cblxuICBfbGVhdmUoZXZlbnQsIGNvbnRleHQpIHtcbiAgICBjb25zdCBkYXRhS2V5ID0gdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWVxuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8ICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5KVxuXG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICBjb250ZXh0ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoXG4gICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICAgIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKClcbiAgICAgIClcbiAgICAgICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5LCBjb250ZXh0KVxuICAgIH1cblxuICAgIGlmIChldmVudCkge1xuICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltcbiAgICAgICAgZXZlbnQudHlwZSA9PT0gJ2ZvY3Vzb3V0JyA/IFRSSUdHRVJfRk9DVVMgOiBUUklHR0VSX0hPVkVSXG4gICAgICBdID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dC5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjbGVhclRpbWVvdXQoY29udGV4dC5fdGltZW91dClcblxuICAgIGNvbnRleHQuX2hvdmVyU3RhdGUgPSBIT1ZFUl9TVEFURV9PVVRcblxuICAgIGlmICghY29udGV4dC5jb25maWcuZGVsYXkgfHwgIWNvbnRleHQuY29uZmlnLmRlbGF5LmhpZGUpIHtcbiAgICAgIGNvbnRleHQuaGlkZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb250ZXh0Ll90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoY29udGV4dC5faG92ZXJTdGF0ZSA9PT0gSE9WRVJfU1RBVEVfT1VUKSB7XG4gICAgICAgIGNvbnRleHQuaGlkZSgpXG4gICAgICB9XG4gICAgfSwgY29udGV4dC5jb25maWcuZGVsYXkuaGlkZSlcbiAgfVxuXG4gIF9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkge1xuICAgIGZvciAoY29uc3QgdHJpZ2dlciBpbiB0aGlzLl9hY3RpdmVUcmlnZ2VyKSB7XG4gICAgICBpZiAodGhpcy5fYWN0aXZlVHJpZ2dlclt0cmlnZ2VyXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25zdCBkYXRhQXR0cmlidXRlcyA9ICQodGhpcy5lbGVtZW50KS5kYXRhKClcblxuICAgIE9iamVjdC5rZXlzKGRhdGFBdHRyaWJ1dGVzKVxuICAgICAgLmZvckVhY2goZGF0YUF0dHIgPT4ge1xuICAgICAgICBpZiAoRElTQUxMT1dFRF9BVFRSSUJVVEVTLmluZGV4T2YoZGF0YUF0dHIpICE9PSAtMSkge1xuICAgICAgICAgIGRlbGV0ZSBkYXRhQXR0cmlidXRlc1tkYXRhQXR0cl1cbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgIGNvbmZpZyA9IHtcbiAgICAgIC4uLnRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCxcbiAgICAgIC4uLmRhdGFBdHRyaWJ1dGVzLFxuICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uZmlnLmRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgY29uZmlnLmRlbGF5ID0ge1xuICAgICAgICBzaG93OiBjb25maWcuZGVsYXksXG4gICAgICAgIGhpZGU6IGNvbmZpZy5kZWxheVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uZmlnLnRpdGxlID09PSAnbnVtYmVyJykge1xuICAgICAgY29uZmlnLnRpdGxlID0gY29uZmlnLnRpdGxlLnRvU3RyaW5nKClcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZy5jb250ZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgY29uZmlnLmNvbnRlbnQgPSBjb25maWcuY29udGVudC50b1N0cmluZygpXG4gICAgfVxuXG4gICAgVXRpbC50eXBlQ2hlY2tDb25maWcoXG4gICAgICBOQU1FLFxuICAgICAgY29uZmlnLFxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZVxuICAgIClcblxuICAgIGlmIChjb25maWcuc2FuaXRpemUpIHtcbiAgICAgIGNvbmZpZy50ZW1wbGF0ZSA9IHNhbml0aXplSHRtbChjb25maWcudGVtcGxhdGUsIGNvbmZpZy53aGl0ZUxpc3QsIGNvbmZpZy5zYW5pdGl6ZUZuKVxuICAgIH1cblxuICAgIHJldHVybiBjb25maWdcbiAgfVxuXG4gIF9nZXREZWxlZ2F0ZUNvbmZpZygpIHtcbiAgICBjb25zdCBjb25maWcgPSB7fVxuXG4gICAgaWYgKHRoaXMuY29uZmlnKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmNvbmZpZykge1xuICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2tleV0gIT09IHRoaXMuY29uZmlnW2tleV0pIHtcbiAgICAgICAgICBjb25maWdba2V5XSA9IHRoaXMuY29uZmlnW2tleV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb25maWdcbiAgfVxuXG4gIF9jbGVhblRpcENsYXNzKCkge1xuICAgIGNvbnN0ICR0aXAgPSAkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKVxuICAgIGNvbnN0IHRhYkNsYXNzID0gJHRpcC5hdHRyKCdjbGFzcycpLm1hdGNoKEJTQ0xTX1BSRUZJWF9SRUdFWClcbiAgICBpZiAodGFiQ2xhc3MgIT09IG51bGwgJiYgdGFiQ2xhc3MubGVuZ3RoKSB7XG4gICAgICAkdGlwLnJlbW92ZUNsYXNzKHRhYkNsYXNzLmpvaW4oJycpKVxuICAgIH1cbiAgfVxuXG4gIF9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UocG9wcGVyRGF0YSkge1xuICAgIHRoaXMudGlwID0gcG9wcGVyRGF0YS5pbnN0YW5jZS5wb3BwZXJcbiAgICB0aGlzLl9jbGVhblRpcENsYXNzKClcbiAgICB0aGlzLmFkZEF0dGFjaG1lbnRDbGFzcyh0aGlzLl9nZXRBdHRhY2htZW50KHBvcHBlckRhdGEucGxhY2VtZW50KSlcbiAgfVxuXG4gIF9maXhUcmFuc2l0aW9uKCkge1xuICAgIGNvbnN0IHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpXG4gICAgY29uc3QgaW5pdENvbmZpZ0FuaW1hdGlvbiA9IHRoaXMuY29uZmlnLmFuaW1hdGlvblxuXG4gICAgaWYgKHRpcC5nZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JykgIT09IG51bGwpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgICQodGlwKS5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX0ZBREUpXG4gICAgdGhpcy5jb25maWcuYW5pbWF0aW9uID0gZmFsc2VcbiAgICB0aGlzLmhpZGUoKVxuICAgIHRoaXMuc2hvdygpXG4gICAgdGhpcy5jb25maWcuYW5pbWF0aW9uID0gaW5pdENvbmZpZ0FuaW1hdGlvblxuICB9XG5cbiAgLy8gU3RhdGljXG5cbiAgc3RhdGljIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCAkZWxlbWVudCA9ICQodGhpcylcbiAgICAgIGxldCBkYXRhID0gJGVsZW1lbnQuZGF0YShEQVRBX0tFWSlcbiAgICAgIGNvbnN0IF9jb25maWcgPSB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWdcblxuICAgICAgaWYgKCFkYXRhICYmIC9kaXNwb3NlfGhpZGUvLnRlc3QoY29uZmlnKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgVG9vbHRpcCh0aGlzLCBfY29uZmlnKVxuICAgICAgICAkZWxlbWVudC5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKVxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtjb25maWddKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBqUXVlcnlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbiQuZm5bTkFNRV0gPSBUb29sdGlwLl9qUXVlcnlJbnRlcmZhY2VcbiQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBUb29sdGlwXG4kLmZuW05BTUVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XG4gICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1RcbiAgcmV0dXJuIFRvb2x0aXAuX2pRdWVyeUludGVyZmFjZVxufVxuXG5leHBvcnQgZGVmYXVsdCBUb29sdGlwXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjYuMCk6IHBvcG92ZXIuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknXG5pbXBvcnQgVG9vbHRpcCBmcm9tICcuL3Rvb2x0aXAnXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUgPSAncG9wb3ZlcidcbmNvbnN0IFZFUlNJT04gPSAnNC42LjAnXG5jb25zdCBEQVRBX0tFWSA9ICdicy5wb3BvdmVyJ1xuY29uc3QgRVZFTlRfS0VZID0gYC4ke0RBVEFfS0VZfWBcbmNvbnN0IEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV1cbmNvbnN0IENMQVNTX1BSRUZJWCA9ICdicy1wb3BvdmVyJ1xuY29uc3QgQlNDTFNfUFJFRklYX1JFR0VYID0gbmV3IFJlZ0V4cChgKF58XFxcXHMpJHtDTEFTU19QUkVGSVh9XFxcXFMrYCwgJ2cnKVxuXG5jb25zdCBEZWZhdWx0ID0ge1xuICAuLi5Ub29sdGlwLkRlZmF1bHQsXG4gIHBsYWNlbWVudDogJ3JpZ2h0JyxcbiAgdHJpZ2dlcjogJ2NsaWNrJyxcbiAgY29udGVudDogJycsXG4gIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInBvcG92ZXJcIiByb2xlPVwidG9vbHRpcFwiPicgK1xuICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImFycm93XCI+PC9kaXY+JyArXG4gICAgICAgICAgICAgICc8aDMgY2xhc3M9XCJwb3BvdmVyLWhlYWRlclwiPjwvaDM+JyArXG4gICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicG9wb3Zlci1ib2R5XCI+PC9kaXY+PC9kaXY+J1xufVxuXG5jb25zdCBEZWZhdWx0VHlwZSA9IHtcbiAgLi4uVG9vbHRpcC5EZWZhdWx0VHlwZSxcbiAgY29udGVudDogJyhzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbiknXG59XG5cbmNvbnN0IENMQVNTX05BTUVfRkFERSA9ICdmYWRlJ1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XID0gJ3Nob3cnXG5cbmNvbnN0IFNFTEVDVE9SX1RJVExFID0gJy5wb3BvdmVyLWhlYWRlcidcbmNvbnN0IFNFTEVDVE9SX0NPTlRFTlQgPSAnLnBvcG92ZXItYm9keSdcblxuY29uc3QgRXZlbnQgPSB7XG4gIEhJREU6IGBoaWRlJHtFVkVOVF9LRVl9YCxcbiAgSElEREVOOiBgaGlkZGVuJHtFVkVOVF9LRVl9YCxcbiAgU0hPVzogYHNob3cke0VWRU5UX0tFWX1gLFxuICBTSE9XTjogYHNob3duJHtFVkVOVF9LRVl9YCxcbiAgSU5TRVJURUQ6IGBpbnNlcnRlZCR7RVZFTlRfS0VZfWAsXG4gIENMSUNLOiBgY2xpY2ske0VWRU5UX0tFWX1gLFxuICBGT0NVU0lOOiBgZm9jdXNpbiR7RVZFTlRfS0VZfWAsXG4gIEZPQ1VTT1VUOiBgZm9jdXNvdXQke0VWRU5UX0tFWX1gLFxuICBNT1VTRUVOVEVSOiBgbW91c2VlbnRlciR7RVZFTlRfS0VZfWAsXG4gIE1PVVNFTEVBVkU6IGBtb3VzZWxlYXZlJHtFVkVOVF9LRVl9YFxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgUG9wb3ZlciBleHRlbmRzIFRvb2x0aXAge1xuICAvLyBHZXR0ZXJzXG5cbiAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgIHJldHVybiBWRVJTSU9OXG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRcbiAgfVxuXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRVxuICB9XG5cbiAgc3RhdGljIGdldCBEQVRBX0tFWSgpIHtcbiAgICByZXR1cm4gREFUQV9LRVlcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRXZlbnQoKSB7XG4gICAgcmV0dXJuIEV2ZW50XG4gIH1cblxuICBzdGF0aWMgZ2V0IEVWRU5UX0tFWSgpIHtcbiAgICByZXR1cm4gRVZFTlRfS0VZXG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZVxuICB9XG5cbiAgLy8gT3ZlcnJpZGVzXG5cbiAgaXNXaXRoQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaXRsZSgpIHx8IHRoaXMuX2dldENvbnRlbnQoKVxuICB9XG5cbiAgYWRkQXR0YWNobWVudENsYXNzKGF0dGFjaG1lbnQpIHtcbiAgICAkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKS5hZGRDbGFzcyhgJHtDTEFTU19QUkVGSVh9LSR7YXR0YWNobWVudH1gKVxuICB9XG5cbiAgZ2V0VGlwRWxlbWVudCgpIHtcbiAgICB0aGlzLnRpcCA9IHRoaXMudGlwIHx8ICQodGhpcy5jb25maWcudGVtcGxhdGUpWzBdXG4gICAgcmV0dXJuIHRoaXMudGlwXG4gIH1cblxuICBzZXRDb250ZW50KCkge1xuICAgIGNvbnN0ICR0aXAgPSAkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKVxuXG4gICAgLy8gV2UgdXNlIGFwcGVuZCBmb3IgaHRtbCBvYmplY3RzIHRvIG1haW50YWluIGpzIGV2ZW50c1xuICAgIHRoaXMuc2V0RWxlbWVudENvbnRlbnQoJHRpcC5maW5kKFNFTEVDVE9SX1RJVExFKSwgdGhpcy5nZXRUaXRsZSgpKVxuICAgIGxldCBjb250ZW50ID0gdGhpcy5fZ2V0Q29udGVudCgpXG4gICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb250ZW50ID0gY29udGVudC5jYWxsKHRoaXMuZWxlbWVudClcbiAgICB9XG5cbiAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KCR0aXAuZmluZChTRUxFQ1RPUl9DT05URU5UKSwgY29udGVudClcblxuICAgICR0aXAucmVtb3ZlQ2xhc3MoYCR7Q0xBU1NfTkFNRV9GQURFfSAke0NMQVNTX05BTUVfU0hPV31gKVxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuXG4gIF9nZXRDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWNvbnRlbnQnKSB8fFxuICAgICAgdGhpcy5jb25maWcuY29udGVudFxuICB9XG5cbiAgX2NsZWFuVGlwQ2xhc3MoKSB7XG4gICAgY29uc3QgJHRpcCA9ICQodGhpcy5nZXRUaXBFbGVtZW50KCkpXG4gICAgY29uc3QgdGFiQ2xhc3MgPSAkdGlwLmF0dHIoJ2NsYXNzJykubWF0Y2goQlNDTFNfUFJFRklYX1JFR0VYKVxuICAgIGlmICh0YWJDbGFzcyAhPT0gbnVsbCAmJiB0YWJDbGFzcy5sZW5ndGggPiAwKSB7XG4gICAgICAkdGlwLnJlbW92ZUNsYXNzKHRhYkNsYXNzLmpvaW4oJycpKVxuICAgIH1cbiAgfVxuXG4gIC8vIFN0YXRpY1xuXG4gIHN0YXRpYyBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgbGV0IGRhdGEgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkpXG4gICAgICBjb25zdCBfY29uZmlnID0gdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgPyBjb25maWcgOiBudWxsXG5cbiAgICAgIGlmICghZGF0YSAmJiAvZGlzcG9zZXxoaWRlLy50ZXN0KGNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBkYXRhID0gbmV3IFBvcG92ZXIodGhpcywgX2NvbmZpZylcbiAgICAgICAgJCh0aGlzKS5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKVxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtjb25maWddKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBqUXVlcnlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbiQuZm5bTkFNRV0gPSBQb3BvdmVyLl9qUXVlcnlJbnRlcmZhY2VcbiQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBQb3BvdmVyXG4kLmZuW05BTUVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XG4gICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1RcbiAgcmV0dXJuIFBvcG92ZXIuX2pRdWVyeUludGVyZmFjZVxufVxuXG5leHBvcnQgZGVmYXVsdCBQb3BvdmVyXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjYuMCk6IHNjcm9sbHNweS5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSdcbmltcG9ydCBVdGlsIGZyb20gJy4vdXRpbCdcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgTkFNRSA9ICdzY3JvbGxzcHknXG5jb25zdCBWRVJTSU9OID0gJzQuNi4wJ1xuY29uc3QgREFUQV9LRVkgPSAnYnMuc2Nyb2xsc3B5J1xuY29uc3QgRVZFTlRfS0VZID0gYC4ke0RBVEFfS0VZfWBcbmNvbnN0IERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknXG5jb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdXG5cbmNvbnN0IERlZmF1bHQgPSB7XG4gIG9mZnNldDogMTAsXG4gIG1ldGhvZDogJ2F1dG8nLFxuICB0YXJnZXQ6ICcnXG59XG5cbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICBvZmZzZXQ6ICdudW1iZXInLFxuICBtZXRob2Q6ICdzdHJpbmcnLFxuICB0YXJnZXQ6ICcoc3RyaW5nfGVsZW1lbnQpJ1xufVxuXG5jb25zdCBFVkVOVF9BQ1RJVkFURSA9IGBhY3RpdmF0ZSR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX1NDUk9MTCA9IGBzY3JvbGwke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJID0gYGxvYWQke0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gXG5cbmNvbnN0IENMQVNTX05BTUVfRFJPUERPV05fSVRFTSA9ICdkcm9wZG93bi1pdGVtJ1xuY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUgPSAnYWN0aXZlJ1xuXG5jb25zdCBTRUxFQ1RPUl9EQVRBX1NQWSA9ICdbZGF0YS1zcHk9XCJzY3JvbGxcIl0nXG5jb25zdCBTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUCA9ICcubmF2LCAubGlzdC1ncm91cCdcbmNvbnN0IFNFTEVDVE9SX05BVl9MSU5LUyA9ICcubmF2LWxpbmsnXG5jb25zdCBTRUxFQ1RPUl9OQVZfSVRFTVMgPSAnLm5hdi1pdGVtJ1xuY29uc3QgU0VMRUNUT1JfTElTVF9JVEVNUyA9ICcubGlzdC1ncm91cC1pdGVtJ1xuY29uc3QgU0VMRUNUT1JfRFJPUERPV04gPSAnLmRyb3Bkb3duJ1xuY29uc3QgU0VMRUNUT1JfRFJPUERPV05fSVRFTVMgPSAnLmRyb3Bkb3duLWl0ZW0nXG5jb25zdCBTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUgPSAnLmRyb3Bkb3duLXRvZ2dsZSdcblxuY29uc3QgTUVUSE9EX09GRlNFVCA9ICdvZmZzZXQnXG5jb25zdCBNRVRIT0RfUE9TSVRJT04gPSAncG9zaXRpb24nXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jbGFzcyBTY3JvbGxTcHkge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudFxuICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQgPSBlbGVtZW50LnRhZ05hbWUgPT09ICdCT0RZJyA/IHdpbmRvdyA6IGVsZW1lbnRcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKVxuICAgIHRoaXMuX3NlbGVjdG9yID0gYCR7dGhpcy5fY29uZmlnLnRhcmdldH0gJHtTRUxFQ1RPUl9OQVZfTElOS1N9LGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBgJHt0aGlzLl9jb25maWcudGFyZ2V0fSAke1NFTEVDVE9SX0xJU1RfSVRFTVN9LGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBgJHt0aGlzLl9jb25maWcudGFyZ2V0fSAke1NFTEVDVE9SX0RST1BET1dOX0lURU1TfWBcbiAgICB0aGlzLl9vZmZzZXRzID0gW11cbiAgICB0aGlzLl90YXJnZXRzID0gW11cbiAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsXG4gICAgdGhpcy5fc2Nyb2xsSGVpZ2h0ID0gMFxuXG4gICAgJCh0aGlzLl9zY3JvbGxFbGVtZW50KS5vbihFVkVOVF9TQ1JPTEwsIGV2ZW50ID0+IHRoaXMuX3Byb2Nlc3MoZXZlbnQpKVxuXG4gICAgdGhpcy5yZWZyZXNoKClcbiAgICB0aGlzLl9wcm9jZXNzKClcbiAgfVxuXG4gIC8vIEdldHRlcnNcblxuICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XG4gICAgcmV0dXJuIFZFUlNJT05cbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFxuICB9XG5cbiAgLy8gUHVibGljXG5cbiAgcmVmcmVzaCgpIHtcbiAgICBjb25zdCBhdXRvTWV0aG9kID0gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gdGhpcy5fc2Nyb2xsRWxlbWVudC53aW5kb3cgP1xuICAgICAgTUVUSE9EX09GRlNFVCA6IE1FVEhPRF9QT1NJVElPTlxuXG4gICAgY29uc3Qgb2Zmc2V0TWV0aG9kID0gdGhpcy5fY29uZmlnLm1ldGhvZCA9PT0gJ2F1dG8nID9cbiAgICAgIGF1dG9NZXRob2QgOiB0aGlzLl9jb25maWcubWV0aG9kXG5cbiAgICBjb25zdCBvZmZzZXRCYXNlID0gb2Zmc2V0TWV0aG9kID09PSBNRVRIT0RfUE9TSVRJT04gP1xuICAgICAgdGhpcy5fZ2V0U2Nyb2xsVG9wKCkgOiAwXG5cbiAgICB0aGlzLl9vZmZzZXRzID0gW11cbiAgICB0aGlzLl90YXJnZXRzID0gW11cblxuICAgIHRoaXMuX3Njcm9sbEhlaWdodCA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpXG5cbiAgICBjb25zdCB0YXJnZXRzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuX3NlbGVjdG9yKSlcblxuICAgIHRhcmdldHNcbiAgICAgIC5tYXAoZWxlbWVudCA9PiB7XG4gICAgICAgIGxldCB0YXJnZXRcbiAgICAgICAgY29uc3QgdGFyZ2V0U2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudClcblxuICAgICAgICBpZiAodGFyZ2V0U2VsZWN0b3IpIHtcbiAgICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldFNlbGVjdG9yKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgIGNvbnN0IHRhcmdldEJDUiA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgIGlmICh0YXJnZXRCQ1Iud2lkdGggfHwgdGFyZ2V0QkNSLmhlaWdodCkge1xuICAgICAgICAgICAgLy8gVE9ETyAoZmF0KTogcmVtb3ZlIHNrZXRjaCByZWxpYW5jZSBvbiBqUXVlcnkgcG9zaXRpb24vb2Zmc2V0XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAkKHRhcmdldClbb2Zmc2V0TWV0aG9kXSgpLnRvcCArIG9mZnNldEJhc2UsXG4gICAgICAgICAgICAgIHRhcmdldFNlbGVjdG9yXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbSlcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSlcbiAgICAgIC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICB0aGlzLl9vZmZzZXRzLnB1c2goaXRlbVswXSlcbiAgICAgICAgdGhpcy5fdGFyZ2V0cy5wdXNoKGl0ZW1bMV0pXG4gICAgICB9KVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpXG4gICAgJCh0aGlzLl9zY3JvbGxFbGVtZW50KS5vZmYoRVZFTlRfS0VZKVxuXG4gICAgdGhpcy5fZWxlbWVudCA9IG51bGxcbiAgICB0aGlzLl9zY3JvbGxFbGVtZW50ID0gbnVsbFxuICAgIHRoaXMuX2NvbmZpZyA9IG51bGxcbiAgICB0aGlzLl9zZWxlY3RvciA9IG51bGxcbiAgICB0aGlzLl9vZmZzZXRzID0gbnVsbFxuICAgIHRoaXMuX3RhcmdldHMgPSBudWxsXG4gICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbFxuICAgIHRoaXMuX3Njcm9sbEhlaWdodCA9IG51bGxcbiAgfVxuXG4gIC8vIFByaXZhdGVcblxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IHtcbiAgICAgIC4uLkRlZmF1bHQsXG4gICAgICAuLi4odHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge30pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcudGFyZ2V0ICE9PSAnc3RyaW5nJyAmJiBVdGlsLmlzRWxlbWVudChjb25maWcudGFyZ2V0KSkge1xuICAgICAgbGV0IGlkID0gJChjb25maWcudGFyZ2V0KS5hdHRyKCdpZCcpXG4gICAgICBpZiAoIWlkKSB7XG4gICAgICAgIGlkID0gVXRpbC5nZXRVSUQoTkFNRSlcbiAgICAgICAgJChjb25maWcudGFyZ2V0KS5hdHRyKCdpZCcsIGlkKVxuICAgICAgfVxuXG4gICAgICBjb25maWcudGFyZ2V0ID0gYCMke2lkfWBcbiAgICB9XG5cbiAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIERlZmF1bHRUeXBlKVxuXG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9XG5cbiAgX2dldFNjcm9sbFRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gd2luZG93ID9cbiAgICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQucGFnZVlPZmZzZXQgOiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbFRvcFxuICB9XG5cbiAgX2dldFNjcm9sbEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxIZWlnaHQgfHwgTWF0aC5tYXgoXG4gICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCxcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHRcbiAgICApXG4gIH1cblxuICBfZ2V0T2Zmc2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB3aW5kb3cgP1xuICAgICAgd2luZG93LmlubmVySGVpZ2h0IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcbiAgfVxuXG4gIF9wcm9jZXNzKCkge1xuICAgIGNvbnN0IHNjcm9sbFRvcCA9IHRoaXMuX2dldFNjcm9sbFRvcCgpICsgdGhpcy5fY29uZmlnLm9mZnNldFxuICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpXG4gICAgY29uc3QgbWF4U2Nyb2xsID0gdGhpcy5fY29uZmlnLm9mZnNldCArIHNjcm9sbEhlaWdodCAtIHRoaXMuX2dldE9mZnNldEhlaWdodCgpXG5cbiAgICBpZiAodGhpcy5fc2Nyb2xsSGVpZ2h0ICE9PSBzY3JvbGxIZWlnaHQpIHtcbiAgICAgIHRoaXMucmVmcmVzaCgpXG4gICAgfVxuXG4gICAgaWYgKHNjcm9sbFRvcCA+PSBtYXhTY3JvbGwpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX3RhcmdldHNbdGhpcy5fdGFyZ2V0cy5sZW5ndGggLSAxXVxuXG4gICAgICBpZiAodGhpcy5fYWN0aXZlVGFyZ2V0ICE9PSB0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZhdGUodGFyZ2V0KVxuICAgICAgfVxuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYWN0aXZlVGFyZ2V0ICYmIHNjcm9sbFRvcCA8IHRoaXMuX29mZnNldHNbMF0gJiYgdGhpcy5fb2Zmc2V0c1swXSA+IDApIHtcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGxcbiAgICAgIHRoaXMuX2NsZWFyKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSB0aGlzLl9vZmZzZXRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgY29uc3QgaXNBY3RpdmVUYXJnZXQgPSB0aGlzLl9hY3RpdmVUYXJnZXQgIT09IHRoaXMuX3RhcmdldHNbaV0gJiZcbiAgICAgICAgICBzY3JvbGxUb3AgPj0gdGhpcy5fb2Zmc2V0c1tpXSAmJlxuICAgICAgICAgICh0eXBlb2YgdGhpcy5fb2Zmc2V0c1tpICsgMV0gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICAgIHNjcm9sbFRvcCA8IHRoaXMuX29mZnNldHNbaSArIDFdKVxuXG4gICAgICBpZiAoaXNBY3RpdmVUYXJnZXQpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZhdGUodGhpcy5fdGFyZ2V0c1tpXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfYWN0aXZhdGUodGFyZ2V0KSB7XG4gICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gdGFyZ2V0XG5cbiAgICB0aGlzLl9jbGVhcigpXG5cbiAgICBjb25zdCBxdWVyaWVzID0gdGhpcy5fc2VsZWN0b3JcbiAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAubWFwKHNlbGVjdG9yID0+IGAke3NlbGVjdG9yfVtkYXRhLXRhcmdldD1cIiR7dGFyZ2V0fVwiXSwke3NlbGVjdG9yfVtocmVmPVwiJHt0YXJnZXR9XCJdYClcblxuICAgIGNvbnN0ICRsaW5rID0gJChbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcmllcy5qb2luKCcsJykpKSlcblxuICAgIGlmICgkbGluay5oYXNDbGFzcyhDTEFTU19OQU1FX0RST1BET1dOX0lURU0pKSB7XG4gICAgICAkbGluay5jbG9zZXN0KFNFTEVDVE9SX0RST1BET1dOKVxuICAgICAgICAuZmluZChTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUpXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19OQU1FX0FDVElWRSlcbiAgICAgICRsaW5rLmFkZENsYXNzKENMQVNTX05BTUVfQUNUSVZFKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXQgdHJpZ2dlcmVkIGxpbmsgYXMgYWN0aXZlXG4gICAgICAkbGluay5hZGRDbGFzcyhDTEFTU19OQU1FX0FDVElWRSlcbiAgICAgIC8vIFNldCB0cmlnZ2VyZWQgbGlua3MgcGFyZW50cyBhcyBhY3RpdmVcbiAgICAgIC8vIFdpdGggYm90aCA8dWw+IGFuZCA8bmF2PiBtYXJrdXAgYSBwYXJlbnQgaXMgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgYW55IG5hdiBhbmNlc3RvclxuICAgICAgJGxpbmsucGFyZW50cyhTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUClcbiAgICAgICAgLnByZXYoYCR7U0VMRUNUT1JfTkFWX0xJTktTfSwgJHtTRUxFQ1RPUl9MSVNUX0lURU1TfWApXG4gICAgICAgIC5hZGRDbGFzcyhDTEFTU19OQU1FX0FDVElWRSlcbiAgICAgIC8vIEhhbmRsZSBzcGVjaWFsIGNhc2Ugd2hlbiAubmF2LWxpbmsgaXMgaW5zaWRlIC5uYXYtaXRlbVxuICAgICAgJGxpbmsucGFyZW50cyhTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUClcbiAgICAgICAgLnByZXYoU0VMRUNUT1JfTkFWX0lURU1TKVxuICAgICAgICAuY2hpbGRyZW4oU0VMRUNUT1JfTkFWX0xJTktTKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgfVxuXG4gICAgJCh0aGlzLl9zY3JvbGxFbGVtZW50KS50cmlnZ2VyKEVWRU5UX0FDVElWQVRFLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0YXJnZXRcbiAgICB9KVxuICB9XG5cbiAgX2NsZWFyKCkge1xuICAgIFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLl9zZWxlY3RvcikpXG4gICAgICAuZmlsdGVyKG5vZGUgPT4gbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9BQ1RJVkUpKVxuICAgICAgLmZvckVhY2gobm9kZSA9PiBub2RlLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUpKVxuICB9XG5cbiAgLy8gU3RhdGljXG5cbiAgc3RhdGljIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgZGF0YSA9ICQodGhpcykuZGF0YShEQVRBX0tFWSlcbiAgICAgIGNvbnN0IF9jb25maWcgPSB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWdcblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgU2Nyb2xsU3B5KHRoaXMsIF9jb25maWcpXG4gICAgICAgICQodGhpcykuZGF0YShEQVRBX0tFWSwgZGF0YSlcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFbY29uZmlnXSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbiQod2luZG93KS5vbihFVkVOVF9MT0FEX0RBVEFfQVBJLCAoKSA9PiB7XG4gIGNvbnN0IHNjcm9sbFNweXMgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfREFUQV9TUFkpKVxuICBjb25zdCBzY3JvbGxTcHlzTGVuZ3RoID0gc2Nyb2xsU3B5cy5sZW5ndGhcblxuICBmb3IgKGxldCBpID0gc2Nyb2xsU3B5c0xlbmd0aDsgaS0tOykge1xuICAgIGNvbnN0ICRzcHkgPSAkKHNjcm9sbFNweXNbaV0pXG4gICAgU2Nyb2xsU3B5Ll9qUXVlcnlJbnRlcmZhY2UuY2FsbCgkc3B5LCAkc3B5LmRhdGEoKSlcbiAgfVxufSlcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGpRdWVyeVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuJC5mbltOQU1FXSA9IFNjcm9sbFNweS5falF1ZXJ5SW50ZXJmYWNlXG4kLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gU2Nyb2xsU3B5XG4kLmZuW05BTUVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XG4gICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1RcbiAgcmV0dXJuIFNjcm9sbFNweS5falF1ZXJ5SW50ZXJmYWNlXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNjcm9sbFNweVxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC42LjApOiB0YWIuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknXG5pbXBvcnQgVXRpbCBmcm9tICcuL3V0aWwnXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUgPSAndGFiJ1xuY29uc3QgVkVSU0lPTiA9ICc0LjYuMCdcbmNvbnN0IERBVEFfS0VZID0gJ2JzLnRhYidcbmNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJ1xuY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltOQU1FXVxuXG5jb25zdCBFVkVOVF9ISURFID0gYGhpZGUke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9ISURERU4gPSBgaGlkZGVuJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0hPVyA9IGBzaG93JHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0hPV04gPSBgc2hvd24ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSA9IGBjbGljayR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWBcblxuY29uc3QgQ0xBU1NfTkFNRV9EUk9QRE9XTl9NRU5VID0gJ2Ryb3Bkb3duLW1lbnUnXG5jb25zdCBDTEFTU19OQU1FX0FDVElWRSA9ICdhY3RpdmUnXG5jb25zdCBDTEFTU19OQU1FX0RJU0FCTEVEID0gJ2Rpc2FibGVkJ1xuY29uc3QgQ0xBU1NfTkFNRV9GQURFID0gJ2ZhZGUnXG5jb25zdCBDTEFTU19OQU1FX1NIT1cgPSAnc2hvdydcblxuY29uc3QgU0VMRUNUT1JfRFJPUERPV04gPSAnLmRyb3Bkb3duJ1xuY29uc3QgU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVAgPSAnLm5hdiwgLmxpc3QtZ3JvdXAnXG5jb25zdCBTRUxFQ1RPUl9BQ1RJVkUgPSAnLmFjdGl2ZSdcbmNvbnN0IFNFTEVDVE9SX0FDVElWRV9VTCA9ICc+IGxpID4gLmFjdGl2ZSdcbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFID0gJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXSwgW2RhdGEtdG9nZ2xlPVwicGlsbFwiXSwgW2RhdGEtdG9nZ2xlPVwibGlzdFwiXSdcbmNvbnN0IFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSA9ICcuZHJvcGRvd24tdG9nZ2xlJ1xuY29uc3QgU0VMRUNUT1JfRFJPUERPV05fQUNUSVZFX0NISUxEID0gJz4gLmRyb3Bkb3duLW1lbnUgLmFjdGl2ZSdcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNsYXNzIFRhYiB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudFxuICB9XG5cbiAgLy8gR2V0dGVyc1xuXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gVkVSU0lPTlxuICB9XG5cbiAgLy8gUHVibGljXG5cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudC5wYXJlbnROb2RlICYmXG4gICAgICAgIHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiZcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX0FDVElWRSkgfHxcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX0RJU0FCTEVEKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHRhcmdldFxuICAgIGxldCBwcmV2aW91c1xuICAgIGNvbnN0IGxpc3RFbGVtZW50ID0gJCh0aGlzLl9lbGVtZW50KS5jbG9zZXN0KFNFTEVDVE9SX05BVl9MSVNUX0dST1VQKVswXVxuICAgIGNvbnN0IHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpXG5cbiAgICBpZiAobGlzdEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGl0ZW1TZWxlY3RvciA9IGxpc3RFbGVtZW50Lm5vZGVOYW1lID09PSAnVUwnIHx8IGxpc3RFbGVtZW50Lm5vZGVOYW1lID09PSAnT0wnID8gU0VMRUNUT1JfQUNUSVZFX1VMIDogU0VMRUNUT1JfQUNUSVZFXG4gICAgICBwcmV2aW91cyA9ICQubWFrZUFycmF5KCQobGlzdEVsZW1lbnQpLmZpbmQoaXRlbVNlbGVjdG9yKSlcbiAgICAgIHByZXZpb3VzID0gcHJldmlvdXNbcHJldmlvdXMubGVuZ3RoIC0gMV1cbiAgICB9XG5cbiAgICBjb25zdCBoaWRlRXZlbnQgPSAkLkV2ZW50KEVWRU5UX0hJREUsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9KVxuXG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gJC5FdmVudChFVkVOVF9TSE9XLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiBwcmV2aW91c1xuICAgIH0pXG5cbiAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICQocHJldmlvdXMpLnRyaWdnZXIoaGlkZUV2ZW50KVxuICAgIH1cblxuICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzaG93RXZlbnQpXG5cbiAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8XG4gICAgICAgIGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKVxuICAgIH1cblxuICAgIHRoaXMuX2FjdGl2YXRlKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIGxpc3RFbGVtZW50XG4gICAgKVxuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICBjb25zdCBoaWRkZW5FdmVudCA9ICQuRXZlbnQoRVZFTlRfSElEREVOLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHNob3duRXZlbnQgPSAkLkV2ZW50KEVWRU5UX1NIT1dOLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHByZXZpb3VzXG4gICAgICB9KVxuXG4gICAgICAkKHByZXZpb3VzKS50cmlnZ2VyKGhpZGRlbkV2ZW50KVxuICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNob3duRXZlbnQpXG4gICAgfVxuXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5fYWN0aXZhdGUodGFyZ2V0LCB0YXJnZXQucGFyZW50Tm9kZSwgY29tcGxldGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBsZXRlKClcbiAgICB9XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgICQucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBEQVRBX0tFWSlcbiAgICB0aGlzLl9lbGVtZW50ID0gbnVsbFxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuXG4gIF9hY3RpdmF0ZShlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgYWN0aXZlRWxlbWVudHMgPSBjb250YWluZXIgJiYgKGNvbnRhaW5lci5ub2RlTmFtZSA9PT0gJ1VMJyB8fCBjb250YWluZXIubm9kZU5hbWUgPT09ICdPTCcpID9cbiAgICAgICQoY29udGFpbmVyKS5maW5kKFNFTEVDVE9SX0FDVElWRV9VTCkgOlxuICAgICAgJChjb250YWluZXIpLmNoaWxkcmVuKFNFTEVDVE9SX0FDVElWRSlcblxuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzWzBdXG4gICAgY29uc3QgaXNUcmFuc2l0aW9uaW5nID0gY2FsbGJhY2sgJiYgKGFjdGl2ZSAmJiAkKGFjdGl2ZSkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9GQURFKSlcbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHRoaXMuX3RyYW5zaXRpb25Db21wbGV0ZShcbiAgICAgIGVsZW1lbnQsXG4gICAgICBhY3RpdmUsXG4gICAgICBjYWxsYmFja1xuICAgIClcblxuICAgIGlmIChhY3RpdmUgJiYgaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KGFjdGl2ZSlcblxuICAgICAgJChhY3RpdmUpXG4gICAgICAgIC5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX1NIT1cpXG4gICAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBsZXRlKClcbiAgICB9XG4gIH1cblxuICBfdHJhbnNpdGlvbkNvbXBsZXRlKGVsZW1lbnQsIGFjdGl2ZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAkKGFjdGl2ZSkucmVtb3ZlQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUpXG5cbiAgICAgIGNvbnN0IGRyb3Bkb3duQ2hpbGQgPSAkKGFjdGl2ZS5wYXJlbnROb2RlKS5maW5kKFxuICAgICAgICBTRUxFQ1RPUl9EUk9QRE9XTl9BQ1RJVkVfQ0hJTERcbiAgICAgIClbMF1cblxuICAgICAgaWYgKGRyb3Bkb3duQ2hpbGQpIHtcbiAgICAgICAgJChkcm9wZG93bkNoaWxkKS5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX0FDVElWRSlcbiAgICAgIH1cblxuICAgICAgaWYgKGFjdGl2ZS5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSA9PT0gJ3RhYicpIHtcbiAgICAgICAgYWN0aXZlLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGZhbHNlKVxuICAgICAgfVxuICAgIH1cblxuICAgICQoZWxlbWVudCkuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICd0YWInKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIHRydWUpXG4gICAgfVxuXG4gICAgVXRpbC5yZWZsb3coZWxlbWVudClcblxuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUpKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XKVxuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnBhcmVudE5vZGUgJiYgJChlbGVtZW50LnBhcmVudE5vZGUpLmhhc0NsYXNzKENMQVNTX05BTUVfRFJPUERPV05fTUVOVSkpIHtcbiAgICAgIGNvbnN0IGRyb3Bkb3duRWxlbWVudCA9ICQoZWxlbWVudCkuY2xvc2VzdChTRUxFQ1RPUl9EUk9QRE9XTilbMF1cblxuICAgICAgaWYgKGRyb3Bkb3duRWxlbWVudCkge1xuICAgICAgICBjb25zdCBkcm9wZG93blRvZ2dsZUxpc3QgPSBbXS5zbGljZS5jYWxsKGRyb3Bkb3duRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSkpXG5cbiAgICAgICAgJChkcm9wZG93blRvZ2dsZUxpc3QpLmFkZENsYXNzKENMQVNTX05BTUVfQUNUSVZFKVxuICAgICAgfVxuXG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpXG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjYWxsYmFjaygpXG4gICAgfVxuICB9XG5cbiAgLy8gU3RhdGljXG5cbiAgc3RhdGljIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCAkdGhpcyA9ICQodGhpcylcbiAgICAgIGxldCBkYXRhID0gJHRoaXMuZGF0YShEQVRBX0tFWSlcblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgVGFiKHRoaXMpXG4gICAgICAgICR0aGlzLmRhdGEoREFUQV9LRVksIGRhdGEpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApXG4gICAgICAgIH1cblxuICAgICAgICBkYXRhW2NvbmZpZ10oKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kKGRvY3VtZW50KVxuICAub24oRVZFTlRfQ0xJQ0tfREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgVGFiLl9qUXVlcnlJbnRlcmZhY2UuY2FsbCgkKHRoaXMpLCAnc2hvdycpXG4gIH0pXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBqUXVlcnlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbiQuZm5bTkFNRV0gPSBUYWIuX2pRdWVyeUludGVyZmFjZVxuJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IFRhYlxuJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUXG4gIHJldHVybiBUYWIuX2pRdWVyeUludGVyZmFjZVxufVxuXG5leHBvcnQgZGVmYXVsdCBUYWJcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuNi4wKTogdG9hc3QuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknXG5pbXBvcnQgVXRpbCBmcm9tICcuL3V0aWwnXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUgPSAndG9hc3QnXG5jb25zdCBWRVJTSU9OID0gJzQuNi4wJ1xuY29uc3QgREFUQV9LRVkgPSAnYnMudG9hc3QnXG5jb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltOQU1FXVxuXG5jb25zdCBFVkVOVF9DTElDS19ESVNNSVNTID0gYGNsaWNrLmRpc21pc3Mke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9ISURFID0gYGhpZGUke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9ISURERU4gPSBgaGlkZGVuJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0hPVyA9IGBzaG93JHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0hPV04gPSBgc2hvd24ke0VWRU5UX0tFWX1gXG5cbmNvbnN0IENMQVNTX05BTUVfRkFERSA9ICdmYWRlJ1xuY29uc3QgQ0xBU1NfTkFNRV9ISURFID0gJ2hpZGUnXG5jb25zdCBDTEFTU19OQU1FX1NIT1cgPSAnc2hvdydcbmNvbnN0IENMQVNTX05BTUVfU0hPV0lORyA9ICdzaG93aW5nJ1xuXG5jb25zdCBEZWZhdWx0VHlwZSA9IHtcbiAgYW5pbWF0aW9uOiAnYm9vbGVhbicsXG4gIGF1dG9oaWRlOiAnYm9vbGVhbicsXG4gIGRlbGF5OiAnbnVtYmVyJ1xufVxuXG5jb25zdCBEZWZhdWx0ID0ge1xuICBhbmltYXRpb246IHRydWUsXG4gIGF1dG9oaWRlOiB0cnVlLFxuICBkZWxheTogNTAwXG59XG5cbmNvbnN0IFNFTEVDVE9SX0RBVEFfRElTTUlTUyA9ICdbZGF0YS1kaXNtaXNzPVwidG9hc3RcIl0nXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jbGFzcyBUb2FzdCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZylcbiAgICB0aGlzLl90aW1lb3V0ID0gbnVsbFxuICAgIHRoaXMuX3NldExpc3RlbmVycygpXG4gIH1cblxuICAvLyBHZXR0ZXJzXG5cbiAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgIHJldHVybiBWRVJTSU9OXG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZVxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0XG4gIH1cblxuICAvLyBQdWJsaWNcblxuICBzaG93KCkge1xuICAgIGNvbnN0IHNob3dFdmVudCA9ICQuRXZlbnQoRVZFTlRfU0hPVylcblxuICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzaG93RXZlbnQpXG4gICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fY2xlYXJUaW1lb3V0KClcblxuICAgIGlmICh0aGlzLl9jb25maWcuYW5pbWF0aW9uKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9GQURFKVxuICAgIH1cblxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPV0lORylcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1cpXG5cbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihFVkVOVF9TSE9XTilcblxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5hdXRvaGlkZSkge1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5oaWRlKClcbiAgICAgICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5KVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0hJREUpXG4gICAgVXRpbC5yZWZsb3codGhpcy5fZWxlbWVudClcbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XSU5HKVxuICAgIGlmICh0aGlzLl9jb25maWcuYW5pbWF0aW9uKSB7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpXG5cbiAgICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcGxldGUoKVxuICAgIH1cbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1cpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBoaWRlRXZlbnQgPSAkLkV2ZW50KEVWRU5UX0hJREUpXG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoaGlkZUV2ZW50KVxuICAgIGlmIChoaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2Nsb3NlKClcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fY2xlYXJUaW1lb3V0KClcblxuICAgIGlmICh0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1cpKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XKVxuICAgIH1cblxuICAgICQodGhpcy5fZWxlbWVudCkub2ZmKEVWRU5UX0NMSUNLX0RJU01JU1MpXG5cbiAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpXG4gICAgdGhpcy5fZWxlbWVudCA9IG51bGxcbiAgICB0aGlzLl9jb25maWcgPSBudWxsXG4gIH1cblxuICAvLyBQcml2YXRlXG5cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSB7XG4gICAgICAuLi5EZWZhdWx0LFxuICAgICAgLi4uJCh0aGlzLl9lbGVtZW50KS5kYXRhKCksXG4gICAgICAuLi4odHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge30pXG4gICAgfVxuXG4gICAgVXRpbC50eXBlQ2hlY2tDb25maWcoXG4gICAgICBOQU1FLFxuICAgICAgY29uZmlnLFxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZVxuICAgIClcblxuICAgIHJldHVybiBjb25maWdcbiAgfVxuXG4gIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgJCh0aGlzLl9lbGVtZW50KS5vbihFVkVOVF9DTElDS19ESVNNSVNTLCBTRUxFQ1RPUl9EQVRBX0RJU01JU1MsICgpID0+IHRoaXMuaGlkZSgpKVxuICB9XG5cbiAgX2Nsb3NlKCkge1xuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfSElERSlcbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihFVkVOVF9ISURERU4pXG4gICAgfVxuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVylcbiAgICBpZiAodGhpcy5fY29uZmlnLmFuaW1hdGlvbikge1xuICAgICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KVxuXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpXG4gICAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBsZXRlKClcbiAgICB9XG4gIH1cblxuICBfY2xlYXJUaW1lb3V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KVxuICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsXG4gIH1cblxuICAvLyBTdGF0aWNcblxuICBzdGF0aWMgX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0ICRlbGVtZW50ID0gJCh0aGlzKVxuICAgICAgbGV0IGRhdGEgPSAkZWxlbWVudC5kYXRhKERBVEFfS0VZKVxuICAgICAgY29uc3QgX2NvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZ1xuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBUb2FzdCh0aGlzLCBfY29uZmlnKVxuICAgICAgICAkZWxlbWVudC5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKVxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtjb25maWddKHRoaXMpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4kLmZuW05BTUVdID0gVG9hc3QuX2pRdWVyeUludGVyZmFjZVxuJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IFRvYXN0XG4kLmZuW05BTUVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XG4gICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1RcbiAgcmV0dXJuIFRvYXN0Ll9qUXVlcnlJbnRlcmZhY2Vcbn1cblxuZXhwb3J0IGRlZmF1bHQgVG9hc3RcbiJdLCJuYW1lcyI6WyJUUkFOU0lUSU9OX0VORCIsIk1BWF9VSUQiLCJNSUxMSVNFQ09ORFNfTVVMVElQTElFUiIsInRvVHlwZSIsIm9iaiIsInRvU3RyaW5nIiwiY2FsbCIsIm1hdGNoIiwidG9Mb3dlckNhc2UiLCJnZXRTcGVjaWFsVHJhbnNpdGlvbkVuZEV2ZW50IiwiYmluZFR5cGUiLCJkZWxlZ2F0ZVR5cGUiLCJoYW5kbGUiLCJldmVudCIsIiRfX2RlZmF1bHQiLCJ0YXJnZXQiLCJpcyIsImhhbmRsZU9iaiIsImhhbmRsZXIiLCJhcHBseSIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsInRyYW5zaXRpb25FbmRFbXVsYXRvciIsImR1cmF0aW9uIiwiX3RoaXMiLCJjYWxsZWQiLCJvbmUiLCJVdGlsIiwic2V0VGltZW91dCIsInRyaWdnZXJUcmFuc2l0aW9uRW5kIiwic2V0VHJhbnNpdGlvbkVuZFN1cHBvcnQiLCJmbiIsImVtdWxhdGVUcmFuc2l0aW9uRW5kIiwic3BlY2lhbCIsImdldFVJRCIsInByZWZpeCIsIk1hdGgiLCJyYW5kb20iLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCIsImVsZW1lbnQiLCJzZWxlY3RvciIsImdldEF0dHJpYnV0ZSIsImhyZWZBdHRyIiwidHJpbSIsInF1ZXJ5U2VsZWN0b3IiLCJfIiwiZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQiLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJjc3MiLCJ0cmFuc2l0aW9uRGVsYXkiLCJmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiIsInBhcnNlRmxvYXQiLCJmbG9hdFRyYW5zaXRpb25EZWxheSIsInNwbGl0IiwicmVmbG93Iiwib2Zmc2V0SGVpZ2h0IiwidHJpZ2dlciIsInN1cHBvcnRzVHJhbnNpdGlvbkVuZCIsIkJvb2xlYW4iLCJpc0VsZW1lbnQiLCJub2RlVHlwZSIsInR5cGVDaGVja0NvbmZpZyIsImNvbXBvbmVudE5hbWUiLCJjb25maWciLCJjb25maWdUeXBlcyIsInByb3BlcnR5IiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJleHBlY3RlZFR5cGVzIiwidmFsdWUiLCJ2YWx1ZVR5cGUiLCJSZWdFeHAiLCJ0ZXN0IiwiRXJyb3IiLCJ0b1VwcGVyQ2FzZSIsImZpbmRTaGFkb3dSb290IiwiZG9jdW1lbnRFbGVtZW50IiwiYXR0YWNoU2hhZG93IiwiZ2V0Um9vdE5vZGUiLCJyb290IiwiU2hhZG93Um9vdCIsInBhcmVudE5vZGUiLCJqUXVlcnlEZXRlY3Rpb24iLCJUeXBlRXJyb3IiLCJ2ZXJzaW9uIiwianF1ZXJ5IiwibWluTWFqb3IiLCJsdE1ham9yIiwibWluTWlub3IiLCJtaW5QYXRjaCIsIm1heE1ham9yIiwiTkFNRSIsIlZFUlNJT04iLCJEQVRBX0tFWSIsIkVWRU5UX0tFWSIsIkRBVEFfQVBJX0tFWSIsIkpRVUVSWV9OT19DT05GTElDVCIsIlNFTEVDVE9SX0RJU01JU1MiLCJFVkVOVF9DTE9TRSIsIkVWRU5UX0NMT1NFRCIsIkVWRU5UX0NMSUNLX0RBVEFfQVBJIiwiQ0xBU1NfTkFNRV9BTEVSVCIsIkNMQVNTX05BTUVfRkFERSIsIkNMQVNTX05BTUVfU0hPVyIsIkFsZXJ0IiwiX2VsZW1lbnQiLCJjbG9zZSIsInJvb3RFbGVtZW50IiwiX2dldFJvb3RFbGVtZW50IiwiY3VzdG9tRXZlbnQiLCJfdHJpZ2dlckNsb3NlRXZlbnQiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJfcmVtb3ZlRWxlbWVudCIsImRpc3Bvc2UiLCJyZW1vdmVEYXRhIiwicGFyZW50IiwiY2xvc2VzdCIsImNsb3NlRXZlbnQiLCJFdmVudCIsInJlbW92ZUNsYXNzIiwiaGFzQ2xhc3MiLCJfZGVzdHJveUVsZW1lbnQiLCJkZXRhY2giLCJyZW1vdmUiLCJfalF1ZXJ5SW50ZXJmYWNlIiwiZWFjaCIsIiRlbGVtZW50IiwiZGF0YSIsIl9oYW5kbGVEaXNtaXNzIiwiYWxlcnRJbnN0YW5jZSIsInByZXZlbnREZWZhdWx0Iiwib24iLCJDb25zdHJ1Y3RvciIsIm5vQ29uZmxpY3QiLCJOQU1FJDEiLCJWRVJTSU9OJDEiLCJEQVRBX0tFWSQxIiwiRVZFTlRfS0VZJDEiLCJEQVRBX0FQSV9LRVkkMSIsIkpRVUVSWV9OT19DT05GTElDVCQxIiwiQ0xBU1NfTkFNRV9BQ1RJVkUiLCJDTEFTU19OQU1FX0JVVFRPTiIsIkNMQVNTX05BTUVfRk9DVVMiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRV9DQVJST1QiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRVMiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSIsIlNFTEVDVE9SX0RBVEFfVE9HR0xFU19CVVRUT05TIiwiU0VMRUNUT1JfSU5QVVQiLCJTRUxFQ1RPUl9BQ1RJVkUiLCJTRUxFQ1RPUl9CVVRUT04iLCJFVkVOVF9DTElDS19EQVRBX0FQSSQxIiwiRVZFTlRfRk9DVVNfQkxVUl9EQVRBX0FQSSIsIkVWRU5UX0xPQURfREFUQV9BUEkiLCJCdXR0b24iLCJzaG91bGRBdm9pZFRyaWdnZXJDaGFuZ2UiLCJ0b2dnbGUiLCJ0cmlnZ2VyQ2hhbmdlRXZlbnQiLCJhZGRBcmlhUHJlc3NlZCIsImlucHV0IiwidHlwZSIsImNoZWNrZWQiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsImFjdGl2ZUVsZW1lbnQiLCJmb2N1cyIsImhhc0F0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsInRvZ2dsZUNsYXNzIiwiYXZvaWRUcmlnZ2VyQ2hhbmdlIiwiYnV0dG9uIiwiaW5pdGlhbEJ1dHRvbiIsImlucHV0QnRuIiwidGFnTmFtZSIsIndpbmRvdyIsImJ1dHRvbnMiLCJzbGljZSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJpIiwibGVuIiwibGVuZ3RoIiwiYWRkIiwiX2kiLCJfbGVuIiwiX2J1dHRvbiIsIk5BTUUkMiIsIlZFUlNJT04kMiIsIkRBVEFfS0VZJDIiLCJFVkVOVF9LRVkkMiIsIkRBVEFfQVBJX0tFWSQyIiwiSlFVRVJZX05PX0NPTkZMSUNUJDIiLCJBUlJPV19MRUZUX0tFWUNPREUiLCJBUlJPV19SSUdIVF9LRVlDT0RFIiwiVE9VQ0hFVkVOVF9DT01QQVRfV0FJVCIsIlNXSVBFX1RIUkVTSE9MRCIsIkRlZmF1bHQiLCJpbnRlcnZhbCIsImtleWJvYXJkIiwic2xpZGUiLCJwYXVzZSIsIndyYXAiLCJ0b3VjaCIsIkRlZmF1bHRUeXBlIiwiRElSRUNUSU9OX05FWFQiLCJESVJFQ1RJT05fUFJFViIsIkRJUkVDVElPTl9MRUZUIiwiRElSRUNUSU9OX1JJR0hUIiwiRVZFTlRfU0xJREUiLCJFVkVOVF9TTElEIiwiRVZFTlRfS0VZRE9XTiIsIkVWRU5UX01PVVNFRU5URVIiLCJFVkVOVF9NT1VTRUxFQVZFIiwiRVZFTlRfVE9VQ0hTVEFSVCIsIkVWRU5UX1RPVUNITU9WRSIsIkVWRU5UX1RPVUNIRU5EIiwiRVZFTlRfUE9JTlRFUkRPV04iLCJFVkVOVF9QT0lOVEVSVVAiLCJFVkVOVF9EUkFHX1NUQVJUIiwiRVZFTlRfTE9BRF9EQVRBX0FQSSQxIiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMiIsIkNMQVNTX05BTUVfQ0FST1VTRUwiLCJDTEFTU19OQU1FX0FDVElWRSQxIiwiQ0xBU1NfTkFNRV9TTElERSIsIkNMQVNTX05BTUVfUklHSFQiLCJDTEFTU19OQU1FX0xFRlQiLCJDTEFTU19OQU1FX05FWFQiLCJDTEFTU19OQU1FX1BSRVYiLCJDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQiLCJTRUxFQ1RPUl9BQ1RJVkUkMSIsIlNFTEVDVE9SX0FDVElWRV9JVEVNIiwiU0VMRUNUT1JfSVRFTSIsIlNFTEVDVE9SX0lURU1fSU1HIiwiU0VMRUNUT1JfTkVYVF9QUkVWIiwiU0VMRUNUT1JfSU5ESUNBVE9SUyIsIlNFTEVDVE9SX0RBVEFfU0xJREUiLCJTRUxFQ1RPUl9EQVRBX1JJREUiLCJQb2ludGVyVHlwZSIsIlRPVUNIIiwiUEVOIiwiQ2Fyb3VzZWwiLCJfaXRlbXMiLCJfaW50ZXJ2YWwiLCJfYWN0aXZlRWxlbWVudCIsIl9pc1BhdXNlZCIsIl9pc1NsaWRpbmciLCJ0b3VjaFRpbWVvdXQiLCJ0b3VjaFN0YXJ0WCIsInRvdWNoRGVsdGFYIiwiX2NvbmZpZyIsIl9nZXRDb25maWciLCJfaW5kaWNhdG9yc0VsZW1lbnQiLCJfdG91Y2hTdXBwb3J0ZWQiLCJuYXZpZ2F0b3IiLCJtYXhUb3VjaFBvaW50cyIsIl9wb2ludGVyRXZlbnQiLCJQb2ludGVyRXZlbnQiLCJNU1BvaW50ZXJFdmVudCIsIl9hZGRFdmVudExpc3RlbmVycyIsIm5leHQiLCJfc2xpZGUiLCJuZXh0V2hlblZpc2libGUiLCJoaWRkZW4iLCJwcmV2IiwiY3ljbGUiLCJjbGVhckludGVydmFsIiwiX3VwZGF0ZUludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJ2aXNpYmlsaXR5U3RhdGUiLCJiaW5kIiwidG8iLCJpbmRleCIsImFjdGl2ZUluZGV4IiwiX2dldEl0ZW1JbmRleCIsImRpcmVjdGlvbiIsIm9mZiIsIl9leHRlbmRzIiwiX2hhbmRsZVN3aXBlIiwiYWJzRGVsdGF4IiwiYWJzIiwiX3RoaXMyIiwiX2tleWRvd24iLCJfYWRkVG91Y2hFdmVudExpc3RlbmVycyIsIl90aGlzMyIsInN0YXJ0Iiwib3JpZ2luYWxFdmVudCIsInBvaW50ZXJUeXBlIiwiY2xpZW50WCIsInRvdWNoZXMiLCJtb3ZlIiwiZW5kIiwiY2xlYXJUaW1lb3V0IiwiZSIsIndoaWNoIiwiaW5kZXhPZiIsIl9nZXRJdGVtQnlEaXJlY3Rpb24iLCJpc05leHREaXJlY3Rpb24iLCJpc1ByZXZEaXJlY3Rpb24iLCJsYXN0SXRlbUluZGV4IiwiaXNHb2luZ1RvV3JhcCIsImRlbHRhIiwiaXRlbUluZGV4IiwiX3RyaWdnZXJTbGlkZUV2ZW50IiwicmVsYXRlZFRhcmdldCIsImV2ZW50RGlyZWN0aW9uTmFtZSIsInRhcmdldEluZGV4IiwiZnJvbUluZGV4Iiwic2xpZGVFdmVudCIsImZyb20iLCJfc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudCIsImluZGljYXRvcnMiLCJuZXh0SW5kaWNhdG9yIiwiY2hpbGRyZW4iLCJhZGRDbGFzcyIsImVsZW1lbnRJbnRlcnZhbCIsInBhcnNlSW50IiwiZGVmYXVsdEludGVydmFsIiwiX3RoaXM0IiwiYWN0aXZlRWxlbWVudEluZGV4IiwibmV4dEVsZW1lbnQiLCJuZXh0RWxlbWVudEluZGV4IiwiaXNDeWNsaW5nIiwiZGlyZWN0aW9uYWxDbGFzc05hbWUiLCJvcmRlckNsYXNzTmFtZSIsInNsaWRFdmVudCIsIl90eXBlb2YiLCJhY3Rpb24iLCJyaWRlIiwiX2RhdGFBcGlDbGlja0hhbmRsZXIiLCJzbGlkZUluZGV4IiwiY2Fyb3VzZWxzIiwiJGNhcm91c2VsIiwiTkFNRSQzIiwiVkVSU0lPTiQzIiwiREFUQV9LRVkkMyIsIkVWRU5UX0tFWSQzIiwiREFUQV9BUElfS0VZJDMiLCJKUVVFUllfTk9fQ09ORkxJQ1QkMyIsIkRlZmF1bHQkMSIsIkRlZmF1bHRUeXBlJDEiLCJFVkVOVF9TSE9XIiwiRVZFTlRfU0hPV04iLCJFVkVOVF9ISURFIiwiRVZFTlRfSElEREVOIiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMyIsIkNMQVNTX05BTUVfU0hPVyQxIiwiQ0xBU1NfTkFNRV9DT0xMQVBTRSIsIkNMQVNTX05BTUVfQ09MTEFQU0lORyIsIkNMQVNTX05BTUVfQ09MTEFQU0VEIiwiRElNRU5TSU9OX1dJRFRIIiwiRElNRU5TSU9OX0hFSUdIVCIsIlNFTEVDVE9SX0FDVElWRVMiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSQxIiwiQ29sbGFwc2UiLCJfaXNUcmFuc2l0aW9uaW5nIiwiX3RyaWdnZXJBcnJheSIsImlkIiwidG9nZ2xlTGlzdCIsImVsZW0iLCJmaWx0ZXJFbGVtZW50IiwiZmlsdGVyIiwiZm91bmRFbGVtIiwiX3NlbGVjdG9yIiwicHVzaCIsIl9wYXJlbnQiLCJfZ2V0UGFyZW50IiwiX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyIsImhpZGUiLCJzaG93IiwiYWN0aXZlcyIsImFjdGl2ZXNEYXRhIiwibm90Iiwic3RhcnRFdmVudCIsImRpbWVuc2lvbiIsIl9nZXREaW1lbnNpb24iLCJzdHlsZSIsImF0dHIiLCJzZXRUcmFuc2l0aW9uaW5nIiwiY29tcGxldGUiLCJjYXBpdGFsaXplZERpbWVuc2lvbiIsInNjcm9sbFNpemUiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0cmlnZ2VyQXJyYXlMZW5ndGgiLCIkZWxlbSIsImlzVHJhbnNpdGlvbmluZyIsImhhc1dpZHRoIiwiX2dldFRhcmdldEZyb21FbGVtZW50IiwidHJpZ2dlckFycmF5IiwiaXNPcGVuIiwiY3VycmVudFRhcmdldCIsIiR0cmlnZ2VyIiwic2VsZWN0b3JzIiwiJHRhcmdldCIsImlzQnJvd3NlciIsInRpbWVvdXREdXJhdGlvbiIsImxvbmdlclRpbWVvdXRCcm93c2VycyIsInVzZXJBZ2VudCIsIm1pY3JvdGFza0RlYm91bmNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwidGFza0RlYm91bmNlIiwic2NoZWR1bGVkIiwic3VwcG9ydHNNaWNyb1Rhc2tzIiwiZGVib3VuY2UiLCJpc0Z1bmN0aW9uIiwiZnVuY3Rpb25Ub0NoZWNrIiwiZ2V0VHlwZSIsImdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQYXJlbnROb2RlIiwibm9kZU5hbWUiLCJob3N0IiwiZ2V0U2Nyb2xsUGFyZW50IiwiYm9keSIsIl9nZXRTdHlsZUNvbXB1dGVkUHJvcCIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwiZ2V0UmVmZXJlbmNlTm9kZSIsInJlZmVyZW5jZSIsInJlZmVyZW5jZU5vZGUiLCJpc0lFMTEiLCJNU0lucHV0TWV0aG9kQ29udGV4dCIsImRvY3VtZW50TW9kZSIsImlzSUUxMCIsImlzSUUiLCJnZXRPZmZzZXRQYXJlbnQiLCJub09mZnNldFBhcmVudCIsIm9mZnNldFBhcmVudCIsIm5leHRFbGVtZW50U2libGluZyIsImlzT2Zmc2V0Q29udGFpbmVyIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJnZXRSb290Iiwibm9kZSIsImZpbmRDb21tb25PZmZzZXRQYXJlbnQiLCJlbGVtZW50MSIsImVsZW1lbnQyIiwib3JkZXIiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsIk5vZGUiLCJET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkciLCJyYW5nZSIsImNyZWF0ZVJhbmdlIiwic2V0U3RhcnQiLCJzZXRFbmQiLCJjb21tb25BbmNlc3RvckNvbnRhaW5lciIsImVsZW1lbnQxcm9vdCIsImdldFNjcm9sbCIsInNpZGUiLCJ1cHBlclNpZGUiLCJodG1sIiwic2Nyb2xsaW5nRWxlbWVudCIsImluY2x1ZGVTY3JvbGwiLCJyZWN0Iiwic3VidHJhY3QiLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0IiwibW9kaWZpZXIiLCJ0b3AiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJnZXRCb3JkZXJzU2l6ZSIsInN0eWxlcyIsImF4aXMiLCJzaWRlQSIsInNpZGVCIiwiZ2V0U2l6ZSIsImNvbXB1dGVkU3R5bGUiLCJtYXgiLCJnZXRXaW5kb3dTaXplcyIsImhlaWdodCIsIndpZHRoIiwiY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsImNyZWF0ZUNsYXNzIiwiZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5Iiwia2V5IiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2V4dGVuZHMkMSIsImFzc2lnbiIsInNvdXJjZSIsImdldENsaWVudFJlY3QiLCJvZmZzZXRzIiwicmVzdWx0Iiwic2l6ZXMiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImhvcml6U2Nyb2xsYmFyIiwib2Zmc2V0V2lkdGgiLCJ2ZXJ0U2Nyb2xsYmFyIiwiZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlIiwiZml4ZWRQb3NpdGlvbiIsImlzSFRNTCIsImNoaWxkcmVuUmVjdCIsInBhcmVudFJlY3QiLCJzY3JvbGxQYXJlbnQiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckxlZnRXaWR0aCIsIm1hcmdpblRvcCIsIm1hcmdpbkxlZnQiLCJnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUiLCJleGNsdWRlU2Nyb2xsIiwicmVsYXRpdmVPZmZzZXQiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJvZmZzZXQiLCJpc0ZpeGVkIiwiZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudCIsInBhcmVudEVsZW1lbnQiLCJlbCIsImdldEJvdW5kYXJpZXMiLCJwb3BwZXIiLCJwYWRkaW5nIiwiYm91bmRhcmllc0VsZW1lbnQiLCJib3VuZGFyaWVzIiwiYm91bmRhcmllc05vZGUiLCJfZ2V0V2luZG93U2l6ZXMiLCJpc1BhZGRpbmdOdW1iZXIiLCJnZXRBcmVhIiwiX3JlZiIsImNvbXB1dGVBdXRvUGxhY2VtZW50IiwicGxhY2VtZW50IiwicmVmUmVjdCIsInJlY3RzIiwic29ydGVkQXJlYXMiLCJrZXlzIiwibWFwIiwiYXJlYSIsInNvcnQiLCJhIiwiYiIsImZpbHRlcmVkQXJlYXMiLCJfcmVmMiIsImNvbXB1dGVkUGxhY2VtZW50IiwidmFyaWF0aW9uIiwiZ2V0UmVmZXJlbmNlT2Zmc2V0cyIsInN0YXRlIiwiY29tbW9uT2Zmc2V0UGFyZW50IiwiZ2V0T3V0ZXJTaXplcyIsIngiLCJtYXJnaW5Cb3R0b20iLCJ5IiwibWFyZ2luUmlnaHQiLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsImhhc2giLCJyZXBsYWNlIiwibWF0Y2hlZCIsImdldFBvcHBlck9mZnNldHMiLCJyZWZlcmVuY2VPZmZzZXRzIiwicG9wcGVyUmVjdCIsInBvcHBlck9mZnNldHMiLCJpc0hvcml6IiwibWFpblNpZGUiLCJzZWNvbmRhcnlTaWRlIiwibWVhc3VyZW1lbnQiLCJzZWNvbmRhcnlNZWFzdXJlbWVudCIsImZpbmQiLCJhcnIiLCJjaGVjayIsIkFycmF5IiwiZmluZEluZGV4IiwicHJvcCIsImN1ciIsInJ1bk1vZGlmaWVycyIsIm1vZGlmaWVycyIsImVuZHMiLCJtb2RpZmllcnNUb1J1biIsImZvckVhY2giLCJjb25zb2xlIiwid2FybiIsImVuYWJsZWQiLCJ1cGRhdGUiLCJpc0Rlc3Ryb3llZCIsImFycm93U3R5bGVzIiwiYXR0cmlidXRlcyIsImZsaXBwZWQiLCJvcHRpb25zIiwicG9zaXRpb25GaXhlZCIsImZsaXAiLCJvcmlnaW5hbFBsYWNlbWVudCIsInBvc2l0aW9uIiwiaXNDcmVhdGVkIiwib25DcmVhdGUiLCJvblVwZGF0ZSIsImlzTW9kaWZpZXJFbmFibGVkIiwibW9kaWZpZXJOYW1lIiwic29tZSIsIm5hbWUiLCJnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUiLCJwcmVmaXhlcyIsInVwcGVyUHJvcCIsImNoYXJBdCIsInRvQ2hlY2siLCJkZXN0cm95IiwicmVtb3ZlQXR0cmlidXRlIiwid2lsbENoYW5nZSIsImRpc2FibGVFdmVudExpc3RlbmVycyIsInJlbW92ZU9uRGVzdHJveSIsInJlbW92ZUNoaWxkIiwiZ2V0V2luZG93IiwiYXR0YWNoVG9TY3JvbGxQYXJlbnRzIiwiY2FsbGJhY2siLCJzY3JvbGxQYXJlbnRzIiwiaXNCb2R5IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJzZXR1cEV2ZW50TGlzdGVuZXJzIiwidXBkYXRlQm91bmQiLCJzY3JvbGxFbGVtZW50IiwiZXZlbnRzRW5hYmxlZCIsImVuYWJsZUV2ZW50TGlzdGVuZXJzIiwic2NoZWR1bGVVcGRhdGUiLCJyZW1vdmVFdmVudExpc3RlbmVycyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImlzTnVtZXJpYyIsIm4iLCJpc05hTiIsImlzRmluaXRlIiwic2V0U3R5bGVzIiwidW5pdCIsInNldEF0dHJpYnV0ZXMiLCJhcHBseVN0eWxlIiwiYXJyb3dFbGVtZW50IiwiYXBwbHlTdHlsZU9uTG9hZCIsIm1vZGlmaWVyT3B0aW9ucyIsImdldFJvdW5kZWRPZmZzZXRzIiwic2hvdWxkUm91bmQiLCJfZGF0YSRvZmZzZXRzIiwicm91bmQiLCJmbG9vciIsIm5vUm91bmQiLCJ2IiwicmVmZXJlbmNlV2lkdGgiLCJwb3BwZXJXaWR0aCIsImlzVmVydGljYWwiLCJpc1ZhcmlhdGlvbiIsInNhbWVXaWR0aFBhcml0eSIsImJvdGhPZGRXaWR0aCIsImhvcml6b250YWxUb0ludGVnZXIiLCJ2ZXJ0aWNhbFRvSW50ZWdlciIsImlzRmlyZWZveCIsImNvbXB1dGVTdHlsZSIsImxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiIsImdwdUFjY2VsZXJhdGlvbiIsIm9mZnNldFBhcmVudFJlY3QiLCJkZXZpY2VQaXhlbFJhdGlvIiwicHJlZml4ZWRQcm9wZXJ0eSIsImludmVydFRvcCIsImludmVydExlZnQiLCJhcnJvdyIsImlzTW9kaWZpZXJSZXF1aXJlZCIsInJlcXVlc3RpbmdOYW1lIiwicmVxdWVzdGVkTmFtZSIsInJlcXVlc3RpbmciLCJpc1JlcXVpcmVkIiwiX3JlcXVlc3RpbmciLCJyZXF1ZXN0ZWQiLCJfZGF0YSRvZmZzZXRzJGFycm93Iiwic2lkZUNhcGl0YWxpemVkIiwiYWx0U2lkZSIsIm9wU2lkZSIsImFycm93RWxlbWVudFNpemUiLCJjZW50ZXIiLCJwb3BwZXJNYXJnaW5TaWRlIiwicG9wcGVyQm9yZGVyU2lkZSIsInNpZGVWYWx1ZSIsIm1pbiIsImdldE9wcG9zaXRlVmFyaWF0aW9uIiwicGxhY2VtZW50cyIsInZhbGlkUGxhY2VtZW50cyIsImNsb2Nrd2lzZSIsImNvdW50ZXIiLCJjb25jYXQiLCJyZXZlcnNlIiwiQkVIQVZJT1JTIiwiRkxJUCIsIkNMT0NLV0lTRSIsIkNPVU5URVJDTE9DS1dJU0UiLCJwbGFjZW1lbnRPcHBvc2l0ZSIsImZsaXBPcmRlciIsImJlaGF2aW9yIiwic3RlcCIsInJlZk9mZnNldHMiLCJvdmVybGFwc1JlZiIsIm92ZXJmbG93c0xlZnQiLCJvdmVyZmxvd3NSaWdodCIsIm92ZXJmbG93c1RvcCIsIm92ZXJmbG93c0JvdHRvbSIsIm92ZXJmbG93c0JvdW5kYXJpZXMiLCJmbGlwcGVkVmFyaWF0aW9uQnlSZWYiLCJmbGlwVmFyaWF0aW9ucyIsImZsaXBwZWRWYXJpYXRpb25CeUNvbnRlbnQiLCJmbGlwVmFyaWF0aW9uc0J5Q29udGVudCIsImZsaXBwZWRWYXJpYXRpb24iLCJrZWVwVG9nZXRoZXIiLCJ0b1ZhbHVlIiwic3RyIiwic2l6ZSIsInBhcnNlT2Zmc2V0IiwiYmFzZVBsYWNlbWVudCIsInVzZUhlaWdodCIsImZyYWdtZW50cyIsImZyYWciLCJkaXZpZGVyIiwic2VhcmNoIiwic3BsaXRSZWdleCIsIm9wcyIsIm9wIiwibWVyZ2VXaXRoUHJldmlvdXMiLCJyZWR1Y2UiLCJpbmRleDIiLCJwcmV2ZW50T3ZlcmZsb3ciLCJ0cmFuc2Zvcm1Qcm9wIiwicG9wcGVyU3R5bGVzIiwidHJhbnNmb3JtIiwicHJpb3JpdHkiLCJwcmltYXJ5IiwiZXNjYXBlV2l0aFJlZmVyZW5jZSIsInNlY29uZGFyeSIsInNoaWZ0Iiwic2hpZnR2YXJpYXRpb24iLCJzaGlmdE9mZnNldHMiLCJib3VuZCIsImlubmVyIiwic3VidHJhY3RMZW5ndGgiLCJvbkxvYWQiLCJEZWZhdWx0cyIsIlBvcHBlciIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInVwZGF0ZSQkMSIsImRlc3Ryb3kkJDEiLCJlbmFibGVFdmVudExpc3RlbmVycyQkMSIsImRpc2FibGVFdmVudExpc3RlbmVycyQkMSIsIlV0aWxzIiwiZ2xvYmFsIiwiUG9wcGVyVXRpbHMiLCJOQU1FJDQiLCJWRVJTSU9OJDQiLCJEQVRBX0tFWSQ0IiwiRVZFTlRfS0VZJDQiLCJEQVRBX0FQSV9LRVkkNCIsIkpRVUVSWV9OT19DT05GTElDVCQ0IiwiRVNDQVBFX0tFWUNPREUiLCJTUEFDRV9LRVlDT0RFIiwiVEFCX0tFWUNPREUiLCJBUlJPV19VUF9LRVlDT0RFIiwiQVJST1dfRE9XTl9LRVlDT0RFIiwiUklHSFRfTU9VU0VfQlVUVE9OX1dISUNIIiwiUkVHRVhQX0tFWURPV04iLCJFVkVOVF9ISURFJDEiLCJFVkVOVF9ISURERU4kMSIsIkVWRU5UX1NIT1ckMSIsIkVWRU5UX1NIT1dOJDEiLCJFVkVOVF9DTElDSyIsIkVWRU5UX0NMSUNLX0RBVEFfQVBJJDQiLCJFVkVOVF9LRVlET1dOX0RBVEFfQVBJIiwiRVZFTlRfS0VZVVBfREFUQV9BUEkiLCJDTEFTU19OQU1FX0RJU0FCTEVEIiwiQ0xBU1NfTkFNRV9TSE9XJDIiLCJDTEFTU19OQU1FX0RST1BVUCIsIkNMQVNTX05BTUVfRFJPUFJJR0hUIiwiQ0xBU1NfTkFNRV9EUk9QTEVGVCIsIkNMQVNTX05BTUVfTUVOVVJJR0hUIiwiQ0xBU1NfTkFNRV9QT1NJVElPTl9TVEFUSUMiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSQyIiwiU0VMRUNUT1JfRk9STV9DSElMRCIsIlNFTEVDVE9SX01FTlUiLCJTRUxFQ1RPUl9OQVZCQVJfTkFWIiwiU0VMRUNUT1JfVklTSUJMRV9JVEVNUyIsIlBMQUNFTUVOVF9UT1AiLCJQTEFDRU1FTlRfVE9QRU5EIiwiUExBQ0VNRU5UX0JPVFRPTSIsIlBMQUNFTUVOVF9CT1RUT01FTkQiLCJQTEFDRU1FTlRfUklHSFQiLCJQTEFDRU1FTlRfTEVGVCIsIkRlZmF1bHQkMiIsImJvdW5kYXJ5IiwiZGlzcGxheSIsInBvcHBlckNvbmZpZyIsIkRlZmF1bHRUeXBlJDIiLCJEcm9wZG93biIsIl9wb3BwZXIiLCJfbWVudSIsIl9nZXRNZW51RWxlbWVudCIsIl9pbk5hdmJhciIsIl9kZXRlY3ROYXZiYXIiLCJkaXNhYmxlZCIsImlzQWN0aXZlIiwiX2NsZWFyTWVudXMiLCJ1c2VQb3BwZXIiLCJzaG93RXZlbnQiLCJfZ2V0UGFyZW50RnJvbUVsZW1lbnQiLCJyZWZlcmVuY2VFbGVtZW50IiwiX2dldFBvcHBlckNvbmZpZyIsIm5vb3AiLCJoaWRlRXZlbnQiLCJzdG9wUHJvcGFnYXRpb24iLCJjb25zdHJ1Y3RvciIsIl9nZXRQbGFjZW1lbnQiLCIkcGFyZW50RHJvcGRvd24iLCJfZ2V0T2Zmc2V0IiwidG9nZ2xlcyIsImNvbnRleHQiLCJjbGlja0V2ZW50IiwiZHJvcGRvd25NZW51IiwiX2RhdGFBcGlLZXlkb3duSGFuZGxlciIsIml0ZW1zIiwiaXRlbSIsIk5BTUUkNSIsIlZFUlNJT04kNSIsIkRBVEFfS0VZJDUiLCJFVkVOVF9LRVkkNSIsIkRBVEFfQVBJX0tFWSQ1IiwiSlFVRVJZX05PX0NPTkZMSUNUJDUiLCJFU0NBUEVfS0VZQ09ERSQxIiwiRGVmYXVsdCQzIiwiYmFja2Ryb3AiLCJEZWZhdWx0VHlwZSQzIiwiRVZFTlRfSElERSQyIiwiRVZFTlRfSElERV9QUkVWRU5URUQiLCJFVkVOVF9ISURERU4kMiIsIkVWRU5UX1NIT1ckMiIsIkVWRU5UX1NIT1dOJDIiLCJFVkVOVF9GT0NVU0lOIiwiRVZFTlRfUkVTSVpFIiwiRVZFTlRfQ0xJQ0tfRElTTUlTUyIsIkVWRU5UX0tFWURPV05fRElTTUlTUyIsIkVWRU5UX01PVVNFVVBfRElTTUlTUyIsIkVWRU5UX01PVVNFRE9XTl9ESVNNSVNTIiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNSIsIkNMQVNTX05BTUVfU0NST0xMQUJMRSIsIkNMQVNTX05BTUVfU0NST0xMQkFSX01FQVNVUkVSIiwiQ0xBU1NfTkFNRV9CQUNLRFJPUCIsIkNMQVNTX05BTUVfT1BFTiIsIkNMQVNTX05BTUVfRkFERSQxIiwiQ0xBU1NfTkFNRV9TSE9XJDMiLCJDTEFTU19OQU1FX1NUQVRJQyIsIlNFTEVDVE9SX0RJQUxPRyIsIlNFTEVDVE9SX01PREFMX0JPRFkiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzIiwiU0VMRUNUT1JfREFUQV9ESVNNSVNTIiwiU0VMRUNUT1JfRklYRURfQ09OVEVOVCIsIlNFTEVDVE9SX1NUSUNLWV9DT05URU5UIiwiTW9kYWwiLCJfZGlhbG9nIiwiX2JhY2tkcm9wIiwiX2lzU2hvd24iLCJfaXNCb2R5T3ZlcmZsb3dpbmciLCJfaWdub3JlQmFja2Ryb3BDbGljayIsIl9zY3JvbGxiYXJXaWR0aCIsIl9jaGVja1Njcm9sbGJhciIsIl9zZXRTY3JvbGxiYXIiLCJfYWRqdXN0RGlhbG9nIiwiX3NldEVzY2FwZUV2ZW50IiwiX3NldFJlc2l6ZUV2ZW50IiwiX3Nob3dCYWNrZHJvcCIsIl9zaG93RWxlbWVudCIsInRyYW5zaXRpb24iLCJfaGlkZU1vZGFsIiwiaHRtbEVsZW1lbnQiLCJoYW5kbGVVcGRhdGUiLCJfdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbiIsImhpZGVFdmVudFByZXZlbnRlZCIsImlzTW9kYWxPdmVyZmxvd2luZyIsInNjcm9sbEhlaWdodCIsIm1vZGFsVHJhbnNpdGlvbkR1cmF0aW9uIiwibW9kYWxCb2R5IiwiRUxFTUVOVF9OT0RFIiwiYXBwZW5kQ2hpbGQiLCJfZW5mb3JjZUZvY3VzIiwic2hvd25FdmVudCIsInRyYW5zaXRpb25Db21wbGV0ZSIsIl90aGlzNSIsImhhcyIsIl90aGlzNiIsIl90aGlzNyIsIl90aGlzOCIsIl9yZXNldEFkanVzdG1lbnRzIiwiX3Jlc2V0U2Nyb2xsYmFyIiwiX3JlbW92ZUJhY2tkcm9wIiwiX3RoaXM5IiwiYW5pbWF0ZSIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJhcHBlbmRUbyIsImJhY2tkcm9wVHJhbnNpdGlvbkR1cmF0aW9uIiwiY2FsbGJhY2tSZW1vdmUiLCJfYmFja2Ryb3BUcmFuc2l0aW9uRHVyYXRpb24iLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsIl9nZXRTY3JvbGxiYXJXaWR0aCIsIl90aGlzMTAiLCJmaXhlZENvbnRlbnQiLCJzdGlja3lDb250ZW50IiwiYWN0dWFsUGFkZGluZyIsImNhbGN1bGF0ZWRQYWRkaW5nIiwiYWN0dWFsTWFyZ2luIiwiY2FsY3VsYXRlZE1hcmdpbiIsImVsZW1lbnRzIiwibWFyZ2luIiwic2Nyb2xsRGl2Iiwic2Nyb2xsYmFyV2lkdGgiLCJfdGhpczExIiwidXJpQXR0cnMiLCJBUklBX0FUVFJJQlVURV9QQVRURVJOIiwiRGVmYXVsdFdoaXRlbGlzdCIsImJyIiwiY29sIiwiY29kZSIsImRpdiIsImVtIiwiaHIiLCJoMSIsImgyIiwiaDMiLCJoNCIsImg1IiwiaDYiLCJpbWciLCJsaSIsIm9sIiwicCIsInByZSIsInMiLCJzbWFsbCIsInNwYW4iLCJzdWIiLCJzdXAiLCJzdHJvbmciLCJ1IiwidWwiLCJTQUZFX1VSTF9QQVRURVJOIiwiREFUQV9VUkxfUEFUVEVSTiIsImFsbG93ZWRBdHRyaWJ1dGUiLCJhbGxvd2VkQXR0cmlidXRlTGlzdCIsImF0dHJOYW1lIiwibm9kZVZhbHVlIiwicmVnRXhwIiwiYXR0clJlZ2V4Iiwic2FuaXRpemVIdG1sIiwidW5zYWZlSHRtbCIsIndoaXRlTGlzdCIsInNhbml0aXplRm4iLCJkb21QYXJzZXIiLCJET01QYXJzZXIiLCJjcmVhdGVkRG9jdW1lbnQiLCJwYXJzZUZyb21TdHJpbmciLCJ3aGl0ZWxpc3RLZXlzIiwiX2xvb3AiLCJlbE5hbWUiLCJhdHRyaWJ1dGVMaXN0Iiwid2hpdGVsaXN0ZWRBdHRyaWJ1dGVzIiwiX3JldCIsImlubmVySFRNTCIsIk5BTUUkNiIsIlZFUlNJT04kNiIsIkRBVEFfS0VZJDYiLCJFVkVOVF9LRVkkNiIsIkpRVUVSWV9OT19DT05GTElDVCQ2IiwiQ0xBU1NfUFJFRklYIiwiQlNDTFNfUFJFRklYX1JFR0VYIiwiRElTQUxMT1dFRF9BVFRSSUJVVEVTIiwiRGVmYXVsdFR5cGUkNCIsImFuaW1hdGlvbiIsInRlbXBsYXRlIiwidGl0bGUiLCJkZWxheSIsImNvbnRhaW5lciIsImZhbGxiYWNrUGxhY2VtZW50IiwiY3VzdG9tQ2xhc3MiLCJzYW5pdGl6ZSIsIkF0dGFjaG1lbnRNYXAiLCJBVVRPIiwiVE9QIiwiUklHSFQiLCJCT1RUT00iLCJMRUZUIiwiRGVmYXVsdCQ0IiwiSE9WRVJfU1RBVEVfU0hPVyIsIkhPVkVSX1NUQVRFX09VVCIsIkhJREUiLCJISURERU4iLCJTSE9XIiwiU0hPV04iLCJJTlNFUlRFRCIsIkNMSUNLIiwiRk9DVVNJTiIsIkZPQ1VTT1VUIiwiTU9VU0VFTlRFUiIsIk1PVVNFTEVBVkUiLCJDTEFTU19OQU1FX0ZBREUkMiIsIkNMQVNTX05BTUVfU0hPVyQ0IiwiU0VMRUNUT1JfVE9PTFRJUF9JTk5FUiIsIlNFTEVDVE9SX0FSUk9XIiwiVFJJR0dFUl9IT1ZFUiIsIlRSSUdHRVJfRk9DVVMiLCJUUklHR0VSX0NMSUNLIiwiVFJJR0dFUl9NQU5VQUwiLCJUb29sdGlwIiwiX2lzRW5hYmxlZCIsIl90aW1lb3V0IiwiX2hvdmVyU3RhdGUiLCJfYWN0aXZlVHJpZ2dlciIsInRpcCIsIl9zZXRMaXN0ZW5lcnMiLCJlbmFibGUiLCJkaXNhYmxlIiwidG9nZ2xlRW5hYmxlZCIsImRhdGFLZXkiLCJfZ2V0RGVsZWdhdGVDb25maWciLCJjbGljayIsIl9pc1dpdGhBY3RpdmVUcmlnZ2VyIiwiX2VudGVyIiwiX2xlYXZlIiwiZ2V0VGlwRWxlbWVudCIsIl9oaWRlTW9kYWxIYW5kbGVyIiwiaXNXaXRoQ29udGVudCIsInNoYWRvd1Jvb3QiLCJpc0luVGhlRG9tIiwidGlwSWQiLCJzZXRDb250ZW50IiwiYXR0YWNobWVudCIsIl9nZXRBdHRhY2htZW50IiwiYWRkQXR0YWNobWVudENsYXNzIiwiX2dldENvbnRhaW5lciIsIl9maXhUcmFuc2l0aW9uIiwicHJldkhvdmVyU3RhdGUiLCJfY2xlYW5UaXBDbGFzcyIsImdldFRpdGxlIiwic2V0RWxlbWVudENvbnRlbnQiLCJjb250ZW50IiwiZW1wdHkiLCJhcHBlbmQiLCJ0ZXh0IiwiZGVmYXVsdEJzQ29uZmlnIiwiX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZSIsInRyaWdnZXJzIiwiZXZlbnRJbiIsImV2ZW50T3V0IiwiX2ZpeFRpdGxlIiwidGl0bGVUeXBlIiwiZGF0YUF0dHJpYnV0ZXMiLCJkYXRhQXR0ciIsIiR0aXAiLCJ0YWJDbGFzcyIsImpvaW4iLCJwb3BwZXJEYXRhIiwiaW5pdENvbmZpZ0FuaW1hdGlvbiIsIk5BTUUkNyIsIlZFUlNJT04kNyIsIkRBVEFfS0VZJDciLCJFVkVOVF9LRVkkNyIsIkpRVUVSWV9OT19DT05GTElDVCQ3IiwiQ0xBU1NfUFJFRklYJDEiLCJCU0NMU19QUkVGSVhfUkVHRVgkMSIsIkRlZmF1bHQkNSIsIkRlZmF1bHRUeXBlJDUiLCJDTEFTU19OQU1FX0ZBREUkMyIsIkNMQVNTX05BTUVfU0hPVyQ1IiwiU0VMRUNUT1JfVElUTEUiLCJTRUxFQ1RPUl9DT05URU5UIiwiRXZlbnQkMSIsIlBvcG92ZXIiLCJfVG9vbHRpcCIsIl9nZXRDb250ZW50IiwiTkFNRSQ4IiwiVkVSU0lPTiQ4IiwiREFUQV9LRVkkOCIsIkVWRU5UX0tFWSQ4IiwiREFUQV9BUElfS0VZJDYiLCJKUVVFUllfTk9fQ09ORkxJQ1QkOCIsIkRlZmF1bHQkNiIsIm1ldGhvZCIsIkRlZmF1bHRUeXBlJDYiLCJFVkVOVF9BQ1RJVkFURSIsIkVWRU5UX1NDUk9MTCIsIkVWRU5UX0xPQURfREFUQV9BUEkkMiIsIkNMQVNTX05BTUVfRFJPUERPV05fSVRFTSIsIkNMQVNTX05BTUVfQUNUSVZFJDIiLCJTRUxFQ1RPUl9EQVRBX1NQWSIsIlNFTEVDVE9SX05BVl9MSVNUX0dST1VQIiwiU0VMRUNUT1JfTkFWX0xJTktTIiwiU0VMRUNUT1JfTkFWX0lURU1TIiwiU0VMRUNUT1JfTElTVF9JVEVNUyIsIlNFTEVDVE9SX0RST1BET1dOIiwiU0VMRUNUT1JfRFJPUERPV05fSVRFTVMiLCJTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUiLCJNRVRIT0RfT0ZGU0VUIiwiTUVUSE9EX1BPU0lUSU9OIiwiU2Nyb2xsU3B5IiwiX3Njcm9sbEVsZW1lbnQiLCJfb2Zmc2V0cyIsIl90YXJnZXRzIiwiX2FjdGl2ZVRhcmdldCIsIl9zY3JvbGxIZWlnaHQiLCJfcHJvY2VzcyIsInJlZnJlc2giLCJhdXRvTWV0aG9kIiwib2Zmc2V0TWV0aG9kIiwib2Zmc2V0QmFzZSIsIl9nZXRTY3JvbGxUb3AiLCJfZ2V0U2Nyb2xsSGVpZ2h0IiwidGFyZ2V0cyIsInRhcmdldFNlbGVjdG9yIiwidGFyZ2V0QkNSIiwicGFnZVlPZmZzZXQiLCJfZ2V0T2Zmc2V0SGVpZ2h0IiwibWF4U2Nyb2xsIiwiX2FjdGl2YXRlIiwiX2NsZWFyIiwiaXNBY3RpdmVUYXJnZXQiLCJxdWVyaWVzIiwiJGxpbmsiLCJwYXJlbnRzIiwic2Nyb2xsU3B5cyIsInNjcm9sbFNweXNMZW5ndGgiLCIkc3B5IiwiTkFNRSQ5IiwiVkVSU0lPTiQ5IiwiREFUQV9LRVkkOSIsIkVWRU5UX0tFWSQ5IiwiREFUQV9BUElfS0VZJDciLCJKUVVFUllfTk9fQ09ORkxJQ1QkOSIsIkVWRU5UX0hJREUkMyIsIkVWRU5UX0hJRERFTiQzIiwiRVZFTlRfU0hPVyQzIiwiRVZFTlRfU0hPV04kMyIsIkVWRU5UX0NMSUNLX0RBVEFfQVBJJDYiLCJDTEFTU19OQU1FX0RST1BET1dOX01FTlUiLCJDTEFTU19OQU1FX0FDVElWRSQzIiwiQ0xBU1NfTkFNRV9ESVNBQkxFRCQxIiwiQ0xBU1NfTkFNRV9GQURFJDQiLCJDTEFTU19OQU1FX1NIT1ckNiIsIlNFTEVDVE9SX0RST1BET1dOJDEiLCJTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUCQxIiwiU0VMRUNUT1JfQUNUSVZFJDIiLCJTRUxFQ1RPUl9BQ1RJVkVfVUwiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0IiwiU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFJDEiLCJTRUxFQ1RPUl9EUk9QRE9XTl9BQ1RJVkVfQ0hJTEQiLCJUYWIiLCJwcmV2aW91cyIsImxpc3RFbGVtZW50IiwiaXRlbVNlbGVjdG9yIiwibWFrZUFycmF5IiwiaGlkZGVuRXZlbnQiLCJhY3RpdmVFbGVtZW50cyIsImFjdGl2ZSIsIl90cmFuc2l0aW9uQ29tcGxldGUiLCJkcm9wZG93bkNoaWxkIiwiZHJvcGRvd25FbGVtZW50IiwiZHJvcGRvd25Ub2dnbGVMaXN0IiwiJHRoaXMiLCJOQU1FJGEiLCJWRVJTSU9OJGEiLCJEQVRBX0tFWSRhIiwiRVZFTlRfS0VZJGEiLCJKUVVFUllfTk9fQ09ORkxJQ1QkYSIsIkVWRU5UX0NMSUNLX0RJU01JU1MkMSIsIkVWRU5UX0hJREUkNCIsIkVWRU5UX0hJRERFTiQ0IiwiRVZFTlRfU0hPVyQ0IiwiRVZFTlRfU0hPV04kNCIsIkNMQVNTX05BTUVfRkFERSQ1IiwiQ0xBU1NfTkFNRV9ISURFIiwiQ0xBU1NfTkFNRV9TSE9XJDciLCJDTEFTU19OQU1FX1NIT1dJTkciLCJEZWZhdWx0VHlwZSQ3IiwiYXV0b2hpZGUiLCJEZWZhdWx0JDciLCJTRUxFQ1RPUl9EQVRBX0RJU01JU1MkMSIsIlRvYXN0IiwiX2NsZWFyVGltZW91dCIsIl9jbG9zZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/themes/bootstrap/vendor/bootstrap/js/bootstrap.bundle.js\n");

/***/ }),

/***/ "./resources/themes/bootstrap/vendor/jquery-easing/jquery_easing.js":
/*!**************************************************************************!*\
  !*** ./resources/themes/bootstrap/vendor/jquery-easing/jquery_easing.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*\n * jQuery Easing v1.4.1 - http://gsgd.co.uk/sandbox/jquery/easing/\n * Open source under the BSD License.\n * Copyright  2008 George McGinley Smith\n * All rights reserved.\n * https://raw.github.com/gdsmith/jquery-easing/master/LICENSE\n*/\n\n(function (factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"jquery\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($) {\n      return factory($);\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(function ($) {\n  // Preserve the original jQuery \"swing\" easing as \"jswing\"\n  $.easing.jswing = $.easing.swing;\n  var pow = Math.pow,\n    sqrt = Math.sqrt,\n    sin = Math.sin,\n    cos = Math.cos,\n    PI = Math.PI,\n    c1 = 1.70158,\n    c2 = c1 * 1.525,\n    c3 = c1 + 1,\n    c4 = 2 * PI / 3,\n    c5 = 2 * PI / 4.5;\n\n  // x is the fraction of animation progress, in the range 0..1\n  function bounceOut(x) {\n    var n1 = 7.5625,\n      d1 = 2.75;\n    if (x < 1 / d1) {\n      return n1 * x * x;\n    } else if (x < 2 / d1) {\n      return n1 * (x -= 1.5 / d1) * x + 0.75;\n    } else if (x < 2.5 / d1) {\n      return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    } else {\n      return n1 * (x -= 2.625 / d1) * x + 0.984375;\n    }\n  }\n  $.extend($.easing, {\n    def: 'easeOutQuad',\n    swing: function swing(x) {\n      return $.easing[$.easing.def](x);\n    },\n    easeInQuad: function easeInQuad(x) {\n      return x * x;\n    },\n    easeOutQuad: function easeOutQuad(x) {\n      return 1 - (1 - x) * (1 - x);\n    },\n    easeInOutQuad: function easeInOutQuad(x) {\n      return x < 0.5 ? 2 * x * x : 1 - pow(-2 * x + 2, 2) / 2;\n    },\n    easeInCubic: function easeInCubic(x) {\n      return x * x * x;\n    },\n    easeOutCubic: function easeOutCubic(x) {\n      return 1 - pow(1 - x, 3);\n    },\n    easeInOutCubic: function easeInOutCubic(x) {\n      return x < 0.5 ? 4 * x * x * x : 1 - pow(-2 * x + 2, 3) / 2;\n    },\n    easeInQuart: function easeInQuart(x) {\n      return x * x * x * x;\n    },\n    easeOutQuart: function easeOutQuart(x) {\n      return 1 - pow(1 - x, 4);\n    },\n    easeInOutQuart: function easeInOutQuart(x) {\n      return x < 0.5 ? 8 * x * x * x * x : 1 - pow(-2 * x + 2, 4) / 2;\n    },\n    easeInQuint: function easeInQuint(x) {\n      return x * x * x * x * x;\n    },\n    easeOutQuint: function easeOutQuint(x) {\n      return 1 - pow(1 - x, 5);\n    },\n    easeInOutQuint: function easeInOutQuint(x) {\n      return x < 0.5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2;\n    },\n    easeInSine: function easeInSine(x) {\n      return 1 - cos(x * PI / 2);\n    },\n    easeOutSine: function easeOutSine(x) {\n      return sin(x * PI / 2);\n    },\n    easeInOutSine: function easeInOutSine(x) {\n      return -(cos(PI * x) - 1) / 2;\n    },\n    easeInExpo: function easeInExpo(x) {\n      return x === 0 ? 0 : pow(2, 10 * x - 10);\n    },\n    easeOutExpo: function easeOutExpo(x) {\n      return x === 1 ? 1 : 1 - pow(2, -10 * x);\n    },\n    easeInOutExpo: function easeInOutExpo(x) {\n      return x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? pow(2, 20 * x - 10) / 2 : (2 - pow(2, -20 * x + 10)) / 2;\n    },\n    easeInCirc: function easeInCirc(x) {\n      return 1 - sqrt(1 - pow(x, 2));\n    },\n    easeOutCirc: function easeOutCirc(x) {\n      return sqrt(1 - pow(x - 1, 2));\n    },\n    easeInOutCirc: function easeInOutCirc(x) {\n      return x < 0.5 ? (1 - sqrt(1 - pow(2 * x, 2))) / 2 : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2;\n    },\n    easeInElastic: function easeInElastic(x) {\n      return x === 0 ? 0 : x === 1 ? 1 : -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4);\n    },\n    easeOutElastic: function easeOutElastic(x) {\n      return x === 0 ? 0 : x === 1 ? 1 : pow(2, -10 * x) * sin((x * 10 - 0.75) * c4) + 1;\n    },\n    easeInOutElastic: function easeInOutElastic(x) {\n      return x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2 : pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5) / 2 + 1;\n    },\n    easeInBack: function easeInBack(x) {\n      return c3 * x * x * x - c1 * x * x;\n    },\n    easeOutBack: function easeOutBack(x) {\n      return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);\n    },\n    easeInOutBack: function easeInOutBack(x) {\n      return x < 0.5 ? pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2 : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\n    },\n    easeInBounce: function easeInBounce(x) {\n      return 1 - bounceOut(1 - x);\n    },\n    easeOutBounce: bounceOut,\n    easeInOutBounce: function easeInOutBounce(x) {\n      return x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2;\n    }\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvdGhlbWVzL2Jvb3RzdHJhcC92ZW5kb3IvanF1ZXJ5LWVhc2luZy9qcXVlcnlfZWFzaW5nLmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLFVBQVVBLE9BQU8sRUFBRTtFQUNuQixJQUFJLElBQTBDLEVBQUU7SUFDL0NDLGlDQUFPLENBQUMsMkNBQVEsQ0FBQyxtQ0FBRSxVQUFVRSxDQUFDLEVBQUU7TUFDL0IsT0FBT0gsT0FBTyxDQUFDRyxDQUFDLENBQUM7SUFDbEIsQ0FBQztBQUFBLGtHQUFDO0VBQ0gsQ0FBQyxNQUFNLEVBSU47QUFDRixDQUFDLEVBQUUsVUFBU0EsQ0FBQyxFQUFDO0VBRWQ7RUFDQUEsQ0FBQyxDQUFDTSxNQUFNLENBQUNDLE1BQU0sR0FBR1AsQ0FBQyxDQUFDTSxNQUFNLENBQUNFLEtBQUs7RUFFaEMsSUFBSUMsR0FBRyxHQUFHQyxJQUFJLENBQUNELEdBQUc7SUFDakJFLElBQUksR0FBR0QsSUFBSSxDQUFDQyxJQUFJO0lBQ2hCQyxHQUFHLEdBQUdGLElBQUksQ0FBQ0UsR0FBRztJQUNkQyxHQUFHLEdBQUdILElBQUksQ0FBQ0csR0FBRztJQUNkQyxFQUFFLEdBQUdKLElBQUksQ0FBQ0ksRUFBRTtJQUNaQyxFQUFFLEdBQUcsT0FBTztJQUNaQyxFQUFFLEdBQUdELEVBQUUsR0FBRyxLQUFLO0lBQ2ZFLEVBQUUsR0FBR0YsRUFBRSxHQUFHLENBQUM7SUFDWEcsRUFBRSxHQUFLLENBQUMsR0FBR0osRUFBRSxHQUFLLENBQUM7SUFDbkJLLEVBQUUsR0FBSyxDQUFDLEdBQUdMLEVBQUUsR0FBSyxHQUFHOztFQUV0QjtFQUNBLFNBQVNNLFNBQVNBLENBQUNDLENBQUMsRUFBRTtJQUNyQixJQUFJQyxFQUFFLEdBQUcsTUFBTTtNQUNkQyxFQUFFLEdBQUcsSUFBSTtJQUNWLElBQUtGLENBQUMsR0FBRyxDQUFDLEdBQUNFLEVBQUUsRUFBRztNQUNmLE9BQU9E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QUFFLENBQUMsR0FBR0MsQ0FBQyxDQUFFO0lBQzlCLENBQUM7SUFDRGlDLGFBQWEsRUFBRWxDLFNBQVM7SUFDeEJtQyxlQUFlLEVBQUUsU0FBQUEsZ0JBQVVsQyxDQUFDLEVBQUU7TUFDN0IsT0FBT0EsQ0FBQyxHQUFHLEdBQUcsR0FDYixDQUFFLENBQUMsR0FBR0QsU0FBUyxDQUFFLENBQUMsR0FBRyxDQUFDLEdBQUdDLENBQUMsQ0FBRSxJQUFLLENBQUMsR0FDbEMsQ0FBRSxDQUFDLEdBQUdELFNBQVMsQ0FBRSxDQUFDLEdBQUdDLENBQUMsR0FBRyxDQUFDLENBQUUsSUFBSyxDQUFDO0lBQ3BDO0VBQ0QsQ0FBQyxDQUFDO0FBRUYsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL3RoZW1lcy9ib290c3RyYXAvdmVuZG9yL2pxdWVyeS1lYXNpbmcvanF1ZXJ5X2Vhc2luZy5qcz9hZDRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBqUXVlcnkgRWFzaW5nIHYxLjQuMSAtIGh0dHA6Ly9nc2dkLmNvLnVrL3NhbmRib3gvanF1ZXJ5L2Vhc2luZy9cbiAqIE9wZW4gc291cmNlIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbiAqIENvcHlyaWdodCDCqSAyMDA4IEdlb3JnZSBNY0dpbmxleSBTbWl0aFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vZ2RzbWl0aC9qcXVlcnktZWFzaW5nL21hc3Rlci9MSUNFTlNFXG4qL1xuXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0ZGVmaW5lKFsnanF1ZXJ5J10sIGZ1bmN0aW9uICgkKSB7XG5cdFx0XHRyZXR1cm4gZmFjdG9yeSgkKTtcblx0XHR9KTtcblx0fSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdGV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2pxdWVyeScpKTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KGpRdWVyeSk7XG5cdH1cbn0pKGZ1bmN0aW9uKCQpe1xuXG4vLyBQcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgalF1ZXJ5IFwic3dpbmdcIiBlYXNpbmcgYXMgXCJqc3dpbmdcIlxuJC5lYXNpbmcuanN3aW5nID0gJC5lYXNpbmcuc3dpbmc7XG5cbnZhciBwb3cgPSBNYXRoLnBvdyxcblx0c3FydCA9IE1hdGguc3FydCxcblx0c2luID0gTWF0aC5zaW4sXG5cdGNvcyA9IE1hdGguY29zLFxuXHRQSSA9IE1hdGguUEksXG5cdGMxID0gMS43MDE1OCxcblx0YzIgPSBjMSAqIDEuNTI1LFxuXHRjMyA9IGMxICsgMSxcblx0YzQgPSAoIDIgKiBQSSApIC8gMyxcblx0YzUgPSAoIDIgKiBQSSApIC8gNC41O1xuXG4vLyB4IGlzIHRoZSBmcmFjdGlvbiBvZiBhbmltYXRpb24gcHJvZ3Jlc3MsIGluIHRoZSByYW5nZSAwLi4xXG5mdW5jdGlvbiBib3VuY2VPdXQoeCkge1xuXHR2YXIgbjEgPSA3LjU2MjUsXG5cdFx0ZDEgPSAyLjc1O1xuXHRpZiAoIHggPCAxL2QxICkge1xuXHRcdHJldHVybiBuMSp4Kng7XG5cdH0gZWxzZSBpZiAoIHggPCAyL2QxICkge1xuXHRcdHJldHVybiBuMSooeC09KDEuNS9kMSkpKnggKyAwLjc1O1xuXHR9IGVsc2UgaWYgKCB4IDwgMi41L2QxICkge1xuXHRcdHJldHVybiBuMSooeC09KDIuMjUvZDEpKSp4ICsgMC45Mzc1O1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBuMSooeC09KDIuNjI1L2QxKSkqeCArIDAuOTg0Mzc1O1xuXHR9XG59XG5cbiQuZXh0ZW5kKCAkLmVhc2luZyxcbntcblx0ZGVmOiAnZWFzZU91dFF1YWQnLFxuXHRzd2luZzogZnVuY3Rpb24gKHgpIHtcblx0XHRyZXR1cm4gJC5lYXNpbmdbJC5lYXNpbmcuZGVmXSh4KTtcblx0fSxcblx0ZWFzZUluUXVhZDogZnVuY3Rpb24gKHgpIHtcblx0XHRyZXR1cm4geCAqIHg7XG5cdH0sXG5cdGVhc2VPdXRRdWFkOiBmdW5jdGlvbiAoeCkge1xuXHRcdHJldHVybiAxIC0gKCAxIC0geCApICogKCAxIC0geCApO1xuXHR9LFxuXHRlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbiAoeCkge1xuXHRcdHJldHVybiB4IDwgMC41ID9cblx0XHRcdDIgKiB4ICogeCA6XG5cdFx0XHQxIC0gcG93KCAtMiAqIHggKyAyLCAyICkgLyAyO1xuXHR9LFxuXHRlYXNlSW5DdWJpYzogZnVuY3Rpb24gKHgpIHtcblx0XHRyZXR1cm4geCAqIHggKiB4O1xuXHR9LFxuXHRlYXNlT3V0Q3ViaWM6IGZ1bmN0aW9uICh4KSB7XG5cdFx0cmV0dXJuIDEgLSBwb3coIDEgLSB4LCAzICk7XG5cdH0sXG5cdGVhc2VJbk91dEN1YmljOiBmdW5jdGlvbiAoeCkge1xuXHRcdHJldHVybiB4IDwgMC41ID9cblx0XHRcdDQgKiB4ICogeCAqIHggOlxuXHRcdFx0MSAtIHBvdyggLTIgKiB4ICsgMiwgMyApIC8gMjtcblx0fSxcblx0ZWFzZUluUXVhcnQ6IGZ1bmN0aW9uICh4KSB7XG5cdFx0cmV0dXJuIHggKiB4ICogeCAqIHg7XG5cdH0sXG5cdGVhc2VPdXRRdWFydDogZnVuY3Rpb24gKHgpIHtcblx0XHRyZXR1cm4gMSAtIHBvdyggMSAtIHgsIDQgKTtcblx0fSxcblx0ZWFzZUluT3V0UXVhcnQ6IGZ1bmN0aW9uICh4KSB7XG5cdFx0cmV0dXJuIHggPCAwLjUgP1xuXHRcdFx0OCAqIHggKiB4ICogeCAqIHggOlxuXHRcdFx0MSAtIHBvdyggLTIgKiB4ICsgMiwgNCApIC8gMjtcblx0fSxcblx0ZWFzZUluUXVpbnQ6IGZ1bmN0aW9uICh4KSB7XG5cdFx0cmV0dXJuIHggKiB4ICogeCAqIHggKiB4O1xuXHR9LFxuXHRlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uICh4KSB7XG5cdFx0cmV0dXJuIDEgLSBwb3coIDEgLSB4LCA1ICk7XG5cdH0sXG5cdGVhc2VJbk91dFF1aW50OiBmdW5jdGlvbiAoeCkge1xuXHRcdHJldHVybiB4IDwgMC41ID9cblx0XHRcdDE2ICogeCAqIHggKiB4ICogeCAqIHggOlxuXHRcdFx0MSAtIHBvdyggLTIgKiB4ICsgMiwgNSApIC8gMjtcblx0fSxcblx0ZWFzZUluU2luZTogZnVuY3Rpb24gKHgpIHtcblx0XHRyZXR1cm4gMSAtIGNvcyggeCAqIFBJLzIgKTtcblx0fSxcblx0ZWFzZU91dFNpbmU6IGZ1bmN0aW9uICh4KSB7XG5cdFx0cmV0dXJuIHNpbiggeCAqIFBJLzIgKTtcblx0fSxcblx0ZWFzZUluT3V0U2luZTogZnVuY3Rpb24gKHgpIHtcblx0XHRyZXR1cm4gLSggY29zKCBQSSAqIHggKSAtIDEgKSAvIDI7XG5cdH0sXG5cdGVhc2VJbkV4cG86IGZ1bmN0aW9uICh4KSB7XG5cdFx0cmV0dXJuIHggPT09IDAgPyAwIDogcG93KCAyLCAxMCAqIHggLSAxMCApO1xuXHR9LFxuXHRlYXNlT3V0RXhwbzogZnVuY3Rpb24gKHgpIHtcblx0XHRyZXR1cm4geCA9PT0gMSA/IDEgOiAxIC0gcG93KCAyLCAtMTAgKiB4ICk7XG5cdH0sXG5cdGVhc2VJbk91dEV4cG86IGZ1bmN0aW9uICh4KSB7XG5cdFx0cmV0dXJuIHggPT09IDAgPyAwIDogeCA9PT0gMSA/IDEgOiB4IDwgMC41ID9cblx0XHRcdHBvdyggMiwgMjAgKiB4IC0gMTAgKSAvIDIgOlxuXHRcdFx0KCAyIC0gcG93KCAyLCAtMjAgKiB4ICsgMTAgKSApIC8gMjtcblx0fSxcblx0ZWFzZUluQ2lyYzogZnVuY3Rpb24gKHgpIHtcblx0XHRyZXR1cm4gMSAtIHNxcnQoIDEgLSBwb3coIHgsIDIgKSApO1xuXHR9LFxuXHRlYXNlT3V0Q2lyYzogZnVuY3Rpb24gKHgpIHtcblx0XHRyZXR1cm4gc3FydCggMSAtIHBvdyggeCAtIDEsIDIgKSApO1xuXHR9LFxuXHRlYXNlSW5PdXRDaXJjOiBmdW5jdGlvbiAoeCkge1xuXHRcdHJldHVybiB4IDwgMC41ID9cblx0XHRcdCggMSAtIHNxcnQoIDEgLSBwb3coIDIgKiB4LCAyICkgKSApIC8gMiA6XG5cdFx0XHQoIHNxcnQoIDEgLSBwb3coIC0yICogeCArIDIsIDIgKSApICsgMSApIC8gMjtcblx0fSxcblx0ZWFzZUluRWxhc3RpYzogZnVuY3Rpb24gKHgpIHtcblx0XHRyZXR1cm4geCA9PT0gMCA/IDAgOiB4ID09PSAxID8gMSA6XG5cdFx0XHQtcG93KCAyLCAxMCAqIHggLSAxMCApICogc2luKCAoIHggKiAxMCAtIDEwLjc1ICkgKiBjNCApO1xuXHR9LFxuXHRlYXNlT3V0RWxhc3RpYzogZnVuY3Rpb24gKHgpIHtcblx0XHRyZXR1cm4geCA9PT0gMCA/IDAgOiB4ID09PSAxID8gMSA6XG5cdFx0XHRwb3coIDIsIC0xMCAqIHggKSAqIHNpbiggKCB4ICogMTAgLSAwLjc1ICkgKiBjNCApICsgMTtcblx0fSxcblx0ZWFzZUluT3V0RWxhc3RpYzogZnVuY3Rpb24gKHgpIHtcblx0XHRyZXR1cm4geCA9PT0gMCA/IDAgOiB4ID09PSAxID8gMSA6IHggPCAwLjUgP1xuXHRcdFx0LSggcG93KCAyLCAyMCAqIHggLSAxMCApICogc2luKCAoIDIwICogeCAtIDExLjEyNSApICogYzUgKSkgLyAyIDpcblx0XHRcdHBvdyggMiwgLTIwICogeCArIDEwICkgKiBzaW4oICggMjAgKiB4IC0gMTEuMTI1ICkgKiBjNSApIC8gMiArIDE7XG5cdH0sXG5cdGVhc2VJbkJhY2s6IGZ1bmN0aW9uICh4KSB7XG5cdFx0cmV0dXJuIGMzICogeCAqIHggKiB4IC0gYzEgKiB4ICogeDtcblx0fSxcblx0ZWFzZU91dEJhY2s6IGZ1bmN0aW9uICh4KSB7XG5cdFx0cmV0dXJuIDEgKyBjMyAqIHBvdyggeCAtIDEsIDMgKSArIGMxICogcG93KCB4IC0gMSwgMiApO1xuXHR9LFxuXHRlYXNlSW5PdXRCYWNrOiBmdW5jdGlvbiAoeCkge1xuXHRcdHJldHVybiB4IDwgMC41ID9cblx0XHRcdCggcG93KCAyICogeCwgMiApICogKCAoIGMyICsgMSApICogMiAqIHggLSBjMiApICkgLyAyIDpcblx0XHRcdCggcG93KCAyICogeCAtIDIsIDIgKSAqKCAoIGMyICsgMSApICogKCB4ICogMiAtIDIgKSArIGMyICkgKyAyICkgLyAyO1xuXHR9LFxuXHRlYXNlSW5Cb3VuY2U6IGZ1bmN0aW9uICh4KSB7XG5cdFx0cmV0dXJuIDEgLSBib3VuY2VPdXQoIDEgLSB4ICk7XG5cdH0sXG5cdGVhc2VPdXRCb3VuY2U6IGJvdW5jZU91dCxcblx0ZWFzZUluT3V0Qm91bmNlOiBmdW5jdGlvbiAoeCkge1xuXHRcdHJldHVybiB4IDwgMC41ID9cblx0XHRcdCggMSAtIGJvdW5jZU91dCggMSAtIDIgKiB4ICkgKSAvIDIgOlxuXHRcdFx0KCAxICsgYm91bmNlT3V0KCAyICogeCAtIDEgKSApIC8gMjtcblx0fVxufSk7XG5cbn0pO1xuIl0sIm5hbWVzIjpbImZhY3RvcnkiLCJkZWZpbmUiLCJhbWQiLCIkIiwibW9kdWxlIiwiX3R5cGVvZiIsImV4cG9ydHMiLCJyZXF1aXJlIiwialF1ZXJ5IiwiZWFzaW5nIiwianN3aW5nIiwic3dpbmciLCJwb3ciLCJNYXRoIiwic3FydCIsInNpbiIsImNvcyIsIlBJIiwiYzEiLCJjMiIsImMzIiwiYzQiLCJjNSIsImJvdW5jZU91dCIsIngiLCJuMSIsImQxIiwiZXh0ZW5kIiwiZGVmIiwiZWFzZUluUXVhZCIsImVhc2VPdXRRdWFkIiwiZWFzZUluT3V0UXVhZCIsImVhc2VJbkN1YmljIiwiZWFzZU91dEN1YmljIiwiZWFzZUluT3V0Q3ViaWMiLCJlYXNlSW5RdWFydCIsImVhc2VPdXRRdWFydCIsImVhc2VJbk91dFF1YXJ0IiwiZWFzZUluUXVpbnQiLCJlYXNlT3V0UXVpbnQiLCJlYXNlSW5PdXRRdWludCIsImVhc2VJblNpbmUiLCJlYXNlT3V0U2luZSIsImVhc2VJbk91dFNpbmUiLCJlYXNlSW5FeHBvIiwiZWFzZU91dEV4cG8iLCJlYXNlSW5PdXRFeHBvIiwiZWFzZUluQ2lyYyIsImVhc2VPdXRDaXJjIiwiZWFzZUluT3V0Q2lyYyIsImVhc2VJbkVsYXN0aWMiLCJlYXNlT3V0RWxhc3RpYyIsImVhc2VJbk91dEVsYXN0aWMiLCJlYXNlSW5CYWNrIiwiZWFzZU91dEJhY2siLCJlYXNlSW5PdXRCYWNrIiwiZWFzZUluQm91bmNlIiwiZWFzZU91dEJvdW5jZSIsImVhc2VJbk91dEJvdW5jZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/themes/bootstrap/vendor/jquery-easing/jquery_easing.js\n");

/***/ }),

/***/ "./resources/themes/bootstrap/vendor/jquery/jquery.js":
/*!************************************************************!*\
  !*** ./resources/themes/bootstrap/vendor/jquery/jquery.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*!\n * jQuery JavaScript Library v3.6.0\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2021-03-02T17:08Z\n */\n(function (global, factory) {\n  \"use strict\";\n\n  if (( false ? 0 : _typeof(module)) === \"object\" && _typeof(module.exports) === \"object\") {\n    // For CommonJS and CommonJS-like environments where a proper `window`\n    // is present, execute the factory and get jQuery.\n    // For environments that do not have a `window` with a `document`\n    // (such as Node.js), expose a factory as module.exports.\n    // This accentuates the need for the creation of a real `window`.\n    // e.g. var jQuery = require(\"jquery\")(window);\n    // See ticket #14549 for more info.\n    module.exports = global.document ? factory(global, true) : function (w) {\n      if (!w.document) {\n        throw new Error(\"jQuery requires a window with a document\");\n      }\n      return factory(w);\n    };\n  } else {\n    factory(global);\n  }\n\n  // Pass this if window is not defined yet\n})(typeof window !== \"undefined\" ? window : this, function (window, noGlobal) {\n  // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n  // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n  // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n  // enough that all such attempts are guarded in a try block.\n  \"use strict\";\n\n  var arr = [];\n  var getProto = Object.getPrototypeOf;\n  var _slice = arr.slice;\n  var flat = arr.flat ? function (array) {\n    return arr.flat.call(array);\n  } : function (array) {\n    return arr.concat.apply([], array);\n  };\n  var push = arr.push;\n  var indexOf = arr.indexOf;\n  var class2type = {};\n  var toString = class2type.toString;\n  var hasOwn = class2type.hasOwnProperty;\n  var fnToString = hasOwn.toString;\n  var ObjectFunctionString = fnToString.call(Object);\n  var support = {};\n  var isFunction = function isFunction(obj) {\n    // Support: Chrome <=57, Firefox <=52\n    // In some browsers, typeof returns \"function\" for HTML <object> elements\n    // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n    // We don't want to classify *any* DOM node as a function.\n    // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5\n    // Plus for old WebKit, typeof returns \"function\" for HTML collections\n    // (e.g., `typeof document.getElementsByTagName(\"div\") === \"function\"`). (gh-4756)\n    return typeof obj === \"function\" && typeof obj.nodeType !== \"number\" && typeof obj.item !== \"function\";\n  };\n  var isWindow = function isWindow(obj) {\n    return obj != null && obj === obj.window;\n  };\n  var document = window.document;\n  var preservedScriptAttributes = {\n    type: true,\n    src: true,\n    nonce: true,\n    noModule: true\n  };\n  function DOMEval(code, node, doc) {\n    doc = doc || document;\n    var i,\n      val,\n      script = doc.createElement(\"script\");\n    script.text = code;\n    if (node) {\n      for (i in preservedScriptAttributes) {\n        // Support: Firefox 64+, Edge 18+\n        // Some browsers don't support the \"nonce\" property on scripts.\n        // On the other hand, just using `getAttribute` is not enough as\n        // the `nonce` attribute is reset to an empty string whenever it\n        // becomes browsing-context connected.\n        // See https://github.com/whatwg/html/issues/2369\n        // See https://html.spec.whatwg.org/#nonce-attributes\n        // The `node.getAttribute` check was added for the sake of\n        // `jQuery.globalEval` so that it can fake a nonce-containing node\n        // via an object.\n        val = node[i] || node.getAttribute && node.getAttribute(i);\n        if (val) {\n          script.setAttribute(i, val);\n        }\n      }\n    }\n    doc.head.appendChild(script).parentNode.removeChild(script);\n  }\n  function toType(obj) {\n    if (obj == null) {\n      return obj + \"\";\n    }\n\n    // Support: Android <=2.3 only (functionish RegExp)\n    return _typeof(obj) === \"object\" || typeof obj === \"function\" ? class2type[toString.call(obj)] || \"object\" : _typeof(obj);\n  }\n  /* global Symbol */\n  // Defining this global in .eslintrc.json would create a danger of using the global\n  // unguarded in another place, it seems safer to define global only for this module\n\n  var version = \"3.6.0\",\n    // Define a local copy of jQuery\n    jQuery = function jQuery(selector, context) {\n      // The jQuery object is actually just the init constructor 'enhanced'\n      // Need init if jQuery is called (just allow error to be thrown if not included)\n      return new jQuery.fn.init(selector, context);\n    };\n  jQuery.fn = jQuery.prototype = {\n    // The current version of jQuery being used\n    jquery: version,\n    constructor: jQuery,\n    // The default length of a jQuery object is 0\n    length: 0,\n    toArray: function toArray() {\n      return _slice.call(this);\n    },\n    // Get the Nth element in the matched element set OR\n    // Get the whole matched element set as a clean array\n    get: function get(num) {\n      // Return all the elements in a clean array\n      if (num == null) {\n        return _slice.call(this);\n      }\n\n      // Return just the one element from the set\n      return num < 0 ? this[num + this.length] : this[num];\n    },\n    // Take an array of elements and push it onto the stack\n    // (returning the new matched element set)\n    pushStack: function pushStack(elems) {\n      // Build a new jQuery matched element set\n      var ret = jQuery.merge(this.constructor(), elems);\n\n      // Add the old object onto the stack (as a reference)\n      ret.prevObject = this;\n\n      // Return the newly-formed element set\n      return ret;\n    },\n    // Execute a callback for every element in the matched set.\n    each: function each(callback) {\n      return jQuery.each(this, callback);\n    },\n    map: function map(callback) {\n      return this.pushStack(jQuery.map(this, function (elem, i) {\n        return callback.call(elem, i, elem);\n      }));\n    },\n    slice: function slice() {\n      return this.pushStack(_slice.apply(this, arguments));\n    },\n    first: function first() {\n      return this.eq(0);\n    },\n    last: function last() {\n      return this.eq(-1);\n    },\n    even: function even() {\n      return this.pushStack(jQuery.grep(this, function (_elem, i) {\n        return (i + 1) % 2;\n      }));\n    },\n    odd: function odd() {\n      return this.pushStack(jQuery.grep(this, function (_elem, i) {\n        return i % 2;\n      }));\n    },\n    eq: function eq(i) {\n      var len = this.length,\n        j = +i + (i < 0 ? len : 0);\n      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);\n    },\n    end: function end() {\n      return this.prevObject || this.constructor();\n    },\n    // For internal use only.\n    // Behaves like an Array's method, not like a jQuery method.\n    push: push,\n    sort: arr.sort,\n    splice: arr.splice\n  };\n  jQuery.extend = jQuery.fn.extend = function () {\n    var options,\n      name,\n      src,\n      copy,\n      copyIsArray,\n      clone,\n      target = arguments[0] || {},\n      i = 1,\n      length = arguments.length,\n      deep = false;\n\n    // Handle a deep copy situation\n    if (typeof target === \"boolean\") {\n      deep = target;\n\n      // Skip the boolean and the target\n      target = arguments[i] || {};\n      i++;\n    }\n\n    // Handle case when target is a string or something (possible in deep copy)\n    if (_typeof(target) !== \"object\" && !isFunction(target)) {\n      target = {};\n    }\n\n    // Extend jQuery itself if only one argument is passed\n    if (i === length) {\n      target = this;\n      i--;\n    }\n    for (; i < length; i++) {\n      // Only deal with non-null/undefined values\n      if ((options = arguments[i]) != null) {\n        // Extend the base object\n        for (name in options) {\n          copy = options[name];\n\n          // Prevent Object.prototype pollution\n          // Prevent never-ending loop\n          if (name === \"__proto__\" || target === copy) {\n            continue;\n          }\n\n          // Recurse if we're merging plain objects or arrays\n          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {\n            src = target[name];\n\n            // Ensure proper type for the source value\n            if (copyIsArray && !Array.isArray(src)) {\n              clone = [];\n            } else if (!copyIsArray && !jQuery.isPlainObject(src)) {\n              clone = {};\n            } else {\n              clone = src;\n            }\n            copyIsArray = false;\n\n            // Never move original objects, clone them\n            target[name] = jQuery.extend(deep, clone, copy);\n\n            // Don't bring in undefined values\n          } else if (copy !== undefined) {\n            target[name] = copy;\n          }\n        }\n      }\n    }\n\n    // Return the modified object\n    return target;\n  };\n  jQuery.extend({\n    // Unique for each copy of jQuery on the page\n    expando: \"jQuery\" + (version + Math.random()).replace(/\\D/g, \"\"),\n    // Assume jQuery is ready without the ready module\n    isReady: true,\n    error: function error(msg) {\n      throw new Error(msg);\n    },\n    noop: function noop() {},\n    isPlainObject: function isPlainObject(obj) {\n      var proto, Ctor;\n\n      // Detect obvious negatives\n      // Use toString instead of jQuery.type to catch host objects\n      if (!obj || toString.call(obj) !== \"[object Object]\") {\n        return false;\n      }\n      proto = getProto(obj);\n\n      // Objects with no prototype (e.g., `Object.create( null )`) are plain\n      if (!proto) {\n        return true;\n      }\n\n      // Objects with prototype are plain iff they were constructed by a global Object function\n      Ctor = hasOwn.call(proto, \"constructor\") && proto.constructor;\n      return typeof Ctor === \"function\" && fnToString.call(Ctor) === ObjectFunctionString;\n    },\n    isEmptyObject: function isEmptyObject(obj) {\n      var name;\n      for (name in obj) {\n        return false;\n      }\n      return true;\n    },\n    // Evaluates a script in a provided context; falls back to the global one\n    // if not specified.\n    globalEval: function globalEval(code, options, doc) {\n      DOMEval(code, {\n        nonce: options && options.nonce\n      }, doc);\n    },\n    each: function each(obj, callback) {\n      var length,\n        i = 0;\n      if (isArrayLike(obj)) {\n        length = obj.length;\n        for (; i < length; i++) {\n          if (callback.call(obj[i], i, obj[i]) === false) {\n            break;\n          }\n        }\n      } else {\n        for (i in obj) {\n          if (callback.call(obj[i], i, obj[i]) === false) {\n            break;\n          }\n        }\n      }\n      return obj;\n    },\n    // results is for internal usage only\n    makeArray: function makeArray(arr, results) {\n      var ret = results || [];\n      if (arr != null) {\n        if (isArrayLike(Object(arr))) {\n          jQuery.merge(ret, typeof arr === \"string\" ? [arr] : arr);\n        } else {\n          push.call(ret, arr);\n        }\n      }\n      return ret;\n    },\n    inArray: function inArray(elem, arr, i) {\n      return arr == null ? -1 : indexOf.call(arr, elem, i);\n    },\n    // Support: Android <=4.0 only, PhantomJS 1 only\n    // push.apply(_, arraylike) throws on ancient WebKit\n    merge: function merge(first, second) {\n      var len = +second.length,\n        j = 0,\n        i = first.length;\n      for (; j < len; j++) {\n        first[i++] = second[j];\n      }\n      first.length = i;\n      return first;\n    },\n    grep: function grep(elems, callback, invert) {\n      var callbackInverse,\n        matches = [],\n        i = 0,\n        length = elems.length,\n        callbackExpect = !invert;\n\n      // Go through the array, only saving the items\n      // that pass the validator function\n      for (; i < length; i++) {\n        callbackInverse = !callback(elems[i], i);\n        if (callbackInverse !== callbackExpect) {\n          matches.push(elems[i]);\n        }\n      }\n      return matches;\n    },\n    // arg is for internal usage only\n    map: function map(elems, callback, arg) {\n      var length,\n        value,\n        i = 0,\n        ret = [];\n\n      // Go through the array, translating each of the items to their new values\n      if (isArrayLike(elems)) {\n        length = elems.length;\n        for (; i < length; i++) {\n          value = callback(elems[i], i, arg);\n          if (value != null) {\n            ret.push(value);\n          }\n        }\n\n        // Go through every key on the object,\n      } else {\n        for (i in elems) {\n          value = callback(elems[i], i, arg);\n          if (value != null) {\n            ret.push(value);\n          }\n        }\n      }\n\n      // Flatten any nested arrays\n      return flat(ret);\n    },\n    // A global GUID counter for objects\n    guid: 1,\n    // jQuery.support is not used in Core but other projects attach their\n    // properties to it so it needs to exist.\n    support: support\n  });\n  if (typeof Symbol === \"function\") {\n    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];\n  }\n\n  // Populate the class2type map\n  jQuery.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"), function (_i, name) {\n    class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n  });\n  function isArrayLike(obj) {\n    // Support: real iOS 8.2 only (not reproducible in simulator)\n    // `in` check used to prevent JIT error (gh-2145)\n    // hasOwn isn't used here due to false negatives\n    // regarding Nodelist length in IE\n    var length = !!obj && \"length\" in obj && obj.length,\n      type = toType(obj);\n    if (isFunction(obj) || isWindow(obj)) {\n      return false;\n    }\n    return type === \"array\" || length === 0 || typeof length === \"number\" && length > 0 && length - 1 in obj;\n  }\n  var Sizzle =\n  /*!\n   * Sizzle CSS Selector Engine v2.3.6\n   * https://sizzlejs.com/\n   *\n   * Copyright JS Foundation and other contributors\n   * Released under the MIT license\n   * https://js.foundation/\n   *\n   * Date: 2021-02-16\n   */\n  function (window) {\n    var i,\n      support,\n      Expr,\n      getText,\n      isXML,\n      tokenize,\n      compile,\n      select,\n      outermostContext,\n      sortInput,\n      hasDuplicate,\n      // Local document vars\n      setDocument,\n      document,\n      docElem,\n      documentIsHTML,\n      rbuggyQSA,\n      rbuggyMatches,\n      matches,\n      contains,\n      // Instance-specific data\n      expando = \"sizzle\" + 1 * new Date(),\n      preferredDoc = window.document,\n      dirruns = 0,\n      done = 0,\n      classCache = createCache(),\n      tokenCache = createCache(),\n      compilerCache = createCache(),\n      nonnativeSelectorCache = createCache(),\n      sortOrder = function sortOrder(a, b) {\n        if (a === b) {\n          hasDuplicate = true;\n        }\n        return 0;\n      },\n      // Instance methods\n      hasOwn = {}.hasOwnProperty,\n      arr = [],\n      pop = arr.pop,\n      pushNative = arr.push,\n      push = arr.push,\n      slice = arr.slice,\n      // Use a stripped-down indexOf as it's faster than native\n      // https://jsperf.com/thor-indexof-vs-for/5\n      indexOf = function indexOf(list, elem) {\n        var i = 0,\n          len = list.length;\n        for (; i < len; i++) {\n          if (list[i] === elem) {\n            return i;\n          }\n        }\n        return -1;\n      },\n      booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|\" + \"ismap|loop|multiple|open|readonly|required|scoped\",\n      // Regular expressions\n\n      // http://www.w3.org/TR/css3-selectors/#whitespace\n      whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n      // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram\n      identifier = \"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",\n      // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n      attributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n      // Operator (capture 2)\n      \"*([*^$|!~]?=)\" + whitespace +\n      // \"Attribute values must be CSS identifiers [capture 5]\n      // or strings [capture 3 or capture 4]\"\n      \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace + \"*\\\\]\",\n      pseudos = \":(\" + identifier + \")(?:\\\\((\" +\n      // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n      // 1. quoted (capture 3; capture 4 or capture 5)\n      \"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n      // 2. simple (capture 6)\n      \"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n      // 3. anything else (capture 2)\n      \".*\" + \")\\\\)|)\",\n      // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n      rwhitespace = new RegExp(whitespace + \"+\", \"g\"),\n      rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"),\n      rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\n      rcombinators = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"),\n      rdescend = new RegExp(whitespace + \"|>\"),\n      rpseudo = new RegExp(pseudos),\n      ridentifier = new RegExp(\"^\" + identifier + \"$\"),\n      matchExpr = {\n        \"ID\": new RegExp(\"^#(\" + identifier + \")\"),\n        \"CLASS\": new RegExp(\"^\\\\.(\" + identifier + \")\"),\n        \"TAG\": new RegExp(\"^(\" + identifier + \"|[*])\"),\n        \"ATTR\": new RegExp(\"^\" + attributes),\n        \"PSEUDO\": new RegExp(\"^\" + pseudos),\n        \"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n        \"bool\": new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n        // For use in libraries implementing .is()\n        // We use this for POS matching in `select`\n        \"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n      },\n      rhtml = /HTML$/i,\n      rinputs = /^(?:input|select|textarea|button)$/i,\n      rheader = /^h\\d$/i,\n      rnative = /^[^{]+\\{\\s*\\[native \\w/,\n      // Easily-parseable/retrievable ID or TAG or CLASS selectors\n      rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n      rsibling = /[+~]/,\n      // CSS escapes\n      // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n      runescape = new RegExp(\"\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\", \"g\"),\n      funescape = function funescape(escape, nonHex) {\n        var high = \"0x\" + escape.slice(1) - 0x10000;\n        return nonHex ?\n        // Strip the backslash prefix from a non-hex escape sequence\n        nonHex :\n        // Replace a hexadecimal escape sequence with the encoded Unicode code point\n        // Support: IE <=11+\n        // For values outside the Basic Multilingual Plane (BMP), manually construct a\n        // surrogate pair\n        high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n      },\n      // CSS string/identifier serialization\n      // https://drafts.csswg.org/cssom/#common-serializing-idioms\n      rcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n      fcssescape = function fcssescape(ch, asCodePoint) {\n        if (asCodePoint) {\n          // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n          if (ch === \"\\0\") {\n            return \"\\uFFFD\";\n          }\n\n          // Control characters and (dependent upon position) numbers get escaped as code points\n          return ch.slice(0, -1) + \"\\\\\" + ch.charCodeAt(ch.length - 1).toString(16) + \" \";\n        }\n\n        // Other potentially-special ASCII characters get backslash-escaped\n        return \"\\\\\" + ch;\n      },\n      // Used for iframes\n      // See setDocument()\n      // Removing the function wrapper causes a \"Permission Denied\"\n      // error in IE\n      unloadHandler = function unloadHandler() {\n        setDocument();\n      },\n      inDisabledFieldset = addCombinator(function (elem) {\n        return elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n      }, {\n        dir: \"parentNode\",\n        next: \"legend\"\n      });\n\n    // Optimize for push.apply( _, NodeList )\n    try {\n      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);\n\n      // Support: Android<4.0\n      // Detect silently failing push.apply\n      // eslint-disable-next-line no-unused-expressions\n      arr[preferredDoc.childNodes.length].nodeType;\n    } catch (e) {\n      push = {\n        apply: arr.length ?\n        // Leverage slice if possible\n        function (target, els) {\n          pushNative.apply(target, slice.call(els));\n        } :\n        // Support: IE<9\n        // Otherwise append directly\n        function (target, els) {\n          var j = target.length,\n            i = 0;\n\n          // Can't trust NodeList.length\n          while (target[j++] = els[i++]) {}\n          target.length = j - 1;\n        }\n      };\n    }\n    function Sizzle(selector, context, results, seed) {\n      var m,\n        i,\n        elem,\n        nid,\n        match,\n        groups,\n        newSelector,\n        newContext = context && context.ownerDocument,\n        // nodeType defaults to 9, since context defaults to document\n        nodeType = context ? context.nodeType : 9;\n      results = results || [];\n\n      // Return early from calls with invalid selector or context\n      if (typeof selector !== \"string\" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n        return results;\n      }\n\n      // Try to shortcut find operations (as opposed to filters) in HTML documents\n      if (!seed) {\n        setDocument(context);\n        context = context || document;\n        if (documentIsHTML) {\n          // If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n          // (excepting DocumentFragment context, where the methods don't exist)\n          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n            // ID selector\n            if (m = match[1]) {\n              // Document context\n              if (nodeType === 9) {\n                if (elem = context.getElementById(m)) {\n                  // Support: IE, Opera, Webkit\n                  // TODO: identify versions\n                  // getElementById can match elements by name instead of ID\n                  if (elem.id === m) {\n                    results.push(elem);\n                    return results;\n                  }\n                } else {\n                  return results;\n                }\n\n                // Element context\n              } else {\n                // Support: IE, Opera, Webkit\n                // TODO: identify versions\n                // getElementById can match elements by name instead of ID\n                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {\n                  results.push(elem);\n                  return results;\n                }\n              }\n\n              // Type selector\n            } else if (match[2]) {\n              push.apply(results, context.getElementsByTagName(selector));\n              return results;\n\n              // Class selector\n            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {\n              push.apply(results, context.getElementsByClassName(m));\n              return results;\n            }\n          }\n\n          // Take advantage of querySelectorAll\n          if (support.qsa && !nonnativeSelectorCache[selector + \" \"] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && (\n          // Support: IE 8 only\n          // Exclude object elements\n          nodeType !== 1 || context.nodeName.toLowerCase() !== \"object\")) {\n            newSelector = selector;\n            newContext = context;\n\n            // qSA considers elements outside a scoping root when evaluating child or\n            // descendant combinators, which is not what we want.\n            // In such cases, we work around the behavior by prefixing every selector in the\n            // list with an ID selector referencing the scope context.\n            // The technique has to be used as well when a leading combinator is used\n            // as such selectors are not recognized by querySelectorAll.\n            // Thanks to Andrew Dupont for this technique.\n            if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {\n              // Expand context for sibling selectors\n              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;\n\n              // We can use :scope instead of the ID hack if the browser\n              // supports it & if we're not changing the context.\n              if (newContext !== context || !support.scope) {\n                // Capture the context ID, setting it first if necessary\n                if (nid = context.getAttribute(\"id\")) {\n                  nid = nid.replace(rcssescape, fcssescape);\n                } else {\n                  context.setAttribute(\"id\", nid = expando);\n                }\n              }\n\n              // Prefix every selector in the list\n              groups = tokenize(selector);\n              i = groups.length;\n              while (i--) {\n                groups[i] = (nid ? \"#\" + nid : \":scope\") + \" \" + toSelector(groups[i]);\n              }\n              newSelector = groups.join(\",\");\n            }\n            try {\n              push.apply(results, newContext.querySelectorAll(newSelector));\n              return results;\n            } catch (qsaError) {\n              nonnativeSelectorCache(selector, true);\n            } finally {\n              if (nid === expando) {\n                context.removeAttribute(\"id\");\n              }\n            }\n          }\n        }\n      }\n\n      // All others\n      return select(selector.replace(rtrim, \"$1\"), context, results, seed);\n    }\n\n    /**\n     * Create key-value caches of limited size\n     * @returns {function(string, object)} Returns the Object data after storing it on itself with\n     *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n     *\tdeleting the oldest entry\n     */\n    function createCache() {\n      var keys = [];\n      function cache(key, value) {\n        // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n        if (keys.push(key + \" \") > Expr.cacheLength) {\n          // Only keep the most recent entries\n          delete cache[keys.shift()];\n        }\n        return cache[key + \" \"] = value;\n      }\n      return cache;\n    }\n\n    /**\n     * Mark a function for special use by Sizzle\n     * @param {Function} fn The function to mark\n     */\n    function markFunction(fn) {\n      fn[expando] = true;\n      return fn;\n    }\n\n    /**\n     * Support testing using an element\n     * @param {Function} fn Passed the created element and returns a boolean result\n     */\n    function assert(fn) {\n      var el = document.createElement(\"fieldset\");\n      try {\n        return !!fn(el);\n      } catch (e) {\n        return false;\n      } finally {\n        // Remove from its parent by default\n        if (el.parentNode) {\n          el.parentNode.removeChild(el);\n        }\n\n        // release memory in IE\n        el = null;\n      }\n    }\n\n    /**\n     * Adds the same handler for all of the specified attrs\n     * @param {String} attrs Pipe-separated list of attributes\n     * @param {Function} handler The method that will be applied\n     */\n    function addHandle(attrs, handler) {\n      var arr = attrs.split(\"|\"),\n        i = arr.length;\n      while (i--) {\n        Expr.attrHandle[arr[i]] = handler;\n      }\n    }\n\n    /**\n     * Checks document order of two siblings\n     * @param {Element} a\n     * @param {Element} b\n     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n     */\n    function siblingCheck(a, b) {\n      var cur = b && a,\n        diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;\n\n      // Use IE sourceIndex if available on both nodes\n      if (diff) {\n        return diff;\n      }\n\n      // Check if b follows a\n      if (cur) {\n        while (cur = cur.nextSibling) {\n          if (cur === b) {\n            return -1;\n          }\n        }\n      }\n      return a ? 1 : -1;\n    }\n\n    /**\n     * Returns a function to use in pseudos for input types\n     * @param {String} type\n     */\n    function createInputPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return name === \"input\" && elem.type === type;\n      };\n    }\n\n    /**\n     * Returns a function to use in pseudos for buttons\n     * @param {String} type\n     */\n    function createButtonPseudo(type) {\n      return function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return (name === \"input\" || name === \"button\") && elem.type === type;\n      };\n    }\n\n    /**\n     * Returns a function to use in pseudos for :enabled/:disabled\n     * @param {Boolean} disabled true for :disabled; false for :enabled\n     */\n    function createDisabledPseudo(disabled) {\n      // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n      return function (elem) {\n        // Only certain elements can match :enabled or :disabled\n        // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n        // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n        if (\"form\" in elem) {\n          // Check for inherited disabledness on relevant non-disabled elements:\n          // * listed form-associated elements in a disabled fieldset\n          //   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n          //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n          // * option elements in a disabled optgroup\n          //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n          // All such elements have a \"form\" property.\n          if (elem.parentNode && elem.disabled === false) {\n            // Option elements defer to a parent optgroup if present\n            if (\"label\" in elem) {\n              if (\"label\" in elem.parentNode) {\n                return elem.parentNode.disabled === disabled;\n              } else {\n                return elem.disabled === disabled;\n              }\n            }\n\n            // Support: IE 6 - 11\n            // Use the isDisabled shortcut property to check for disabled fieldset ancestors\n            return elem.isDisabled === disabled ||\n            // Where there is no isDisabled, check manually\n            /* jshint -W018 */\n            elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;\n          }\n          return elem.disabled === disabled;\n\n          // Try to winnow out elements that can't be disabled before trusting the disabled property.\n          // Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n          // even exist on them, let alone have a boolean value.\n        } else if (\"label\" in elem) {\n          return elem.disabled === disabled;\n        }\n\n        // Remaining elements are neither :enabled nor :disabled\n        return false;\n      };\n    }\n\n    /**\n     * Returns a function to use in pseudos for positionals\n     * @param {Function} fn\n     */\n    function createPositionalPseudo(fn) {\n      return markFunction(function (argument) {\n        argument = +argument;\n        return markFunction(function (seed, matches) {\n          var j,\n            matchIndexes = fn([], seed.length, argument),\n            i = matchIndexes.length;\n\n          // Match elements found at the specified indexes\n          while (i--) {\n            if (seed[j = matchIndexes[i]]) {\n              seed[j] = !(matches[j] = seed[j]);\n            }\n          }\n        });\n      });\n    }\n\n    /**\n     * Checks a node for validity as a Sizzle context\n     * @param {Element|Object=} context\n     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n     */\n    function testContext(context) {\n      return context && typeof context.getElementsByTagName !== \"undefined\" && context;\n    }\n\n    // Expose support vars for convenience\n    support = Sizzle.support = {};\n\n    /**\n     * Detects XML nodes\n     * @param {Element|Object} elem An element or a document\n     * @returns {Boolean} True iff elem is a non-HTML XML node\n     */\n    isXML = Sizzle.isXML = function (elem) {\n      var namespace = elem && elem.namespaceURI,\n        docElem = elem && (elem.ownerDocument || elem).documentElement;\n\n      // Support: IE <=8\n      // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes\n      // https://bugs.jquery.com/ticket/4833\n      return !rhtml.test(namespace || docElem && docElem.nodeName || \"HTML\");\n    };\n\n    /**\n     * Sets document-related variables once based on the current document\n     * @param {Element|Object} [doc] An element or document object to use to set the document\n     * @returns {Object} Returns the current document\n     */\n    setDocument = Sizzle.setDocument = function (node) {\n      var hasCompare,\n        subWindow,\n        doc = node ? node.ownerDocument || node : preferredDoc;\n\n      // Return early if doc is invalid or already selected\n      // Support: IE 11+, Edge 17 - 18+\n      // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n      // two documents; shallow comparisons work.\n      // eslint-disable-next-line eqeqeq\n      if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {\n        return document;\n      }\n\n      // Update global variables\n      document = doc;\n      docElem = document.documentElement;\n      documentIsHTML = !isXML(document);\n\n      // Support: IE 9 - 11+, Edge 12 - 18+\n      // Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n      // Support: IE 11+, Edge 17 - 18+\n      // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n      // two documents; shallow comparisons work.\n      // eslint-disable-next-line eqeqeq\n      if (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {\n        // Support: IE 11, Edge\n        if (subWindow.addEventListener) {\n          subWindow.addEventListener(\"unload\", unloadHandler, false);\n\n          // Support: IE 9 - 10 only\n        } else if (subWindow.attachEvent) {\n          subWindow.attachEvent(\"onunload\", unloadHandler);\n        }\n      }\n\n      // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,\n      // Safari 4 - 5 only, Opera <=11.6 - 12.x only\n      // IE/Edge & older browsers don't support the :scope pseudo-class.\n      // Support: Safari 6.0 only\n      // Safari 6.0 supports :scope but it's an alias of :root there.\n      support.scope = assert(function (el) {\n        docElem.appendChild(el).appendChild(document.createElement(\"div\"));\n        return typeof el.querySelectorAll !== \"undefined\" && !el.querySelectorAll(\":scope fieldset div\").length;\n      });\n\n      /* Attributes\n      ---------------------------------------------------------------------- */\n\n      // Support: IE<8\n      // Verify that getAttribute really returns attributes and not properties\n      // (excepting IE8 booleans)\n      support.attributes = assert(function (el) {\n        el.className = \"i\";\n        return !el.getAttribute(\"className\");\n      });\n\n      /* getElement(s)By*\n      ---------------------------------------------------------------------- */\n\n      // Check if getElementsByTagName(\"*\") returns only elements\n      support.getElementsByTagName = assert(function (el) {\n        el.appendChild(document.createComment(\"\"));\n        return !el.getElementsByTagName(\"*\").length;\n      });\n\n      // Support: IE<9\n      support.getElementsByClassName = rnative.test(document.getElementsByClassName);\n\n      // Support: IE<10\n      // Check if getElementById returns elements by name\n      // The broken getElementById methods don't pick up programmatically-set names,\n      // so use a roundabout getElementsByName test\n      support.getById = assert(function (el) {\n        docElem.appendChild(el).id = expando;\n        return !document.getElementsByName || !document.getElementsByName(expando).length;\n      });\n\n      // ID filter and find\n      if (support.getById) {\n        Expr.filter[\"ID\"] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            return elem.getAttribute(\"id\") === attrId;\n          };\n        };\n        Expr.find[\"ID\"] = function (id, context) {\n          if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n            var elem = context.getElementById(id);\n            return elem ? [elem] : [];\n          }\n        };\n      } else {\n        Expr.filter[\"ID\"] = function (id) {\n          var attrId = id.replace(runescape, funescape);\n          return function (elem) {\n            var node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n            return node && node.value === attrId;\n          };\n        };\n\n        // Support: IE 6 - 7 only\n        // getElementById is not reliable as a find shortcut\n        Expr.find[\"ID\"] = function (id, context) {\n          if (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n            var node,\n              i,\n              elems,\n              elem = context.getElementById(id);\n            if (elem) {\n              // Verify the id attribute\n              node = elem.getAttributeNode(\"id\");\n              if (node && node.value === id) {\n                return [elem];\n              }\n\n              // Fall back on getElementsByName\n              elems = context.getElementsByName(id);\n              i = 0;\n              while (elem = elems[i++]) {\n                node = elem.getAttributeNode(\"id\");\n                if (node && node.value === id) {\n                  return [elem];\n                }\n              }\n            }\n            return [];\n          }\n        };\n      }\n\n      // Tag\n      Expr.find[\"TAG\"] = support.getElementsByTagName ? function (tag, context) {\n        if (typeof context.getElementsByTagName !== \"undefined\") {\n          return context.getElementsByTagName(tag);\n\n          // DocumentFragment nodes don't have gEBTN\n        } else if (support.qsa) {\n          return context.querySelectorAll(tag);\n        }\n      } : function (tag, context) {\n        var elem,\n          tmp = [],\n          i = 0,\n          // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n          results = context.getElementsByTagName(tag);\n\n        // Filter out possible comments\n        if (tag === \"*\") {\n          while (elem = results[i++]) {\n            if (elem.nodeType === 1) {\n              tmp.push(elem);\n            }\n          }\n          return tmp;\n        }\n        return results;\n      };\n\n      // Class\n      Expr.find[\"CLASS\"] = support.getElementsByClassName && function (className, context) {\n        if (typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML) {\n          return context.getElementsByClassName(className);\n        }\n      };\n\n      /* QSA/matchesSelector\n      ---------------------------------------------------------------------- */\n\n      // QSA and matchesSelector support\n\n      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n      rbuggyMatches = [];\n\n      // qSa(:focus) reports false when true (Chrome 21)\n      // We allow this because of a bug in IE8/9 that throws an error\n      // whenever `document.activeElement` is accessed on an iframe\n      // So, we allow :focus to pass through QSA all the time to avoid the IE error\n      // See https://bugs.jquery.com/ticket/13378\n      rbuggyQSA = [];\n      if (support.qsa = rnative.test(document.querySelectorAll)) {\n        // Build QSA regex\n        // Regex strategy adopted from Diego Perini\n        assert(function (el) {\n          var input;\n\n          // Select is set to empty string on purpose\n          // This is to test IE's treatment of not explicitly\n          // setting a boolean content attribute,\n          // since its presence should be enough\n          // https://bugs.jquery.com/ticket/12359\n          docElem.appendChild(el).innerHTML = \"<a id='\" + expando + \"'></a>\" + \"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" + \"<option selected=''></option></select>\";\n\n          // Support: IE8, Opera 11-12.16\n          // Nothing should be selected when empty strings follow ^= or $= or *=\n          // The test attribute must be unknown in Opera but \"safe\" for WinRT\n          // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n          if (el.querySelectorAll(\"[msallowcapture^='']\").length) {\n            rbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\");\n          }\n\n          // Support: IE8\n          // Boolean attributes and \"value\" are not treated correctly\n          if (!el.querySelectorAll(\"[selected]\").length) {\n            rbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\n          }\n\n          // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n          if (!el.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\n            rbuggyQSA.push(\"~=\");\n          }\n\n          // Support: IE 11+, Edge 15 - 18+\n          // IE 11/Edge don't find elements on a `[name='']` query in some cases.\n          // Adding a temporary attribute to the document before the selection works\n          // around the issue.\n          // Interestingly, IE 10 & older don't seem to have the issue.\n          input = document.createElement(\"input\");\n          input.setAttribute(\"name\", \"\");\n          el.appendChild(input);\n          if (!el.querySelectorAll(\"[name='']\").length) {\n            rbuggyQSA.push(\"\\\\[\" + whitespace + \"*name\" + whitespace + \"*=\" + whitespace + \"*(?:''|\\\"\\\")\");\n          }\n\n          // Webkit/Opera - :checked should return selected option elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          // IE8 throws error here and will not see later tests\n          if (!el.querySelectorAll(\":checked\").length) {\n            rbuggyQSA.push(\":checked\");\n          }\n\n          // Support: Safari 8+, iOS 8+\n          // https://bugs.webkit.org/show_bug.cgi?id=136851\n          // In-page `selector#id sibling-combinator selector` fails\n          if (!el.querySelectorAll(\"a#\" + expando + \"+*\").length) {\n            rbuggyQSA.push(\".#.+[+~]\");\n          }\n\n          // Support: Firefox <=3.6 - 5 only\n          // Old Firefox doesn't throw on a badly-escaped identifier.\n          el.querySelectorAll(\"\\\\\\f\");\n          rbuggyQSA.push(\"[\\\\r\\\\n\\\\f]\");\n        });\n        assert(function (el) {\n          el.innerHTML = \"<a href='' disabled='disabled'></a>\" + \"<select disabled='disabled'><option/></select>\";\n\n          // Support: Windows 8 Native Apps\n          // The type and name attributes are restricted during .innerHTML assignment\n          var input = document.createElement(\"input\");\n          input.setAttribute(\"type\", \"hidden\");\n          el.appendChild(input).setAttribute(\"name\", \"D\");\n\n          // Support: IE8\n          // Enforce case-sensitivity of name attribute\n          if (el.querySelectorAll(\"[name=d]\").length) {\n            rbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\n          }\n\n          // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n          // IE8 throws error here and will not see later tests\n          if (el.querySelectorAll(\":enabled\").length !== 2) {\n            rbuggyQSA.push(\":enabled\", \":disabled\");\n          }\n\n          // Support: IE9-11+\n          // IE's :disabled selector does not pick up the children of disabled fieldsets\n          docElem.appendChild(el).disabled = true;\n          if (el.querySelectorAll(\":disabled\").length !== 2) {\n            rbuggyQSA.push(\":enabled\", \":disabled\");\n          }\n\n          // Support: Opera 10 - 11 only\n          // Opera 10-11 does not throw on post-comma invalid pseudos\n          el.querySelectorAll(\"*,:x\");\n          rbuggyQSA.push(\",.*:\");\n        });\n      }\n      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n        assert(function (el) {\n          // Check to see if it's possible to do matchesSelector\n          // on a disconnected node (IE 9)\n          support.disconnectedMatch = matches.call(el, \"*\");\n\n          // This should fail with an exception\n          // Gecko does not error, returns false instead\n          matches.call(el, \"[s!='']:x\");\n          rbuggyMatches.push(\"!=\", pseudos);\n        });\n      }\n      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join(\"|\"));\n\n      /* Contains\n      ---------------------------------------------------------------------- */\n      hasCompare = rnative.test(docElem.compareDocumentPosition);\n\n      // Element contains another\n      // Purposefully self-exclusive\n      // As in, an element does not contain itself\n      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\n        var adown = a.nodeType === 9 ? a.documentElement : a,\n          bup = b && b.parentNode;\n        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n      } : function (a, b) {\n        if (b) {\n          while (b = b.parentNode) {\n            if (b === a) {\n              return true;\n            }\n          }\n        }\n        return false;\n      };\n\n      /* Sorting\n      ---------------------------------------------------------------------- */\n\n      // Document order sorting\n      sortOrder = hasCompare ? function (a, b) {\n        // Flag for duplicate removal\n        if (a === b) {\n          hasDuplicate = true;\n          return 0;\n        }\n\n        // Sort on method existence if only one input has compareDocumentPosition\n        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n        if (compare) {\n          return compare;\n        }\n\n        // Calculate position if both inputs belong to the same document\n        // Support: IE 11+, Edge 17 - 18+\n        // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n        // two documents; shallow comparisons work.\n        // eslint-disable-next-line eqeqeq\n        compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) :\n        // Otherwise we know they are disconnected\n        1;\n\n        // Disconnected nodes\n        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n          // Choose the first element that is related to our preferred document\n          // Support: IE 11+, Edge 17 - 18+\n          // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n          // two documents; shallow comparisons work.\n          // eslint-disable-next-line eqeqeq\n          if (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {\n            return -1;\n          }\n\n          // Support: IE 11+, Edge 17 - 18+\n          // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n          // two documents; shallow comparisons work.\n          // eslint-disable-next-line eqeqeq\n          if (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {\n            return 1;\n          }\n\n          // Maintain original order\n          return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n        }\n        return compare & 4 ? -1 : 1;\n      } : function (a, b) {\n        // Exit early if the nodes are identical\n        if (a === b) {\n          hasDuplicate = true;\n          return 0;\n        }\n        var cur,\n          i = 0,\n          aup = a.parentNode,\n          bup = b.parentNode,\n          ap = [a],\n          bp = [b];\n\n        // Parentless nodes are either documents or disconnected\n        if (!aup || !bup) {\n          // Support: IE 11+, Edge 17 - 18+\n          // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n          // two documents; shallow comparisons work.\n          /* eslint-disable eqeqeq */\n          return a == document ? -1 : b == document ? 1 : /* eslint-enable eqeqeq */\n          aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n\n          // If the nodes are siblings, we can do a quick check\n        } else if (aup === bup) {\n          return siblingCheck(a, b);\n        }\n\n        // Otherwise we need full lists of their ancestors for comparison\n        cur = a;\n        while (cur = cur.parentNode) {\n          ap.unshift(cur);\n        }\n        cur = b;\n        while (cur = cur.parentNode) {\n          bp.unshift(cur);\n        }\n\n        // Walk down the tree looking for a discrepancy\n        while (ap[i] === bp[i]) {\n          i++;\n        }\n        return i ?\n        // Do a sibling check if the nodes have a common ancestor\n        siblingCheck(ap[i], bp[i]) :\n        // Otherwise nodes in our document sort first\n        // Support: IE 11+, Edge 17 - 18+\n        // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n        // two documents; shallow comparisons work.\n        /* eslint-disable eqeqeq */\n        ap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 : /* eslint-enable eqeqeq */\n        0;\n      };\n      return document;\n    };\n    Sizzle.matches = function (expr, elements) {\n      return Sizzle(expr, null, null, elements);\n    };\n    Sizzle.matchesSelector = function (elem, expr) {\n      setDocument(elem);\n      if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + \" \"] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n        try {\n          var ret = matches.call(elem, expr);\n\n          // IE 9's matchesSelector returns false on disconnected nodes\n          if (ret || support.disconnectedMatch ||\n          // As well, disconnected nodes are said to be in a document\n          // fragment in IE 9\n          elem.document && elem.document.nodeType !== 11) {\n            return ret;\n          }\n        } catch (e) {\n          nonnativeSelectorCache(expr, true);\n        }\n      }\n      return Sizzle(expr, document, null, [elem]).length > 0;\n    };\n    Sizzle.contains = function (context, elem) {\n      // Set document vars if needed\n      // Support: IE 11+, Edge 17 - 18+\n      // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n      // two documents; shallow comparisons work.\n      // eslint-disable-next-line eqeqeq\n      if ((context.ownerDocument || context) != document) {\n        setDocument(context);\n      }\n      return contains(context, elem);\n    };\n    Sizzle.attr = function (elem, name) {\n      // Set document vars if needed\n      // Support: IE 11+, Edge 17 - 18+\n      // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n      // two documents; shallow comparisons work.\n      // eslint-disable-next-line eqeqeq\n      if ((elem.ownerDocument || elem) != document) {\n        setDocument(elem);\n      }\n      var fn = Expr.attrHandle[name.toLowerCase()],\n        // Don't get fooled by Object.prototype properties (jQuery #13807)\n        val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n    };\n    Sizzle.escape = function (sel) {\n      return (sel + \"\").replace(rcssescape, fcssescape);\n    };\n    Sizzle.error = function (msg) {\n      throw new Error(\"Syntax error, unrecognized expression: \" + msg);\n    };\n\n    /**\n     * Document sorting and removing duplicates\n     * @param {ArrayLike} results\n     */\n    Sizzle.uniqueSort = function (results) {\n      var elem,\n        duplicates = [],\n        j = 0,\n        i = 0;\n\n      // Unless we *know* we can detect duplicates, assume their presence\n      hasDuplicate = !support.detectDuplicates;\n      sortInput = !support.sortStable && results.slice(0);\n      results.sort(sortOrder);\n      if (hasDuplicate) {\n        while (elem = results[i++]) {\n          if (elem === results[i]) {\n            j = duplicates.push(i);\n          }\n        }\n        while (j--) {\n          results.splice(duplicates[j], 1);\n        }\n      }\n\n      // Clear input after sorting to release objects\n      // See https://github.com/jquery/sizzle/pull/225\n      sortInput = null;\n      return results;\n    };\n\n    /**\n     * Utility function for retrieving the text value of an array of DOM nodes\n     * @param {Array|Element} elem\n     */\n    getText = Sizzle.getText = function (elem) {\n      var node,\n        ret = \"\",\n        i = 0,\n        nodeType = elem.nodeType;\n      if (!nodeType) {\n        // If no nodeType, this is expected to be an array\n        while (node = elem[i++]) {\n          // Do not traverse comment nodes\n          ret += getText(node);\n        }\n      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n        // Use textContent for elements\n        // innerText usage removed for consistency of new lines (jQuery #11153)\n        if (typeof elem.textContent === \"string\") {\n          return elem.textContent;\n        } else {\n          // Traverse its children\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            ret += getText(elem);\n          }\n        }\n      } else if (nodeType === 3 || nodeType === 4) {\n        return elem.nodeValue;\n      }\n\n      // Do not include comment or processing instruction nodes\n\n      return ret;\n    };\n    Expr = Sizzle.selectors = {\n      // Can be adjusted by the user\n      cacheLength: 50,\n      createPseudo: markFunction,\n      match: matchExpr,\n      attrHandle: {},\n      find: {},\n      relative: {\n        \">\": {\n          dir: \"parentNode\",\n          first: true\n        },\n        \" \": {\n          dir: \"parentNode\"\n        },\n        \"+\": {\n          dir: \"previousSibling\",\n          first: true\n        },\n        \"~\": {\n          dir: \"previousSibling\"\n        }\n      },\n      preFilter: {\n        \"ATTR\": function ATTR(match) {\n          match[1] = match[1].replace(runescape, funescape);\n\n          // Move the given value to match[3] whether quoted or unquoted\n          match[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\n          if (match[2] === \"~=\") {\n            match[3] = \" \" + match[3] + \" \";\n          }\n          return match.slice(0, 4);\n        },\n        \"CHILD\": function CHILD(match) {\n          /* matches from matchExpr[\"CHILD\"]\n          \t1 type (only|nth|...)\n          \t2 what (child|of-type)\n          \t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n          \t4 xn-component of xn+y argument ([+-]?\\d*n|)\n          \t5 sign of xn-component\n          \t6 x of xn-component\n          \t7 sign of y-component\n          \t8 y of y-component\n          */\n          match[1] = match[1].toLowerCase();\n          if (match[1].slice(0, 3) === \"nth\") {\n            // nth-* requires argument\n            if (!match[3]) {\n              Sizzle.error(match[0]);\n            }\n\n            // numeric x and y parameters for Expr.filter.CHILD\n            // remember that false/true cast respectively to 0/1\n            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n            match[5] = +(match[7] + match[8] || match[3] === \"odd\");\n\n            // other types prohibit arguments\n          } else if (match[3]) {\n            Sizzle.error(match[0]);\n          }\n          return match;\n        },\n        \"PSEUDO\": function PSEUDO(match) {\n          var excess,\n            unquoted = !match[6] && match[2];\n          if (matchExpr[\"CHILD\"].test(match[0])) {\n            return null;\n          }\n\n          // Accept quoted arguments as-is\n          if (match[3]) {\n            match[2] = match[4] || match[5] || \"\";\n\n            // Strip excess characters from unquoted arguments\n          } else if (unquoted && rpseudo.test(unquoted) && (\n          // Get excess from tokenize (recursively)\n          excess = tokenize(unquoted, true)) && (\n          // advance to the next closing parenthesis\n          excess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n            // excess is a negative index\n            match[0] = match[0].slice(0, excess);\n            match[2] = unquoted.slice(0, excess);\n          }\n\n          // Return only captures needed by the pseudo filter method (type and argument)\n          return match.slice(0, 3);\n        }\n      },\n      filter: {\n        \"TAG\": function TAG(nodeNameSelector) {\n          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n          return nodeNameSelector === \"*\" ? function () {\n            return true;\n          } : function (elem) {\n            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n          };\n        },\n        \"CLASS\": function CLASS(className) {\n          var pattern = classCache[className + \" \"];\n          return pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function (elem) {\n            return pattern.test(typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\");\n          });\n        },\n        \"ATTR\": function ATTR(name, operator, check) {\n          return function (elem) {\n            var result = Sizzle.attr(elem, name);\n            if (result == null) {\n              return operator === \"!=\";\n            }\n            if (!operator) {\n              return true;\n            }\n            result += \"\";\n\n            /* eslint-disable max-len */\n\n            return operator === \"=\" ? result === check : operator === \"!=\" ? result !== check : operator === \"^=\" ? check && result.indexOf(check) === 0 : operator === \"*=\" ? check && result.indexOf(check) > -1 : operator === \"$=\" ? check && result.slice(-check.length) === check : operator === \"~=\" ? (\" \" + result.replace(rwhitespace, \" \") + \" \").indexOf(check) > -1 : operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" : false;\n            /* eslint-enable max-len */\n          };\n        },\n\n        \"CHILD\": function CHILD(type, what, _argument, first, last) {\n          var simple = type.slice(0, 3) !== \"nth\",\n            forward = type.slice(-4) !== \"last\",\n            ofType = what === \"of-type\";\n          return first === 1 && last === 0 ?\n          // Shortcut for :nth-*(n)\n          function (elem) {\n            return !!elem.parentNode;\n          } : function (elem, _context, xml) {\n            var cache,\n              uniqueCache,\n              outerCache,\n              node,\n              nodeIndex,\n              start,\n              dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n              parent = elem.parentNode,\n              name = ofType && elem.nodeName.toLowerCase(),\n              useCache = !xml && !ofType,\n              diff = false;\n            if (parent) {\n              // :(first|last|only)-(child|of-type)\n              if (simple) {\n                while (dir) {\n                  node = elem;\n                  while (node = node[dir]) {\n                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n                      return false;\n                    }\n                  }\n\n                  // Reverse direction for :only-* (if we haven't yet done so)\n                  start = dir = type === \"only\" && !start && \"nextSibling\";\n                }\n                return true;\n              }\n              start = [forward ? parent.firstChild : parent.lastChild];\n\n              // non-xml :nth-child(...) stores cache data on `parent`\n              if (forward && useCache) {\n                // Seek `elem` from a previously-cached index\n\n                // ...in a gzip-friendly way\n                node = parent;\n                outerCache = node[expando] || (node[expando] = {});\n\n                // Support: IE <9 only\n                // Defend against cloned attroperties (jQuery gh-1709)\n                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                cache = uniqueCache[type] || [];\n                nodeIndex = cache[0] === dirruns && cache[1];\n                diff = nodeIndex && cache[2];\n                node = nodeIndex && parent.childNodes[nodeIndex];\n                while (node = ++nodeIndex && node && node[dir] || (\n                // Fallback to seeking `elem` from the start\n                diff = nodeIndex = 0) || start.pop()) {\n                  // When found, cache indexes on `parent` and break\n                  if (node.nodeType === 1 && ++diff && node === elem) {\n                    uniqueCache[type] = [dirruns, nodeIndex, diff];\n                    break;\n                  }\n                }\n              } else {\n                // Use previously-cached element index if available\n                if (useCache) {\n                  // ...in a gzip-friendly way\n                  node = elem;\n                  outerCache = node[expando] || (node[expando] = {});\n\n                  // Support: IE <9 only\n                  // Defend against cloned attroperties (jQuery gh-1709)\n                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                  cache = uniqueCache[type] || [];\n                  nodeIndex = cache[0] === dirruns && cache[1];\n                  diff = nodeIndex;\n                }\n\n                // xml :nth-child(...)\n                // or :nth-last-child(...) or :nth(-last)?-of-type(...)\n                if (diff === false) {\n                  // Use the same loop as above to seek `elem` from the start\n                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n                      // Cache the index of each encountered element\n                      if (useCache) {\n                        outerCache = node[expando] || (node[expando] = {});\n\n                        // Support: IE <9 only\n                        // Defend against cloned attroperties (jQuery gh-1709)\n                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n                        uniqueCache[type] = [dirruns, diff];\n                      }\n                      if (node === elem) {\n                        break;\n                      }\n                    }\n                  }\n                }\n              }\n\n              // Incorporate the offset, then check against cycle size\n              diff -= last;\n              return diff === first || diff % first === 0 && diff / first >= 0;\n            }\n          };\n        },\n        \"PSEUDO\": function PSEUDO(pseudo, argument) {\n          // pseudo-class names are case-insensitive\n          // http://www.w3.org/TR/selectors/#pseudo-classes\n          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n          // Remember that setFilters inherits from pseudos\n          var args,\n            fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(\"unsupported pseudo: \" + pseudo);\n\n          // The user may use createPseudo to indicate that\n          // arguments are needed to create the filter function\n          // just as Sizzle does\n          if (fn[expando]) {\n            return fn(argument);\n          }\n\n          // But maintain support for old signatures\n          if (fn.length > 1) {\n            args = [pseudo, pseudo, \"\", argument];\n            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n              var idx,\n                matched = fn(seed, argument),\n                i = matched.length;\n              while (i--) {\n                idx = indexOf(seed, matched[i]);\n                seed[idx] = !(matches[idx] = matched[i]);\n              }\n            }) : function (elem) {\n              return fn(elem, 0, args);\n            };\n          }\n          return fn;\n        }\n      },\n      pseudos: {\n        // Potentially complex pseudos\n        \"not\": markFunction(function (selector) {\n          // Trim the selector passed to compile\n          // to avoid treating leading and trailing\n          // spaces as combinators\n          var input = [],\n            results = [],\n            matcher = compile(selector.replace(rtrim, \"$1\"));\n          return matcher[expando] ? markFunction(function (seed, matches, _context, xml) {\n            var elem,\n              unmatched = matcher(seed, null, xml, []),\n              i = seed.length;\n\n            // Match elements unmatched by `matcher`\n            while (i--) {\n              if (elem = unmatched[i]) {\n                seed[i] = !(matches[i] = elem);\n              }\n            }\n          }) : function (elem, _context, xml) {\n            input[0] = elem;\n            matcher(input, null, xml, results);\n\n            // Don't keep the element (issue #299)\n            input[0] = null;\n            return !results.pop();\n          };\n        }),\n        \"has\": markFunction(function (selector) {\n          return function (elem) {\n            return Sizzle(selector, elem).length > 0;\n          };\n        }),\n        \"contains\": markFunction(function (text) {\n          text = text.replace(runescape, funescape);\n          return function (elem) {\n            return (elem.textContent || getText(elem)).indexOf(text) > -1;\n          };\n        }),\n        // \"Whether an element is represented by a :lang() selector\n        // is based solely on the element's language value\n        // being equal to the identifier C,\n        // or beginning with the identifier C immediately followed by \"-\".\n        // The matching of C against the element's language value is performed case-insensitively.\n        // The identifier C does not have to be a valid language name.\"\n        // http://www.w3.org/TR/selectors/#lang-pseudo\n        \"lang\": markFunction(function (lang) {\n          // lang value must be a valid identifier\n          if (!ridentifier.test(lang || \"\")) {\n            Sizzle.error(\"unsupported lang: \" + lang);\n          }\n          lang = lang.replace(runescape, funescape).toLowerCase();\n          return function (elem) {\n            var elemLang;\n            do {\n              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) {\n                elemLang = elemLang.toLowerCase();\n                return elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n              }\n            } while ((elem = elem.parentNode) && elem.nodeType === 1);\n            return false;\n          };\n        }),\n        // Miscellaneous\n        \"target\": function target(elem) {\n          var hash = window.location && window.location.hash;\n          return hash && hash.slice(1) === elem.id;\n        },\n        \"root\": function root(elem) {\n          return elem === docElem;\n        },\n        \"focus\": function focus(elem) {\n          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n        },\n        // Boolean properties\n        \"enabled\": createDisabledPseudo(false),\n        \"disabled\": createDisabledPseudo(true),\n        \"checked\": function checked(elem) {\n          // In CSS3, :checked should return both checked and selected elements\n          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n          var nodeName = elem.nodeName.toLowerCase();\n          return nodeName === \"input\" && !!elem.checked || nodeName === \"option\" && !!elem.selected;\n        },\n        \"selected\": function selected(elem) {\n          // Accessing this property makes selected-by-default\n          // options in Safari work properly\n          if (elem.parentNode) {\n            // eslint-disable-next-line no-unused-expressions\n            elem.parentNode.selectedIndex;\n          }\n          return elem.selected === true;\n        },\n        // Contents\n        \"empty\": function empty(elem) {\n          // http://www.w3.org/TR/selectors/#empty-pseudo\n          // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n          //   but not by others (comment: 8; processing instruction: 7; etc.)\n          // nodeType < 6 works because attributes (2) do not appear as children\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            if (elem.nodeType < 6) {\n              return false;\n            }\n          }\n          return true;\n        },\n        \"parent\": function parent(elem) {\n          return !Expr.pseudos[\"empty\"](elem);\n        },\n        // Element/input types\n        \"header\": function header(elem) {\n          return rheader.test(elem.nodeName);\n        },\n        \"input\": function input(elem) {\n          return rinputs.test(elem.nodeName);\n        },\n        \"button\": function button(elem) {\n          var name = elem.nodeName.toLowerCase();\n          return name === \"input\" && elem.type === \"button\" || name === \"button\";\n        },\n        \"text\": function text(elem) {\n          var attr;\n          return elem.nodeName.toLowerCase() === \"input\" && elem.type === \"text\" && (\n          // Support: IE<8\n          // New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n          (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\");\n        },\n        // Position-in-collection\n        \"first\": createPositionalPseudo(function () {\n          return [0];\n        }),\n        \"last\": createPositionalPseudo(function (_matchIndexes, length) {\n          return [length - 1];\n        }),\n        \"eq\": createPositionalPseudo(function (_matchIndexes, length, argument) {\n          return [argument < 0 ? argument + length : argument];\n        }),\n        \"even\": createPositionalPseudo(function (matchIndexes, length) {\n          var i = 0;\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n          return matchIndexes;\n        }),\n        \"odd\": createPositionalPseudo(function (matchIndexes, length) {\n          var i = 1;\n          for (; i < length; i += 2) {\n            matchIndexes.push(i);\n          }\n          return matchIndexes;\n        }),\n        \"lt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument > length ? length : argument;\n          for (; --i >= 0;) {\n            matchIndexes.push(i);\n          }\n          return matchIndexes;\n        }),\n        \"gt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n          var i = argument < 0 ? argument + length : argument;\n          for (; ++i < length;) {\n            matchIndexes.push(i);\n          }\n          return matchIndexes;\n        })\n      }\n    };\n    Expr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n    // Add button/input type pseudos\n    for (i in {\n      radio: true,\n      checkbox: true,\n      file: true,\n      password: true,\n      image: true\n    }) {\n      Expr.pseudos[i] = createInputPseudo(i);\n    }\n    for (i in {\n      submit: true,\n      reset: true\n    }) {\n      Expr.pseudos[i] = createButtonPseudo(i);\n    }\n\n    // Easy API for creating new setFilters\n    function setFilters() {}\n    setFilters.prototype = Expr.filters = Expr.pseudos;\n    Expr.setFilters = new setFilters();\n    tokenize = Sizzle.tokenize = function (selector, parseOnly) {\n      var matched,\n        match,\n        tokens,\n        type,\n        soFar,\n        groups,\n        preFilters,\n        cached = tokenCache[selector + \" \"];\n      if (cached) {\n        return parseOnly ? 0 : cached.slice(0);\n      }\n      soFar = selector;\n      groups = [];\n      preFilters = Expr.preFilter;\n      while (soFar) {\n        // Comma and first run\n        if (!matched || (match = rcomma.exec(soFar))) {\n          if (match) {\n            // Don't consume trailing commas as valid\n            soFar = soFar.slice(match[0].length) || soFar;\n          }\n          groups.push(tokens = []);\n        }\n        matched = false;\n\n        // Combinators\n        if (match = rcombinators.exec(soFar)) {\n          matched = match.shift();\n          tokens.push({\n            value: matched,\n            // Cast descendant combinators to space\n            type: match[0].replace(rtrim, \" \")\n          });\n          soFar = soFar.slice(matched.length);\n        }\n\n        // Filters\n        for (type in Expr.filter) {\n          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n            matched = match.shift();\n            tokens.push({\n              value: matched,\n              type: type,\n              matches: match\n            });\n            soFar = soFar.slice(matched.length);\n          }\n        }\n        if (!matched) {\n          break;\n        }\n      }\n\n      // Return the length of the invalid excess\n      // if we're just parsing\n      // Otherwise, throw an error or return tokens\n      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) :\n      // Cache the tokens\n      tokenCache(selector, groups).slice(0);\n    };\n    function toSelector(tokens) {\n      var i = 0,\n        len = tokens.length,\n        selector = \"\";\n      for (; i < len; i++) {\n        selector += tokens[i].value;\n      }\n      return selector;\n    }\n    function addCombinator(matcher, combinator, base) {\n      var dir = combinator.dir,\n        skip = combinator.next,\n        key = skip || dir,\n        checkNonElements = base && key === \"parentNode\",\n        doneName = done++;\n      return combinator.first ?\n      // Check against closest ancestor/preceding element\n      function (elem, context, xml) {\n        while (elem = elem[dir]) {\n          if (elem.nodeType === 1 || checkNonElements) {\n            return matcher(elem, context, xml);\n          }\n        }\n        return false;\n      } :\n      // Check against all ancestor/preceding elements\n      function (elem, context, xml) {\n        var oldCache,\n          uniqueCache,\n          outerCache,\n          newCache = [dirruns, doneName];\n\n        // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n        if (xml) {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              if (matcher(elem, context, xml)) {\n                return true;\n              }\n            }\n          }\n        } else {\n          while (elem = elem[dir]) {\n            if (elem.nodeType === 1 || checkNonElements) {\n              outerCache = elem[expando] || (elem[expando] = {});\n\n              // Support: IE <9 only\n              // Defend against cloned attroperties (jQuery gh-1709)\n              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});\n              if (skip && skip === elem.nodeName.toLowerCase()) {\n                elem = elem[dir] || elem;\n              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n                // Assign to newCache so results back-propagate to previous elements\n                return newCache[2] = oldCache[2];\n              } else {\n                // Reuse newcache so results back-propagate to previous elements\n                uniqueCache[key] = newCache;\n\n                // A match means we're done; a fail means we have to keep checking\n                if (newCache[2] = matcher(elem, context, xml)) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n        return false;\n      };\n    }\n    function elementMatcher(matchers) {\n      return matchers.length > 1 ? function (elem, context, xml) {\n        var i = matchers.length;\n        while (i--) {\n          if (!matchers[i](elem, context, xml)) {\n            return false;\n          }\n        }\n        return true;\n      } : matchers[0];\n    }\n    function multipleContexts(selector, contexts, results) {\n      var i = 0,\n        len = contexts.length;\n      for (; i < len; i++) {\n        Sizzle(selector, contexts[i], results);\n      }\n      return results;\n    }\n    function condense(unmatched, map, filter, context, xml) {\n      var elem,\n        newUnmatched = [],\n        i = 0,\n        len = unmatched.length,\n        mapped = map != null;\n      for (; i < len; i++) {\n        if (elem = unmatched[i]) {\n          if (!filter || filter(elem, context, xml)) {\n            newUnmatched.push(elem);\n            if (mapped) {\n              map.push(i);\n            }\n          }\n        }\n      }\n      return newUnmatched;\n    }\n    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n      if (postFilter && !postFilter[expando]) {\n        postFilter = setMatcher(postFilter);\n      }\n      if (postFinder && !postFinder[expando]) {\n        postFinder = setMatcher(postFinder, postSelector);\n      }\n      return markFunction(function (seed, results, context, xml) {\n        var temp,\n          i,\n          elem,\n          preMap = [],\n          postMap = [],\n          preexisting = results.length,\n          // Get initial elements from seed or context\n          elems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []),\n          // Prefilter to get matcher input, preserving a map for seed-results synchronization\n          matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n          matcherOut = matcher ?\n          // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n          postFinder || (seed ? preFilter : preexisting || postFilter) ?\n          // ...intermediate processing is necessary\n          [] :\n          // ...otherwise use results directly\n          results : matcherIn;\n\n        // Find primary matches\n        if (matcher) {\n          matcher(matcherIn, matcherOut, context, xml);\n        }\n\n        // Apply postFilter\n        if (postFilter) {\n          temp = condense(matcherOut, postMap);\n          postFilter(temp, [], context, xml);\n\n          // Un-match failing elements by moving them back to matcherIn\n          i = temp.length;\n          while (i--) {\n            if (elem = temp[i]) {\n              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n            }\n          }\n        }\n        if (seed) {\n          if (postFinder || preFilter) {\n            if (postFinder) {\n              // Get the final matcherOut by condensing this intermediate into postFinder contexts\n              temp = [];\n              i = matcherOut.length;\n              while (i--) {\n                if (elem = matcherOut[i]) {\n                  // Restore matcherIn since elem is not yet a final match\n                  temp.push(matcherIn[i] = elem);\n                }\n              }\n              postFinder(null, matcherOut = [], temp, xml);\n            }\n\n            // Move matched elements from seed to results to keep them synchronized\n            i = matcherOut.length;\n            while (i--) {\n              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\n                seed[temp] = !(results[temp] = elem);\n              }\n            }\n          }\n\n          // Add elements to results, through postFinder if defined\n        } else {\n          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n          if (postFinder) {\n            postFinder(null, results, matcherOut, xml);\n          } else {\n            push.apply(results, matcherOut);\n          }\n        }\n      });\n    }\n    function matcherFromTokens(tokens) {\n      var checkContext,\n        matcher,\n        j,\n        len = tokens.length,\n        leadingRelative = Expr.relative[tokens[0].type],\n        implicitRelative = leadingRelative || Expr.relative[\" \"],\n        i = leadingRelative ? 1 : 0,\n        // The foundational matcher ensures that elements are reachable from top-level context(s)\n        matchContext = addCombinator(function (elem) {\n          return elem === checkContext;\n        }, implicitRelative, true),\n        matchAnyContext = addCombinator(function (elem) {\n          return indexOf(checkContext, elem) > -1;\n        }, implicitRelative, true),\n        matchers = [function (elem, context, xml) {\n          var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));\n\n          // Avoid hanging onto element (issue #299)\n          checkContext = null;\n          return ret;\n        }];\n      for (; i < len; i++) {\n        if (matcher = Expr.relative[tokens[i].type]) {\n          matchers = [addCombinator(elementMatcher(matchers), matcher)];\n        } else {\n          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);\n\n          // Return special upon seeing a positional matcher\n          if (matcher[expando]) {\n            // Find the next relative operator (if any) for proper handling\n            j = ++i;\n            for (; j < len; j++) {\n              if (Expr.relative[tokens[j].type]) {\n                break;\n              }\n            }\n            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(\n            // If the preceding token was a descendant combinator, insert an implicit any-element `*`\n            tokens.slice(0, i - 1).concat({\n              value: tokens[i - 2].type === \" \" ? \"*\" : \"\"\n            })).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n          }\n          matchers.push(matcher);\n        }\n      }\n      return elementMatcher(matchers);\n    }\n    function matcherFromGroupMatchers(elementMatchers, setMatchers) {\n      var bySet = setMatchers.length > 0,\n        byElement = elementMatchers.length > 0,\n        superMatcher = function superMatcher(seed, context, xml, results, outermost) {\n          var elem,\n            j,\n            matcher,\n            matchedCount = 0,\n            i = \"0\",\n            unmatched = seed && [],\n            setMatched = [],\n            contextBackup = outermostContext,\n            // We must always have either seed elements or outermost context\n            elems = seed || byElement && Expr.find[\"TAG\"](\"*\", outermost),\n            // Use integer dirruns iff this is the outermost matcher\n            dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,\n            len = elems.length;\n          if (outermost) {\n            // Support: IE 11+, Edge 17 - 18+\n            // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n            // two documents; shallow comparisons work.\n            // eslint-disable-next-line eqeqeq\n            outermostContext = context == document || context || outermost;\n          }\n\n          // Add elements passing elementMatchers directly to results\n          // Support: IE<9, Safari\n          // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n          for (; i !== len && (elem = elems[i]) != null; i++) {\n            if (byElement && elem) {\n              j = 0;\n\n              // Support: IE 11+, Edge 17 - 18+\n              // IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n              // two documents; shallow comparisons work.\n              // eslint-disable-next-line eqeqeq\n              if (!context && elem.ownerDocument != document) {\n                setDocument(elem);\n                xml = !documentIsHTML;\n              }\n              while (matcher = elementMatchers[j++]) {\n                if (matcher(elem, context || document, xml)) {\n                  results.push(elem);\n                  break;\n                }\n              }\n              if (outermost) {\n                dirruns = dirrunsUnique;\n              }\n            }\n\n            // Track unmatched elements for set filters\n            if (bySet) {\n              // They will have gone through all possible matchers\n              if (elem = !matcher && elem) {\n                matchedCount--;\n              }\n\n              // Lengthen the array for every element, matched or not\n              if (seed) {\n                unmatched.push(elem);\n              }\n            }\n          }\n\n          // `i` is now the count of elements visited above, and adding it to `matchedCount`\n          // makes the latter nonnegative.\n          matchedCount += i;\n\n          // Apply set filters to unmatched elements\n          // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n          // equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n          // no element matchers and no seed.\n          // Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n          // case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n          // numerically zero.\n          if (bySet && i !== matchedCount) {\n            j = 0;\n            while (matcher = setMatchers[j++]) {\n              matcher(unmatched, setMatched, context, xml);\n            }\n            if (seed) {\n              // Reintegrate element matches to eliminate the need for sorting\n              if (matchedCount > 0) {\n                while (i--) {\n                  if (!(unmatched[i] || setMatched[i])) {\n                    setMatched[i] = pop.call(results);\n                  }\n                }\n              }\n\n              // Discard index placeholder values to get only actual matches\n              setMatched = condense(setMatched);\n            }\n\n            // Add matches to results\n            push.apply(results, setMatched);\n\n            // Seedless set matches succeeding multiple successful matchers stipulate sorting\n            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n              Sizzle.uniqueSort(results);\n            }\n          }\n\n          // Override manipulation of globals by nested matchers\n          if (outermost) {\n            dirruns = dirrunsUnique;\n            outermostContext = contextBackup;\n          }\n          return unmatched;\n        };\n      return bySet ? markFunction(superMatcher) : superMatcher;\n    }\n    compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {\n      var i,\n        setMatchers = [],\n        elementMatchers = [],\n        cached = compilerCache[selector + \" \"];\n      if (!cached) {\n        // Generate a function of recursive functions that can be used to check each element\n        if (!match) {\n          match = tokenize(selector);\n        }\n        i = match.length;\n        while (i--) {\n          cached = matcherFromTokens(match[i]);\n          if (cached[expando]) {\n            setMatchers.push(cached);\n          } else {\n            elementMatchers.push(cached);\n          }\n        }\n\n        // Cache the compiled function\n        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));\n\n        // Save selector and tokenization\n        cached.selector = selector;\n      }\n      return cached;\n    };\n\n    /**\n     * A low-level selection function that works with Sizzle's compiled\n     *  selector functions\n     * @param {String|Function} selector A selector or a pre-compiled\n     *  selector function built with Sizzle.compile\n     * @param {Element} context\n     * @param {Array} [results]\n     * @param {Array} [seed] A set of elements to match against\n     */\n    select = Sizzle.select = function (selector, context, results, seed) {\n      var i,\n        tokens,\n        token,\n        type,\n        find,\n        compiled = typeof selector === \"function\" && selector,\n        match = !seed && tokenize(selector = compiled.selector || selector);\n      results = results || [];\n\n      // Try to minimize operations if there is only one selector in the list and no seed\n      // (the latter of which guarantees us context)\n      if (match.length === 1) {\n        // Reduce context if the leading compound selector is an ID\n        tokens = match[0] = match[0].slice(0);\n        if (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n          context = (Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context) || [])[0];\n          if (!context) {\n            return results;\n\n            // Precompiled matchers will still verify ancestry, so step up a level\n          } else if (compiled) {\n            context = context.parentNode;\n          }\n          selector = selector.slice(tokens.shift().value.length);\n        }\n\n        // Fetch a seed set for right-to-left matching\n        i = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\n        while (i--) {\n          token = tokens[i];\n\n          // Abort if we hit a combinator\n          if (Expr.relative[type = token.type]) {\n            break;\n          }\n          if (find = Expr.find[type]) {\n            // Search, expanding context for leading sibling combinators\n            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n              // If seed is empty or no tokens remain, we can return early\n              tokens.splice(i, 1);\n              selector = seed.length && toSelector(tokens);\n              if (!selector) {\n                push.apply(results, seed);\n                return results;\n              }\n              break;\n            }\n          }\n        }\n      }\n\n      // Compile and execute a filtering function if one is not provided\n      // Provide `match` to avoid retokenization if we modified the selector above\n      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\n      return results;\n    };\n\n    // One-time assignments\n\n    // Sort stability\n    support.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando;\n\n    // Support: Chrome 14-35+\n    // Always assume duplicates if they aren't passed to the comparison function\n    support.detectDuplicates = !!hasDuplicate;\n\n    // Initialize against the default document\n    setDocument();\n\n    // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n    // Detached nodes confoundingly follow *each other*\n    support.sortDetached = assert(function (el) {\n      // Should return 1, but returns 4 (following)\n      return el.compareDocumentPosition(document.createElement(\"fieldset\")) & 1;\n    });\n\n    // Support: IE<8\n    // Prevent attribute/property \"interpolation\"\n    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n    if (!assert(function (el) {\n      el.innerHTML = \"<a href='#'></a>\";\n      return el.firstChild.getAttribute(\"href\") === \"#\";\n    })) {\n      addHandle(\"type|href|height|width\", function (elem, name, isXML) {\n        if (!isXML) {\n          return elem.getAttribute(name, name.toLowerCase() === \"type\" ? 1 : 2);\n        }\n      });\n    }\n\n    // Support: IE<9\n    // Use defaultValue in place of getAttribute(\"value\")\n    if (!support.attributes || !assert(function (el) {\n      el.innerHTML = \"<input/>\";\n      el.firstChild.setAttribute(\"value\", \"\");\n      return el.firstChild.getAttribute(\"value\") === \"\";\n    })) {\n      addHandle(\"value\", function (elem, _name, isXML) {\n        if (!isXML && elem.nodeName.toLowerCase() === \"input\") {\n          return elem.defaultValue;\n        }\n      });\n    }\n\n    // Support: IE<9\n    // Use getAttributeNode to fetch booleans when getAttribute lies\n    if (!assert(function (el) {\n      return el.getAttribute(\"disabled\") == null;\n    })) {\n      addHandle(booleans, function (elem, name, isXML) {\n        var val;\n        if (!isXML) {\n          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n        }\n      });\n    }\n    return Sizzle;\n  }(window);\n  jQuery.find = Sizzle;\n  jQuery.expr = Sizzle.selectors;\n\n  // Deprecated\n  jQuery.expr[\":\"] = jQuery.expr.pseudos;\n  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\n  jQuery.text = Sizzle.getText;\n  jQuery.isXMLDoc = Sizzle.isXML;\n  jQuery.contains = Sizzle.contains;\n  jQuery.escapeSelector = Sizzle.escape;\n  var dir = function dir(elem, _dir, until) {\n    var matched = [],\n      truncate = until !== undefined;\n    while ((elem = elem[_dir]) && elem.nodeType !== 9) {\n      if (elem.nodeType === 1) {\n        if (truncate && jQuery(elem).is(until)) {\n          break;\n        }\n        matched.push(elem);\n      }\n    }\n    return matched;\n  };\n  var _siblings = function siblings(n, elem) {\n    var matched = [];\n    for (; n; n = n.nextSibling) {\n      if (n.nodeType === 1 && n !== elem) {\n        matched.push(n);\n      }\n    }\n    return matched;\n  };\n  var rneedsContext = jQuery.expr.match.needsContext;\n  function nodeName(elem, name) {\n    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n  }\n  var rsingleTag = /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i;\n\n  // Implement the identical functionality for filter and not\n  function winnow(elements, qualifier, not) {\n    if (isFunction(qualifier)) {\n      return jQuery.grep(elements, function (elem, i) {\n        return !!qualifier.call(elem, i, elem) !== not;\n      });\n    }\n\n    // Single element\n    if (qualifier.nodeType) {\n      return jQuery.grep(elements, function (elem) {\n        return elem === qualifier !== not;\n      });\n    }\n\n    // Arraylike of elements (jQuery, arguments, Array)\n    if (typeof qualifier !== \"string\") {\n      return jQuery.grep(elements, function (elem) {\n        return indexOf.call(qualifier, elem) > -1 !== not;\n      });\n    }\n\n    // Filtered directly for both simple and complex selectors\n    return jQuery.filter(qualifier, elements, not);\n  }\n  jQuery.filter = function (expr, elems, not) {\n    var elem = elems[0];\n    if (not) {\n      expr = \":not(\" + expr + \")\";\n    }\n    if (elems.length === 1 && elem.nodeType === 1) {\n      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];\n    }\n    return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {\n      return elem.nodeType === 1;\n    }));\n  };\n  jQuery.fn.extend({\n    find: function find(selector) {\n      var i,\n        ret,\n        len = this.length,\n        self = this;\n      if (typeof selector !== \"string\") {\n        return this.pushStack(jQuery(selector).filter(function () {\n          for (i = 0; i < len; i++) {\n            if (jQuery.contains(self[i], this)) {\n              return true;\n            }\n          }\n        }));\n      }\n      ret = this.pushStack([]);\n      for (i = 0; i < len; i++) {\n        jQuery.find(selector, self[i], ret);\n      }\n      return len > 1 ? jQuery.uniqueSort(ret) : ret;\n    },\n    filter: function filter(selector) {\n      return this.pushStack(winnow(this, selector || [], false));\n    },\n    not: function not(selector) {\n      return this.pushStack(winnow(this, selector || [], true));\n    },\n    is: function is(selector) {\n      return !!winnow(this,\n      // If this is a positional/relative selector, check membership in the returned set\n      // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n      typeof selector === \"string\" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;\n    }\n  });\n\n  // Initialize a jQuery object\n\n  // A central reference to the root jQuery(document)\n  var rootjQuery,\n    // A simple way to check for HTML strings\n    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n    // Strict HTML recognition (#11290: must start with <)\n    // Shortcut simple #id case for speed\n    rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n    init = jQuery.fn.init = function (selector, context, root) {\n      var match, elem;\n\n      // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n      if (!selector) {\n        return this;\n      }\n\n      // Method init() accepts an alternate rootjQuery\n      // so migrate can support jQuery.sub (gh-2101)\n      root = root || rootjQuery;\n\n      // Handle HTML strings\n      if (typeof selector === \"string\") {\n        if (selector[0] === \"<\" && selector[selector.length - 1] === \">\" && selector.length >= 3) {\n          // Assume that strings that start and end with <> are HTML and skip the regex check\n          match = [null, selector, null];\n        } else {\n          match = rquickExpr.exec(selector);\n        }\n\n        // Match html or make sure no context is specified for #id\n        if (match && (match[1] || !context)) {\n          // HANDLE: $(html) -> $(array)\n          if (match[1]) {\n            context = context instanceof jQuery ? context[0] : context;\n\n            // Option to run scripts is true for back-compat\n            // Intentionally let the error be thrown if parseHTML is not present\n            jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));\n\n            // HANDLE: $(html, props)\n            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\n              for (match in context) {\n                // Properties of context are called as methods if possible\n                if (isFunction(this[match])) {\n                  this[match](context[match]);\n\n                  // ...and otherwise set as attributes\n                } else {\n                  this.attr(match, context[match]);\n                }\n              }\n            }\n            return this;\n\n            // HANDLE: $(#id)\n          } else {\n            elem = document.getElementById(match[2]);\n            if (elem) {\n              // Inject the element directly into the jQuery object\n              this[0] = elem;\n              this.length = 1;\n            }\n            return this;\n          }\n\n          // HANDLE: $(expr, $(...))\n        } else if (!context || context.jquery) {\n          return (context || root).find(selector);\n\n          // HANDLE: $(expr, context)\n          // (which is just equivalent to: $(context).find(expr)\n        } else {\n          return this.constructor(context).find(selector);\n        }\n\n        // HANDLE: $(DOMElement)\n      } else if (selector.nodeType) {\n        this[0] = selector;\n        this.length = 1;\n        return this;\n\n        // HANDLE: $(function)\n        // Shortcut for document ready\n      } else if (isFunction(selector)) {\n        return root.ready !== undefined ? root.ready(selector) :\n        // Execute immediately if ready is not present\n        selector(jQuery);\n      }\n      return jQuery.makeArray(selector, this);\n    };\n\n  // Give the init function the jQuery prototype for later instantiation\n  init.prototype = jQuery.fn;\n\n  // Initialize central reference\n  rootjQuery = jQuery(document);\n  var rparentsprev = /^(?:parents|prev(?:Until|All))/,\n    // Methods guaranteed to produce a unique set when starting from a unique set\n    guaranteedUnique = {\n      children: true,\n      contents: true,\n      next: true,\n      prev: true\n    };\n  jQuery.fn.extend({\n    has: function has(target) {\n      var targets = jQuery(target, this),\n        l = targets.length;\n      return this.filter(function () {\n        var i = 0;\n        for (; i < l; i++) {\n          if (jQuery.contains(this, targets[i])) {\n            return true;\n          }\n        }\n      });\n    },\n    closest: function closest(selectors, context) {\n      var cur,\n        i = 0,\n        l = this.length,\n        matched = [],\n        targets = typeof selectors !== \"string\" && jQuery(selectors);\n\n      // Positional selectors never match, since there's no _selection_ context\n      if (!rneedsContext.test(selectors)) {\n        for (; i < l; i++) {\n          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {\n            // Always skip document fragments\n            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 :\n            // Don't pass non-elements to Sizzle\n            cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {\n              matched.push(cur);\n              break;\n            }\n          }\n        }\n      }\n      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);\n    },\n    // Determine the position of an element within the set\n    index: function index(elem) {\n      // No argument, return index in parent\n      if (!elem) {\n        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n      }\n\n      // Index in selector\n      if (typeof elem === \"string\") {\n        return indexOf.call(jQuery(elem), this[0]);\n      }\n\n      // Locate the position of the desired element\n      return indexOf.call(this,\n      // If it receives a jQuery object, the first element is used\n      elem.jquery ? elem[0] : elem);\n    },\n    add: function add(selector, context) {\n      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));\n    },\n    addBack: function addBack(selector) {\n      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));\n    }\n  });\n  function sibling(cur, dir) {\n    while ((cur = cur[dir]) && cur.nodeType !== 1) {}\n    return cur;\n  }\n  jQuery.each({\n    parent: function parent(elem) {\n      var parent = elem.parentNode;\n      return parent && parent.nodeType !== 11 ? parent : null;\n    },\n    parents: function parents(elem) {\n      return dir(elem, \"parentNode\");\n    },\n    parentsUntil: function parentsUntil(elem, _i, until) {\n      return dir(elem, \"parentNode\", until);\n    },\n    next: function next(elem) {\n      return sibling(elem, \"nextSibling\");\n    },\n    prev: function prev(elem) {\n      return sibling(elem, \"previousSibling\");\n    },\n    nextAll: function nextAll(elem) {\n      return dir(elem, \"nextSibling\");\n    },\n    prevAll: function prevAll(elem) {\n      return dir(elem, \"previousSibling\");\n    },\n    nextUntil: function nextUntil(elem, _i, until) {\n      return dir(elem, \"nextSibling\", until);\n    },\n    prevUntil: function prevUntil(elem, _i, until) {\n      return dir(elem, \"previousSibling\", until);\n    },\n    siblings: function siblings(elem) {\n      return _siblings((elem.parentNode || {}).firstChild, elem);\n    },\n    children: function children(elem) {\n      return _siblings(elem.firstChild);\n    },\n    contents: function contents(elem) {\n      if (elem.contentDocument != null &&\n      // Support: IE 11+\n      // <object> elements with no `data` attribute has an object\n      // `contentDocument` with a `null` prototype.\n      getProto(elem.contentDocument)) {\n        return elem.contentDocument;\n      }\n\n      // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n      // Treat the template element as a regular one in browsers that\n      // don't support it.\n      if (nodeName(elem, \"template\")) {\n        elem = elem.content || elem;\n      }\n      return jQuery.merge([], elem.childNodes);\n    }\n  }, function (name, fn) {\n    jQuery.fn[name] = function (until, selector) {\n      var matched = jQuery.map(this, fn, until);\n      if (name.slice(-5) !== \"Until\") {\n        selector = until;\n      }\n      if (selector && typeof selector === \"string\") {\n        matched = jQuery.filter(selector, matched);\n      }\n      if (this.length > 1) {\n        // Remove duplicates\n        if (!guaranteedUnique[name]) {\n          jQuery.uniqueSort(matched);\n        }\n\n        // Reverse order for parents* and prev-derivatives\n        if (rparentsprev.test(name)) {\n          matched.reverse();\n        }\n      }\n      return this.pushStack(matched);\n    };\n  });\n  var rnothtmlwhite = /[^\\x20\\t\\r\\n\\f]+/g;\n\n  // Convert String-formatted options into Object-formatted ones\n  function createOptions(options) {\n    var object = {};\n    jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {\n      object[flag] = true;\n    });\n    return object;\n  }\n\n  /*\n   * Create a callback list using the following parameters:\n   *\n   *\toptions: an optional list of space-separated options that will change how\n   *\t\t\tthe callback list behaves or a more traditional option object\n   *\n   * By default a callback list will act like an event callback list and can be\n   * \"fired\" multiple times.\n   *\n   * Possible options:\n   *\n   *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n   *\n   *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n   *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n   *\t\t\t\t\tvalues (like a Deferred)\n   *\n   *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n   *\n   *\tstopOnFalse:\tinterrupt callings when a callback returns false\n   *\n   */\n  jQuery.Callbacks = function (options) {\n    // Convert options from String-formatted to Object-formatted if needed\n    // (we check in cache first)\n    options = typeof options === \"string\" ? createOptions(options) : jQuery.extend({}, options);\n    var\n      // Flag to know if list is currently firing\n      firing,\n      // Last fire value for non-forgettable lists\n      memory,\n      // Flag to know if list was already fired\n      _fired,\n      // Flag to prevent firing\n      _locked,\n      // Actual callback list\n      list = [],\n      // Queue of execution data for repeatable lists\n      queue = [],\n      // Index of currently firing callback (modified by add/remove as needed)\n      firingIndex = -1,\n      // Fire callbacks\n      fire = function fire() {\n        // Enforce single-firing\n        _locked = _locked || options.once;\n\n        // Execute callbacks for all pending executions,\n        // respecting firingIndex overrides and runtime changes\n        _fired = firing = true;\n        for (; queue.length; firingIndex = -1) {\n          memory = queue.shift();\n          while (++firingIndex < list.length) {\n            // Run callback and check for early termination\n            if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {\n              // Jump to end and forget the data so .add doesn't re-fire\n              firingIndex = list.length;\n              memory = false;\n            }\n          }\n        }\n\n        // Forget the data if we're done with it\n        if (!options.memory) {\n          memory = false;\n        }\n        firing = false;\n\n        // Clean up if we're done firing for good\n        if (_locked) {\n          // Keep an empty list if we have data for future add calls\n          if (memory) {\n            list = [];\n\n            // Otherwise, this object is spent\n          } else {\n            list = \"\";\n          }\n        }\n      },\n      // Actual Callbacks object\n      self = {\n        // Add a callback or a collection of callbacks to the list\n        add: function add() {\n          if (list) {\n            // If we have memory from a past run, we should fire after adding\n            if (memory && !firing) {\n              firingIndex = list.length - 1;\n              queue.push(memory);\n            }\n            (function add(args) {\n              jQuery.each(args, function (_, arg) {\n                if (isFunction(arg)) {\n                  if (!options.unique || !self.has(arg)) {\n                    list.push(arg);\n                  }\n                } else if (arg && arg.length && toType(arg) !== \"string\") {\n                  // Inspect recursively\n                  add(arg);\n                }\n              });\n            })(arguments);\n            if (memory && !firing) {\n              fire();\n            }\n          }\n          return this;\n        },\n        // Remove a callback from the list\n        remove: function remove() {\n          jQuery.each(arguments, function (_, arg) {\n            var index;\n            while ((index = jQuery.inArray(arg, list, index)) > -1) {\n              list.splice(index, 1);\n\n              // Handle firing indexes\n              if (index <= firingIndex) {\n                firingIndex--;\n              }\n            }\n          });\n          return this;\n        },\n        // Check if a given callback is in the list.\n        // If no argument is given, return whether or not list has callbacks attached.\n        has: function has(fn) {\n          return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;\n        },\n        // Remove all callbacks from the list\n        empty: function empty() {\n          if (list) {\n            list = [];\n          }\n          return this;\n        },\n        // Disable .fire and .add\n        // Abort any current/pending executions\n        // Clear all callbacks and values\n        disable: function disable() {\n          _locked = queue = [];\n          list = memory = \"\";\n          return this;\n        },\n        disabled: function disabled() {\n          return !list;\n        },\n        // Disable .fire\n        // Also disable .add unless we have memory (since it would have no effect)\n        // Abort any pending executions\n        lock: function lock() {\n          _locked = queue = [];\n          if (!memory && !firing) {\n            list = memory = \"\";\n          }\n          return this;\n        },\n        locked: function locked() {\n          return !!_locked;\n        },\n        // Call all callbacks with the given context and arguments\n        fireWith: function fireWith(context, args) {\n          if (!_locked) {\n            args = args || [];\n            args = [context, args.slice ? args.slice() : args];\n            queue.push(args);\n            if (!firing) {\n              fire();\n            }\n          }\n          return this;\n        },\n        // Call all the callbacks with the given arguments\n        fire: function fire() {\n          self.fireWith(this, arguments);\n          return this;\n        },\n        // To know if the callbacks have already been called at least once\n        fired: function fired() {\n          return !!_fired;\n        }\n      };\n    return self;\n  };\n  function Identity(v) {\n    return v;\n  }\n  function Thrower(ex) {\n    throw ex;\n  }\n  function adoptValue(value, resolve, reject, noValue) {\n    var method;\n    try {\n      // Check for promise aspect first to privilege synchronous behavior\n      if (value && isFunction(method = value.promise)) {\n        method.call(value).done(resolve).fail(reject);\n\n        // Other thenables\n      } else if (value && isFunction(method = value.then)) {\n        method.call(value, resolve, reject);\n\n        // Other non-thenables\n      } else {\n        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n        // * false: [ value ].slice( 0 ) => resolve( value )\n        // * true: [ value ].slice( 1 ) => resolve()\n        resolve.apply(undefined, [value].slice(noValue));\n      }\n\n      // For Promises/A+, convert exceptions into rejections\n      // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n      // Deferred#then to conditionally suppress rejection.\n    } catch (value) {\n      // Support: Android 4.0 only\n      // Strict mode functions invoked without .call/.apply get global-object context\n      reject.apply(undefined, [value]);\n    }\n  }\n  jQuery.extend({\n    Deferred: function Deferred(func) {\n      var tuples = [\n        // action, add listener, callbacks,\n        // ... .then handlers, argument index, [final state]\n        [\"notify\", \"progress\", jQuery.Callbacks(\"memory\"), jQuery.Callbacks(\"memory\"), 2], [\"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), jQuery.Callbacks(\"once memory\"), 0, \"resolved\"], [\"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), jQuery.Callbacks(\"once memory\"), 1, \"rejected\"]],\n        _state = \"pending\",\n        _promise = {\n          state: function state() {\n            return _state;\n          },\n          always: function always() {\n            deferred.done(arguments).fail(arguments);\n            return this;\n          },\n          \"catch\": function _catch(fn) {\n            return _promise.then(null, fn);\n          },\n          // Keep pipe for back-compat\n          pipe: function pipe( /* fnDone, fnFail, fnProgress */\n          ) {\n            var fns = arguments;\n            return jQuery.Deferred(function (newDefer) {\n              jQuery.each(tuples, function (_i, tuple) {\n                // Map tuples (progress, done, fail) to arguments (done, fail, progress)\n                var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];\n\n                // deferred.progress(function() { bind to newDefer or newDefer.notify })\n                // deferred.done(function() { bind to newDefer or newDefer.resolve })\n                // deferred.fail(function() { bind to newDefer or newDefer.reject })\n                deferred[tuple[1]](function () {\n                  var returned = fn && fn.apply(this, arguments);\n                  if (returned && isFunction(returned.promise)) {\n                    returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);\n                  } else {\n                    newDefer[tuple[0] + \"With\"](this, fn ? [returned] : arguments);\n                  }\n                });\n              });\n              fns = null;\n            }).promise();\n          },\n          then: function then(onFulfilled, onRejected, onProgress) {\n            var maxDepth = 0;\n            function resolve(depth, deferred, handler, special) {\n              return function () {\n                var that = this,\n                  args = arguments,\n                  mightThrow = function mightThrow() {\n                    var returned, then;\n\n                    // Support: Promises/A+ section 2.3.3.3.3\n                    // https://promisesaplus.com/#point-59\n                    // Ignore double-resolution attempts\n                    if (depth < maxDepth) {\n                      return;\n                    }\n                    returned = handler.apply(that, args);\n\n                    // Support: Promises/A+ section 2.3.1\n                    // https://promisesaplus.com/#point-48\n                    if (returned === deferred.promise()) {\n                      throw new TypeError(\"Thenable self-resolution\");\n                    }\n\n                    // Support: Promises/A+ sections 2.3.3.1, 3.5\n                    // https://promisesaplus.com/#point-54\n                    // https://promisesaplus.com/#point-75\n                    // Retrieve `then` only once\n                    then = returned && (\n                    // Support: Promises/A+ section 2.3.4\n                    // https://promisesaplus.com/#point-64\n                    // Only check objects and functions for thenability\n                    _typeof(returned) === \"object\" || typeof returned === \"function\") && returned.then;\n\n                    // Handle a returned thenable\n                    if (isFunction(then)) {\n                      // Special processors (notify) just wait for resolution\n                      if (special) {\n                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));\n\n                        // Normal processors (resolve) also hook into progress\n                      } else {\n                        // ...and disregard older resolution values\n                        maxDepth++;\n                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));\n                      }\n\n                      // Handle all other returned values\n                    } else {\n                      // Only substitute handlers pass on context\n                      // and multiple values (non-spec behavior)\n                      if (handler !== Identity) {\n                        that = undefined;\n                        args = [returned];\n                      }\n\n                      // Process the value(s)\n                      // Default process is resolve\n                      (special || deferred.resolveWith)(that, args);\n                    }\n                  },\n                  // Only normal processors (resolve) catch and reject exceptions\n                  process = special ? mightThrow : function () {\n                    try {\n                      mightThrow();\n                    } catch (e) {\n                      if (jQuery.Deferred.exceptionHook) {\n                        jQuery.Deferred.exceptionHook(e, process.stackTrace);\n                      }\n\n                      // Support: Promises/A+ section 2.3.3.3.4.1\n                      // https://promisesaplus.com/#point-61\n                      // Ignore post-resolution exceptions\n                      if (depth + 1 >= maxDepth) {\n                        // Only substitute handlers pass on context\n                        // and multiple values (non-spec behavior)\n                        if (handler !== Thrower) {\n                          that = undefined;\n                          args = [e];\n                        }\n                        deferred.rejectWith(that, args);\n                      }\n                    }\n                  };\n\n                // Support: Promises/A+ section 2.3.3.3.1\n                // https://promisesaplus.com/#point-57\n                // Re-resolve promises immediately to dodge false rejection from\n                // subsequent errors\n                if (depth) {\n                  process();\n                } else {\n                  // Call an optional hook to record the stack, in case of exception\n                  // since it's otherwise lost when execution goes async\n                  if (jQuery.Deferred.getStackHook) {\n                    process.stackTrace = jQuery.Deferred.getStackHook();\n                  }\n                  window.setTimeout(process);\n                }\n              };\n            }\n            return jQuery.Deferred(function (newDefer) {\n              // progress_handlers.add( ... )\n              tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));\n\n              // fulfilled_handlers.add( ... )\n              tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));\n\n              // rejected_handlers.add( ... )\n              tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));\n            }).promise();\n          },\n          // Get a promise for this deferred\n          // If obj is provided, the promise aspect is added to the object\n          promise: function promise(obj) {\n            return obj != null ? jQuery.extend(obj, _promise) : _promise;\n          }\n        },\n        deferred = {};\n\n      // Add list-specific methods\n      jQuery.each(tuples, function (i, tuple) {\n        var list = tuple[2],\n          stateString = tuple[5];\n\n        // promise.progress = list.add\n        // promise.done = list.add\n        // promise.fail = list.add\n        _promise[tuple[1]] = list.add;\n\n        // Handle state\n        if (stateString) {\n          list.add(function () {\n            // state = \"resolved\" (i.e., fulfilled)\n            // state = \"rejected\"\n            _state = stateString;\n          },\n          // rejected_callbacks.disable\n          // fulfilled_callbacks.disable\n          tuples[3 - i][2].disable,\n          // rejected_handlers.disable\n          // fulfilled_handlers.disable\n          tuples[3 - i][3].disable,\n          // progress_callbacks.lock\n          tuples[0][2].lock,\n          // progress_handlers.lock\n          tuples[0][3].lock);\n        }\n\n        // progress_handlers.fire\n        // fulfilled_handlers.fire\n        // rejected_handlers.fire\n        list.add(tuple[3].fire);\n\n        // deferred.notify = function() { deferred.notifyWith(...) }\n        // deferred.resolve = function() { deferred.resolveWith(...) }\n        // deferred.reject = function() { deferred.rejectWith(...) }\n        deferred[tuple[0]] = function () {\n          deferred[tuple[0] + \"With\"](this === deferred ? undefined : this, arguments);\n          return this;\n        };\n\n        // deferred.notifyWith = list.fireWith\n        // deferred.resolveWith = list.fireWith\n        // deferred.rejectWith = list.fireWith\n        deferred[tuple[0] + \"With\"] = list.fireWith;\n      });\n\n      // Make the deferred a promise\n      _promise.promise(deferred);\n\n      // Call given func if any\n      if (func) {\n        func.call(deferred, deferred);\n      }\n\n      // All done!\n      return deferred;\n    },\n    // Deferred helper\n    when: function when(singleValue) {\n      var\n        // count of uncompleted subordinates\n        remaining = arguments.length,\n        // count of unprocessed arguments\n        i = remaining,\n        // subordinate fulfillment data\n        resolveContexts = Array(i),\n        resolveValues = _slice.call(arguments),\n        // the primary Deferred\n        primary = jQuery.Deferred(),\n        // subordinate callback factory\n        updateFunc = function updateFunc(i) {\n          return function (value) {\n            resolveContexts[i] = this;\n            resolveValues[i] = arguments.length > 1 ? _slice.call(arguments) : value;\n            if (! --remaining) {\n              primary.resolveWith(resolveContexts, resolveValues);\n            }\n          };\n        };\n\n      // Single- and empty arguments are adopted like Promise.resolve\n      if (remaining <= 1) {\n        adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject, !remaining);\n\n        // Use .then() to unwrap secondary thenables (cf. gh-3000)\n        if (primary.state() === \"pending\" || isFunction(resolveValues[i] && resolveValues[i].then)) {\n          return primary.then();\n        }\n      }\n\n      // Multiple arguments are aggregated like Promise.all array elements\n      while (i--) {\n        adoptValue(resolveValues[i], updateFunc(i), primary.reject);\n      }\n      return primary.promise();\n    }\n  });\n\n  // These usually indicate a programmer mistake during development,\n  // warn about them ASAP rather than swallowing them by default.\n  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n  jQuery.Deferred.exceptionHook = function (error, stack) {\n    // Support: IE 8 - 9 only\n    // Console exists when dev tools are open, which can happen at any time\n    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {\n      window.console.warn(\"jQuery.Deferred exception: \" + error.message, error.stack, stack);\n    }\n  };\n  jQuery.readyException = function (error) {\n    window.setTimeout(function () {\n      throw error;\n    });\n  };\n\n  // The deferred used on DOM ready\n  var readyList = jQuery.Deferred();\n  jQuery.fn.ready = function (fn) {\n    readyList.then(fn)\n\n    // Wrap jQuery.readyException in a function so that the lookup\n    // happens at the time of error handling instead of callback\n    // registration.\n    [\"catch\"](function (error) {\n      jQuery.readyException(error);\n    });\n    return this;\n  };\n  jQuery.extend({\n    // Is the DOM ready to be used? Set to true once it occurs.\n    isReady: false,\n    // A counter to track how many items to wait for before\n    // the ready event fires. See #6781\n    readyWait: 1,\n    // Handle when the DOM is ready\n    ready: function ready(wait) {\n      // Abort if there are pending holds or we're already ready\n      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {\n        return;\n      }\n\n      // Remember that the DOM is ready\n      jQuery.isReady = true;\n\n      // If a normal DOM Ready event fired, decrement, and wait if need be\n      if (wait !== true && --jQuery.readyWait > 0) {\n        return;\n      }\n\n      // If there are functions bound, to execute\n      readyList.resolveWith(document, [jQuery]);\n    }\n  });\n  jQuery.ready.then = readyList.then;\n\n  // The ready event handler and self cleanup method\n  function completed() {\n    document.removeEventListener(\"DOMContentLoaded\", completed);\n    window.removeEventListener(\"load\", completed);\n    jQuery.ready();\n  }\n\n  // Catch cases where $(document).ready() is called\n  // after the browser event has already occurred.\n  // Support: IE <=9 - 10 only\n  // Older IE sometimes signals \"interactive\" too soon\n  if (document.readyState === \"complete\" || document.readyState !== \"loading\" && !document.documentElement.doScroll) {\n    // Handle it asynchronously to allow scripts the opportunity to delay ready\n    window.setTimeout(jQuery.ready);\n  } else {\n    // Use the handy event callback\n    document.addEventListener(\"DOMContentLoaded\", completed);\n\n    // A fallback to window.onload, that will always work\n    window.addEventListener(\"load\", completed);\n  }\n\n  // Multifunctional method to get and set values of a collection\n  // The value/s can optionally be executed if it's a function\n  var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {\n    var i = 0,\n      len = elems.length,\n      bulk = key == null;\n\n    // Sets many values\n    if (toType(key) === \"object\") {\n      chainable = true;\n      for (i in key) {\n        access(elems, fn, i, key[i], true, emptyGet, raw);\n      }\n\n      // Sets one value\n    } else if (value !== undefined) {\n      chainable = true;\n      if (!isFunction(value)) {\n        raw = true;\n      }\n      if (bulk) {\n        // Bulk operations run against the entire set\n        if (raw) {\n          fn.call(elems, value);\n          fn = null;\n\n          // ...except when executing function values\n        } else {\n          bulk = fn;\n          fn = function fn(elem, _key, value) {\n            return bulk.call(jQuery(elem), value);\n          };\n        }\n      }\n      if (fn) {\n        for (; i < len; i++) {\n          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));\n        }\n      }\n    }\n    if (chainable) {\n      return elems;\n    }\n\n    // Gets\n    if (bulk) {\n      return fn.call(elems);\n    }\n    return len ? fn(elems[0], key) : emptyGet;\n  };\n\n  // Matches dashed string for camelizing\n  var rmsPrefix = /^-ms-/,\n    rdashAlpha = /-([a-z])/g;\n\n  // Used by camelCase as callback to replace()\n  function fcamelCase(_all, letter) {\n    return letter.toUpperCase();\n  }\n\n  // Convert dashed to camelCase; used by the css and data modules\n  // Support: IE <=9 - 11, Edge 12 - 15\n  // Microsoft forgot to hump their vendor prefix (#9572)\n  function camelCase(string) {\n    return string.replace(rmsPrefix, \"ms-\").replace(rdashAlpha, fcamelCase);\n  }\n  var acceptData = function acceptData(owner) {\n    // Accepts only:\n    //  - Node\n    //    - Node.ELEMENT_NODE\n    //    - Node.DOCUMENT_NODE\n    //  - Object\n    //    - Any\n    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;\n  };\n  function Data() {\n    this.expando = jQuery.expando + Data.uid++;\n  }\n  Data.uid = 1;\n  Data.prototype = {\n    cache: function cache(owner) {\n      // Check if the owner object already has a cache\n      var value = owner[this.expando];\n\n      // If not, create one\n      if (!value) {\n        value = {};\n\n        // We can accept data for non-element nodes in modern browsers,\n        // but we should not, see #8335.\n        // Always return an empty object.\n        if (acceptData(owner)) {\n          // If it is a node unlikely to be stringify-ed or looped over\n          // use plain assignment\n          if (owner.nodeType) {\n            owner[this.expando] = value;\n\n            // Otherwise secure it in a non-enumerable property\n            // configurable must be true to allow the property to be\n            // deleted when data is removed\n          } else {\n            Object.defineProperty(owner, this.expando, {\n              value: value,\n              configurable: true\n            });\n          }\n        }\n      }\n      return value;\n    },\n    set: function set(owner, data, value) {\n      var prop,\n        cache = this.cache(owner);\n\n      // Handle: [ owner, key, value ] args\n      // Always use camelCase key (gh-2257)\n      if (typeof data === \"string\") {\n        cache[camelCase(data)] = value;\n\n        // Handle: [ owner, { properties } ] args\n      } else {\n        // Copy the properties one-by-one to the cache object\n        for (prop in data) {\n          cache[camelCase(prop)] = data[prop];\n        }\n      }\n      return cache;\n    },\n    get: function get(owner, key) {\n      return key === undefined ? this.cache(owner) :\n      // Always use camelCase key (gh-2257)\n      owner[this.expando] && owner[this.expando][camelCase(key)];\n    },\n    access: function access(owner, key, value) {\n      // In cases where either:\n      //\n      //   1. No key was specified\n      //   2. A string key was specified, but no value provided\n      //\n      // Take the \"read\" path and allow the get method to determine\n      // which value to return, respectively either:\n      //\n      //   1. The entire cache object\n      //   2. The data stored at the key\n      //\n      if (key === undefined || key && typeof key === \"string\" && value === undefined) {\n        return this.get(owner, key);\n      }\n\n      // When the key is not a string, or both a key and value\n      // are specified, set or extend (existing objects) with either:\n      //\n      //   1. An object of properties\n      //   2. A key and value\n      //\n      this.set(owner, key, value);\n\n      // Since the \"set\" path can have two possible entry points\n      // return the expected data based on which path was taken[*]\n      return value !== undefined ? value : key;\n    },\n    remove: function remove(owner, key) {\n      var i,\n        cache = owner[this.expando];\n      if (cache === undefined) {\n        return;\n      }\n      if (key !== undefined) {\n        // Support array or space separated string of keys\n        if (Array.isArray(key)) {\n          // If key is an array of keys...\n          // We always set camelCase keys, so remove that.\n          key = key.map(camelCase);\n        } else {\n          key = camelCase(key);\n\n          // If a key with the spaces exists, use it.\n          // Otherwise, create an array by matching non-whitespace\n          key = key in cache ? [key] : key.match(rnothtmlwhite) || [];\n        }\n        i = key.length;\n        while (i--) {\n          delete cache[key[i]];\n        }\n      }\n\n      // Remove the expando if there's no more data\n      if (key === undefined || jQuery.isEmptyObject(cache)) {\n        // Support: Chrome <=35 - 45\n        // Webkit & Blink performance suffers when deleting properties\n        // from DOM nodes, so set to undefined instead\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n        if (owner.nodeType) {\n          owner[this.expando] = undefined;\n        } else {\n          delete owner[this.expando];\n        }\n      }\n    },\n    hasData: function hasData(owner) {\n      var cache = owner[this.expando];\n      return cache !== undefined && !jQuery.isEmptyObject(cache);\n    }\n  };\n  var dataPriv = new Data();\n  var dataUser = new Data();\n\n  //\tImplementation Summary\n  //\n  //\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n  //\t2. Improve the module's maintainability by reducing the storage\n  //\t\tpaths to a single mechanism.\n  //\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n  //\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n  //\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n  //\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\n  var rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n    rmultiDash = /[A-Z]/g;\n  function getData(data) {\n    if (data === \"true\") {\n      return true;\n    }\n    if (data === \"false\") {\n      return false;\n    }\n    if (data === \"null\") {\n      return null;\n    }\n\n    // Only convert to a number if it doesn't change the string\n    if (data === +data + \"\") {\n      return +data;\n    }\n    if (rbrace.test(data)) {\n      return JSON.parse(data);\n    }\n    return data;\n  }\n  function dataAttr(elem, key, data) {\n    var name;\n\n    // If nothing was found internally, try to fetch any\n    // data from the HTML5 data-* attribute\n    if (data === undefined && elem.nodeType === 1) {\n      name = \"data-\" + key.replace(rmultiDash, \"-$&\").toLowerCase();\n      data = elem.getAttribute(name);\n      if (typeof data === \"string\") {\n        try {\n          data = getData(data);\n        } catch (e) {}\n\n        // Make sure we set the data so it isn't changed later\n        dataUser.set(elem, key, data);\n      } else {\n        data = undefined;\n      }\n    }\n    return data;\n  }\n  jQuery.extend({\n    hasData: function hasData(elem) {\n      return dataUser.hasData(elem) || dataPriv.hasData(elem);\n    },\n    data: function data(elem, name, _data) {\n      return dataUser.access(elem, name, _data);\n    },\n    removeData: function removeData(elem, name) {\n      dataUser.remove(elem, name);\n    },\n    // TODO: Now that all calls to _data and _removeData have been replaced\n    // with direct calls to dataPriv methods, these can be deprecated.\n    _data: function _data(elem, name, data) {\n      return dataPriv.access(elem, name, data);\n    },\n    _removeData: function _removeData(elem, name) {\n      dataPriv.remove(elem, name);\n    }\n  });\n  jQuery.fn.extend({\n    data: function data(key, value) {\n      var i,\n        name,\n        data,\n        elem = this[0],\n        attrs = elem && elem.attributes;\n\n      // Gets all values\n      if (key === undefined) {\n        if (this.length) {\n          data = dataUser.get(elem);\n          if (elem.nodeType === 1 && !dataPriv.get(elem, \"hasDataAttrs\")) {\n            i = attrs.length;\n            while (i--) {\n              // Support: IE 11 only\n              // The attrs elements can be null (#14894)\n              if (attrs[i]) {\n                name = attrs[i].name;\n                if (name.indexOf(\"data-\") === 0) {\n                  name = camelCase(name.slice(5));\n                  dataAttr(elem, name, data[name]);\n                }\n              }\n            }\n            dataPriv.set(elem, \"hasDataAttrs\", true);\n          }\n        }\n        return data;\n      }\n\n      // Sets multiple values\n      if (_typeof(key) === \"object\") {\n        return this.each(function () {\n          dataUser.set(this, key);\n        });\n      }\n      return access(this, function (value) {\n        var data;\n\n        // The calling jQuery object (element matches) is not empty\n        // (and therefore has an element appears at this[ 0 ]) and the\n        // `value` parameter was not undefined. An empty jQuery object\n        // will result in `undefined` for elem = this[ 0 ] which will\n        // throw an exception if an attempt to read a data cache is made.\n        if (elem && value === undefined) {\n          // Attempt to get data from the cache\n          // The key will always be camelCased in Data\n          data = dataUser.get(elem, key);\n          if (data !== undefined) {\n            return data;\n          }\n\n          // Attempt to \"discover\" the data in\n          // HTML5 custom data-* attrs\n          data = dataAttr(elem, key);\n          if (data !== undefined) {\n            return data;\n          }\n\n          // We tried really hard, but the data doesn't exist.\n          return;\n        }\n\n        // Set the data...\n        this.each(function () {\n          // We always store the camelCased key\n          dataUser.set(this, key, value);\n        });\n      }, null, value, arguments.length > 1, null, true);\n    },\n    removeData: function removeData(key) {\n      return this.each(function () {\n        dataUser.remove(this, key);\n      });\n    }\n  });\n  jQuery.extend({\n    queue: function queue(elem, type, data) {\n      var queue;\n      if (elem) {\n        type = (type || \"fx\") + \"queue\";\n        queue = dataPriv.get(elem, type);\n\n        // Speed up dequeue by getting out quickly if this is just a lookup\n        if (data) {\n          if (!queue || Array.isArray(data)) {\n            queue = dataPriv.access(elem, type, jQuery.makeArray(data));\n          } else {\n            queue.push(data);\n          }\n        }\n        return queue || [];\n      }\n    },\n    dequeue: function dequeue(elem, type) {\n      type = type || \"fx\";\n      var queue = jQuery.queue(elem, type),\n        startLength = queue.length,\n        fn = queue.shift(),\n        hooks = jQuery._queueHooks(elem, type),\n        next = function next() {\n          jQuery.dequeue(elem, type);\n        };\n\n      // If the fx queue is dequeued, always remove the progress sentinel\n      if (fn === \"inprogress\") {\n        fn = queue.shift();\n        startLength--;\n      }\n      if (fn) {\n        // Add a progress sentinel to prevent the fx queue from being\n        // automatically dequeued\n        if (type === \"fx\") {\n          queue.unshift(\"inprogress\");\n        }\n\n        // Clear up the last queue stop function\n        delete hooks.stop;\n        fn.call(elem, next, hooks);\n      }\n      if (!startLength && hooks) {\n        hooks.empty.fire();\n      }\n    },\n    // Not public - generate a queueHooks object, or return the current one\n    _queueHooks: function _queueHooks(elem, type) {\n      var key = type + \"queueHooks\";\n      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {\n        empty: jQuery.Callbacks(\"once memory\").add(function () {\n          dataPriv.remove(elem, [type + \"queue\", key]);\n        })\n      });\n    }\n  });\n  jQuery.fn.extend({\n    queue: function queue(type, data) {\n      var setter = 2;\n      if (typeof type !== \"string\") {\n        data = type;\n        type = \"fx\";\n        setter--;\n      }\n      if (arguments.length < setter) {\n        return jQuery.queue(this[0], type);\n      }\n      return data === undefined ? this : this.each(function () {\n        var queue = jQuery.queue(this, type, data);\n\n        // Ensure a hooks for this queue\n        jQuery._queueHooks(this, type);\n        if (type === \"fx\" && queue[0] !== \"inprogress\") {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    dequeue: function dequeue(type) {\n      return this.each(function () {\n        jQuery.dequeue(this, type);\n      });\n    },\n    clearQueue: function clearQueue(type) {\n      return this.queue(type || \"fx\", []);\n    },\n    // Get a promise resolved when queues of a certain type\n    // are emptied (fx is the type by default)\n    promise: function promise(type, obj) {\n      var tmp,\n        count = 1,\n        defer = jQuery.Deferred(),\n        elements = this,\n        i = this.length,\n        resolve = function resolve() {\n          if (! --count) {\n            defer.resolveWith(elements, [elements]);\n          }\n        };\n      if (typeof type !== \"string\") {\n        obj = type;\n        type = undefined;\n      }\n      type = type || \"fx\";\n      while (i--) {\n        tmp = dataPriv.get(elements[i], type + \"queueHooks\");\n        if (tmp && tmp.empty) {\n          count++;\n          tmp.empty.add(resolve);\n        }\n      }\n      resolve();\n      return defer.promise(obj);\n    }\n  });\n  var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n  var rcssNum = new RegExp(\"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\");\n  var cssExpand = [\"Top\", \"Right\", \"Bottom\", \"Left\"];\n  var documentElement = document.documentElement;\n  var isAttached = function isAttached(elem) {\n      return jQuery.contains(elem.ownerDocument, elem);\n    },\n    composed = {\n      composed: true\n    };\n\n  // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\n  // Check attachment across shadow DOM boundaries when possible (gh-3504)\n  // Support: iOS 10.0-10.2 only\n  // Early iOS 10 versions support `attachShadow` but not `getRootNode`,\n  // leading to errors. We need to check for `getRootNode`.\n  if (documentElement.getRootNode) {\n    isAttached = function isAttached(elem) {\n      return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;\n    };\n  }\n  var isHiddenWithinTree = function isHiddenWithinTree(elem, el) {\n    // isHiddenWithinTree might be called from jQuery#filter function;\n    // in that case, element will be second argument\n    elem = el || elem;\n\n    // Inline style trumps all\n    return elem.style.display === \"none\" || elem.style.display === \"\" &&\n    // Otherwise, check computed style\n    // Support: Firefox <=43 - 45\n    // Disconnected elements can have computed display: none, so first confirm that elem is\n    // in the document.\n    isAttached(elem) && jQuery.css(elem, \"display\") === \"none\";\n  };\n  function adjustCSS(elem, prop, valueParts, tween) {\n    var adjusted,\n      scale,\n      maxIterations = 20,\n      currentValue = tween ? function () {\n        return tween.cur();\n      } : function () {\n        return jQuery.css(elem, prop, \"\");\n      },\n      initial = currentValue(),\n      unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? \"\" : \"px\"),\n      // Starting value computation is required for potential unit mismatches\n      initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== \"px\" && +initial) && rcssNum.exec(jQuery.css(elem, prop));\n    if (initialInUnit && initialInUnit[3] !== unit) {\n      // Support: Firefox <=54\n      // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n      initial = initial / 2;\n\n      // Trust units reported by jQuery.css\n      unit = unit || initialInUnit[3];\n\n      // Iteratively approximate from a nonzero starting point\n      initialInUnit = +initial || 1;\n      while (maxIterations--) {\n        // Evaluate and update our best guess (doubling guesses that zero out).\n        // Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n        jQuery.style(elem, prop, initialInUnit + unit);\n        if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {\n          maxIterations = 0;\n        }\n        initialInUnit = initialInUnit / scale;\n      }\n      initialInUnit = initialInUnit * 2;\n      jQuery.style(elem, prop, initialInUnit + unit);\n\n      // Make sure we update the tween properties later on\n      valueParts = valueParts || [];\n    }\n    if (valueParts) {\n      initialInUnit = +initialInUnit || +initial || 0;\n\n      // Apply relative offset (+=/-=) if specified\n      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];\n      if (tween) {\n        tween.unit = unit;\n        tween.start = initialInUnit;\n        tween.end = adjusted;\n      }\n    }\n    return adjusted;\n  }\n  var defaultDisplayMap = {};\n  function getDefaultDisplay(elem) {\n    var temp,\n      doc = elem.ownerDocument,\n      nodeName = elem.nodeName,\n      display = defaultDisplayMap[nodeName];\n    if (display) {\n      return display;\n    }\n    temp = doc.body.appendChild(doc.createElement(nodeName));\n    display = jQuery.css(temp, \"display\");\n    temp.parentNode.removeChild(temp);\n    if (display === \"none\") {\n      display = \"block\";\n    }\n    defaultDisplayMap[nodeName] = display;\n    return display;\n  }\n  function showHide(elements, show) {\n    var display,\n      elem,\n      values = [],\n      index = 0,\n      length = elements.length;\n\n    // Determine new display value for elements that need to change\n    for (; index < length; index++) {\n      elem = elements[index];\n      if (!elem.style) {\n        continue;\n      }\n      display = elem.style.display;\n      if (show) {\n        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n        // check is required in this first loop unless we have a nonempty display value (either\n        // inline or about-to-be-restored)\n        if (display === \"none\") {\n          values[index] = dataPriv.get(elem, \"display\") || null;\n          if (!values[index]) {\n            elem.style.display = \"\";\n          }\n        }\n        if (elem.style.display === \"\" && isHiddenWithinTree(elem)) {\n          values[index] = getDefaultDisplay(elem);\n        }\n      } else {\n        if (display !== \"none\") {\n          values[index] = \"none\";\n\n          // Remember what we're overwriting\n          dataPriv.set(elem, \"display\", display);\n        }\n      }\n    }\n\n    // Set the display of the elements in a second loop to avoid constant reflow\n    for (index = 0; index < length; index++) {\n      if (values[index] != null) {\n        elements[index].style.display = values[index];\n      }\n    }\n    return elements;\n  }\n  jQuery.fn.extend({\n    show: function show() {\n      return showHide(this, true);\n    },\n    hide: function hide() {\n      return showHide(this);\n    },\n    toggle: function toggle(state) {\n      if (typeof state === \"boolean\") {\n        return state ? this.show() : this.hide();\n      }\n      return this.each(function () {\n        if (isHiddenWithinTree(this)) {\n          jQuery(this).show();\n        } else {\n          jQuery(this).hide();\n        }\n      });\n    }\n  });\n  var rcheckableType = /^(?:checkbox|radio)$/i;\n  var rtagName = /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i;\n  var rscriptType = /^$|^module$|\\/(?:java|ecma)script/i;\n  (function () {\n    var fragment = document.createDocumentFragment(),\n      div = fragment.appendChild(document.createElement(\"div\")),\n      input = document.createElement(\"input\");\n\n    // Support: Android 4.0 - 4.3 only\n    // Check state lost if the name is set (#11217)\n    // Support: Windows Web Apps (WWA)\n    // `name` and `type` must use .setAttribute for WWA (#14901)\n    input.setAttribute(\"type\", \"radio\");\n    input.setAttribute(\"checked\", \"checked\");\n    input.setAttribute(\"name\", \"t\");\n    div.appendChild(input);\n\n    // Support: Android <=4.1 only\n    // Older WebKit doesn't clone checked state correctly in fragments\n    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;\n\n    // Support: IE <=11 only\n    // Make sure textarea (and checkbox) defaultValue is properly cloned\n    div.innerHTML = \"<textarea>x</textarea>\";\n    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;\n\n    // Support: IE <=9 only\n    // IE <=9 replaces <option> tags with their contents when inserted outside of\n    // the select element.\n    div.innerHTML = \"<option></option>\";\n    support.option = !!div.lastChild;\n  })();\n\n  // We have to close these tags to support XHTML (#13200)\n  var wrapMap = {\n    // XHTML parsers do not magically insert elements in the\n    // same way that tag soup parsers do. So we cannot shorten\n    // this by omitting <tbody> or other required elements.\n    thead: [1, \"<table>\", \"</table>\"],\n    col: [2, \"<table><colgroup>\", \"</colgroup></table>\"],\n    tr: [2, \"<table><tbody>\", \"</tbody></table>\"],\n    td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"],\n    _default: [0, \"\", \"\"]\n  };\n  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\n  wrapMap.th = wrapMap.td;\n\n  // Support: IE <=9 only\n  if (!support.option) {\n    wrapMap.optgroup = wrapMap.option = [1, \"<select multiple='multiple'>\", \"</select>\"];\n  }\n  function getAll(context, tag) {\n    // Support: IE <=9 - 11 only\n    // Use typeof to avoid zero-argument method invocation on host objects (#15151)\n    var ret;\n    if (typeof context.getElementsByTagName !== \"undefined\") {\n      ret = context.getElementsByTagName(tag || \"*\");\n    } else if (typeof context.querySelectorAll !== \"undefined\") {\n      ret = context.querySelectorAll(tag || \"*\");\n    } else {\n      ret = [];\n    }\n    if (tag === undefined || tag && nodeName(context, tag)) {\n      return jQuery.merge([context], ret);\n    }\n    return ret;\n  }\n\n  // Mark scripts as having already been evaluated\n  function setGlobalEval(elems, refElements) {\n    var i = 0,\n      l = elems.length;\n    for (; i < l; i++) {\n      dataPriv.set(elems[i], \"globalEval\", !refElements || dataPriv.get(refElements[i], \"globalEval\"));\n    }\n  }\n  var rhtml = /<|&#?\\w+;/;\n  function buildFragment(elems, context, scripts, selection, ignored) {\n    var elem,\n      tmp,\n      tag,\n      wrap,\n      attached,\n      j,\n      fragment = context.createDocumentFragment(),\n      nodes = [],\n      i = 0,\n      l = elems.length;\n    for (; i < l; i++) {\n      elem = elems[i];\n      if (elem || elem === 0) {\n        // Add nodes directly\n        if (toType(elem) === \"object\") {\n          // Support: Android <=4.0 only, PhantomJS 1 only\n          // push.apply(_, arraylike) throws on ancient WebKit\n          jQuery.merge(nodes, elem.nodeType ? [elem] : elem);\n\n          // Convert non-html into a text node\n        } else if (!rhtml.test(elem)) {\n          nodes.push(context.createTextNode(elem));\n\n          // Convert html into DOM nodes\n        } else {\n          tmp = tmp || fragment.appendChild(context.createElement(\"div\"));\n\n          // Deserialize a standard representation\n          tag = (rtagName.exec(elem) || [\"\", \"\"])[1].toLowerCase();\n          wrap = wrapMap[tag] || wrapMap._default;\n          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];\n\n          // Descend through wrappers to the right content\n          j = wrap[0];\n          while (j--) {\n            tmp = tmp.lastChild;\n          }\n\n          // Support: Android <=4.0 only, PhantomJS 1 only\n          // push.apply(_, arraylike) throws on ancient WebKit\n          jQuery.merge(nodes, tmp.childNodes);\n\n          // Remember the top-level container\n          tmp = fragment.firstChild;\n\n          // Ensure the created nodes are orphaned (#12392)\n          tmp.textContent = \"\";\n        }\n      }\n    }\n\n    // Remove wrapper from fragment\n    fragment.textContent = \"\";\n    i = 0;\n    while (elem = nodes[i++]) {\n      // Skip elements already in the context collection (trac-4087)\n      if (selection && jQuery.inArray(elem, selection) > -1) {\n        if (ignored) {\n          ignored.push(elem);\n        }\n        continue;\n      }\n      attached = isAttached(elem);\n\n      // Append to fragment\n      tmp = getAll(fragment.appendChild(elem), \"script\");\n\n      // Preserve script evaluation history\n      if (attached) {\n        setGlobalEval(tmp);\n      }\n\n      // Capture executables\n      if (scripts) {\n        j = 0;\n        while (elem = tmp[j++]) {\n          if (rscriptType.test(elem.type || \"\")) {\n            scripts.push(elem);\n          }\n        }\n      }\n    }\n    return fragment;\n  }\n  var rtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n  function returnTrue() {\n    return true;\n  }\n  function returnFalse() {\n    return false;\n  }\n\n  // Support: IE <=9 - 11+\n  // focus() and blur() are asynchronous, except when they are no-op.\n  // So expect focus to be synchronous when the element is already active,\n  // and blur to be synchronous when the element is not already active.\n  // (focus and blur are always synchronous in other supported browsers,\n  // this just defines when we can count on it).\n  function expectSync(elem, type) {\n    return elem === safeActiveElement() === (type === \"focus\");\n  }\n\n  // Support: IE <=9 only\n  // Accessing document.activeElement can throw unexpectedly\n  // https://bugs.jquery.com/ticket/13393\n  function safeActiveElement() {\n    try {\n      return document.activeElement;\n    } catch (err) {}\n  }\n  function _on(elem, types, selector, data, fn, one) {\n    var origFn, type;\n\n    // Types can be a map of types/handlers\n    if (_typeof(types) === \"object\") {\n      // ( types-Object, selector, data )\n      if (typeof selector !== \"string\") {\n        // ( types-Object, data )\n        data = data || selector;\n        selector = undefined;\n      }\n      for (type in types) {\n        _on(elem, type, selector, data, types[type], one);\n      }\n      return elem;\n    }\n    if (data == null && fn == null) {\n      // ( types, fn )\n      fn = selector;\n      data = selector = undefined;\n    } else if (fn == null) {\n      if (typeof selector === \"string\") {\n        // ( types, selector, fn )\n        fn = data;\n        data = undefined;\n      } else {\n        // ( types, data, fn )\n        fn = data;\n        data = selector;\n        selector = undefined;\n      }\n    }\n    if (fn === false) {\n      fn = returnFalse;\n    } else if (!fn) {\n      return elem;\n    }\n    if (one === 1) {\n      origFn = fn;\n      fn = function fn(event) {\n        // Can use an empty set, since event contains the info\n        jQuery().off(event);\n        return origFn.apply(this, arguments);\n      };\n\n      // Use same guid so caller can remove using origFn\n      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);\n    }\n    return elem.each(function () {\n      jQuery.event.add(this, types, fn, data, selector);\n    });\n  }\n\n  /*\n   * Helper functions for managing events -- not part of the public interface.\n   * Props to Dean Edwards' addEvent library for many of the ideas.\n   */\n  jQuery.event = {\n    global: {},\n    add: function add(elem, types, handler, data, selector) {\n      var handleObjIn,\n        eventHandle,\n        tmp,\n        events,\n        t,\n        handleObj,\n        special,\n        handlers,\n        type,\n        namespaces,\n        origType,\n        elemData = dataPriv.get(elem);\n\n      // Only attach events to objects that accept data\n      if (!acceptData(elem)) {\n        return;\n      }\n\n      // Caller can pass in an object of custom data in lieu of the handler\n      if (handler.handler) {\n        handleObjIn = handler;\n        handler = handleObjIn.handler;\n        selector = handleObjIn.selector;\n      }\n\n      // Ensure that invalid selectors throw exceptions at attach time\n      // Evaluate against documentElement in case elem is a non-element node (e.g., document)\n      if (selector) {\n        jQuery.find.matchesSelector(documentElement, selector);\n      }\n\n      // Make sure that the handler has a unique ID, used to find/remove it later\n      if (!handler.guid) {\n        handler.guid = jQuery.guid++;\n      }\n\n      // Init the element's event structure and main handler, if this is the first\n      if (!(events = elemData.events)) {\n        events = elemData.events = Object.create(null);\n      }\n      if (!(eventHandle = elemData.handle)) {\n        eventHandle = elemData.handle = function (e) {\n          // Discard the second event of a jQuery.event.trigger() and\n          // when an event is called after a page has unloaded\n          return typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;\n        };\n      }\n\n      // Handle multiple events separated by a space\n      types = (types || \"\").match(rnothtmlwhite) || [\"\"];\n      t = types.length;\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || \"\").split(\".\").sort();\n\n        // There *must* be a type, no attaching namespace-only handlers\n        if (!type) {\n          continue;\n        }\n\n        // If event changes its type, use the special event handlers for the changed type\n        special = jQuery.event.special[type] || {};\n\n        // If selector defined, determine special event api type, otherwise given type\n        type = (selector ? special.delegateType : special.bindType) || type;\n\n        // Update special based on newly reset type\n        special = jQuery.event.special[type] || {};\n\n        // handleObj is passed to all event handlers\n        handleObj = jQuery.extend({\n          type: type,\n          origType: origType,\n          data: data,\n          handler: handler,\n          guid: handler.guid,\n          selector: selector,\n          needsContext: selector && jQuery.expr.match.needsContext.test(selector),\n          namespace: namespaces.join(\".\")\n        }, handleObjIn);\n\n        // Init the event handler queue if we're the first\n        if (!(handlers = events[type])) {\n          handlers = events[type] = [];\n          handlers.delegateCount = 0;\n\n          // Only use addEventListener if the special events handler returns false\n          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n            if (elem.addEventListener) {\n              elem.addEventListener(type, eventHandle);\n            }\n          }\n        }\n        if (special.add) {\n          special.add.call(elem, handleObj);\n          if (!handleObj.handler.guid) {\n            handleObj.handler.guid = handler.guid;\n          }\n        }\n\n        // Add to the element's handler list, delegates in front\n        if (selector) {\n          handlers.splice(handlers.delegateCount++, 0, handleObj);\n        } else {\n          handlers.push(handleObj);\n        }\n\n        // Keep track of which events have ever been used, for event optimization\n        jQuery.event.global[type] = true;\n      }\n    },\n    // Detach an event or set of events from an element\n    remove: function remove(elem, types, handler, selector, mappedTypes) {\n      var j,\n        origCount,\n        tmp,\n        events,\n        t,\n        handleObj,\n        special,\n        handlers,\n        type,\n        namespaces,\n        origType,\n        elemData = dataPriv.hasData(elem) && dataPriv.get(elem);\n      if (!elemData || !(events = elemData.events)) {\n        return;\n      }\n\n      // Once for each type.namespace in types; type may be omitted\n      types = (types || \"\").match(rnothtmlwhite) || [\"\"];\n      t = types.length;\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || [];\n        type = origType = tmp[1];\n        namespaces = (tmp[2] || \"\").split(\".\").sort();\n\n        // Unbind all events (on this namespace, if provided) for the element\n        if (!type) {\n          for (type in events) {\n            jQuery.event.remove(elem, type + types[t], handler, selector, true);\n          }\n          continue;\n        }\n        special = jQuery.event.special[type] || {};\n        type = (selector ? special.delegateType : special.bindType) || type;\n        handlers = events[type] || [];\n        tmp = tmp[2] && new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\");\n\n        // Remove matching events\n        origCount = j = handlers.length;\n        while (j--) {\n          handleObj = handlers[j];\n          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector)) {\n            handlers.splice(j, 1);\n            if (handleObj.selector) {\n              handlers.delegateCount--;\n            }\n            if (special.remove) {\n              special.remove.call(elem, handleObj);\n            }\n          }\n        }\n\n        // Remove generic event handler if we removed something and no more handlers exist\n        // (avoids potential for endless recursion during removal of special event handlers)\n        if (origCount && !handlers.length) {\n          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\n            jQuery.removeEvent(elem, type, elemData.handle);\n          }\n          delete events[type];\n        }\n      }\n\n      // Remove data and the expando if it's no longer used\n      if (jQuery.isEmptyObject(events)) {\n        dataPriv.remove(elem, \"handle events\");\n      }\n    },\n    dispatch: function dispatch(nativeEvent) {\n      var i,\n        j,\n        ret,\n        matched,\n        handleObj,\n        handlerQueue,\n        args = new Array(arguments.length),\n        // Make a writable jQuery.Event from the native event object\n        event = jQuery.event.fix(nativeEvent),\n        handlers = (dataPriv.get(this, \"events\") || Object.create(null))[event.type] || [],\n        special = jQuery.event.special[event.type] || {};\n\n      // Use the fix-ed jQuery.Event rather than the (read-only) native event\n      args[0] = event;\n      for (i = 1; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      }\n      event.delegateTarget = this;\n\n      // Call the preDispatch hook for the mapped type, and let it bail if desired\n      if (special.preDispatch && special.preDispatch.call(this, event) === false) {\n        return;\n      }\n\n      // Determine handlers\n      handlerQueue = jQuery.event.handlers.call(this, event, handlers);\n\n      // Run delegates first; they may want to stop propagation beneath us\n      i = 0;\n      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n        event.currentTarget = matched.elem;\n        j = 0;\n        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\n          // If the event is namespaced, then each handler is only invoked if it is\n          // specially universal or its namespaces are a superset of the event's.\n          if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {\n            event.handleObj = handleObj;\n            event.data = handleObj.data;\n            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);\n            if (ret !== undefined) {\n              if ((event.result = ret) === false) {\n                event.preventDefault();\n                event.stopPropagation();\n              }\n            }\n          }\n        }\n      }\n\n      // Call the postDispatch hook for the mapped type\n      if (special.postDispatch) {\n        special.postDispatch.call(this, event);\n      }\n      return event.result;\n    },\n    handlers: function handlers(event, _handlers) {\n      var i,\n        handleObj,\n        sel,\n        matchedHandlers,\n        matchedSelectors,\n        handlerQueue = [],\n        delegateCount = _handlers.delegateCount,\n        cur = event.target;\n\n      // Find delegate handlers\n      if (delegateCount &&\n      // Support: IE <=9\n      // Black-hole SVG <use> instance trees (trac-13180)\n      cur.nodeType &&\n      // Support: Firefox <=42\n      // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n      // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n      // Support: IE 11 only\n      // ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n      !(event.type === \"click\" && event.button >= 1)) {\n        for (; cur !== this; cur = cur.parentNode || this) {\n          // Don't check non-elements (#13208)\n          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n          if (cur.nodeType === 1 && !(event.type === \"click\" && cur.disabled === true)) {\n            matchedHandlers = [];\n            matchedSelectors = {};\n            for (i = 0; i < delegateCount; i++) {\n              handleObj = _handlers[i];\n\n              // Don't conflict with Object.prototype properties (#13203)\n              sel = handleObj.selector + \" \";\n              if (matchedSelectors[sel] === undefined) {\n                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;\n              }\n              if (matchedSelectors[sel]) {\n                matchedHandlers.push(handleObj);\n              }\n            }\n            if (matchedHandlers.length) {\n              handlerQueue.push({\n                elem: cur,\n                handlers: matchedHandlers\n              });\n            }\n          }\n        }\n      }\n\n      // Add the remaining (directly-bound) handlers\n      cur = this;\n      if (delegateCount < _handlers.length) {\n        handlerQueue.push({\n          elem: cur,\n          handlers: _handlers.slice(delegateCount)\n        });\n      }\n      return handlerQueue;\n    },\n    addProp: function addProp(name, hook) {\n      Object.defineProperty(jQuery.Event.prototype, name, {\n        enumerable: true,\n        configurable: true,\n        get: isFunction(hook) ? function () {\n          if (this.originalEvent) {\n            return hook(this.originalEvent);\n          }\n        } : function () {\n          if (this.originalEvent) {\n            return this.originalEvent[name];\n          }\n        },\n        set: function set(value) {\n          Object.defineProperty(this, name, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: value\n          });\n        }\n      });\n    },\n    fix: function fix(originalEvent) {\n      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);\n    },\n    special: {\n      load: {\n        // Prevent triggered image.load events from bubbling to window.load\n        noBubble: true\n      },\n      click: {\n        // Utilize native event to ensure correct state for checkable inputs\n        setup: function setup(data) {\n          // For mutual compressibility with _default, replace `this` access with a local var.\n          // `|| data` is dead code meant only to preserve the variable through minification.\n          var el = this || data;\n\n          // Claim the first handler\n          if (rcheckableType.test(el.type) && el.click && nodeName(el, \"input\")) {\n            // dataPriv.set( el, \"click\", ... )\n            leverageNative(el, \"click\", returnTrue);\n          }\n\n          // Return false to allow normal processing in the caller\n          return false;\n        },\n        trigger: function trigger(data) {\n          // For mutual compressibility with _default, replace `this` access with a local var.\n          // `|| data` is dead code meant only to preserve the variable through minification.\n          var el = this || data;\n\n          // Force setup before triggering a click\n          if (rcheckableType.test(el.type) && el.click && nodeName(el, \"input\")) {\n            leverageNative(el, \"click\");\n          }\n\n          // Return non-false to allow normal event-path propagation\n          return true;\n        },\n        // For cross-browser consistency, suppress native .click() on links\n        // Also prevent it if we're currently inside a leveraged native-event stack\n        _default: function _default(event) {\n          var target = event.target;\n          return rcheckableType.test(target.type) && target.click && nodeName(target, \"input\") && dataPriv.get(target, \"click\") || nodeName(target, \"a\");\n        }\n      },\n      beforeunload: {\n        postDispatch: function postDispatch(event) {\n          // Support: Firefox 20+\n          // Firefox doesn't alert if the returnValue field is not set.\n          if (event.result !== undefined && event.originalEvent) {\n            event.originalEvent.returnValue = event.result;\n          }\n        }\n      }\n    }\n  };\n\n  // Ensure the presence of an event listener that handles manually-triggered\n  // synthetic events by interrupting progress until reinvoked in response to\n  // *native* events that it fires directly, ensuring that state changes have\n  // already occurred before other listeners are invoked.\n  function leverageNative(el, type, expectSync) {\n    // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add\n    if (!expectSync) {\n      if (dataPriv.get(el, type) === undefined) {\n        jQuery.event.add(el, type, returnTrue);\n      }\n      return;\n    }\n\n    // Register the controller as a special universal handler for all event namespaces\n    dataPriv.set(el, type, false);\n    jQuery.event.add(el, type, {\n      namespace: false,\n      handler: function handler(event) {\n        var notAsync,\n          result,\n          saved = dataPriv.get(this, type);\n        if (event.isTrigger & 1 && this[type]) {\n          // Interrupt processing of the outer synthetic .trigger()ed event\n          // Saved data should be false in such cases, but might be a leftover capture object\n          // from an async native handler (gh-4350)\n          if (!saved.length) {\n            // Store arguments for use when handling the inner native event\n            // There will always be at least one argument (an event object), so this array\n            // will not be confused with a leftover capture object.\n            saved = _slice.call(arguments);\n            dataPriv.set(this, type, saved);\n\n            // Trigger the native event and capture its result\n            // Support: IE <=9 - 11+\n            // focus() and blur() are asynchronous\n            notAsync = expectSync(this, type);\n            this[type]();\n            result = dataPriv.get(this, type);\n            if (saved !== result || notAsync) {\n              dataPriv.set(this, type, false);\n            } else {\n              result = {};\n            }\n            if (saved !== result) {\n              // Cancel the outer synthetic event\n              event.stopImmediatePropagation();\n              event.preventDefault();\n\n              // Support: Chrome 86+\n              // In Chrome, if an element having a focusout handler is blurred by\n              // clicking outside of it, it invokes the handler synchronously. If\n              // that handler calls `.remove()` on the element, the data is cleared,\n              // leaving `result` undefined. We need to guard against this.\n              return result && result.value;\n            }\n\n            // If this is an inner synthetic event for an event with a bubbling surrogate\n            // (focus or blur), assume that the surrogate already propagated from triggering the\n            // native event and prevent that from happening again here.\n            // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\n            // bubbling surrogate propagates *after* the non-bubbling base), but that seems\n            // less bad than duplication.\n          } else if ((jQuery.event.special[type] || {}).delegateType) {\n            event.stopPropagation();\n          }\n\n          // If this is a native event triggered above, everything is now in order\n          // Fire an inner synthetic event with the original arguments\n        } else if (saved.length) {\n          // ...and capture the result\n          dataPriv.set(this, type, {\n            value: jQuery.event.trigger(\n            // Support: IE <=9 - 11+\n            // Extend with the prototype to reset the above stopImmediatePropagation()\n            jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)\n          });\n\n          // Abort handling of the native event\n          event.stopImmediatePropagation();\n        }\n      }\n    });\n  }\n  jQuery.removeEvent = function (elem, type, handle) {\n    // This \"if\" is needed for plain objects\n    if (elem.removeEventListener) {\n      elem.removeEventListener(type, handle);\n    }\n  };\n  jQuery.Event = function (src, props) {\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof jQuery.Event)) {\n      return new jQuery.Event(src, props);\n    }\n\n    // Event object\n    if (src && src.type) {\n      this.originalEvent = src;\n      this.type = src.type;\n\n      // Events bubbling up the document may have been marked as prevented\n      // by a handler lower down the tree; reflect the correct value.\n      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &&\n      // Support: Android <=2.3 only\n      src.returnValue === false ? returnTrue : returnFalse;\n\n      // Create target properties\n      // Support: Safari <=6 - 7 only\n      // Target should not be a text node (#504, #13143)\n      this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;\n      this.currentTarget = src.currentTarget;\n      this.relatedTarget = src.relatedTarget;\n\n      // Event type\n    } else {\n      this.type = src;\n    }\n\n    // Put explicitly provided properties onto the event object\n    if (props) {\n      jQuery.extend(this, props);\n    }\n\n    // Create a timestamp if incoming event doesn't have one\n    this.timeStamp = src && src.timeStamp || Date.now();\n\n    // Mark it as fixed\n    this[jQuery.expando] = true;\n  };\n\n  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n  jQuery.Event.prototype = {\n    constructor: jQuery.Event,\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse,\n    isSimulated: false,\n    preventDefault: function preventDefault() {\n      var e = this.originalEvent;\n      this.isDefaultPrevented = returnTrue;\n      if (e && !this.isSimulated) {\n        e.preventDefault();\n      }\n    },\n    stopPropagation: function stopPropagation() {\n      var e = this.originalEvent;\n      this.isPropagationStopped = returnTrue;\n      if (e && !this.isSimulated) {\n        e.stopPropagation();\n      }\n    },\n    stopImmediatePropagation: function stopImmediatePropagation() {\n      var e = this.originalEvent;\n      this.isImmediatePropagationStopped = returnTrue;\n      if (e && !this.isSimulated) {\n        e.stopImmediatePropagation();\n      }\n      this.stopPropagation();\n    }\n  };\n\n  // Includes all common event props including KeyEvent and MouseEvent specific props\n  jQuery.each({\n    altKey: true,\n    bubbles: true,\n    cancelable: true,\n    changedTouches: true,\n    ctrlKey: true,\n    detail: true,\n    eventPhase: true,\n    metaKey: true,\n    pageX: true,\n    pageY: true,\n    shiftKey: true,\n    view: true,\n    \"char\": true,\n    code: true,\n    charCode: true,\n    key: true,\n    keyCode: true,\n    button: true,\n    buttons: true,\n    clientX: true,\n    clientY: true,\n    offsetX: true,\n    offsetY: true,\n    pointerId: true,\n    pointerType: true,\n    screenX: true,\n    screenY: true,\n    targetTouches: true,\n    toElement: true,\n    touches: true,\n    which: true\n  }, jQuery.event.addProp);\n  jQuery.each({\n    focus: \"focusin\",\n    blur: \"focusout\"\n  }, function (type, delegateType) {\n    jQuery.event.special[type] = {\n      // Utilize native event if possible so blur/focus sequence is correct\n      setup: function setup() {\n        // Claim the first handler\n        // dataPriv.set( this, \"focus\", ... )\n        // dataPriv.set( this, \"blur\", ... )\n        leverageNative(this, type, expectSync);\n\n        // Return false to allow normal processing in the caller\n        return false;\n      },\n      trigger: function trigger() {\n        // Force setup before trigger\n        leverageNative(this, type);\n\n        // Return non-false to allow normal event-path propagation\n        return true;\n      },\n      // Suppress native focus or blur as it's already being fired\n      // in leverageNative.\n      _default: function _default() {\n        return true;\n      },\n      delegateType: delegateType\n    };\n  });\n\n  // Create mouseenter/leave events using mouseover/out and event-time checks\n  // so that event delegation works in jQuery.\n  // Do the same for pointerenter/pointerleave and pointerover/pointerout\n  //\n  // Support: Safari 7 only\n  // Safari sends mouseenter too often; see:\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n  // for the description of the bug (it existed in older Chrome versions as well).\n  jQuery.each({\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\",\n    pointerenter: \"pointerover\",\n    pointerleave: \"pointerout\"\n  }, function (orig, fix) {\n    jQuery.event.special[orig] = {\n      delegateType: fix,\n      bindType: fix,\n      handle: function handle(event) {\n        var ret,\n          target = this,\n          related = event.relatedTarget,\n          handleObj = event.handleObj;\n\n        // For mouseenter/leave call the handler if related is outside the target.\n        // NB: No relatedTarget if the mouse left/entered the browser window\n        if (!related || related !== target && !jQuery.contains(target, related)) {\n          event.type = handleObj.origType;\n          ret = handleObj.handler.apply(this, arguments);\n          event.type = fix;\n        }\n        return ret;\n      }\n    };\n  });\n  jQuery.fn.extend({\n    on: function on(types, selector, data, fn) {\n      return _on(this, types, selector, data, fn);\n    },\n    one: function one(types, selector, data, fn) {\n      return _on(this, types, selector, data, fn, 1);\n    },\n    off: function off(types, selector, fn) {\n      var handleObj, type;\n      if (types && types.preventDefault && types.handleObj) {\n        // ( event )  dispatched jQuery.Event\n        handleObj = types.handleObj;\n        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);\n        return this;\n      }\n      if (_typeof(types) === \"object\") {\n        // ( types-object [, selector] )\n        for (type in types) {\n          this.off(type, selector, types[type]);\n        }\n        return this;\n      }\n      if (selector === false || typeof selector === \"function\") {\n        // ( types [, fn] )\n        fn = selector;\n        selector = undefined;\n      }\n      if (fn === false) {\n        fn = returnFalse;\n      }\n      return this.each(function () {\n        jQuery.event.remove(this, types, fn, selector);\n      });\n    }\n  });\n  var\n    // Support: IE <=10 - 11, Edge 12 - 13 only\n    // In IE/Edge using regex groups here causes severe slowdowns.\n    // See https://connect.microsoft.com/IE/feedback/details/1736512/\n    rnoInnerhtml = /<script|<style|<link/i,\n    // checked=\"checked\" or checked\n    rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n    rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n  // Prefer a tbody over its parent table for containing new rows\n  function manipulationTarget(elem, content) {\n    if (nodeName(elem, \"table\") && nodeName(content.nodeType !== 11 ? content : content.firstChild, \"tr\")) {\n      return jQuery(elem).children(\"tbody\")[0] || elem;\n    }\n    return elem;\n  }\n\n  // Replace/restore the type attribute of script elements for safe DOM manipulation\n  function disableScript(elem) {\n    elem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n    return elem;\n  }\n  function restoreScript(elem) {\n    if ((elem.type || \"\").slice(0, 5) === \"true/\") {\n      elem.type = elem.type.slice(5);\n    } else {\n      elem.removeAttribute(\"type\");\n    }\n    return elem;\n  }\n  function cloneCopyEvent(src, dest) {\n    var i, l, type, pdataOld, udataOld, udataCur, events;\n    if (dest.nodeType !== 1) {\n      return;\n    }\n\n    // 1. Copy private data: events, handlers, etc.\n    if (dataPriv.hasData(src)) {\n      pdataOld = dataPriv.get(src);\n      events = pdataOld.events;\n      if (events) {\n        dataPriv.remove(dest, \"handle events\");\n        for (type in events) {\n          for (i = 0, l = events[type].length; i < l; i++) {\n            jQuery.event.add(dest, type, events[type][i]);\n          }\n        }\n      }\n    }\n\n    // 2. Copy user data\n    if (dataUser.hasData(src)) {\n      udataOld = dataUser.access(src);\n      udataCur = jQuery.extend({}, udataOld);\n      dataUser.set(dest, udataCur);\n    }\n  }\n\n  // Fix IE bugs, see support tests\n  function fixInput(src, dest) {\n    var nodeName = dest.nodeName.toLowerCase();\n\n    // Fails to persist the checked state of a cloned checkbox or radio button.\n    if (nodeName === \"input\" && rcheckableType.test(src.type)) {\n      dest.checked = src.checked;\n\n      // Fails to return the selected option to the default selected state when cloning options\n    } else if (nodeName === \"input\" || nodeName === \"textarea\") {\n      dest.defaultValue = src.defaultValue;\n    }\n  }\n  function domManip(collection, args, callback, ignored) {\n    // Flatten any nested arrays\n    args = flat(args);\n    var fragment,\n      first,\n      scripts,\n      hasScripts,\n      node,\n      doc,\n      i = 0,\n      l = collection.length,\n      iNoClone = l - 1,\n      value = args[0],\n      valueIsFunction = isFunction(value);\n\n    // We can't cloneNode fragments that contain checked, in WebKit\n    if (valueIsFunction || l > 1 && typeof value === \"string\" && !support.checkClone && rchecked.test(value)) {\n      return collection.each(function (index) {\n        var self = collection.eq(index);\n        if (valueIsFunction) {\n          args[0] = value.call(this, index, self.html());\n        }\n        domManip(self, args, callback, ignored);\n      });\n    }\n    if (l) {\n      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);\n      first = fragment.firstChild;\n      if (fragment.childNodes.length === 1) {\n        fragment = first;\n      }\n\n      // Require either new content or an interest in ignored elements to invoke the callback\n      if (first || ignored) {\n        scripts = jQuery.map(getAll(fragment, \"script\"), disableScript);\n        hasScripts = scripts.length;\n\n        // Use the original fragment for the last item\n        // instead of the first because it can end up\n        // being emptied incorrectly in certain situations (#8070).\n        for (; i < l; i++) {\n          node = fragment;\n          if (i !== iNoClone) {\n            node = jQuery.clone(node, true, true);\n\n            // Keep references to cloned scripts for later restoration\n            if (hasScripts) {\n              // Support: Android <=4.0 only, PhantomJS 1 only\n              // push.apply(_, arraylike) throws on ancient WebKit\n              jQuery.merge(scripts, getAll(node, \"script\"));\n            }\n          }\n          callback.call(collection[i], node, i);\n        }\n        if (hasScripts) {\n          doc = scripts[scripts.length - 1].ownerDocument;\n\n          // Reenable scripts\n          jQuery.map(scripts, restoreScript);\n\n          // Evaluate executable scripts on first document insertion\n          for (i = 0; i < hasScripts; i++) {\n            node = scripts[i];\n            if (rscriptType.test(node.type || \"\") && !dataPriv.access(node, \"globalEval\") && jQuery.contains(doc, node)) {\n              if (node.src && (node.type || \"\").toLowerCase() !== \"module\") {\n                // Optional AJAX dependency, but won't run scripts if not present\n                if (jQuery._evalUrl && !node.noModule) {\n                  jQuery._evalUrl(node.src, {\n                    nonce: node.nonce || node.getAttribute(\"nonce\")\n                  }, doc);\n                }\n              } else {\n                DOMEval(node.textContent.replace(rcleanScript, \"\"), node, doc);\n              }\n            }\n          }\n        }\n      }\n    }\n    return collection;\n  }\n  function _remove(elem, selector, keepData) {\n    var node,\n      nodes = selector ? jQuery.filter(selector, elem) : elem,\n      i = 0;\n    for (; (node = nodes[i]) != null; i++) {\n      if (!keepData && node.nodeType === 1) {\n        jQuery.cleanData(getAll(node));\n      }\n      if (node.parentNode) {\n        if (keepData && isAttached(node)) {\n          setGlobalEval(getAll(node, \"script\"));\n        }\n        node.parentNode.removeChild(node);\n      }\n    }\n    return elem;\n  }\n  jQuery.extend({\n    htmlPrefilter: function htmlPrefilter(html) {\n      return html;\n    },\n    clone: function clone(elem, dataAndEvents, deepDataAndEvents) {\n      var i,\n        l,\n        srcElements,\n        destElements,\n        clone = elem.cloneNode(true),\n        inPage = isAttached(elem);\n\n      // Fix IE cloning issues\n      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {\n        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n        destElements = getAll(clone);\n        srcElements = getAll(elem);\n        for (i = 0, l = srcElements.length; i < l; i++) {\n          fixInput(srcElements[i], destElements[i]);\n        }\n      }\n\n      // Copy the events from the original to the clone\n      if (dataAndEvents) {\n        if (deepDataAndEvents) {\n          srcElements = srcElements || getAll(elem);\n          destElements = destElements || getAll(clone);\n          for (i = 0, l = srcElements.length; i < l; i++) {\n            cloneCopyEvent(srcElements[i], destElements[i]);\n          }\n        } else {\n          cloneCopyEvent(elem, clone);\n        }\n      }\n\n      // Preserve script evaluation history\n      destElements = getAll(clone, \"script\");\n      if (destElements.length > 0) {\n        setGlobalEval(destElements, !inPage && getAll(elem, \"script\"));\n      }\n\n      // Return the cloned set\n      return clone;\n    },\n    cleanData: function cleanData(elems) {\n      var data,\n        elem,\n        type,\n        special = jQuery.event.special,\n        i = 0;\n      for (; (elem = elems[i]) !== undefined; i++) {\n        if (acceptData(elem)) {\n          if (data = elem[dataPriv.expando]) {\n            if (data.events) {\n              for (type in data.events) {\n                if (special[type]) {\n                  jQuery.event.remove(elem, type);\n\n                  // This is a shortcut to avoid jQuery.event.remove's overhead\n                } else {\n                  jQuery.removeEvent(elem, type, data.handle);\n                }\n              }\n            }\n\n            // Support: Chrome <=35 - 45+\n            // Assign undefined instead of using delete, see Data#remove\n            elem[dataPriv.expando] = undefined;\n          }\n          if (elem[dataUser.expando]) {\n            // Support: Chrome <=35 - 45+\n            // Assign undefined instead of using delete, see Data#remove\n            elem[dataUser.expando] = undefined;\n          }\n        }\n      }\n    }\n  });\n  jQuery.fn.extend({\n    detach: function detach(selector) {\n      return _remove(this, selector, true);\n    },\n    remove: function remove(selector) {\n      return _remove(this, selector);\n    },\n    text: function text(value) {\n      return access(this, function (value) {\n        return value === undefined ? jQuery.text(this) : this.empty().each(function () {\n          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n            this.textContent = value;\n          }\n        });\n      }, null, value, arguments.length);\n    },\n    append: function append() {\n      return domManip(this, arguments, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          var target = manipulationTarget(this, elem);\n          target.appendChild(elem);\n        }\n      });\n    },\n    prepend: function prepend() {\n      return domManip(this, arguments, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          var target = manipulationTarget(this, elem);\n          target.insertBefore(elem, target.firstChild);\n        }\n      });\n    },\n    before: function before() {\n      return domManip(this, arguments, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this);\n        }\n      });\n    },\n    after: function after() {\n      return domManip(this, arguments, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this.nextSibling);\n        }\n      });\n    },\n    empty: function empty() {\n      var elem,\n        i = 0;\n      for (; (elem = this[i]) != null; i++) {\n        if (elem.nodeType === 1) {\n          // Prevent memory leaks\n          jQuery.cleanData(getAll(elem, false));\n\n          // Remove any remaining nodes\n          elem.textContent = \"\";\n        }\n      }\n      return this;\n    },\n    clone: function clone(dataAndEvents, deepDataAndEvents) {\n      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n      return this.map(function () {\n        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);\n      });\n    },\n    html: function html(value) {\n      return access(this, function (value) {\n        var elem = this[0] || {},\n          i = 0,\n          l = this.length;\n        if (value === undefined && elem.nodeType === 1) {\n          return elem.innerHTML;\n        }\n\n        // See if we can take a shortcut and just use innerHTML\n        if (typeof value === \"string\" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [\"\", \"\"])[1].toLowerCase()]) {\n          value = jQuery.htmlPrefilter(value);\n          try {\n            for (; i < l; i++) {\n              elem = this[i] || {};\n\n              // Remove element nodes and prevent memory leaks\n              if (elem.nodeType === 1) {\n                jQuery.cleanData(getAll(elem, false));\n                elem.innerHTML = value;\n              }\n            }\n            elem = 0;\n\n            // If using innerHTML throws an exception, use the fallback method\n          } catch (e) {}\n        }\n        if (elem) {\n          this.empty().append(value);\n        }\n      }, null, value, arguments.length);\n    },\n    replaceWith: function replaceWith() {\n      var ignored = [];\n\n      // Make the changes, replacing each non-ignored context element with the new content\n      return domManip(this, arguments, function (elem) {\n        var parent = this.parentNode;\n        if (jQuery.inArray(this, ignored) < 0) {\n          jQuery.cleanData(getAll(this));\n          if (parent) {\n            parent.replaceChild(elem, this);\n          }\n        }\n\n        // Force callback invocation\n      }, ignored);\n    }\n  });\n  jQuery.each({\n    appendTo: \"append\",\n    prependTo: \"prepend\",\n    insertBefore: \"before\",\n    insertAfter: \"after\",\n    replaceAll: \"replaceWith\"\n  }, function (name, original) {\n    jQuery.fn[name] = function (selector) {\n      var elems,\n        ret = [],\n        insert = jQuery(selector),\n        last = insert.length - 1,\n        i = 0;\n      for (; i <= last; i++) {\n        elems = i === last ? this : this.clone(true);\n        jQuery(insert[i])[original](elems);\n\n        // Support: Android <=4.0 only, PhantomJS 1 only\n        // .get() because push.apply(_, arraylike) throws on ancient WebKit\n        push.apply(ret, elems.get());\n      }\n      return this.pushStack(ret);\n    };\n  });\n  var rnumnonpx = new RegExp(\"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\");\n  var getStyles = function getStyles(elem) {\n    // Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n    // IE throws on elements created in popups\n    // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n    var view = elem.ownerDocument.defaultView;\n    if (!view || !view.opener) {\n      view = window;\n    }\n    return view.getComputedStyle(elem);\n  };\n  var swap = function swap(elem, options, callback) {\n    var ret,\n      name,\n      old = {};\n\n    // Remember the old values, and insert the new ones\n    for (name in options) {\n      old[name] = elem.style[name];\n      elem.style[name] = options[name];\n    }\n    ret = callback.call(elem);\n\n    // Revert the old values\n    for (name in options) {\n      elem.style[name] = old[name];\n    }\n    return ret;\n  };\n  var rboxStyle = new RegExp(cssExpand.join(\"|\"), \"i\");\n  (function () {\n    // Executing both pixelPosition & boxSizingReliable tests require only one layout\n    // so they're executed at the same time to save the second computation.\n    function computeStyleTests() {\n      // This is a singleton, we need to execute it only once\n      if (!div) {\n        return;\n      }\n      container.style.cssText = \"position:absolute;left:-11111px;width:60px;\" + \"margin-top:1px;padding:0;border:0\";\n      div.style.cssText = \"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" + \"margin:auto;border:1px;padding:1px;\" + \"width:60%;top:1%\";\n      documentElement.appendChild(container).appendChild(div);\n      var divStyle = window.getComputedStyle(div);\n      pixelPositionVal = divStyle.top !== \"1%\";\n\n      // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n      reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;\n\n      // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n      // Some styles come back with percentage values, even though they shouldn't\n      div.style.right = \"60%\";\n      pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;\n\n      // Support: IE 9 - 11 only\n      // Detect misreporting of content dimensions for box-sizing:border-box elements\n      boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;\n\n      // Support: IE 9 only\n      // Detect overflow:scroll screwiness (gh-3699)\n      // Support: Chrome <=64\n      // Don't get tricked when zoom affects offsetWidth (gh-4029)\n      div.style.position = \"absolute\";\n      scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;\n      documentElement.removeChild(container);\n\n      // Nullify the div so it wouldn't be stored in the memory and\n      // it will also be a sign that checks already performed\n      div = null;\n    }\n    function roundPixelMeasures(measure) {\n      return Math.round(parseFloat(measure));\n    }\n    var pixelPositionVal,\n      boxSizingReliableVal,\n      scrollboxSizeVal,\n      pixelBoxStylesVal,\n      reliableTrDimensionsVal,\n      reliableMarginLeftVal,\n      container = document.createElement(\"div\"),\n      div = document.createElement(\"div\");\n\n    // Finish early in limited (non-browser) environments\n    if (!div.style) {\n      return;\n    }\n\n    // Support: IE <=9 - 11 only\n    // Style of cloned element affects source element cloned (#8908)\n    div.style.backgroundClip = \"content-box\";\n    div.cloneNode(true).style.backgroundClip = \"\";\n    support.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n    jQuery.extend(support, {\n      boxSizingReliable: function boxSizingReliable() {\n        computeStyleTests();\n        return boxSizingReliableVal;\n      },\n      pixelBoxStyles: function pixelBoxStyles() {\n        computeStyleTests();\n        return pixelBoxStylesVal;\n      },\n      pixelPosition: function pixelPosition() {\n        computeStyleTests();\n        return pixelPositionVal;\n      },\n      reliableMarginLeft: function reliableMarginLeft() {\n        computeStyleTests();\n        return reliableMarginLeftVal;\n      },\n      scrollboxSize: function scrollboxSize() {\n        computeStyleTests();\n        return scrollboxSizeVal;\n      },\n      // Support: IE 9 - 11+, Edge 15 - 18+\n      // IE/Edge misreport `getComputedStyle` of table rows with width/height\n      // set in CSS while `offset*` properties report correct values.\n      // Behavior in IE 9 is more subtle than in newer versions & it passes\n      // some versions of this test; make sure not to make it pass there!\n      //\n      // Support: Firefox 70+\n      // Only Firefox includes border widths\n      // in computed dimensions. (gh-4529)\n      reliableTrDimensions: function reliableTrDimensions() {\n        var table, tr, trChild, trStyle;\n        if (reliableTrDimensionsVal == null) {\n          table = document.createElement(\"table\");\n          tr = document.createElement(\"tr\");\n          trChild = document.createElement(\"div\");\n          table.style.cssText = \"position:absolute;left:-11111px;border-collapse:separate\";\n          tr.style.cssText = \"border:1px solid\";\n\n          // Support: Chrome 86+\n          // Height set through cssText does not get applied.\n          // Computed height then comes back as 0.\n          tr.style.height = \"1px\";\n          trChild.style.height = \"9px\";\n\n          // Support: Android 8 Chrome 86+\n          // In our bodyBackground.html iframe,\n          // display for all div elements is set to \"inline\",\n          // which causes a problem only in Android 8 Chrome 86.\n          // Ensuring the div is display: block\n          // gets around this issue.\n          trChild.style.display = \"block\";\n          documentElement.appendChild(table).appendChild(tr).appendChild(trChild);\n          trStyle = window.getComputedStyle(tr);\n          reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;\n          documentElement.removeChild(table);\n        }\n        return reliableTrDimensionsVal;\n      }\n    });\n  })();\n  function curCSS(elem, name, computed) {\n    var width,\n      minWidth,\n      maxWidth,\n      ret,\n      // Support: Firefox 51+\n      // Retrieving style before computed somehow\n      // fixes an issue with getting wrong values\n      // on detached elements\n      style = elem.style;\n    computed = computed || getStyles(elem);\n\n    // getPropertyValue is needed for:\n    //   .css('filter') (IE 9 only, #12537)\n    //   .css('--customProperty) (#3144)\n    if (computed) {\n      ret = computed.getPropertyValue(name) || computed[name];\n      if (ret === \"\" && !isAttached(elem)) {\n        ret = jQuery.style(elem, name);\n      }\n\n      // A tribute to the \"awesome hack by Dean Edwards\"\n      // Android Browser returns percentage for some values,\n      // but width seems to be reliably pixels.\n      // This is against the CSSOM draft spec:\n      // https://drafts.csswg.org/cssom/#resolved-values\n      if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {\n        // Remember the original values\n        width = style.width;\n        minWidth = style.minWidth;\n        maxWidth = style.maxWidth;\n\n        // Put in the new values to get a computed value out\n        style.minWidth = style.maxWidth = style.width = ret;\n        ret = computed.width;\n\n        // Revert the changed values\n        style.width = width;\n        style.minWidth = minWidth;\n        style.maxWidth = maxWidth;\n      }\n    }\n    return ret !== undefined ?\n    // Support: IE <=9 - 11 only\n    // IE returns zIndex value as an integer.\n    ret + \"\" : ret;\n  }\n  function addGetHookIf(conditionFn, hookFn) {\n    // Define the hook, we'll check on the first run if it's really needed.\n    return {\n      get: function get() {\n        if (conditionFn()) {\n          // Hook not needed (or it's not possible to use it due\n          // to missing dependency), remove it.\n          delete this.get;\n          return;\n        }\n\n        // Hook needed; redefine it so that the support test is not executed again.\n        return (this.get = hookFn).apply(this, arguments);\n      }\n    };\n  }\n  var cssPrefixes = [\"Webkit\", \"Moz\", \"ms\"],\n    emptyStyle = document.createElement(\"div\").style,\n    vendorProps = {};\n\n  // Return a vendor-prefixed property or undefined\n  function vendorPropName(name) {\n    // Check for vendor prefixed names\n    var capName = name[0].toUpperCase() + name.slice(1),\n      i = cssPrefixes.length;\n    while (i--) {\n      name = cssPrefixes[i] + capName;\n      if (name in emptyStyle) {\n        return name;\n      }\n    }\n  }\n\n  // Return a potentially-mapped jQuery.cssProps or vendor prefixed property\n  function finalPropName(name) {\n    var _final = jQuery.cssProps[name] || vendorProps[name];\n    if (_final) {\n      return _final;\n    }\n    if (name in emptyStyle) {\n      return name;\n    }\n    return vendorProps[name] = vendorPropName(name) || name;\n  }\n  var\n    // Swappable if display is none or starts with table\n    // except \"table\", \"table-cell\", or \"table-caption\"\n    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n    rdisplayswap = /^(none|table(?!-c[ea]).+)/,\n    rcustomProp = /^--/,\n    cssShow = {\n      position: \"absolute\",\n      visibility: \"hidden\",\n      display: \"block\"\n    },\n    cssNormalTransform = {\n      letterSpacing: \"0\",\n      fontWeight: \"400\"\n    };\n  function setPositiveNumber(_elem, value, subtract) {\n    // Any relative (+/-) values have already been\n    // normalized at this point\n    var matches = rcssNum.exec(value);\n    return matches ?\n    // Guard against undefined \"subtract\", e.g., when used as in cssHooks\n    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || \"px\") : value;\n  }\n  function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {\n    var i = dimension === \"width\" ? 1 : 0,\n      extra = 0,\n      delta = 0;\n\n    // Adjustment may not be necessary\n    if (box === (isBorderBox ? \"border\" : \"content\")) {\n      return 0;\n    }\n    for (; i < 4; i += 2) {\n      // Both box models exclude margin\n      if (box === \"margin\") {\n        delta += jQuery.css(elem, box + cssExpand[i], true, styles);\n      }\n\n      // If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n      if (!isBorderBox) {\n        // Add padding\n        delta += jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n\n        // For \"border\" or \"margin\", add border\n        if (box !== \"padding\") {\n          delta += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n\n          // But still keep track of it otherwise\n        } else {\n          extra += jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n        }\n\n        // If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n        // \"padding\" or \"margin\"\n      } else {\n        // For \"content\", subtract padding\n        if (box === \"content\") {\n          delta -= jQuery.css(elem, \"padding\" + cssExpand[i], true, styles);\n        }\n\n        // For \"content\" or \"padding\", subtract border\n        if (box !== \"margin\") {\n          delta -= jQuery.css(elem, \"border\" + cssExpand[i] + \"Width\", true, styles);\n        }\n      }\n    }\n\n    // Account for positive content-box scroll gutter when requested by providing computedVal\n    if (!isBorderBox && computedVal >= 0) {\n      // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n      // Assuming integer scroll gutter, subtract the rest and round down\n      delta += Math.max(0, Math.ceil(elem[\"offset\" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5\n\n      // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter\n      // Use an explicit zero to avoid NaN (gh-3964)\n      )) || 0;\n    }\n    return delta;\n  }\n  function getWidthOrHeight(elem, dimension, extra) {\n    // Start with computed style\n    var styles = getStyles(elem),\n      // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\n      // Fake content-box until we know it's needed to know the true value.\n      boxSizingNeeded = !support.boxSizingReliable() || extra,\n      isBorderBox = boxSizingNeeded && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\",\n      valueIsBorderBox = isBorderBox,\n      val = curCSS(elem, dimension, styles),\n      offsetProp = \"offset\" + dimension[0].toUpperCase() + dimension.slice(1);\n\n    // Support: Firefox <=54\n    // Return a confounding non-pixel value or feign ignorance, as appropriate.\n    if (rnumnonpx.test(val)) {\n      if (!extra) {\n        return val;\n      }\n      val = \"auto\";\n    }\n\n    // Support: IE 9 - 11 only\n    // Use offsetWidth/offsetHeight for when box sizing is unreliable.\n    // In those cases, the computed value can be trusted to be border-box.\n    if ((!support.boxSizingReliable() && isBorderBox ||\n    // Support: IE 10 - 11+, Edge 15 - 18+\n    // IE/Edge misreport `getComputedStyle` of table rows with width/height\n    // set in CSS while `offset*` properties report correct values.\n    // Interestingly, in some cases IE 9 doesn't suffer from this issue.\n    !support.reliableTrDimensions() && nodeName(elem, \"tr\") ||\n    // Fall back to offsetWidth/offsetHeight when value is \"auto\"\n    // This happens for inline elements with no explicit setting (gh-3571)\n    val === \"auto\" ||\n    // Support: Android <=4.1 - 4.3 only\n    // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n    !parseFloat(val) && jQuery.css(elem, \"display\", false, styles) === \"inline\") &&\n    // Make sure the element is visible & connected\n    elem.getClientRects().length) {\n      isBorderBox = jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\";\n\n      // Where available, offsetWidth/offsetHeight approximate border box dimensions.\n      // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\n      // retrieved value as a content box dimension.\n      valueIsBorderBox = offsetProp in elem;\n      if (valueIsBorderBox) {\n        val = elem[offsetProp];\n      }\n    }\n\n    // Normalize \"\" and auto\n    val = parseFloat(val) || 0;\n\n    // Adjust for the element's box model\n    return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? \"border\" : \"content\"), valueIsBorderBox, styles,\n    // Provide the current computed size to request scroll gutter calculation (gh-3589)\n    val) + \"px\";\n  }\n  jQuery.extend({\n    // Add in style property hooks for overriding the default\n    // behavior of getting and setting a style property\n    cssHooks: {\n      opacity: {\n        get: function get(elem, computed) {\n          if (computed) {\n            // We should always get a number back from opacity\n            var ret = curCSS(elem, \"opacity\");\n            return ret === \"\" ? \"1\" : ret;\n          }\n        }\n      }\n    },\n    // Don't automatically add \"px\" to these possibly-unitless properties\n    cssNumber: {\n      \"animationIterationCount\": true,\n      \"columnCount\": true,\n      \"fillOpacity\": true,\n      \"flexGrow\": true,\n      \"flexShrink\": true,\n      \"fontWeight\": true,\n      \"gridArea\": true,\n      \"gridColumn\": true,\n      \"gridColumnEnd\": true,\n      \"gridColumnStart\": true,\n      \"gridRow\": true,\n      \"gridRowEnd\": true,\n      \"gridRowStart\": true,\n      \"lineHeight\": true,\n      \"opacity\": true,\n      \"order\": true,\n      \"orphans\": true,\n      \"widows\": true,\n      \"zIndex\": true,\n      \"zoom\": true\n    },\n    // Add in properties whose names you wish to fix before\n    // setting or getting the value\n    cssProps: {},\n    // Get and set the style property on a DOM Node\n    style: function style(elem, name, value, extra) {\n      // Don't set styles on text and comment nodes\n      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\n        return;\n      }\n\n      // Make sure that we're working with the right name\n      var ret,\n        type,\n        hooks,\n        origName = camelCase(name),\n        isCustomProp = rcustomProp.test(name),\n        style = elem.style;\n\n      // Make sure that we're working with the right name. We don't\n      // want to query the value if it is a CSS custom property\n      // since they are user-defined.\n      if (!isCustomProp) {\n        name = finalPropName(origName);\n      }\n\n      // Gets hook for the prefixed version, then unprefixed version\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\n\n      // Check if we're setting a value\n      if (value !== undefined) {\n        type = _typeof(value);\n\n        // Convert \"+=\" or \"-=\" to relative numbers (#7345)\n        if (type === \"string\" && (ret = rcssNum.exec(value)) && ret[1]) {\n          value = adjustCSS(elem, name, ret);\n\n          // Fixes bug #9237\n          type = \"number\";\n        }\n\n        // Make sure that null and NaN values aren't set (#7116)\n        if (value == null || value !== value) {\n          return;\n        }\n\n        // If a number was passed in, add the unit (except for certain CSS properties)\n        // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\n        // \"px\" to a few hardcoded values.\n        if (type === \"number\" && !isCustomProp) {\n          value += ret && ret[3] || (jQuery.cssNumber[origName] ? \"\" : \"px\");\n        }\n\n        // background-* props affect original clone's values\n        if (!support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0) {\n          style[name] = \"inherit\";\n        }\n\n        // If a hook was provided, use that value, otherwise just set the specified value\n        if (!hooks || !(\"set\" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {\n          if (isCustomProp) {\n            style.setProperty(name, value);\n          } else {\n            style[name] = value;\n          }\n        }\n      } else {\n        // If a hook was provided get the non-computed value from there\n        if (hooks && \"get\" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\n          return ret;\n        }\n\n        // Otherwise just get the value from the style object\n        return style[name];\n      }\n    },\n    css: function css(elem, name, extra, styles) {\n      var val,\n        num,\n        hooks,\n        origName = camelCase(name),\n        isCustomProp = rcustomProp.test(name);\n\n      // Make sure that we're working with the right name. We don't\n      // want to modify the value if it is a CSS custom property\n      // since they are user-defined.\n      if (!isCustomProp) {\n        name = finalPropName(origName);\n      }\n\n      // Try prefixed name followed by the unprefixed name\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];\n\n      // If a hook was provided get the computed value from there\n      if (hooks && \"get\" in hooks) {\n        val = hooks.get(elem, true, extra);\n      }\n\n      // Otherwise, if a way to get the computed value exists, use that\n      if (val === undefined) {\n        val = curCSS(elem, name, styles);\n      }\n\n      // Convert \"normal\" to computed value\n      if (val === \"normal\" && name in cssNormalTransform) {\n        val = cssNormalTransform[name];\n      }\n\n      // Make numeric if forced or a qualifier was provided and val looks numeric\n      if (extra === \"\" || extra) {\n        num = parseFloat(val);\n        return extra === true || isFinite(num) ? num || 0 : val;\n      }\n      return val;\n    }\n  });\n  jQuery.each([\"height\", \"width\"], function (_i, dimension) {\n    jQuery.cssHooks[dimension] = {\n      get: function get(elem, computed, extra) {\n        if (computed) {\n          // Certain elements can have dimension info if we invisibly show them\n          // but it must have a current display style that would benefit\n          return rdisplayswap.test(jQuery.css(elem, \"display\")) && (\n          // Support: Safari 8+\n          // Table columns in Safari have non-zero offsetWidth & zero\n          // getBoundingClientRect().width unless display is changed.\n          // Support: IE <=11 only\n          // Running getBoundingClientRect on a disconnected node\n          // in IE throws an error.\n          !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {\n            return getWidthOrHeight(elem, dimension, extra);\n          }) : getWidthOrHeight(elem, dimension, extra);\n        }\n      },\n      set: function set(elem, value, extra) {\n        var matches,\n          styles = getStyles(elem),\n          // Only read styles.position if the test has a chance to fail\n          // to avoid forcing a reflow.\n          scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === \"absolute\",\n          // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\n          boxSizingNeeded = scrollboxSizeBuggy || extra,\n          isBorderBox = boxSizingNeeded && jQuery.css(elem, \"boxSizing\", false, styles) === \"border-box\",\n          subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0;\n\n        // Account for unreliable border-box dimensions by comparing offset* to computed and\n        // faking a content-box to get border and padding (gh-3699)\n        if (isBorderBox && scrollboxSizeBuggy) {\n          subtract -= Math.ceil(elem[\"offset\" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, \"border\", false, styles) - 0.5);\n        }\n\n        // Convert to pixels if value adjustment is needed\n        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || \"px\") !== \"px\") {\n          elem.style[dimension] = value;\n          value = jQuery.css(elem, dimension);\n        }\n        return setPositiveNumber(elem, value, subtract);\n      }\n    };\n  });\n  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {\n    if (computed) {\n      return (parseFloat(curCSS(elem, \"marginLeft\")) || elem.getBoundingClientRect().left - swap(elem, {\n        marginLeft: 0\n      }, function () {\n        return elem.getBoundingClientRect().left;\n      })) + \"px\";\n    }\n  });\n\n  // These hooks are used by animate to expand properties\n  jQuery.each({\n    margin: \"\",\n    padding: \"\",\n    border: \"Width\"\n  }, function (prefix, suffix) {\n    jQuery.cssHooks[prefix + suffix] = {\n      expand: function expand(value) {\n        var i = 0,\n          expanded = {},\n          // Assumes a single number if not a string\n          parts = typeof value === \"string\" ? value.split(\" \") : [value];\n        for (; i < 4; i++) {\n          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];\n        }\n        return expanded;\n      }\n    };\n    if (prefix !== \"margin\") {\n      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;\n    }\n  });\n  jQuery.fn.extend({\n    css: function css(name, value) {\n      return access(this, function (elem, name, value) {\n        var styles,\n          len,\n          map = {},\n          i = 0;\n        if (Array.isArray(name)) {\n          styles = getStyles(elem);\n          len = name.length;\n          for (; i < len; i++) {\n            map[name[i]] = jQuery.css(elem, name[i], false, styles);\n          }\n          return map;\n        }\n        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);\n      }, name, value, arguments.length > 1);\n    }\n  });\n  function Tween(elem, options, prop, end, easing) {\n    return new Tween.prototype.init(elem, options, prop, end, easing);\n  }\n  jQuery.Tween = Tween;\n  Tween.prototype = {\n    constructor: Tween,\n    init: function init(elem, options, prop, end, easing, unit) {\n      this.elem = elem;\n      this.prop = prop;\n      this.easing = easing || jQuery.easing._default;\n      this.options = options;\n      this.start = this.now = this.cur();\n      this.end = end;\n      this.unit = unit || (jQuery.cssNumber[prop] ? \"\" : \"px\");\n    },\n    cur: function cur() {\n      var hooks = Tween.propHooks[this.prop];\n      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);\n    },\n    run: function run(percent) {\n      var eased,\n        hooks = Tween.propHooks[this.prop];\n      if (this.options.duration) {\n        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);\n      } else {\n        this.pos = eased = percent;\n      }\n      this.now = (this.end - this.start) * eased + this.start;\n      if (this.options.step) {\n        this.options.step.call(this.elem, this.now, this);\n      }\n      if (hooks && hooks.set) {\n        hooks.set(this);\n      } else {\n        Tween.propHooks._default.set(this);\n      }\n      return this;\n    }\n  };\n  Tween.prototype.init.prototype = Tween.prototype;\n  Tween.propHooks = {\n    _default: {\n      get: function get(tween) {\n        var result;\n\n        // Use a property on the element directly when it is not a DOM element,\n        // or when there is no matching style property that exists.\n        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {\n          return tween.elem[tween.prop];\n        }\n\n        // Passing an empty string as a 3rd parameter to .css will automatically\n        // attempt a parseFloat and fallback to a string if the parse fails.\n        // Simple values such as \"10px\" are parsed to Float;\n        // complex values such as \"rotate(1rad)\" are returned as-is.\n        result = jQuery.css(tween.elem, tween.prop, \"\");\n\n        // Empty strings, null, undefined and \"auto\" are converted to 0.\n        return !result || result === \"auto\" ? 0 : result;\n      },\n      set: function set(tween) {\n        // Use step hook for back compat.\n        // Use cssHook if its there.\n        // Use .style if available and use plain properties where available.\n        if (jQuery.fx.step[tween.prop]) {\n          jQuery.fx.step[tween.prop](tween);\n        } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {\n          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);\n        } else {\n          tween.elem[tween.prop] = tween.now;\n        }\n      }\n    }\n  };\n\n  // Support: IE <=9 only\n  // Panic based approach to setting things on disconnected nodes\n  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n    set: function set(tween) {\n      if (tween.elem.nodeType && tween.elem.parentNode) {\n        tween.elem[tween.prop] = tween.now;\n      }\n    }\n  };\n  jQuery.easing = {\n    linear: function linear(p) {\n      return p;\n    },\n    swing: function swing(p) {\n      return 0.5 - Math.cos(p * Math.PI) / 2;\n    },\n    _default: \"swing\"\n  };\n  jQuery.fx = Tween.prototype.init;\n\n  // Back compat <1.8 extension point\n  jQuery.fx.step = {};\n  var fxNow,\n    inProgress,\n    rfxtypes = /^(?:toggle|show|hide)$/,\n    rrun = /queueHooks$/;\n  function schedule() {\n    if (inProgress) {\n      if (document.hidden === false && window.requestAnimationFrame) {\n        window.requestAnimationFrame(schedule);\n      } else {\n        window.setTimeout(schedule, jQuery.fx.interval);\n      }\n      jQuery.fx.tick();\n    }\n  }\n\n  // Animations created synchronously will run synchronously\n  function createFxNow() {\n    window.setTimeout(function () {\n      fxNow = undefined;\n    });\n    return fxNow = Date.now();\n  }\n\n  // Generate parameters to create a standard animation\n  function genFx(type, includeWidth) {\n    var which,\n      i = 0,\n      attrs = {\n        height: type\n      };\n\n    // If we include width, step value is 1 to do all cssExpand values,\n    // otherwise step value is 2 to skip over Left and Right\n    includeWidth = includeWidth ? 1 : 0;\n    for (; i < 4; i += 2 - includeWidth) {\n      which = cssExpand[i];\n      attrs[\"margin\" + which] = attrs[\"padding\" + which] = type;\n    }\n    if (includeWidth) {\n      attrs.opacity = attrs.width = type;\n    }\n    return attrs;\n  }\n  function createTween(value, prop, animation) {\n    var tween,\n      collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners[\"*\"]),\n      index = 0,\n      length = collection.length;\n    for (; index < length; index++) {\n      if (tween = collection[index].call(animation, prop, value)) {\n        // We're done with this property\n        return tween;\n      }\n    }\n  }\n  function defaultPrefilter(elem, props, opts) {\n    var prop,\n      value,\n      toggle,\n      hooks,\n      oldfire,\n      propTween,\n      restoreDisplay,\n      display,\n      isBox = \"width\" in props || \"height\" in props,\n      anim = this,\n      orig = {},\n      style = elem.style,\n      hidden = elem.nodeType && isHiddenWithinTree(elem),\n      dataShow = dataPriv.get(elem, \"fxshow\");\n\n    // Queue-skipping animations hijack the fx hooks\n    if (!opts.queue) {\n      hooks = jQuery._queueHooks(elem, \"fx\");\n      if (hooks.unqueued == null) {\n        hooks.unqueued = 0;\n        oldfire = hooks.empty.fire;\n        hooks.empty.fire = function () {\n          if (!hooks.unqueued) {\n            oldfire();\n          }\n        };\n      }\n      hooks.unqueued++;\n      anim.always(function () {\n        // Ensure the complete handler is called before this completes\n        anim.always(function () {\n          hooks.unqueued--;\n          if (!jQuery.queue(elem, \"fx\").length) {\n            hooks.empty.fire();\n          }\n        });\n      });\n    }\n\n    // Detect show/hide animations\n    for (prop in props) {\n      value = props[prop];\n      if (rfxtypes.test(value)) {\n        delete props[prop];\n        toggle = toggle || value === \"toggle\";\n        if (value === (hidden ? \"hide\" : \"show\")) {\n          // Pretend to be hidden if this is a \"show\" and\n          // there is still data from a stopped show/hide\n          if (value === \"show\" && dataShow && dataShow[prop] !== undefined) {\n            hidden = true;\n\n            // Ignore all other no-op show/hide data\n          } else {\n            continue;\n          }\n        }\n        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);\n      }\n    }\n\n    // Bail out if this is a no-op like .hide().hide()\n    propTween = !jQuery.isEmptyObject(props);\n    if (!propTween && jQuery.isEmptyObject(orig)) {\n      return;\n    }\n\n    // Restrict \"overflow\" and \"display\" styles during box animations\n    if (isBox && elem.nodeType === 1) {\n      // Support: IE <=9 - 11, Edge 12 - 15\n      // Record all 3 overflow attributes because IE does not infer the shorthand\n      // from identically-valued overflowX and overflowY and Edge just mirrors\n      // the overflowX value there.\n      opts.overflow = [style.overflow, style.overflowX, style.overflowY];\n\n      // Identify a display type, preferring old show/hide data over the CSS cascade\n      restoreDisplay = dataShow && dataShow.display;\n      if (restoreDisplay == null) {\n        restoreDisplay = dataPriv.get(elem, \"display\");\n      }\n      display = jQuery.css(elem, \"display\");\n      if (display === \"none\") {\n        if (restoreDisplay) {\n          display = restoreDisplay;\n        } else {\n          // Get nonempty value(s) by temporarily forcing visibility\n          showHide([elem], true);\n          restoreDisplay = elem.style.display || restoreDisplay;\n          display = jQuery.css(elem, \"display\");\n          showHide([elem]);\n        }\n      }\n\n      // Animate inline elements as inline-block\n      if (display === \"inline\" || display === \"inline-block\" && restoreDisplay != null) {\n        if (jQuery.css(elem, \"float\") === \"none\") {\n          // Restore the original display value at the end of pure show/hide animations\n          if (!propTween) {\n            anim.done(function () {\n              style.display = restoreDisplay;\n            });\n            if (restoreDisplay == null) {\n              display = style.display;\n              restoreDisplay = display === \"none\" ? \"\" : display;\n            }\n          }\n          style.display = \"inline-block\";\n        }\n      }\n    }\n    if (opts.overflow) {\n      style.overflow = \"hidden\";\n      anim.always(function () {\n        style.overflow = opts.overflow[0];\n        style.overflowX = opts.overflow[1];\n        style.overflowY = opts.overflow[2];\n      });\n    }\n\n    // Implement show/hide animations\n    propTween = false;\n    for (prop in orig) {\n      // General show/hide setup for this element animation\n      if (!propTween) {\n        if (dataShow) {\n          if (\"hidden\" in dataShow) {\n            hidden = dataShow.hidden;\n          }\n        } else {\n          dataShow = dataPriv.access(elem, \"fxshow\", {\n            display: restoreDisplay\n          });\n        }\n\n        // Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n        if (toggle) {\n          dataShow.hidden = !hidden;\n        }\n\n        // Show elements before animating them\n        if (hidden) {\n          showHide([elem], true);\n        }\n\n        /* eslint-disable no-loop-func */\n\n        anim.done(function () {\n          /* eslint-enable no-loop-func */\n\n          // The final step of a \"hide\" animation is actually hiding the element\n          if (!hidden) {\n            showHide([elem]);\n          }\n          dataPriv.remove(elem, \"fxshow\");\n          for (prop in orig) {\n            jQuery.style(elem, prop, orig[prop]);\n          }\n        });\n      }\n\n      // Per-property setup\n      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);\n      if (!(prop in dataShow)) {\n        dataShow[prop] = propTween.start;\n        if (hidden) {\n          propTween.end = propTween.start;\n          propTween.start = 0;\n        }\n      }\n    }\n  }\n  function propFilter(props, specialEasing) {\n    var index, name, easing, value, hooks;\n\n    // camelCase, specialEasing and expand cssHook pass\n    for (index in props) {\n      name = camelCase(index);\n      easing = specialEasing[name];\n      value = props[index];\n      if (Array.isArray(value)) {\n        easing = value[1];\n        value = props[index] = value[0];\n      }\n      if (index !== name) {\n        props[name] = value;\n        delete props[index];\n      }\n      hooks = jQuery.cssHooks[name];\n      if (hooks && \"expand\" in hooks) {\n        value = hooks.expand(value);\n        delete props[name];\n\n        // Not quite $.extend, this won't overwrite existing keys.\n        // Reusing 'index' because we have the correct \"name\"\n        for (index in value) {\n          if (!(index in props)) {\n            props[index] = value[index];\n            specialEasing[index] = easing;\n          }\n        }\n      } else {\n        specialEasing[name] = easing;\n      }\n    }\n  }\n  function Animation(elem, properties, options) {\n    var result,\n      stopped,\n      index = 0,\n      length = Animation.prefilters.length,\n      deferred = jQuery.Deferred().always(function () {\n        // Don't match elem in the :animated selector\n        delete tick.elem;\n      }),\n      tick = function tick() {\n        if (stopped) {\n          return false;\n        }\n        var currentTime = fxNow || createFxNow(),\n          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),\n          // Support: Android 2.3 only\n          // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n          temp = remaining / animation.duration || 0,\n          percent = 1 - temp,\n          index = 0,\n          length = animation.tweens.length;\n        for (; index < length; index++) {\n          animation.tweens[index].run(percent);\n        }\n        deferred.notifyWith(elem, [animation, percent, remaining]);\n\n        // If there's more to do, yield\n        if (percent < 1 && length) {\n          return remaining;\n        }\n\n        // If this was an empty animation, synthesize a final progress notification\n        if (!length) {\n          deferred.notifyWith(elem, [animation, 1, 0]);\n        }\n\n        // Resolve the animation and report its conclusion\n        deferred.resolveWith(elem, [animation]);\n        return false;\n      },\n      animation = deferred.promise({\n        elem: elem,\n        props: jQuery.extend({}, properties),\n        opts: jQuery.extend(true, {\n          specialEasing: {},\n          easing: jQuery.easing._default\n        }, options),\n        originalProperties: properties,\n        originalOptions: options,\n        startTime: fxNow || createFxNow(),\n        duration: options.duration,\n        tweens: [],\n        createTween: function createTween(prop, end) {\n          var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);\n          animation.tweens.push(tween);\n          return tween;\n        },\n        stop: function stop(gotoEnd) {\n          var index = 0,\n            // If we are going to the end, we want to run all the tweens\n            // otherwise we skip this part\n            length = gotoEnd ? animation.tweens.length : 0;\n          if (stopped) {\n            return this;\n          }\n          stopped = true;\n          for (; index < length; index++) {\n            animation.tweens[index].run(1);\n          }\n\n          // Resolve when we played the last frame; otherwise, reject\n          if (gotoEnd) {\n            deferred.notifyWith(elem, [animation, 1, 0]);\n            deferred.resolveWith(elem, [animation, gotoEnd]);\n          } else {\n            deferred.rejectWith(elem, [animation, gotoEnd]);\n          }\n          return this;\n        }\n      }),\n      props = animation.props;\n    propFilter(props, animation.opts.specialEasing);\n    for (; index < length; index++) {\n      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);\n      if (result) {\n        if (isFunction(result.stop)) {\n          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);\n        }\n        return result;\n      }\n    }\n    jQuery.map(props, createTween, animation);\n    if (isFunction(animation.opts.start)) {\n      animation.opts.start.call(elem, animation);\n    }\n\n    // Attach callbacks from options\n    animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);\n    jQuery.fx.timer(jQuery.extend(tick, {\n      elem: elem,\n      anim: animation,\n      queue: animation.opts.queue\n    }));\n    return animation;\n  }\n  jQuery.Animation = jQuery.extend(Animation, {\n    tweeners: {\n      \"*\": [function (prop, value) {\n        var tween = this.createTween(prop, value);\n        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);\n        return tween;\n      }]\n    },\n    tweener: function tweener(props, callback) {\n      if (isFunction(props)) {\n        callback = props;\n        props = [\"*\"];\n      } else {\n        props = props.match(rnothtmlwhite);\n      }\n      var prop,\n        index = 0,\n        length = props.length;\n      for (; index < length; index++) {\n        prop = props[index];\n        Animation.tweeners[prop] = Animation.tweeners[prop] || [];\n        Animation.tweeners[prop].unshift(callback);\n      }\n    },\n    prefilters: [defaultPrefilter],\n    prefilter: function prefilter(callback, prepend) {\n      if (prepend) {\n        Animation.prefilters.unshift(callback);\n      } else {\n        Animation.prefilters.push(callback);\n      }\n    }\n  });\n  jQuery.speed = function (speed, easing, fn) {\n    var opt = speed && _typeof(speed) === \"object\" ? jQuery.extend({}, speed) : {\n      complete: fn || !fn && easing || isFunction(speed) && speed,\n      duration: speed,\n      easing: fn && easing || easing && !isFunction(easing) && easing\n    };\n\n    // Go to the end state if fx are off\n    if (jQuery.fx.off) {\n      opt.duration = 0;\n    } else {\n      if (typeof opt.duration !== \"number\") {\n        if (opt.duration in jQuery.fx.speeds) {\n          opt.duration = jQuery.fx.speeds[opt.duration];\n        } else {\n          opt.duration = jQuery.fx.speeds._default;\n        }\n      }\n    }\n\n    // Normalize opt.queue - true/undefined/null -> \"fx\"\n    if (opt.queue == null || opt.queue === true) {\n      opt.queue = \"fx\";\n    }\n\n    // Queueing\n    opt.old = opt.complete;\n    opt.complete = function () {\n      if (isFunction(opt.old)) {\n        opt.old.call(this);\n      }\n      if (opt.queue) {\n        jQuery.dequeue(this, opt.queue);\n      }\n    };\n    return opt;\n  };\n  jQuery.fn.extend({\n    fadeTo: function fadeTo(speed, to, easing, callback) {\n      // Show any hidden elements after setting opacity to 0\n      return this.filter(isHiddenWithinTree).css(\"opacity\", 0).show()\n\n      // Animate to the value specified\n      .end().animate({\n        opacity: to\n      }, speed, easing, callback);\n    },\n    animate: function animate(prop, speed, easing, callback) {\n      var empty = jQuery.isEmptyObject(prop),\n        optall = jQuery.speed(speed, easing, callback),\n        doAnimation = function doAnimation() {\n          // Operate on a copy of prop so per-property easing won't be lost\n          var anim = Animation(this, jQuery.extend({}, prop), optall);\n\n          // Empty animations, or finishing resolves immediately\n          if (empty || dataPriv.get(this, \"finish\")) {\n            anim.stop(true);\n          }\n        };\n      doAnimation.finish = doAnimation;\n      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);\n    },\n    stop: function stop(type, clearQueue, gotoEnd) {\n      var stopQueue = function stopQueue(hooks) {\n        var stop = hooks.stop;\n        delete hooks.stop;\n        stop(gotoEnd);\n      };\n      if (typeof type !== \"string\") {\n        gotoEnd = clearQueue;\n        clearQueue = type;\n        type = undefined;\n      }\n      if (clearQueue) {\n        this.queue(type || \"fx\", []);\n      }\n      return this.each(function () {\n        var dequeue = true,\n          index = type != null && type + \"queueHooks\",\n          timers = jQuery.timers,\n          data = dataPriv.get(this);\n        if (index) {\n          if (data[index] && data[index].stop) {\n            stopQueue(data[index]);\n          }\n        } else {\n          for (index in data) {\n            if (data[index] && data[index].stop && rrun.test(index)) {\n              stopQueue(data[index]);\n            }\n          }\n        }\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {\n            timers[index].anim.stop(gotoEnd);\n            dequeue = false;\n            timers.splice(index, 1);\n          }\n        }\n\n        // Start the next in the queue if the last step wasn't forced.\n        // Timers currently will call their complete callbacks, which\n        // will dequeue but only if they were gotoEnd.\n        if (dequeue || !gotoEnd) {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    finish: function finish(type) {\n      if (type !== false) {\n        type = type || \"fx\";\n      }\n      return this.each(function () {\n        var index,\n          data = dataPriv.get(this),\n          queue = data[type + \"queue\"],\n          hooks = data[type + \"queueHooks\"],\n          timers = jQuery.timers,\n          length = queue ? queue.length : 0;\n\n        // Enable finishing flag on private data\n        data.finish = true;\n\n        // Empty the queue first\n        jQuery.queue(this, type, []);\n        if (hooks && hooks.stop) {\n          hooks.stop.call(this, true);\n        }\n\n        // Look for any active animations, and finish them\n        for (index = timers.length; index--;) {\n          if (timers[index].elem === this && timers[index].queue === type) {\n            timers[index].anim.stop(true);\n            timers.splice(index, 1);\n          }\n        }\n\n        // Look for any animations in the old queue and finish them\n        for (index = 0; index < length; index++) {\n          if (queue[index] && queue[index].finish) {\n            queue[index].finish.call(this);\n          }\n        }\n\n        // Turn off finishing flag\n        delete data.finish;\n      });\n    }\n  });\n  jQuery.each([\"toggle\", \"show\", \"hide\"], function (_i, name) {\n    var cssFn = jQuery.fn[name];\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return speed == null || typeof speed === \"boolean\" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);\n    };\n  });\n\n  // Generate shortcuts for custom animations\n  jQuery.each({\n    slideDown: genFx(\"show\"),\n    slideUp: genFx(\"hide\"),\n    slideToggle: genFx(\"toggle\"),\n    fadeIn: {\n      opacity: \"show\"\n    },\n    fadeOut: {\n      opacity: \"hide\"\n    },\n    fadeToggle: {\n      opacity: \"toggle\"\n    }\n  }, function (name, props) {\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return this.animate(props, speed, easing, callback);\n    };\n  });\n  jQuery.timers = [];\n  jQuery.fx.tick = function () {\n    var timer,\n      i = 0,\n      timers = jQuery.timers;\n    fxNow = Date.now();\n    for (; i < timers.length; i++) {\n      timer = timers[i];\n\n      // Run the timer and safely remove it when done (allowing for external removal)\n      if (!timer() && timers[i] === timer) {\n        timers.splice(i--, 1);\n      }\n    }\n    if (!timers.length) {\n      jQuery.fx.stop();\n    }\n    fxNow = undefined;\n  };\n  jQuery.fx.timer = function (timer) {\n    jQuery.timers.push(timer);\n    jQuery.fx.start();\n  };\n  jQuery.fx.interval = 13;\n  jQuery.fx.start = function () {\n    if (inProgress) {\n      return;\n    }\n    inProgress = true;\n    schedule();\n  };\n  jQuery.fx.stop = function () {\n    inProgress = null;\n  };\n  jQuery.fx.speeds = {\n    slow: 600,\n    fast: 200,\n    // Default speed\n    _default: 400\n  };\n\n  // Based off of the plugin by Clint Helfers, with permission.\n  // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\n  jQuery.fn.delay = function (time, type) {\n    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;\n    type = type || \"fx\";\n    return this.queue(type, function (next, hooks) {\n      var timeout = window.setTimeout(next, time);\n      hooks.stop = function () {\n        window.clearTimeout(timeout);\n      };\n    });\n  };\n  (function () {\n    var input = document.createElement(\"input\"),\n      select = document.createElement(\"select\"),\n      opt = select.appendChild(document.createElement(\"option\"));\n    input.type = \"checkbox\";\n\n    // Support: Android <=4.3 only\n    // Default value for a checkbox should be \"on\"\n    support.checkOn = input.value !== \"\";\n\n    // Support: IE <=11 only\n    // Must access selectedIndex to make default options select\n    support.optSelected = opt.selected;\n\n    // Support: IE <=11 only\n    // An input loses its value after becoming a radio\n    input = document.createElement(\"input\");\n    input.value = \"t\";\n    input.type = \"radio\";\n    support.radioValue = input.value === \"t\";\n  })();\n  var boolHook,\n    attrHandle = jQuery.expr.attrHandle;\n  jQuery.fn.extend({\n    attr: function attr(name, value) {\n      return access(this, jQuery.attr, name, value, arguments.length > 1);\n    },\n    removeAttr: function removeAttr(name) {\n      return this.each(function () {\n        jQuery.removeAttr(this, name);\n      });\n    }\n  });\n  jQuery.extend({\n    attr: function attr(elem, name, value) {\n      var ret,\n        hooks,\n        nType = elem.nodeType;\n\n      // Don't get/set attributes on text, comment and attribute nodes\n      if (nType === 3 || nType === 8 || nType === 2) {\n        return;\n      }\n\n      // Fallback to prop when attributes are not supported\n      if (typeof elem.getAttribute === \"undefined\") {\n        return jQuery.prop(elem, name, value);\n      }\n\n      // Attribute hooks are determined by the lowercase version\n      // Grab necessary hook if one is defined\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n        hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);\n      }\n      if (value !== undefined) {\n        if (value === null) {\n          jQuery.removeAttr(elem, name);\n          return;\n        }\n        if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret;\n        }\n        elem.setAttribute(name, value + \"\");\n        return value;\n      }\n      if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n        return ret;\n      }\n      ret = jQuery.find.attr(elem, name);\n\n      // Non-existent attributes return null, we normalize to undefined\n      return ret == null ? undefined : ret;\n    },\n    attrHooks: {\n      type: {\n        set: function set(elem, value) {\n          if (!support.radioValue && value === \"radio\" && nodeName(elem, \"input\")) {\n            var val = elem.value;\n            elem.setAttribute(\"type\", value);\n            if (val) {\n              elem.value = val;\n            }\n            return value;\n          }\n        }\n      }\n    },\n    removeAttr: function removeAttr(elem, value) {\n      var name,\n        i = 0,\n        // Attribute names can contain non-HTML whitespace characters\n        // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n        attrNames = value && value.match(rnothtmlwhite);\n      if (attrNames && elem.nodeType === 1) {\n        while (name = attrNames[i++]) {\n          elem.removeAttribute(name);\n        }\n      }\n    }\n  });\n\n  // Hooks for boolean attributes\n  boolHook = {\n    set: function set(elem, value, name) {\n      if (value === false) {\n        // Remove boolean attributes when set to false\n        jQuery.removeAttr(elem, name);\n      } else {\n        elem.setAttribute(name, name);\n      }\n      return name;\n    }\n  };\n  jQuery.each(jQuery.expr.match.bool.source.match(/\\w+/g), function (_i, name) {\n    var getter = attrHandle[name] || jQuery.find.attr;\n    attrHandle[name] = function (elem, name, isXML) {\n      var ret,\n        handle,\n        lowercaseName = name.toLowerCase();\n      if (!isXML) {\n        // Avoid an infinite loop by temporarily removing this function from the getter\n        handle = attrHandle[lowercaseName];\n        attrHandle[lowercaseName] = ret;\n        ret = getter(elem, name, isXML) != null ? lowercaseName : null;\n        attrHandle[lowercaseName] = handle;\n      }\n      return ret;\n    };\n  });\n  var rfocusable = /^(?:input|select|textarea|button)$/i,\n    rclickable = /^(?:a|area)$/i;\n  jQuery.fn.extend({\n    prop: function prop(name, value) {\n      return access(this, jQuery.prop, name, value, arguments.length > 1);\n    },\n    removeProp: function removeProp(name) {\n      return this.each(function () {\n        delete this[jQuery.propFix[name] || name];\n      });\n    }\n  });\n  jQuery.extend({\n    prop: function prop(elem, name, value) {\n      var ret,\n        hooks,\n        nType = elem.nodeType;\n\n      // Don't get/set properties on text, comment and attribute nodes\n      if (nType === 3 || nType === 8 || nType === 2) {\n        return;\n      }\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n        // Fix name and attach hooks\n        name = jQuery.propFix[name] || name;\n        hooks = jQuery.propHooks[name];\n      }\n      if (value !== undefined) {\n        if (hooks && \"set\" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret;\n        }\n        return elem[name] = value;\n      }\n      if (hooks && \"get\" in hooks && (ret = hooks.get(elem, name)) !== null) {\n        return ret;\n      }\n      return elem[name];\n    },\n    propHooks: {\n      tabIndex: {\n        get: function get(elem) {\n          // Support: IE <=9 - 11 only\n          // elem.tabIndex doesn't always return the\n          // correct value when it hasn't been explicitly set\n          // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n          // Use proper attribute retrieval(#12072)\n          var tabindex = jQuery.find.attr(elem, \"tabindex\");\n          if (tabindex) {\n            return parseInt(tabindex, 10);\n          }\n          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {\n            return 0;\n          }\n          return -1;\n        }\n      }\n    },\n    propFix: {\n      \"for\": \"htmlFor\",\n      \"class\": \"className\"\n    }\n  });\n\n  // Support: IE <=11 only\n  // Accessing the selectedIndex property\n  // forces the browser to respect setting selected\n  // on the option\n  // The getter ensures a default option is selected\n  // when in an optgroup\n  // eslint rule \"no-unused-expressions\" is disabled for this code\n  // since it considers such accessions noop\n  if (!support.optSelected) {\n    jQuery.propHooks.selected = {\n      get: function get(elem) {\n        /* eslint no-unused-expressions: \"off\" */\n\n        var parent = elem.parentNode;\n        if (parent && parent.parentNode) {\n          parent.parentNode.selectedIndex;\n        }\n        return null;\n      },\n      set: function set(elem) {\n        /* eslint no-unused-expressions: \"off\" */\n\n        var parent = elem.parentNode;\n        if (parent) {\n          parent.selectedIndex;\n          if (parent.parentNode) {\n            parent.parentNode.selectedIndex;\n          }\n        }\n      }\n    };\n  }\n  jQuery.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function () {\n    jQuery.propFix[this.toLowerCase()] = this;\n  });\n\n  // Strip and collapse whitespace according to HTML spec\n  // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n  function stripAndCollapse(value) {\n    var tokens = value.match(rnothtmlwhite) || [];\n    return tokens.join(\" \");\n  }\n  function getClass(elem) {\n    return elem.getAttribute && elem.getAttribute(\"class\") || \"\";\n  }\n  function classesToArray(value) {\n    if (Array.isArray(value)) {\n      return value;\n    }\n    if (typeof value === \"string\") {\n      return value.match(rnothtmlwhite) || [];\n    }\n    return [];\n  }\n  jQuery.fn.extend({\n    addClass: function addClass(value) {\n      var classes,\n        elem,\n        cur,\n        curValue,\n        clazz,\n        j,\n        finalValue,\n        i = 0;\n      if (isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).addClass(value.call(this, j, getClass(this)));\n        });\n      }\n      classes = classesToArray(value);\n      if (classes.length) {\n        while (elem = this[i++]) {\n          curValue = getClass(elem);\n          cur = elem.nodeType === 1 && \" \" + stripAndCollapse(curValue) + \" \";\n          if (cur) {\n            j = 0;\n            while (clazz = classes[j++]) {\n              if (cur.indexOf(\" \" + clazz + \" \") < 0) {\n                cur += clazz + \" \";\n              }\n            }\n\n            // Only assign if different to avoid unneeded rendering.\n            finalValue = stripAndCollapse(cur);\n            if (curValue !== finalValue) {\n              elem.setAttribute(\"class\", finalValue);\n            }\n          }\n        }\n      }\n      return this;\n    },\n    removeClass: function removeClass(value) {\n      var classes,\n        elem,\n        cur,\n        curValue,\n        clazz,\n        j,\n        finalValue,\n        i = 0;\n      if (isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).removeClass(value.call(this, j, getClass(this)));\n        });\n      }\n      if (!arguments.length) {\n        return this.attr(\"class\", \"\");\n      }\n      classes = classesToArray(value);\n      if (classes.length) {\n        while (elem = this[i++]) {\n          curValue = getClass(elem);\n\n          // This expression is here for better compressibility (see addClass)\n          cur = elem.nodeType === 1 && \" \" + stripAndCollapse(curValue) + \" \";\n          if (cur) {\n            j = 0;\n            while (clazz = classes[j++]) {\n              // Remove *all* instances\n              while (cur.indexOf(\" \" + clazz + \" \") > -1) {\n                cur = cur.replace(\" \" + clazz + \" \", \" \");\n              }\n            }\n\n            // Only assign if different to avoid unneeded rendering.\n            finalValue = stripAndCollapse(cur);\n            if (curValue !== finalValue) {\n              elem.setAttribute(\"class\", finalValue);\n            }\n          }\n        }\n      }\n      return this;\n    },\n    toggleClass: function toggleClass(value, stateVal) {\n      var type = _typeof(value),\n        isValidValue = type === \"string\" || Array.isArray(value);\n      if (typeof stateVal === \"boolean\" && isValidValue) {\n        return stateVal ? this.addClass(value) : this.removeClass(value);\n      }\n      if (isFunction(value)) {\n        return this.each(function (i) {\n          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);\n        });\n      }\n      return this.each(function () {\n        var className, i, self, classNames;\n        if (isValidValue) {\n          // Toggle individual class names\n          i = 0;\n          self = jQuery(this);\n          classNames = classesToArray(value);\n          while (className = classNames[i++]) {\n            // Check each className given, space separated list\n            if (self.hasClass(className)) {\n              self.removeClass(className);\n            } else {\n              self.addClass(className);\n            }\n          }\n\n          // Toggle whole class name\n        } else if (value === undefined || type === \"boolean\") {\n          className = getClass(this);\n          if (className) {\n            // Store className if set\n            dataPriv.set(this, \"__className__\", className);\n          }\n\n          // If the element has a class name or if we're passed `false`,\n          // then remove the whole classname (if there was one, the above saved it).\n          // Otherwise bring back whatever was previously saved (if anything),\n          // falling back to the empty string if nothing was stored.\n          if (this.setAttribute) {\n            this.setAttribute(\"class\", className || value === false ? \"\" : dataPriv.get(this, \"__className__\") || \"\");\n          }\n        }\n      });\n    },\n    hasClass: function hasClass(selector) {\n      var className,\n        elem,\n        i = 0;\n      className = \" \" + selector + \" \";\n      while (elem = this[i++]) {\n        if (elem.nodeType === 1 && (\" \" + stripAndCollapse(getClass(elem)) + \" \").indexOf(className) > -1) {\n          return true;\n        }\n      }\n      return false;\n    }\n  });\n  var rreturn = /\\r/g;\n  jQuery.fn.extend({\n    val: function val(value) {\n      var hooks,\n        ret,\n        valueIsFunction,\n        elem = this[0];\n      if (!arguments.length) {\n        if (elem) {\n          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];\n          if (hooks && \"get\" in hooks && (ret = hooks.get(elem, \"value\")) !== undefined) {\n            return ret;\n          }\n          ret = elem.value;\n\n          // Handle most common string cases\n          if (typeof ret === \"string\") {\n            return ret.replace(rreturn, \"\");\n          }\n\n          // Handle cases where value is null/undef or number\n          return ret == null ? \"\" : ret;\n        }\n        return;\n      }\n      valueIsFunction = isFunction(value);\n      return this.each(function (i) {\n        var val;\n        if (this.nodeType !== 1) {\n          return;\n        }\n        if (valueIsFunction) {\n          val = value.call(this, i, jQuery(this).val());\n        } else {\n          val = value;\n        }\n\n        // Treat null/undefined as \"\"; convert numbers to string\n        if (val == null) {\n          val = \"\";\n        } else if (typeof val === \"number\") {\n          val += \"\";\n        } else if (Array.isArray(val)) {\n          val = jQuery.map(val, function (value) {\n            return value == null ? \"\" : value + \"\";\n          });\n        }\n        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];\n\n        // If set returns undefined, fall back to normal setting\n        if (!hooks || !(\"set\" in hooks) || hooks.set(this, val, \"value\") === undefined) {\n          this.value = val;\n        }\n      });\n    }\n  });\n  jQuery.extend({\n    valHooks: {\n      option: {\n        get: function get(elem) {\n          var val = jQuery.find.attr(elem, \"value\");\n          return val != null ? val :\n          // Support: IE <=10 - 11 only\n          // option.text throws exceptions (#14686, #14858)\n          // Strip and collapse whitespace\n          // https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n          stripAndCollapse(jQuery.text(elem));\n        }\n      },\n      select: {\n        get: function get(elem) {\n          var value,\n            option,\n            i,\n            options = elem.options,\n            index = elem.selectedIndex,\n            one = elem.type === \"select-one\",\n            values = one ? null : [],\n            max = one ? index + 1 : options.length;\n          if (index < 0) {\n            i = max;\n          } else {\n            i = one ? index : 0;\n          }\n\n          // Loop through all the selected options\n          for (; i < max; i++) {\n            option = options[i];\n\n            // Support: IE <=9 only\n            // IE8-9 doesn't update selected after form reset (#2551)\n            if ((option.selected || i === index) &&\n            // Don't return options that are disabled or in a disabled optgroup\n            !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, \"optgroup\"))) {\n              // Get the specific value for the option\n              value = jQuery(option).val();\n\n              // We don't need an array for one selects\n              if (one) {\n                return value;\n              }\n\n              // Multi-Selects return an array\n              values.push(value);\n            }\n          }\n          return values;\n        },\n        set: function set(elem, value) {\n          var optionSet,\n            option,\n            options = elem.options,\n            values = jQuery.makeArray(value),\n            i = options.length;\n          while (i--) {\n            option = options[i];\n\n            /* eslint-disable no-cond-assign */\n\n            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {\n              optionSet = true;\n            }\n\n            /* eslint-enable no-cond-assign */\n          }\n\n          // Force browsers to behave consistently when non-matching value is set\n          if (!optionSet) {\n            elem.selectedIndex = -1;\n          }\n          return values;\n        }\n      }\n    }\n  });\n\n  // Radios and checkboxes getter/setter\n  jQuery.each([\"radio\", \"checkbox\"], function () {\n    jQuery.valHooks[this] = {\n      set: function set(elem, value) {\n        if (Array.isArray(value)) {\n          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;\n        }\n      }\n    };\n    if (!support.checkOn) {\n      jQuery.valHooks[this].get = function (elem) {\n        return elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n      };\n    }\n  });\n\n  // Return jQuery for attributes-only inclusion\n\n  support.focusin = \"onfocusin\" in window;\n  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n    stopPropagationCallback = function stopPropagationCallback(e) {\n      e.stopPropagation();\n    };\n  jQuery.extend(jQuery.event, {\n    trigger: function trigger(event, data, elem, onlyHandlers) {\n      var i,\n        cur,\n        tmp,\n        bubbleType,\n        ontype,\n        handle,\n        special,\n        lastElement,\n        eventPath = [elem || document],\n        type = hasOwn.call(event, \"type\") ? event.type : event,\n        namespaces = hasOwn.call(event, \"namespace\") ? event.namespace.split(\".\") : [];\n      cur = lastElement = tmp = elem = elem || document;\n\n      // Don't do events on text and comment nodes\n      if (elem.nodeType === 3 || elem.nodeType === 8) {\n        return;\n      }\n\n      // focus/blur morphs to focusin/out; ensure we're not firing them right now\n      if (rfocusMorph.test(type + jQuery.event.triggered)) {\n        return;\n      }\n      if (type.indexOf(\".\") > -1) {\n        // Namespaced trigger; create a regexp to match event type in handle()\n        namespaces = type.split(\".\");\n        type = namespaces.shift();\n        namespaces.sort();\n      }\n      ontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n      // Caller can pass in a jQuery.Event object, Object, or just an event type string\n      event = event[jQuery.expando] ? event : new jQuery.Event(type, _typeof(event) === \"object\" && event);\n\n      // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n      event.isTrigger = onlyHandlers ? 2 : 3;\n      event.namespace = namespaces.join(\".\");\n      event.rnamespace = event.namespace ? new RegExp(\"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null;\n\n      // Clean up the event in case it is being reused\n      event.result = undefined;\n      if (!event.target) {\n        event.target = elem;\n      }\n\n      // Clone any incoming data and prepend the event, creating the handler arg list\n      data = data == null ? [event] : jQuery.makeArray(data, [event]);\n\n      // Allow special events to draw outside the lines\n      special = jQuery.event.special[type] || {};\n      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\n        return;\n      }\n\n      // Determine event propagation path in advance, per W3C events spec (#9951)\n      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n      if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {\n        bubbleType = special.delegateType || type;\n        if (!rfocusMorph.test(bubbleType + type)) {\n          cur = cur.parentNode;\n        }\n        for (; cur; cur = cur.parentNode) {\n          eventPath.push(cur);\n          tmp = cur;\n        }\n\n        // Only add window if we got to document (e.g., not plain obj or detached DOM)\n        if (tmp === (elem.ownerDocument || document)) {\n          eventPath.push(tmp.defaultView || tmp.parentWindow || window);\n        }\n      }\n\n      // Fire handlers on the event path\n      i = 0;\n      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\n        lastElement = cur;\n        event.type = i > 1 ? bubbleType : special.bindType || type;\n\n        // jQuery handler\n        handle = (dataPriv.get(cur, \"events\") || Object.create(null))[event.type] && dataPriv.get(cur, \"handle\");\n        if (handle) {\n          handle.apply(cur, data);\n        }\n\n        // Native handler\n        handle = ontype && cur[ontype];\n        if (handle && handle.apply && acceptData(cur)) {\n          event.result = handle.apply(cur, data);\n          if (event.result === false) {\n            event.preventDefault();\n          }\n        }\n      }\n      event.type = type;\n\n      // If nobody prevented the default action, do it now\n      if (!onlyHandlers && !event.isDefaultPrevented()) {\n        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {\n          // Call a native DOM method on the target with the same name as the event.\n          // Don't do default actions on window, that's where global variables be (#6170)\n          if (ontype && isFunction(elem[type]) && !isWindow(elem)) {\n            // Don't re-trigger an onFOO event when we call its FOO() method\n            tmp = elem[ontype];\n            if (tmp) {\n              elem[ontype] = null;\n            }\n\n            // Prevent re-triggering of the same event, since we already bubbled it above\n            jQuery.event.triggered = type;\n            if (event.isPropagationStopped()) {\n              lastElement.addEventListener(type, stopPropagationCallback);\n            }\n            elem[type]();\n            if (event.isPropagationStopped()) {\n              lastElement.removeEventListener(type, stopPropagationCallback);\n            }\n            jQuery.event.triggered = undefined;\n            if (tmp) {\n              elem[ontype] = tmp;\n            }\n          }\n        }\n      }\n      return event.result;\n    },\n    // Piggyback on a donor event to simulate a different one\n    // Used only for `focus(in | out)` events\n    simulate: function simulate(type, elem, event) {\n      var e = jQuery.extend(new jQuery.Event(), event, {\n        type: type,\n        isSimulated: true\n      });\n      jQuery.event.trigger(e, null, elem);\n    }\n  });\n  jQuery.fn.extend({\n    trigger: function trigger(type, data) {\n      return this.each(function () {\n        jQuery.event.trigger(type, data, this);\n      });\n    },\n    triggerHandler: function triggerHandler(type, data) {\n      var elem = this[0];\n      if (elem) {\n        return jQuery.event.trigger(type, data, elem, true);\n      }\n    }\n  });\n\n  // Support: Firefox <=44\n  // Firefox doesn't have focus(in | out) events\n  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n  //\n  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n  // focus(in | out) events fire after focus & blur events,\n  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\n  if (!support.focusin) {\n    jQuery.each({\n      focus: \"focusin\",\n      blur: \"focusout\"\n    }, function (orig, fix) {\n      // Attach a single capturing handler on the document while someone wants focusin/focusout\n      var handler = function handler(event) {\n        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));\n      };\n      jQuery.event.special[fix] = {\n        setup: function setup() {\n          // Handle: regular nodes (via `this.ownerDocument`), window\n          // (via `this.document`) & document (via `this`).\n          var doc = this.ownerDocument || this.document || this,\n            attaches = dataPriv.access(doc, fix);\n          if (!attaches) {\n            doc.addEventListener(orig, handler, true);\n          }\n          dataPriv.access(doc, fix, (attaches || 0) + 1);\n        },\n        teardown: function teardown() {\n          var doc = this.ownerDocument || this.document || this,\n            attaches = dataPriv.access(doc, fix) - 1;\n          if (!attaches) {\n            doc.removeEventListener(orig, handler, true);\n            dataPriv.remove(doc, fix);\n          } else {\n            dataPriv.access(doc, fix, attaches);\n          }\n        }\n      };\n    });\n  }\n  var location = window.location;\n  var nonce = {\n    guid: Date.now()\n  };\n  var rquery = /\\?/;\n\n  // Cross-browser xml parsing\n  jQuery.parseXML = function (data) {\n    var xml, parserErrorElem;\n    if (!data || typeof data !== \"string\") {\n      return null;\n    }\n\n    // Support: IE 9 - 11 only\n    // IE throws on parseFromString with invalid input.\n    try {\n      xml = new window.DOMParser().parseFromString(data, \"text/xml\");\n    } catch (e) {}\n    parserErrorElem = xml && xml.getElementsByTagName(\"parsererror\")[0];\n    if (!xml || parserErrorElem) {\n      jQuery.error(\"Invalid XML: \" + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function (el) {\n        return el.textContent;\n      }).join(\"\\n\") : data));\n    }\n    return xml;\n  };\n  var rbracket = /\\[\\]$/,\n    rCRLF = /\\r?\\n/g,\n    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n    rsubmittable = /^(?:input|select|textarea|keygen)/i;\n  function buildParams(prefix, obj, traditional, add) {\n    var name;\n    if (Array.isArray(obj)) {\n      // Serialize array item.\n      jQuery.each(obj, function (i, v) {\n        if (traditional || rbracket.test(prefix)) {\n          // Treat each array item as a scalar.\n          add(prefix, v);\n        } else {\n          // Item is non-scalar (array or object), encode its numeric index.\n          buildParams(prefix + \"[\" + (_typeof(v) === \"object\" && v != null ? i : \"\") + \"]\", v, traditional, add);\n        }\n      });\n    } else if (!traditional && toType(obj) === \"object\") {\n      // Serialize object item.\n      for (name in obj) {\n        buildParams(prefix + \"[\" + name + \"]\", obj[name], traditional, add);\n      }\n    } else {\n      // Serialize scalar item.\n      add(prefix, obj);\n    }\n  }\n\n  // Serialize an array of form elements or a set of\n  // key/values into a query string\n  jQuery.param = function (a, traditional) {\n    var prefix,\n      s = [],\n      add = function add(key, valueOrFunction) {\n        // If value is a function, invoke it and use its return value\n        var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;\n        s[s.length] = encodeURIComponent(key) + \"=\" + encodeURIComponent(value == null ? \"\" : value);\n      };\n    if (a == null) {\n      return \"\";\n    }\n\n    // If an array was passed in, assume that it is an array of form elements.\n    if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {\n      // Serialize the form elements\n      jQuery.each(a, function () {\n        add(this.name, this.value);\n      });\n    } else {\n      // If traditional, encode the \"old\" way (the way 1.3.2 or older\n      // did it), otherwise encode params recursively.\n      for (prefix in a) {\n        buildParams(prefix, a[prefix], traditional, add);\n      }\n    }\n\n    // Return the resulting serialization\n    return s.join(\"&\");\n  };\n  jQuery.fn.extend({\n    serialize: function serialize() {\n      return jQuery.param(this.serializeArray());\n    },\n    serializeArray: function serializeArray() {\n      return this.map(function () {\n        // Can add propHook for \"elements\" to filter or add form elements\n        var elements = jQuery.prop(this, \"elements\");\n        return elements ? jQuery.makeArray(elements) : this;\n      }).filter(function () {\n        var type = this.type;\n\n        // Use .is( \":disabled\" ) so that fieldset[disabled] works\n        return this.name && !jQuery(this).is(\":disabled\") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));\n      }).map(function (_i, elem) {\n        var val = jQuery(this).val();\n        if (val == null) {\n          return null;\n        }\n        if (Array.isArray(val)) {\n          return jQuery.map(val, function (val) {\n            return {\n              name: elem.name,\n              value: val.replace(rCRLF, \"\\r\\n\")\n            };\n          });\n        }\n        return {\n          name: elem.name,\n          value: val.replace(rCRLF, \"\\r\\n\")\n        };\n      }).get();\n    }\n  });\n  var r20 = /%20/g,\n    rhash = /#.*$/,\n    rantiCache = /([?&])_=[^&]*/,\n    rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n    // #7653, #8125, #8152: local protocol detection\n    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n    rnoContent = /^(?:GET|HEAD)$/,\n    rprotocol = /^\\/\\//,\n    /* Prefilters\n     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n     * 2) These are called:\n     *    - BEFORE asking for a transport\n     *    - AFTER param serialization (s.data is a string if s.processData is true)\n     * 3) key is the dataType\n     * 4) the catchall symbol \"*\" can be used\n     * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n     */\n    prefilters = {},\n    /* Transports bindings\n     * 1) key is the dataType\n     * 2) the catchall symbol \"*\" can be used\n     * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n     */\n    transports = {},\n    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n    allTypes = \"*/\".concat(\"*\"),\n    // Anchor tag for parsing the document origin\n    originAnchor = document.createElement(\"a\");\n  originAnchor.href = location.href;\n\n  // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n  function addToPrefiltersOrTransports(structure) {\n    // dataTypeExpression is optional and defaults to \"*\"\n    return function (dataTypeExpression, func) {\n      if (typeof dataTypeExpression !== \"string\") {\n        func = dataTypeExpression;\n        dataTypeExpression = \"*\";\n      }\n      var dataType,\n        i = 0,\n        dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];\n      if (isFunction(func)) {\n        // For each dataType in the dataTypeExpression\n        while (dataType = dataTypes[i++]) {\n          // Prepend if requested\n          if (dataType[0] === \"+\") {\n            dataType = dataType.slice(1) || \"*\";\n            (structure[dataType] = structure[dataType] || []).unshift(func);\n\n            // Otherwise append\n          } else {\n            (structure[dataType] = structure[dataType] || []).push(func);\n          }\n        }\n      }\n    };\n  }\n\n  // Base inspection function for prefilters and transports\n  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\n    var inspected = {},\n      seekingTransport = structure === transports;\n    function inspect(dataType) {\n      var selected;\n      inspected[dataType] = true;\n      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\n        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\n        if (typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[dataTypeOrTransport]) {\n          options.dataTypes.unshift(dataTypeOrTransport);\n          inspect(dataTypeOrTransport);\n          return false;\n        } else if (seekingTransport) {\n          return !(selected = dataTypeOrTransport);\n        }\n      });\n      return selected;\n    }\n    return inspect(options.dataTypes[0]) || !inspected[\"*\"] && inspect(\"*\");\n  }\n\n  // A special extend for ajax options\n  // that takes \"flat\" options (not to be deep extended)\n  // Fixes #9887\n  function ajaxExtend(target, src) {\n    var key,\n      deep,\n      flatOptions = jQuery.ajaxSettings.flatOptions || {};\n    for (key in src) {\n      if (src[key] !== undefined) {\n        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\n      }\n    }\n    if (deep) {\n      jQuery.extend(true, target, deep);\n    }\n    return target;\n  }\n\n  /* Handles responses to an ajax request:\n   * - finds the right dataType (mediates between content-type and expected dataType)\n   * - returns the corresponding response\n   */\n  function ajaxHandleResponses(s, jqXHR, responses) {\n    var ct,\n      type,\n      finalDataType,\n      firstDataType,\n      contents = s.contents,\n      dataTypes = s.dataTypes;\n\n    // Remove auto dataType and get content-type in the process\n    while (dataTypes[0] === \"*\") {\n      dataTypes.shift();\n      if (ct === undefined) {\n        ct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n      }\n    }\n\n    // Check if we're dealing with a known content-type\n    if (ct) {\n      for (type in contents) {\n        if (contents[type] && contents[type].test(ct)) {\n          dataTypes.unshift(type);\n          break;\n        }\n      }\n    }\n\n    // Check to see if we have a response for the expected dataType\n    if (dataTypes[0] in responses) {\n      finalDataType = dataTypes[0];\n    } else {\n      // Try convertible dataTypes\n      for (type in responses) {\n        if (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\n          finalDataType = type;\n          break;\n        }\n        if (!firstDataType) {\n          firstDataType = type;\n        }\n      }\n\n      // Or just use first one\n      finalDataType = finalDataType || firstDataType;\n    }\n\n    // If we found a dataType\n    // We add the dataType to the list if needed\n    // and return the corresponding response\n    if (finalDataType) {\n      if (finalDataType !== dataTypes[0]) {\n        dataTypes.unshift(finalDataType);\n      }\n      return responses[finalDataType];\n    }\n  }\n\n  /* Chain conversions given the request and the original response\n   * Also sets the responseXXX fields on the jqXHR instance\n   */\n  function ajaxConvert(s, response, jqXHR, isSuccess) {\n    var conv2,\n      current,\n      conv,\n      tmp,\n      prev,\n      converters = {},\n      // Work with a copy of dataTypes in case we need to modify it for conversion\n      dataTypes = s.dataTypes.slice();\n\n    // Create converters map with lowercased keys\n    if (dataTypes[1]) {\n      for (conv in s.converters) {\n        converters[conv.toLowerCase()] = s.converters[conv];\n      }\n    }\n    current = dataTypes.shift();\n\n    // Convert to each sequential dataType\n    while (current) {\n      if (s.responseFields[current]) {\n        jqXHR[s.responseFields[current]] = response;\n      }\n\n      // Apply the dataFilter if provided\n      if (!prev && isSuccess && s.dataFilter) {\n        response = s.dataFilter(response, s.dataType);\n      }\n      prev = current;\n      current = dataTypes.shift();\n      if (current) {\n        // There's only work to do if current dataType is non-auto\n        if (current === \"*\") {\n          current = prev;\n\n          // Convert response if prev dataType is non-auto and differs from current\n        } else if (prev !== \"*\" && prev !== current) {\n          // Seek a direct converter\n          conv = converters[prev + \" \" + current] || converters[\"* \" + current];\n\n          // If none found, seek a pair\n          if (!conv) {\n            for (conv2 in converters) {\n              // If conv2 outputs current\n              tmp = conv2.split(\" \");\n              if (tmp[1] === current) {\n                // If prev can be converted to accepted input\n                conv = converters[prev + \" \" + tmp[0]] || converters[\"* \" + tmp[0]];\n                if (conv) {\n                  // Condense equivalence converters\n                  if (conv === true) {\n                    conv = converters[conv2];\n\n                    // Otherwise, insert the intermediate dataType\n                  } else if (converters[conv2] !== true) {\n                    current = tmp[0];\n                    dataTypes.unshift(tmp[1]);\n                  }\n                  break;\n                }\n              }\n            }\n          }\n\n          // Apply converter (if not an equivalence)\n          if (conv !== true) {\n            // Unless errors are allowed to bubble, catch and return them\n            if (conv && s[\"throws\"]) {\n              response = conv(response);\n            } else {\n              try {\n                response = conv(response);\n              } catch (e) {\n                return {\n                  state: \"parsererror\",\n                  error: conv ? e : \"No conversion from \" + prev + \" to \" + current\n                };\n              }\n            }\n          }\n        }\n      }\n    }\n    return {\n      state: \"success\",\n      data: response\n    };\n  }\n  jQuery.extend({\n    // Counter for holding the number of active queries\n    active: 0,\n    // Last-Modified header cache for next request\n    lastModified: {},\n    etag: {},\n    ajaxSettings: {\n      url: location.href,\n      type: \"GET\",\n      isLocal: rlocalProtocol.test(location.protocol),\n      global: true,\n      processData: true,\n      async: true,\n      contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n      /*\n      timeout: 0,\n      data: null,\n      dataType: null,\n      username: null,\n      password: null,\n      cache: null,\n      throws: false,\n      traditional: false,\n      headers: {},\n      */\n\n      accepts: {\n        \"*\": allTypes,\n        text: \"text/plain\",\n        html: \"text/html\",\n        xml: \"application/xml, text/xml\",\n        json: \"application/json, text/javascript\"\n      },\n      contents: {\n        xml: /\\bxml\\b/,\n        html: /\\bhtml/,\n        json: /\\bjson\\b/\n      },\n      responseFields: {\n        xml: \"responseXML\",\n        text: \"responseText\",\n        json: \"responseJSON\"\n      },\n      // Data converters\n      // Keys separate source (or catchall \"*\") and destination types with a single space\n      converters: {\n        // Convert anything to text\n        \"* text\": String,\n        // Text to html (true = no transformation)\n        \"text html\": true,\n        // Evaluate text as a json expression\n        \"text json\": JSON.parse,\n        // Parse text as xml\n        \"text xml\": jQuery.parseXML\n      },\n      // For options that shouldn't be deep extended:\n      // you can add your own custom options here if\n      // and when you create one that shouldn't be\n      // deep extended (see ajaxExtend)\n      flatOptions: {\n        url: true,\n        context: true\n      }\n    },\n    // Creates a full fledged settings object into target\n    // with both ajaxSettings and settings fields.\n    // If target is omitted, writes into ajaxSettings.\n    ajaxSetup: function ajaxSetup(target, settings) {\n      return settings ?\n      // Building a settings object\n      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :\n      // Extending ajaxSettings\n      ajaxExtend(jQuery.ajaxSettings, target);\n    },\n    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n    ajaxTransport: addToPrefiltersOrTransports(transports),\n    // Main method\n    ajax: function ajax(url, options) {\n      // If url is an object, simulate pre-1.5 signature\n      if (_typeof(url) === \"object\") {\n        options = url;\n        url = undefined;\n      }\n\n      // Force options to be an object\n      options = options || {};\n      var transport,\n        // URL without anti-cache param\n        cacheURL,\n        // Response headers\n        responseHeadersString,\n        responseHeaders,\n        // timeout handle\n        timeoutTimer,\n        // Url cleanup var\n        urlAnchor,\n        // Request state (becomes false upon send and true upon completion)\n        completed,\n        // To know if global events are to be dispatched\n        fireGlobals,\n        // Loop variable\n        i,\n        // uncached part of the url\n        uncached,\n        // Create the final options object\n        s = jQuery.ajaxSetup({}, options),\n        // Callbacks context\n        callbackContext = s.context || s,\n        // Context for global events is callbackContext if it is a DOM node or jQuery collection\n        globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,\n        // Deferreds\n        deferred = jQuery.Deferred(),\n        completeDeferred = jQuery.Callbacks(\"once memory\"),\n        // Status-dependent callbacks\n        _statusCode = s.statusCode || {},\n        // Headers (they are sent all at once)\n        requestHeaders = {},\n        requestHeadersNames = {},\n        // Default abort message\n        strAbort = \"canceled\",\n        // Fake xhr\n        jqXHR = {\n          readyState: 0,\n          // Builds headers hashtable if needed\n          getResponseHeader: function getResponseHeader(key) {\n            var match;\n            if (completed) {\n              if (!responseHeaders) {\n                responseHeaders = {};\n                while (match = rheaders.exec(responseHeadersString)) {\n                  responseHeaders[match[1].toLowerCase() + \" \"] = (responseHeaders[match[1].toLowerCase() + \" \"] || []).concat(match[2]);\n                }\n              }\n              match = responseHeaders[key.toLowerCase() + \" \"];\n            }\n            return match == null ? null : match.join(\", \");\n          },\n          // Raw string\n          getAllResponseHeaders: function getAllResponseHeaders() {\n            return completed ? responseHeadersString : null;\n          },\n          // Caches the header\n          setRequestHeader: function setRequestHeader(name, value) {\n            if (completed == null) {\n              name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;\n              requestHeaders[name] = value;\n            }\n            return this;\n          },\n          // Overrides response content-type header\n          overrideMimeType: function overrideMimeType(type) {\n            if (completed == null) {\n              s.mimeType = type;\n            }\n            return this;\n          },\n          // Status-dependent callbacks\n          statusCode: function statusCode(map) {\n            var code;\n            if (map) {\n              if (completed) {\n                // Execute the appropriate callbacks\n                jqXHR.always(map[jqXHR.status]);\n              } else {\n                // Lazy-add the new callbacks in a way that preserves old ones\n                for (code in map) {\n                  _statusCode[code] = [_statusCode[code], map[code]];\n                }\n              }\n            }\n            return this;\n          },\n          // Cancel the request\n          abort: function abort(statusText) {\n            var finalText = statusText || strAbort;\n            if (transport) {\n              transport.abort(finalText);\n            }\n            done(0, finalText);\n            return this;\n          }\n        };\n\n      // Attach deferreds\n      deferred.promise(jqXHR);\n\n      // Add protocol if not provided (prefilters might expect it)\n      // Handle falsy url in the settings object (#10093: consistency with old signature)\n      // We also use the url parameter if available\n      s.url = ((url || s.url || location.href) + \"\").replace(rprotocol, location.protocol + \"//\");\n\n      // Alias method option to type as per ticket #12004\n      s.type = options.method || options.type || s.method || s.type;\n\n      // Extract dataTypes list\n      s.dataTypes = (s.dataType || \"*\").toLowerCase().match(rnothtmlwhite) || [\"\"];\n\n      // A cross-domain request is in order when the origin doesn't match the current origin.\n      if (s.crossDomain == null) {\n        urlAnchor = document.createElement(\"a\");\n\n        // Support: IE <=8 - 11, Edge 12 - 15\n        // IE throws exception on accessing the href property if url is malformed,\n        // e.g. http://example.com:80x/\n        try {\n          urlAnchor.href = s.url;\n\n          // Support: IE <=8 - 11 only\n          // Anchor's host property isn't correctly set when s.url is relative\n          urlAnchor.href = urlAnchor.href;\n          s.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !== urlAnchor.protocol + \"//\" + urlAnchor.host;\n        } catch (e) {\n          // If there is an error parsing the URL, assume it is crossDomain,\n          // it can be rejected by the transport if it is invalid\n          s.crossDomain = true;\n        }\n      }\n\n      // Convert data if not already a string\n      if (s.data && s.processData && typeof s.data !== \"string\") {\n        s.data = jQuery.param(s.data, s.traditional);\n      }\n\n      // Apply prefilters\n      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);\n\n      // If request was aborted inside a prefilter, stop there\n      if (completed) {\n        return jqXHR;\n      }\n\n      // We can fire global events as of now if asked to\n      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n      fireGlobals = jQuery.event && s.global;\n\n      // Watch for a new set of requests\n      if (fireGlobals && jQuery.active++ === 0) {\n        jQuery.event.trigger(\"ajaxStart\");\n      }\n\n      // Uppercase the type\n      s.type = s.type.toUpperCase();\n\n      // Determine if request has content\n      s.hasContent = !rnoContent.test(s.type);\n\n      // Save the URL in case we're toying with the If-Modified-Since\n      // and/or If-None-Match header later on\n      // Remove hash to simplify url manipulation\n      cacheURL = s.url.replace(rhash, \"\");\n\n      // More options handling for requests with no content\n      if (!s.hasContent) {\n        // Remember the hash so we can put it back\n        uncached = s.url.slice(cacheURL.length);\n\n        // If data is available and should be processed, append data to url\n        if (s.data && (s.processData || typeof s.data === \"string\")) {\n          cacheURL += (rquery.test(cacheURL) ? \"&\" : \"?\") + s.data;\n\n          // #9682: remove data so that it's not used in an eventual retry\n          delete s.data;\n        }\n\n        // Add or update anti-cache param if needed\n        if (s.cache === false) {\n          cacheURL = cacheURL.replace(rantiCache, \"$1\");\n          uncached = (rquery.test(cacheURL) ? \"&\" : \"?\") + \"_=\" + nonce.guid++ + uncached;\n        }\n\n        // Put hash and anti-cache on the URL that will be requested (gh-1732)\n        s.url = cacheURL + uncached;\n\n        // Change '%20' to '+' if this is encoded form body content (gh-2658)\n      } else if (s.data && s.processData && (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0) {\n        s.data = s.data.replace(r20, \"+\");\n      }\n\n      // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n      if (s.ifModified) {\n        if (jQuery.lastModified[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[cacheURL]);\n        }\n        if (jQuery.etag[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-None-Match\", jQuery.etag[cacheURL]);\n        }\n      }\n\n      // Set the correct header, if data is being sent\n      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {\n        jqXHR.setRequestHeader(\"Content-Type\", s.contentType);\n      }\n\n      // Set the Accepts header for the server, depending on the dataType\n      jqXHR.setRequestHeader(\"Accept\", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\") : s.accepts[\"*\"]);\n\n      // Check for headers option\n      for (i in s.headers) {\n        jqXHR.setRequestHeader(i, s.headers[i]);\n      }\n\n      // Allow custom headers/mimetypes and early abort\n      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {\n        // Abort if not done already and return\n        return jqXHR.abort();\n      }\n\n      // Aborting is no longer a cancellation\n      strAbort = \"abort\";\n\n      // Install callbacks on deferreds\n      completeDeferred.add(s.complete);\n      jqXHR.done(s.success);\n      jqXHR.fail(s.error);\n\n      // Get transport\n      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);\n\n      // If no transport, we auto-abort\n      if (!transport) {\n        done(-1, \"No Transport\");\n      } else {\n        jqXHR.readyState = 1;\n\n        // Send global event\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxSend\", [jqXHR, s]);\n        }\n\n        // If request was aborted inside ajaxSend, stop there\n        if (completed) {\n          return jqXHR;\n        }\n\n        // Timeout\n        if (s.async && s.timeout > 0) {\n          timeoutTimer = window.setTimeout(function () {\n            jqXHR.abort(\"timeout\");\n          }, s.timeout);\n        }\n        try {\n          completed = false;\n          transport.send(requestHeaders, done);\n        } catch (e) {\n          // Rethrow post-completion exceptions\n          if (completed) {\n            throw e;\n          }\n\n          // Propagate others as results\n          done(-1, e);\n        }\n      }\n\n      // Callback for when everything is done\n      function done(status, nativeStatusText, responses, headers) {\n        var isSuccess,\n          success,\n          error,\n          response,\n          modified,\n          statusText = nativeStatusText;\n\n        // Ignore repeat invocations\n        if (completed) {\n          return;\n        }\n        completed = true;\n\n        // Clear timeout if it exists\n        if (timeoutTimer) {\n          window.clearTimeout(timeoutTimer);\n        }\n\n        // Dereference transport for early garbage collection\n        // (no matter how long the jqXHR object will be used)\n        transport = undefined;\n\n        // Cache response headers\n        responseHeadersString = headers || \"\";\n\n        // Set readyState\n        jqXHR.readyState = status > 0 ? 4 : 0;\n\n        // Determine if successful\n        isSuccess = status >= 200 && status < 300 || status === 304;\n\n        // Get response data\n        if (responses) {\n          response = ajaxHandleResponses(s, jqXHR, responses);\n        }\n\n        // Use a noop converter for missing script but not if jsonp\n        if (!isSuccess && jQuery.inArray(\"script\", s.dataTypes) > -1 && jQuery.inArray(\"json\", s.dataTypes) < 0) {\n          s.converters[\"text script\"] = function () {};\n        }\n\n        // Convert no matter what (that way responseXXX fields are always set)\n        response = ajaxConvert(s, response, jqXHR, isSuccess);\n\n        // If successful, handle type chaining\n        if (isSuccess) {\n          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n          if (s.ifModified) {\n            modified = jqXHR.getResponseHeader(\"Last-Modified\");\n            if (modified) {\n              jQuery.lastModified[cacheURL] = modified;\n            }\n            modified = jqXHR.getResponseHeader(\"etag\");\n            if (modified) {\n              jQuery.etag[cacheURL] = modified;\n            }\n          }\n\n          // if no content\n          if (status === 204 || s.type === \"HEAD\") {\n            statusText = \"nocontent\";\n\n            // if not modified\n          } else if (status === 304) {\n            statusText = \"notmodified\";\n\n            // If we have data, let's convert it\n          } else {\n            statusText = response.state;\n            success = response.data;\n            error = response.error;\n            isSuccess = !error;\n          }\n        } else {\n          // Extract error from statusText and normalize for non-aborts\n          error = statusText;\n          if (status || !statusText) {\n            statusText = \"error\";\n            if (status < 0) {\n              status = 0;\n            }\n          }\n        }\n\n        // Set data for the fake xhr object\n        jqXHR.status = status;\n        jqXHR.statusText = (nativeStatusText || statusText) + \"\";\n\n        // Success/Error\n        if (isSuccess) {\n          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\n        } else {\n          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\n        }\n\n        // Status-dependent callbacks\n        jqXHR.statusCode(_statusCode);\n        _statusCode = undefined;\n        if (fireGlobals) {\n          globalEventContext.trigger(isSuccess ? \"ajaxSuccess\" : \"ajaxError\", [jqXHR, s, isSuccess ? success : error]);\n        }\n\n        // Complete\n        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxComplete\", [jqXHR, s]);\n\n          // Handle the global AJAX counter\n          if (! --jQuery.active) {\n            jQuery.event.trigger(\"ajaxStop\");\n          }\n        }\n      }\n      return jqXHR;\n    },\n    getJSON: function getJSON(url, data, callback) {\n      return jQuery.get(url, data, callback, \"json\");\n    },\n    getScript: function getScript(url, callback) {\n      return jQuery.get(url, undefined, callback, \"script\");\n    }\n  });\n  jQuery.each([\"get\", \"post\"], function (_i, method) {\n    jQuery[method] = function (url, data, callback, type) {\n      // Shift arguments if data argument was omitted\n      if (isFunction(data)) {\n        type = type || callback;\n        callback = data;\n        data = undefined;\n      }\n\n      // The url can be an options object (which then must have .url)\n      return jQuery.ajax(jQuery.extend({\n        url: url,\n        type: method,\n        dataType: type,\n        data: data,\n        success: callback\n      }, jQuery.isPlainObject(url) && url));\n    };\n  });\n  jQuery.ajaxPrefilter(function (s) {\n    var i;\n    for (i in s.headers) {\n      if (i.toLowerCase() === \"content-type\") {\n        s.contentType = s.headers[i] || \"\";\n      }\n    }\n  });\n  jQuery._evalUrl = function (url, options, doc) {\n    return jQuery.ajax({\n      url: url,\n      // Make this explicit, since user can override this through ajaxSetup (#11264)\n      type: \"GET\",\n      dataType: \"script\",\n      cache: true,\n      async: false,\n      global: false,\n      // Only evaluate the response if it is successful (gh-4126)\n      // dataFilter is not invoked for failure responses, so using it instead\n      // of the default converter is kludgy but it works.\n      converters: {\n        \"text script\": function textScript() {}\n      },\n      dataFilter: function dataFilter(response) {\n        jQuery.globalEval(response, options, doc);\n      }\n    });\n  };\n  jQuery.fn.extend({\n    wrapAll: function wrapAll(html) {\n      var wrap;\n      if (this[0]) {\n        if (isFunction(html)) {\n          html = html.call(this[0]);\n        }\n\n        // The elements to wrap the target around\n        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);\n        if (this[0].parentNode) {\n          wrap.insertBefore(this[0]);\n        }\n        wrap.map(function () {\n          var elem = this;\n          while (elem.firstElementChild) {\n            elem = elem.firstElementChild;\n          }\n          return elem;\n        }).append(this);\n      }\n      return this;\n    },\n    wrapInner: function wrapInner(html) {\n      if (isFunction(html)) {\n        return this.each(function (i) {\n          jQuery(this).wrapInner(html.call(this, i));\n        });\n      }\n      return this.each(function () {\n        var self = jQuery(this),\n          contents = self.contents();\n        if (contents.length) {\n          contents.wrapAll(html);\n        } else {\n          self.append(html);\n        }\n      });\n    },\n    wrap: function wrap(html) {\n      var htmlIsFunction = isFunction(html);\n      return this.each(function (i) {\n        jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);\n      });\n    },\n    unwrap: function unwrap(selector) {\n      this.parent(selector).not(\"body\").each(function () {\n        jQuery(this).replaceWith(this.childNodes);\n      });\n      return this;\n    }\n  });\n  jQuery.expr.pseudos.hidden = function (elem) {\n    return !jQuery.expr.pseudos.visible(elem);\n  };\n  jQuery.expr.pseudos.visible = function (elem) {\n    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);\n  };\n  jQuery.ajaxSettings.xhr = function () {\n    try {\n      return new window.XMLHttpRequest();\n    } catch (e) {}\n  };\n  var xhrSuccessStatus = {\n      // File protocol always yields status code 0, assume 200\n      0: 200,\n      // Support: IE <=9 only\n      // #1450: sometimes IE returns 1223 when it should be 204\n      1223: 204\n    },\n    xhrSupported = jQuery.ajaxSettings.xhr();\n  support.cors = !!xhrSupported && \"withCredentials\" in xhrSupported;\n  support.ajax = xhrSupported = !!xhrSupported;\n  jQuery.ajaxTransport(function (options) {\n    var _callback, errorCallback;\n\n    // Cross domain only allowed if supported through XMLHttpRequest\n    if (support.cors || xhrSupported && !options.crossDomain) {\n      return {\n        send: function send(headers, complete) {\n          var i,\n            xhr = options.xhr();\n          xhr.open(options.type, options.url, options.async, options.username, options.password);\n\n          // Apply custom fields if provided\n          if (options.xhrFields) {\n            for (i in options.xhrFields) {\n              xhr[i] = options.xhrFields[i];\n            }\n          }\n\n          // Override mime type if needed\n          if (options.mimeType && xhr.overrideMimeType) {\n            xhr.overrideMimeType(options.mimeType);\n          }\n\n          // X-Requested-With header\n          // For cross-domain requests, seeing as conditions for a preflight are\n          // akin to a jigsaw puzzle, we simply never set it to be sure.\n          // (it can always be set on a per-request basis or even using ajaxSetup)\n          // For same-domain requests, won't change header if already provided.\n          if (!options.crossDomain && !headers[\"X-Requested-With\"]) {\n            headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n          }\n\n          // Set headers\n          for (i in headers) {\n            xhr.setRequestHeader(i, headers[i]);\n          }\n\n          // Callback\n          _callback = function callback(type) {\n            return function () {\n              if (_callback) {\n                _callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;\n                if (type === \"abort\") {\n                  xhr.abort();\n                } else if (type === \"error\") {\n                  // Support: IE <=9 only\n                  // On a manual native abort, IE9 throws\n                  // errors on any property access that is not readyState\n                  if (typeof xhr.status !== \"number\") {\n                    complete(0, \"error\");\n                  } else {\n                    complete(\n                    // File: protocol always yields status 0; see #8605, #14207\n                    xhr.status, xhr.statusText);\n                  }\n                } else {\n                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText,\n                  // Support: IE <=9 only\n                  // IE9 has no XHR2 but throws on binary (trac-11426)\n                  // For XHR2 non-text, let the caller handle it (gh-2498)\n                  (xhr.responseType || \"text\") !== \"text\" || typeof xhr.responseText !== \"string\" ? {\n                    binary: xhr.response\n                  } : {\n                    text: xhr.responseText\n                  }, xhr.getAllResponseHeaders());\n                }\n              }\n            };\n          };\n\n          // Listen to events\n          xhr.onload = _callback();\n          errorCallback = xhr.onerror = xhr.ontimeout = _callback(\"error\");\n\n          // Support: IE 9 only\n          // Use onreadystatechange to replace onabort\n          // to handle uncaught aborts\n          if (xhr.onabort !== undefined) {\n            xhr.onabort = errorCallback;\n          } else {\n            xhr.onreadystatechange = function () {\n              // Check readyState before timeout as it changes\n              if (xhr.readyState === 4) {\n                // Allow onerror to be called first,\n                // but that will not handle a native abort\n                // Also, save errorCallback to a variable\n                // as xhr.onerror cannot be accessed\n                window.setTimeout(function () {\n                  if (_callback) {\n                    errorCallback();\n                  }\n                });\n              }\n            };\n          }\n\n          // Create the abort callback\n          _callback = _callback(\"abort\");\n          try {\n            // Do send the request (this may raise an exception)\n            xhr.send(options.hasContent && options.data || null);\n          } catch (e) {\n            // #14683: Only rethrow if this hasn't been notified as an error yet\n            if (_callback) {\n              throw e;\n            }\n          }\n        },\n        abort: function abort() {\n          if (_callback) {\n            _callback();\n          }\n        }\n      };\n    }\n  });\n\n  // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\n  jQuery.ajaxPrefilter(function (s) {\n    if (s.crossDomain) {\n      s.contents.script = false;\n    }\n  });\n\n  // Install script dataType\n  jQuery.ajaxSetup({\n    accepts: {\n      script: \"text/javascript, application/javascript, \" + \"application/ecmascript, application/x-ecmascript\"\n    },\n    contents: {\n      script: /\\b(?:java|ecma)script\\b/\n    },\n    converters: {\n      \"text script\": function textScript(text) {\n        jQuery.globalEval(text);\n        return text;\n      }\n    }\n  });\n\n  // Handle cache's special case and crossDomain\n  jQuery.ajaxPrefilter(\"script\", function (s) {\n    if (s.cache === undefined) {\n      s.cache = false;\n    }\n    if (s.crossDomain) {\n      s.type = \"GET\";\n    }\n  });\n\n  // Bind script tag hack transport\n  jQuery.ajaxTransport(\"script\", function (s) {\n    // This transport only deals with cross domain or forced-by-attrs requests\n    if (s.crossDomain || s.scriptAttrs) {\n      var script, _callback2;\n      return {\n        send: function send(_, complete) {\n          script = jQuery(\"<script>\").attr(s.scriptAttrs || {}).prop({\n            charset: s.scriptCharset,\n            src: s.url\n          }).on(\"load error\", _callback2 = function callback(evt) {\n            script.remove();\n            _callback2 = null;\n            if (evt) {\n              complete(evt.type === \"error\" ? 404 : 200, evt.type);\n            }\n          });\n\n          // Use native DOM manipulation to avoid our domManip AJAX trickery\n          document.head.appendChild(script[0]);\n        },\n        abort: function abort() {\n          if (_callback2) {\n            _callback2();\n          }\n        }\n      };\n    }\n  });\n  var oldCallbacks = [],\n    rjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n  // Default jsonp settings\n  jQuery.ajaxSetup({\n    jsonp: \"callback\",\n    jsonpCallback: function jsonpCallback() {\n      var callback = oldCallbacks.pop() || jQuery.expando + \"_\" + nonce.guid++;\n      this[callback] = true;\n      return callback;\n    }\n  });\n\n  // Detect, normalize options and install callbacks for jsonp requests\n  jQuery.ajaxPrefilter(\"json jsonp\", function (s, originalSettings, jqXHR) {\n    var callbackName,\n      overwritten,\n      responseContainer,\n      jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? \"url\" : typeof s.data === \"string\" && (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0 && rjsonp.test(s.data) && \"data\");\n\n    // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n    if (jsonProp || s.dataTypes[0] === \"jsonp\") {\n      // Get callback name, remembering preexisting value associated with it\n      callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;\n\n      // Insert callback into url or form data\n      if (jsonProp) {\n        s[jsonProp] = s[jsonProp].replace(rjsonp, \"$1\" + callbackName);\n      } else if (s.jsonp !== false) {\n        s.url += (rquery.test(s.url) ? \"&\" : \"?\") + s.jsonp + \"=\" + callbackName;\n      }\n\n      // Use data converter to retrieve json after script execution\n      s.converters[\"script json\"] = function () {\n        if (!responseContainer) {\n          jQuery.error(callbackName + \" was not called\");\n        }\n        return responseContainer[0];\n      };\n\n      // Force json dataType\n      s.dataTypes[0] = \"json\";\n\n      // Install callback\n      overwritten = window[callbackName];\n      window[callbackName] = function () {\n        responseContainer = arguments;\n      };\n\n      // Clean-up function (fires after converters)\n      jqXHR.always(function () {\n        // If previous value didn't exist - remove it\n        if (overwritten === undefined) {\n          jQuery(window).removeProp(callbackName);\n\n          // Otherwise restore preexisting value\n        } else {\n          window[callbackName] = overwritten;\n        }\n\n        // Save back as free\n        if (s[callbackName]) {\n          // Make sure that re-using the options doesn't screw things around\n          s.jsonpCallback = originalSettings.jsonpCallback;\n\n          // Save the callback name for future use\n          oldCallbacks.push(callbackName);\n        }\n\n        // Call if it was a function and we have a response\n        if (responseContainer && isFunction(overwritten)) {\n          overwritten(responseContainer[0]);\n        }\n        responseContainer = overwritten = undefined;\n      });\n\n      // Delegate to script\n      return \"script\";\n    }\n  });\n\n  // Support: Safari 8 only\n  // In Safari 8 documents created via document.implementation.createHTMLDocument\n  // collapse sibling forms: the second one becomes a child of the first one.\n  // Because of that, this security measure has to be disabled in Safari 8.\n  // https://bugs.webkit.org/show_bug.cgi?id=137337\n  support.createHTMLDocument = function () {\n    var body = document.implementation.createHTMLDocument(\"\").body;\n    body.innerHTML = \"<form></form><form></form>\";\n    return body.childNodes.length === 2;\n  }();\n\n  // Argument \"data\" should be string of html\n  // context (optional): If specified, the fragment will be created in this context,\n  // defaults to document\n  // keepScripts (optional): If true, will include scripts passed in the html string\n  jQuery.parseHTML = function (data, context, keepScripts) {\n    if (typeof data !== \"string\") {\n      return [];\n    }\n    if (typeof context === \"boolean\") {\n      keepScripts = context;\n      context = false;\n    }\n    var base, parsed, scripts;\n    if (!context) {\n      // Stop scripts or inline event handlers from being executed immediately\n      // by using document.implementation\n      if (support.createHTMLDocument) {\n        context = document.implementation.createHTMLDocument(\"\");\n\n        // Set the base href for the created document\n        // so any parsed elements with URLs\n        // are based on the document's URL (gh-2965)\n        base = context.createElement(\"base\");\n        base.href = document.location.href;\n        context.head.appendChild(base);\n      } else {\n        context = document;\n      }\n    }\n    parsed = rsingleTag.exec(data);\n    scripts = !keepScripts && [];\n\n    // Single tag\n    if (parsed) {\n      return [context.createElement(parsed[1])];\n    }\n    parsed = buildFragment([data], context, scripts);\n    if (scripts && scripts.length) {\n      jQuery(scripts).remove();\n    }\n    return jQuery.merge([], parsed.childNodes);\n  };\n\n  /**\n   * Load a url into a page\n   */\n  jQuery.fn.load = function (url, params, callback) {\n    var selector,\n      type,\n      response,\n      self = this,\n      off = url.indexOf(\" \");\n    if (off > -1) {\n      selector = stripAndCollapse(url.slice(off));\n      url = url.slice(0, off);\n    }\n\n    // If it's a function\n    if (isFunction(params)) {\n      // We assume that it's the callback\n      callback = params;\n      params = undefined;\n\n      // Otherwise, build a param string\n    } else if (params && _typeof(params) === \"object\") {\n      type = \"POST\";\n    }\n\n    // If we have elements to modify, make the request\n    if (self.length > 0) {\n      jQuery.ajax({\n        url: url,\n        // If \"type\" variable is undefined, then \"GET\" method will be used.\n        // Make value of this field explicit since\n        // user can override it through ajaxSetup method\n        type: type || \"GET\",\n        dataType: \"html\",\n        data: params\n      }).done(function (responseText) {\n        // Save response for use in complete callback\n        response = arguments;\n        self.html(selector ?\n        // If a selector was specified, locate the right elements in a dummy div\n        // Exclude scripts to avoid IE 'Permission Denied' errors\n        jQuery(\"<div>\").append(jQuery.parseHTML(responseText)).find(selector) :\n        // Otherwise use the full result\n        responseText);\n\n        // If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n        // but they are ignored because response was set above.\n        // If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n      }).always(callback && function (jqXHR, status) {\n        self.each(function () {\n          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);\n        });\n      });\n    }\n    return this;\n  };\n  jQuery.expr.pseudos.animated = function (elem) {\n    return jQuery.grep(jQuery.timers, function (fn) {\n      return elem === fn.elem;\n    }).length;\n  };\n  jQuery.offset = {\n    setOffset: function setOffset(elem, options, i) {\n      var curPosition,\n        curLeft,\n        curCSSTop,\n        curTop,\n        curOffset,\n        curCSSLeft,\n        calculatePosition,\n        position = jQuery.css(elem, \"position\"),\n        curElem = jQuery(elem),\n        props = {};\n\n      // Set position first, in-case top/left are set even on static elem\n      if (position === \"static\") {\n        elem.style.position = \"relative\";\n      }\n      curOffset = curElem.offset();\n      curCSSTop = jQuery.css(elem, \"top\");\n      curCSSLeft = jQuery.css(elem, \"left\");\n      calculatePosition = (position === \"absolute\" || position === \"fixed\") && (curCSSTop + curCSSLeft).indexOf(\"auto\") > -1;\n\n      // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n      if (calculatePosition) {\n        curPosition = curElem.position();\n        curTop = curPosition.top;\n        curLeft = curPosition.left;\n      } else {\n        curTop = parseFloat(curCSSTop) || 0;\n        curLeft = parseFloat(curCSSLeft) || 0;\n      }\n      if (isFunction(options)) {\n        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n        options = options.call(elem, i, jQuery.extend({}, curOffset));\n      }\n      if (options.top != null) {\n        props.top = options.top - curOffset.top + curTop;\n      }\n      if (options.left != null) {\n        props.left = options.left - curOffset.left + curLeft;\n      }\n      if (\"using\" in options) {\n        options.using.call(elem, props);\n      } else {\n        curElem.css(props);\n      }\n    }\n  };\n  jQuery.fn.extend({\n    // offset() relates an element's border box to the document origin\n    offset: function offset(options) {\n      // Preserve chaining for setter\n      if (arguments.length) {\n        return options === undefined ? this : this.each(function (i) {\n          jQuery.offset.setOffset(this, options, i);\n        });\n      }\n      var rect,\n        win,\n        elem = this[0];\n      if (!elem) {\n        return;\n      }\n\n      // Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n      // Support: IE <=11 only\n      // Running getBoundingClientRect on a\n      // disconnected node in IE throws an error\n      if (!elem.getClientRects().length) {\n        return {\n          top: 0,\n          left: 0\n        };\n      }\n\n      // Get document-relative position by adding viewport scroll to viewport-relative gBCR\n      rect = elem.getBoundingClientRect();\n      win = elem.ownerDocument.defaultView;\n      return {\n        top: rect.top + win.pageYOffset,\n        left: rect.left + win.pageXOffset\n      };\n    },\n    // position() relates an element's margin box to its offset parent's padding box\n    // This corresponds to the behavior of CSS absolute positioning\n    position: function position() {\n      if (!this[0]) {\n        return;\n      }\n      var offsetParent,\n        offset,\n        doc,\n        elem = this[0],\n        parentOffset = {\n          top: 0,\n          left: 0\n        };\n\n      // position:fixed elements are offset from the viewport, which itself always has zero offset\n      if (jQuery.css(elem, \"position\") === \"fixed\") {\n        // Assume position:fixed implies availability of getBoundingClientRect\n        offset = elem.getBoundingClientRect();\n      } else {\n        offset = this.offset();\n\n        // Account for the *real* offset parent, which can be the document or its root element\n        // when a statically positioned element is identified\n        doc = elem.ownerDocument;\n        offsetParent = elem.offsetParent || doc.documentElement;\n        while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, \"position\") === \"static\") {\n          offsetParent = offsetParent.parentNode;\n        }\n        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {\n          // Incorporate borders into its offset, since they are outside its content origin\n          parentOffset = jQuery(offsetParent).offset();\n          parentOffset.top += jQuery.css(offsetParent, \"borderTopWidth\", true);\n          parentOffset.left += jQuery.css(offsetParent, \"borderLeftWidth\", true);\n        }\n      }\n\n      // Subtract parent offsets and element margins\n      return {\n        top: offset.top - parentOffset.top - jQuery.css(elem, \"marginTop\", true),\n        left: offset.left - parentOffset.left - jQuery.css(elem, \"marginLeft\", true)\n      };\n    },\n    // This method will return documentElement in the following cases:\n    // 1) For the element inside the iframe without offsetParent, this method will return\n    //    documentElement of the parent window\n    // 2) For the hidden or detached element\n    // 3) For body or html element, i.e. in case of the html node - it will return itself\n    //\n    // but those exceptions were never presented as a real life use-cases\n    // and might be considered as more preferable results.\n    //\n    // This logic, however, is not guaranteed and can change at any point in the future\n    offsetParent: function offsetParent() {\n      return this.map(function () {\n        var offsetParent = this.offsetParent;\n        while (offsetParent && jQuery.css(offsetParent, \"position\") === \"static\") {\n          offsetParent = offsetParent.offsetParent;\n        }\n        return offsetParent || documentElement;\n      });\n    }\n  });\n\n  // Create scrollLeft and scrollTop methods\n  jQuery.each({\n    scrollLeft: \"pageXOffset\",\n    scrollTop: \"pageYOffset\"\n  }, function (method, prop) {\n    var top = \"pageYOffset\" === prop;\n    jQuery.fn[method] = function (val) {\n      return access(this, function (elem, method, val) {\n        // Coalesce documents and windows\n        var win;\n        if (isWindow(elem)) {\n          win = elem;\n        } else if (elem.nodeType === 9) {\n          win = elem.defaultView;\n        }\n        if (val === undefined) {\n          return win ? win[prop] : elem[method];\n        }\n        if (win) {\n          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);\n        } else {\n          elem[method] = val;\n        }\n      }, method, val, arguments.length);\n    };\n  });\n\n  // Support: Safari <=7 - 9.1, Chrome <=37 - 49\n  // Add the top/left cssHooks using jQuery.fn.position\n  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n  // getComputedStyle returns percent when specified for top/left/bottom/right;\n  // rather than make the css module depend on the offset module, just check for it here\n  jQuery.each([\"top\", \"left\"], function (_i, prop) {\n    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {\n      if (computed) {\n        computed = curCSS(elem, prop);\n\n        // If curCSS returns percentage, fallback to offset\n        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + \"px\" : computed;\n      }\n    });\n  });\n\n  // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n  jQuery.each({\n    Height: \"height\",\n    Width: \"width\"\n  }, function (name, type) {\n    jQuery.each({\n      padding: \"inner\" + name,\n      content: type,\n      \"\": \"outer\" + name\n    }, function (defaultExtra, funcName) {\n      // Margin is only for outerHeight, outerWidth\n      jQuery.fn[funcName] = function (margin, value) {\n        var chainable = arguments.length && (defaultExtra || typeof margin !== \"boolean\"),\n          extra = defaultExtra || (margin === true || value === true ? \"margin\" : \"border\");\n        return access(this, function (elem, type, value) {\n          var doc;\n          if (isWindow(elem)) {\n            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n            return funcName.indexOf(\"outer\") === 0 ? elem[\"inner\" + name] : elem.document.documentElement[\"client\" + name];\n          }\n\n          // Get document width or height\n          if (elem.nodeType === 9) {\n            doc = elem.documentElement;\n\n            // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n            // whichever is greatest\n            return Math.max(elem.body[\"scroll\" + name], doc[\"scroll\" + name], elem.body[\"offset\" + name], doc[\"offset\" + name], doc[\"client\" + name]);\n          }\n          return value === undefined ?\n          // Get width or height on the element, requesting but not forcing parseFloat\n          jQuery.css(elem, type, extra) :\n          // Set width or height on the element\n          jQuery.style(elem, type, value, extra);\n        }, type, chainable ? margin : undefined, chainable);\n      };\n    });\n  });\n  jQuery.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (_i, type) {\n    jQuery.fn[type] = function (fn) {\n      return this.on(type, fn);\n    };\n  });\n  jQuery.fn.extend({\n    bind: function bind(types, data, fn) {\n      return this.on(types, null, data, fn);\n    },\n    unbind: function unbind(types, fn) {\n      return this.off(types, null, fn);\n    },\n    delegate: function delegate(selector, types, data, fn) {\n      return this.on(types, selector, data, fn);\n    },\n    undelegate: function undelegate(selector, types, fn) {\n      // ( namespace ) or ( selector, types [, fn] )\n      return arguments.length === 1 ? this.off(selector, \"**\") : this.off(types, selector || \"**\", fn);\n    },\n    hover: function hover(fnOver, fnOut) {\n      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);\n    }\n  });\n  jQuery.each((\"blur focus focusin focusout resize scroll click dblclick \" + \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" + \"change select submit keydown keypress keyup contextmenu\").split(\" \"), function (_i, name) {\n    // Handle event binding\n    jQuery.fn[name] = function (data, fn) {\n      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);\n    };\n  });\n\n  // Support: Android <=4.0 only\n  // Make sure we trim BOM and NBSP\n  var rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\n  // Bind a function to a context, optionally partially applying any\n  // arguments.\n  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n  // However, it is not slated for removal any time soon\n  jQuery.proxy = function (fn, context) {\n    var tmp, args, proxy;\n    if (typeof context === \"string\") {\n      tmp = fn[context];\n      context = fn;\n      fn = tmp;\n    }\n\n    // Quick check to determine if target is callable, in the spec\n    // this throws a TypeError, but we will just return undefined.\n    if (!isFunction(fn)) {\n      return undefined;\n    }\n\n    // Simulated bind\n    args = _slice.call(arguments, 2);\n    proxy = function proxy() {\n      return fn.apply(context || this, args.concat(_slice.call(arguments)));\n    };\n\n    // Set the guid of unique handler to the same of original handler, so it can be removed\n    proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n    return proxy;\n  };\n  jQuery.holdReady = function (hold) {\n    if (hold) {\n      jQuery.readyWait++;\n    } else {\n      jQuery.ready(true);\n    }\n  };\n  jQuery.isArray = Array.isArray;\n  jQuery.parseJSON = JSON.parse;\n  jQuery.nodeName = nodeName;\n  jQuery.isFunction = isFunction;\n  jQuery.isWindow = isWindow;\n  jQuery.camelCase = camelCase;\n  jQuery.type = toType;\n  jQuery.now = Date.now;\n  jQuery.isNumeric = function (obj) {\n    // As of jQuery 3.0, isNumeric is limited to\n    // strings and numbers (primitives or objects)\n    // that can be coerced to finite numbers (gh-2662)\n    var type = jQuery.type(obj);\n    return (type === \"number\" || type === \"string\") &&\n    // parseFloat NaNs numeric-cast false positives (\"\")\n    // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n    // subtraction forces infinities to NaN\n    !isNaN(obj - parseFloat(obj));\n  };\n  jQuery.trim = function (text) {\n    return text == null ? \"\" : (text + \"\").replace(rtrim, \"\");\n  };\n\n  // Register as a named AMD module, since jQuery can be concatenated with other\n  // files that may use define, but not via a proper concatenation script that\n  // understands anonymous AMD modules. A named AMD is safest and most robust\n  // way to register. Lowercase jquery is used because AMD module names are\n  // derived from file names, and jQuery is normally delivered in a lowercase\n  // file name. Do this after creating the global so that if an AMD module wants\n  // to call noConflict to hide this version of jQuery, it will work.\n\n  // Note that for maximum portability, libraries that are not jQuery should\n  // declare themselves as anonymous modules, and avoid setting a global if an\n  // AMD loader is present. jQuery is a special case. For more information, see\n  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return jQuery;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n  var\n    // Map over jQuery in case of overwrite\n    _jQuery = window.jQuery,\n    // Map over the $ in case of overwrite\n    _$ = window.$;\n  jQuery.noConflict = function (deep) {\n    if (window.$ === jQuery) {\n      window.$ = _$;\n    }\n    if (deep && window.jQuery === jQuery) {\n      window.jQuery = _jQuery;\n    }\n    return jQuery;\n  };\n\n  // Expose jQuery and $ identifiers, even in AMD\n  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n  // and CommonJS for browser emulators (#13566)\n  if (typeof noGlobal === \"undefined\") {\n    window.jQuery = window.$ = jQuery;\n  }\n  return jQuery;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvdGhlbWVzL2Jvb3RzdHJhcC92ZW5kb3IvanF1ZXJ5L2pxdWVyeS5qcy5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBRSxVQUFVQSxNQUFNLEVBQUVDLE9BQU8sRUFBRztFQUU3QixZQUFZOztFQUVaLElBQUssT0FBYSxPQUFBRSxPQUFBLENBQU5ELE1BQU0sT0FBSyxRQUFRLElBQUlDLE9BQUEsQ0FBT0QsTUFBTSxDQUFDRSxPQUFPLE1BQUssUUFBUSxFQUFHO0lBRXZFO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0FGLE1BQU0sQ0FBQ0UsT0FBTyxHQUFHSixNQUFNLENBQUNLLFFBQVEsR0FDL0JKLE9BQU8sQ0FBRUQsTUFBTSxFQUFFLElBQUksQ0FBRSxHQUN2QixVQUFVTSxDQUFDLEVBQUc7TUFDYixJQUFLLENBQUNBLENBQUMsQ0FBQ0QsUUFBUSxFQUFHO1FBQ2xCLE1BQU0sSUFBSUUsS0FBSyxDQUFFLDBDQUEwQyxDQUFFO01BQzlEO01BQ0EsT0FBT04sT0FBTyxDQUFFSyxDQUFDLENBQUU7SUFDcEIsQ0FBQztFQUNILENBQUMsTUFBTTtJQUNOTCxPQUFPLENBQUVELE1BQU0sQ0FBRTtFQUNsQjs7RUFFRDtBQUNBLENBQUMsRUFBSSxPQUFPUSxNQUFNLEtBQUssV0FBVyxHQUFHQSxNQUFNLEdBQUcsSUFBSSxFQUFFLFVBQVVBLE1BQU0sRUFBRUMsUUFBUSxFQUFHO0VBRWpGO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsWUFBWTs7RUFFWixJQUFJQyxHQUFHLEdBQUcsRUFBRTtFQUVaLElBQUlDLFFBQVEsR0FBR0MsTUFBTSxDQUFDQyxjQUFjO0VBRXBDLElBQUlDLE1BQUssR0FBR0osR0FBRyxDQUFDSSxLQUFLO0VBRXJCLElBQUlDLElBQUksR0FBR0wsR0FBRyxDQUFDSyxJQUFJLEdBQUcsVUFBVUMsS0FBSyxF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O0lBQ0E2bkMsRUFBRSxHQUFHN3FDLE1BQU0sQ0FBQzhxQyxDQUFDO0VBRWQ5bkMsTUFBTSxDQUFDK25DLFVBQVUsR0FBRyxVQUFVdGxDLElBQUksRUFBRztJQUNwQyxJQUFLekYsTUFBTSxDQUFDOHFDLENBQUMsS0FBSzluQyxNQUFNLEVBQUc7TUFDMUJoRCxNQUFNLENBQUM4cUMsQ0FBQyxHQUFHRCxFQUFFO0lBQ2Q7SUFFQSxJQUFLcGxDLElBQUksSUFBSXpGLE1BQU0sQ0FBQ2dELE1BQU0sS0FBS0EsTUFBTSxFQUFHO01BQ3ZDaEQsTUFBTSxDQUFDZ0QsTUFBTSxHQUFHNG5DLE9BQU87SUFDeEI7SUFFQSxPQUFPNW5DLE1BQU07RUFDZCxDQUFDOztFQUVEO0VBQ0E7RUFDQTtFQUNBLElBQUssT0FBTy9DLFFBQVEsS0FBSyxXQUFXLEVBQUc7SUFDdENELE1BQU0sQ0FBQ2dELE1BQU0sR0FBR2hELE1BQU0sQ0FBQzhxQyxDQUFDLEdBQUc5bkMsTUFBTTtFQUNsQztFQUtBLE9BQU9BLE1BQU07QUFDYixDQUFDLENBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvdGhlbWVzL2Jvb3RzdHJhcC92ZW5kb3IvanF1ZXJ5L2pxdWVyeS5qcz8zZjlmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My42LjBcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBPcGVuSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAyMS0wMy0wMlQxNzowOFpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgZmxhdCA9IGFyci5mbGF0ID8gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRyZXR1cm4gYXJyLmZsYXQuY2FsbCggYXJyYXkgKTtcbn0gOiBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdHJldHVybiBhcnIuY29uY2F0LmFwcGx5KCBbXSwgYXJyYXkgKTtcbn07XG5cblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTU3LCBGaXJlZm94IDw9NTJcblx0XHQvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcblx0XHQvLyAoaS5lLiwgYHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9iamVjdFwiICkgPT09IFwiZnVuY3Rpb25cImApLlxuXHRcdC8vIFdlIGRvbid0IHdhbnQgdG8gY2xhc3NpZnkgKmFueSogRE9NIG5vZGUgYXMgYSBmdW5jdGlvbi5cblx0XHQvLyBTdXBwb3J0OiBRdFdlYiA8PTMuOC41LCBXZWJLaXQgPD01MzQuMzQsIHdraHRtbHRvcGRmIHRvb2wgPD0wLjEyLjVcblx0XHQvLyBQbHVzIGZvciBvbGQgV2ViS2l0LCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgY29sbGVjdGlvbnNcblx0XHQvLyAoZS5nLiwgYHR5cGVvZiBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRpdlwiKSA9PT0gXCJmdW5jdGlvblwiYCkuIChnaC00NzU2KVxuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iai5ub2RlVHlwZSAhPT0gXCJudW1iZXJcIiAmJlxuXHRcdFx0dHlwZW9mIG9iai5pdGVtICE9PSBcImZ1bmN0aW9uXCI7XG5cdH07XG5cblxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuXG5cblx0dmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XG5cdFx0dHlwZTogdHJ1ZSxcblx0XHRzcmM6IHRydWUsXG5cdFx0bm9uY2U6IHRydWUsXG5cdFx0bm9Nb2R1bGU6IHRydWVcblx0fTtcblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBub2RlLCBkb2MgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIGksIHZhbCxcblx0XHRcdHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0aWYgKCBub2RlICkge1xuXHRcdFx0Zm9yICggaSBpbiBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNjQrLCBFZGdlIDE4K1xuXHRcdFx0XHQvLyBTb21lIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIFwibm9uY2VcIiBwcm9wZXJ0eSBvbiBzY3JpcHRzLlxuXHRcdFx0XHQvLyBPbiB0aGUgb3RoZXIgaGFuZCwganVzdCB1c2luZyBgZ2V0QXR0cmlidXRlYCBpcyBub3QgZW5vdWdoIGFzXG5cdFx0XHRcdC8vIHRoZSBgbm9uY2VgIGF0dHJpYnV0ZSBpcyByZXNldCB0byBhbiBlbXB0eSBzdHJpbmcgd2hlbmV2ZXIgaXRcblx0XHRcdFx0Ly8gYmVjb21lcyBicm93c2luZy1jb250ZXh0IGNvbm5lY3RlZC5cblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvaHRtbC9pc3N1ZXMvMjM2OVxuXHRcdFx0XHQvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jbm9uY2UtYXR0cmlidXRlc1xuXHRcdFx0XHQvLyBUaGUgYG5vZGUuZ2V0QXR0cmlidXRlYCBjaGVjayB3YXMgYWRkZWQgZm9yIHRoZSBzYWtlIG9mXG5cdFx0XHRcdC8vIGBqUXVlcnkuZ2xvYmFsRXZhbGAgc28gdGhhdCBpdCBjYW4gZmFrZSBhIG5vbmNlLWNvbnRhaW5pbmcgbm9kZVxuXHRcdFx0XHQvLyB2aWEgYW4gb2JqZWN0LlxuXHRcdFx0XHR2YWwgPSBub2RlWyBpIF0gfHwgbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoIGkgKTtcblx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZSggaSwgdmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG5cblxuZnVuY3Rpb24gdG9UeXBlKCBvYmogKSB7XG5cdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdHR5cGVvZiBvYmo7XG59XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIzLjYuMFwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXZlbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkuZ3JlcCggdGhpcywgZnVuY3Rpb24oIF9lbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICggaSArIDEgKSAlIDI7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0b2RkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5ncmVwKCB0aGlzLCBmdW5jdGlvbiggX2VsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gaSAlIDI7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IE9iamVjdC5wcm90b3R5cGUgcG9sbHV0aW9uXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8IHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblx0XHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSBwcm9wZXIgdHlwZSBmb3IgdGhlIHNvdXJjZSB2YWx1ZVxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgJiYgIUFycmF5LmlzQXJyYXkoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBbXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhY29weUlzQXJyYXkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0ge307XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIHByb3ZpZGVkIGNvbnRleHQ7IGZhbGxzIGJhY2sgdG8gdGhlIGdsb2JhbCBvbmVcblx0Ly8gaWYgbm90IHNwZWNpZmllZC5cblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUsIG9wdGlvbnMsIGRvYyApIHtcblx0XHRET01FdmFsKCBjb2RlLCB7IG5vbmNlOiBvcHRpb25zICYmIG9wdGlvbnMubm9uY2UgfSwgZG9jICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gZmxhdCggcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0XHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0gdG9UeXBlKCBvYmogKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIG9iaiApIHx8IGlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy42XG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanMuZm91bmRhdGlvbi9cbiAqXG4gKiBEYXRlOiAyMDIxLTAyLTE2XG4gKi9cbiggZnVuY3Rpb24oIHdpbmRvdyApIHtcbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICgge30gKS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hOYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbIGkgXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufFwiICtcblx0XHRcImlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXN5bnRheC0zLyNpZGVudC10b2tlbi1kaWFncmFtXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIj98XFxcXFxcXFxbXlxcXFxyXFxcXG5cXFxcZl18W1xcXFx3LV18W15cXDAtXFxcXHg3Zl0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdXG5cdFx0Ly8gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgK1xuXHRcdHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblxuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblxuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArXG5cdFx0d2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXCIgKSxcblx0cmRlc2NlbmQgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCJ8PlwiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmh0bWwgPSAvSFRNTCQvaSxcblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblxuXHQvLyBDU1MgZXNjYXBlc1xuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98XFxcXFxcXFwoW15cXFxcclxcXFxuXFxcXGZdKVwiLCBcImdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggZXNjYXBlLCBub25IZXggKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGUuc2xpY2UoIDEgKSAtIDB4MTAwMDA7XG5cblx0XHRyZXR1cm4gbm9uSGV4ID9cblxuXHRcdFx0Ly8gU3RyaXAgdGhlIGJhY2tzbGFzaCBwcmVmaXggZnJvbSBhIG5vbi1oZXggZXNjYXBlIHNlcXVlbmNlXG5cdFx0XHRub25IZXggOlxuXG5cdFx0XHQvLyBSZXBsYWNlIGEgaGV4YWRlY2ltYWwgZXNjYXBlIHNlcXVlbmNlIHdpdGggdGhlIGVuY29kZWQgVW5pY29kZSBjb2RlIHBvaW50XG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExK1xuXHRcdFx0Ly8gRm9yIHZhbHVlcyBvdXRzaWRlIHRoZSBCYXNpYyBNdWx0aWxpbmd1YWwgUGxhbmUgKEJNUCksIG1hbnVhbGx5IGNvbnN0cnVjdCBhXG5cdFx0XHQvLyBzdXJyb2dhdGUgcGFpclxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cblx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG5cdHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcblx0ZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdFx0aWYgKCBhc0NvZGVQb2ludCApIHtcblxuXHRcdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0XHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArXG5cdFx0XHRcdGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFwiIFwiO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0XHRyZXR1cm4gXCJcXFxcXCIgKyBjaDtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fSxcblxuXHRpbkRpc2FibGVkRmllbGRzZXQgPSBhZGRDb21iaW5hdG9yKFxuXHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImZpZWxkc2V0XCI7XG5cdFx0fSxcblx0XHR7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfVxuXHQpO1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoIGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkgKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaE5hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKCBlbHMgKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKCB0YXJnZXRbIGorKyBdID0gZWxzWyBpKysgXSApICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmICggbWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkgKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoICggbSA9IG1hdGNoWyAxIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoIGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkgKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWyAyIF0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoICggbSA9IG1hdGNoWyAzIF0gKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoICFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApICkgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA4IG9ubHlcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0KCBub2RlVHlwZSAhPT0gMSB8fCBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSApIHtcblxuXHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblxuXHRcdFx0XHQvLyBxU0EgY29uc2lkZXJzIGVsZW1lbnRzIG91dHNpZGUgYSBzY29waW5nIHJvb3Qgd2hlbiBldmFsdWF0aW5nIGNoaWxkIG9yXG5cdFx0XHRcdC8vIGRlc2NlbmRhbnQgY29tYmluYXRvcnMsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQuXG5cdFx0XHRcdC8vIEluIHN1Y2ggY2FzZXMsIHdlIHdvcmsgYXJvdW5kIHRoZSBiZWhhdmlvciBieSBwcmVmaXhpbmcgZXZlcnkgc2VsZWN0b3IgaW4gdGhlXG5cdFx0XHRcdC8vIGxpc3Qgd2l0aCBhbiBJRCBzZWxlY3RvciByZWZlcmVuY2luZyB0aGUgc2NvcGUgY29udGV4dC5cblx0XHRcdFx0Ly8gVGhlIHRlY2huaXF1ZSBoYXMgdG8gYmUgdXNlZCBhcyB3ZWxsIHdoZW4gYSBsZWFkaW5nIGNvbWJpbmF0b3IgaXMgdXNlZFxuXHRcdFx0XHQvLyBhcyBzdWNoIHNlbGVjdG9ycyBhcmUgbm90IHJlY29nbml6ZWQgYnkgcXVlcnlTZWxlY3RvckFsbC5cblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgdGVjaG5pcXVlLlxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCByZGVzY2VuZC50ZXN0KCBzZWxlY3RvciApIHx8IHJjb21iaW5hdG9ycy50ZXN0KCBzZWxlY3RvciApICkgKSB7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBXZSBjYW4gdXNlIDpzY29wZSBpbnN0ZWFkIG9mIHRoZSBJRCBoYWNrIGlmIHRoZSBicm93c2VyXG5cdFx0XHRcdFx0Ly8gc3VwcG9ydHMgaXQgJiBpZiB3ZSdyZSBub3QgY2hhbmdpbmcgdGhlIGNvbnRleHQuXG5cdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICE9PSBjb250ZXh0IHx8ICFzdXBwb3J0LnNjb3BlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFx0aWYgKCAoIG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSApICkge1xuXHRcdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKCBuaWQgPSBleHBhbmRvICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1sgaSBdID0gKCBuaWQgPyBcIiNcIiArIG5pZCA6IFwiOnNjb3BlXCIgKSArIFwiIFwiICtcblx0XHRcdFx0XHRcdFx0dG9TZWxlY3RvciggZ3JvdXBzWyBpIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuICggY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSApO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImZpZWxkc2V0XCIgKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdCggXCJ8XCIgKSxcblx0XHRpID0gYXJyLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFyclsgaSBdIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoICggY3VyID0gY3VyLm5leHRTaWJsaW5nICkgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKCBuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIiApICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBkaXNhYmxlZCB0cnVlIGZvciA6ZGlzYWJsZWQ7IGZhbHNlIGZvciA6ZW5hYmxlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZGlzYWJsZWQgKSB7XG5cblx0Ly8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXG5cdFx0aWYgKCBcImZvcm1cIiBpbiBlbGVtICkge1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XG5cdFx0XHQvLyAqIGxpc3RlZCBmb3JtLWFzc29jaWF0ZWQgZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBmaWVsZHNldFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcblx0XHRcdC8vICogb3B0aW9uIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxuXHRcdFx0Ly8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFwiZm9ybVwiIHByb3BlcnR5LlxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gT3B0aW9uIGVsZW1lbnRzIGRlZmVyIHRvIGEgcGFyZW50IG9wdGdyb3VwIGlmIHByZXNlbnRcblx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDYgLSAxMVxuXHRcdFx0XHQvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fFxuXG5cdFx0XHRcdFx0Ly8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcblx0XHRcdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdFx0XHRlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxuXHRcdFx0XHRcdGluRGlzYWJsZWRGaWVsZHNldCggZWxlbSApID09PSBkaXNhYmxlZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXG5cdFx0Ly8gVHJ5IHRvIHdpbm5vdyBvdXQgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSBkaXNhYmxlZCBiZWZvcmUgdHJ1c3RpbmcgdGhlIGRpc2FibGVkIHByb3BlcnR5LlxuXHRcdC8vIFNvbWUgdmljdGltcyBnZXQgY2F1Z2h0IGluIG91ciBuZXQgKGxhYmVsLCBsZWdlbmQsIG1lbnUsIHRyYWNrKSwgYnV0IGl0IHNob3VsZG4ndFxuXHRcdC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxuXHRcdH0gZWxzZSBpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdH1cblxuXHRcdC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKCBqID0gbWF0Y2hJbmRleGVzWyBpIF0gKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbIGogXSA9ICEoIG1hdGNoZXNbIGogXSA9IHNlZWRbIGogXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbmFtZXNwYWNlID0gZWxlbSAmJiBlbGVtLm5hbWVzcGFjZVVSSSxcblx0XHRkb2NFbGVtID0gZWxlbSAmJiAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkuZG9jdW1lbnRFbGVtZW50O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHQvLyBBc3N1bWUgSFRNTCB3aGVuIGRvY3VtZW50RWxlbWVudCBkb2Vzbid0IHlldCBleGlzdCwgc3VjaCBhcyBpbnNpZGUgbG9hZGluZyBpZnJhbWVzXG5cdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC80ODMzXG5cdHJldHVybiAhcmh0bWwudGVzdCggbmFtZXNwYWNlIHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5ub2RlTmFtZSB8fCBcIkhUTUxcIiApO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggZG9jID09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4K1xuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggcHJlZmVycmVkRG9jICE9IGRvY3VtZW50ICYmXG5cdFx0KCBzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldyApICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSAxMSssIEVkZ2UgMTIgLSAxOCssIENocm9tZSA8PTE2IC0gMjUgb25seSwgRmlyZWZveCA8PTMuNiAtIDMxIG9ubHksXG5cdC8vIFNhZmFyaSA0IC0gNSBvbmx5LCBPcGVyYSA8PTExLjYgLSAxMi54IG9ubHlcblx0Ly8gSUUvRWRnZSAmIG9sZGVyIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIDpzY29wZSBwc2V1ZG8tY2xhc3MuXG5cdC8vIFN1cHBvcnQ6IFNhZmFyaSA2LjAgb25seVxuXHQvLyBTYWZhcmkgNi4wIHN1cHBvcnRzIDpzY29wZSBidXQgaXQncyBhbiBhbGlhcyBvZiA6cm9vdCB0aGVyZS5cblx0c3VwcG9ydC5zY29wZSA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXHRcdHJldHVybiB0eXBlb2YgZWwucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0IWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOnNjb3BlIGZpZWxkc2V0IGRpdlwiICkubGVuZ3RoO1xuXHR9ICk7XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKCBcImNsYXNzTmFtZVwiICk7XG5cdH0gKTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudCggXCJcIiApICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCIqXCIgKS5sZW5ndGg7XG5cdH0gKTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9ICk7XG5cblx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmlsdGVyWyBcIklEXCIgXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kWyBcIklEXCIgXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIGVsZW0gPyBbIGVsZW0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0RXhwci5maWx0ZXJbIFwiSURcIiBdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZFsgXCJJRFwiIF0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbm9kZSwgaSwgZWxlbXMsXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFsgXCJUQUdcIiBdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IHJlc3VsdHNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbIFwiQ0xBU1NcIiBdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoICggc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSApICkge1xuXG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdFx0XHR2YXIgaW5wdXQ7XG5cblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIlttc2FsbG93Y2FwdHVyZV49JyddXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbc2VsZWN0ZWRdXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwifj1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHRcdC8vIElFIDExL0VkZ2UgZG9uJ3QgZmluZCBlbGVtZW50cyBvbiBhIGBbbmFtZT0nJ11gIHF1ZXJ5IGluIHNvbWUgY2FzZXMuXG5cdFx0XHQvLyBBZGRpbmcgYSB0ZW1wb3JhcnkgYXR0cmlidXRlIHRvIHRoZSBkb2N1bWVudCBiZWZvcmUgdGhlIHNlbGVjdGlvbiB3b3Jrc1xuXHRcdFx0Ly8gYXJvdW5kIHRoZSBpc3N1ZS5cblx0XHRcdC8vIEludGVyZXN0aW5nbHksIElFIDEwICYgb2xkZXIgZG9uJ3Qgc2VlbSB0byBoYXZlIHRoZSBpc3N1ZS5cblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIlwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW25hbWU9JyddXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqbmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKj1cIiArXG5cdFx0XHRcdFx0d2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmNoZWNrZWRcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmNoZWNrZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiLiMuK1srfl1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9My42IC0gNSBvbmx5XG5cdFx0XHQvLyBPbGQgRmlyZWZveCBkb2Vzbid0IHRocm93IG9uIGEgYmFkbHktZXNjYXBlZCBpZGVudGlmaWVyLlxuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbCggXCJcXFxcXFxmXCIgKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIltcXFxcclxcXFxuXFxcXGZdXCIgKTtcblx0XHR9ICk7XG5cblx0XHRhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltuYW1lPWRdXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmVuYWJsZWRcIiApLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpkaXNhYmxlZFwiICkubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IE9wZXJhIDEwIC0gMTEgb25seVxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiKiw6eFwiICk7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCIsLio6XCIgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoICggbWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yICkgKSApICkge1xuXG5cdFx0YXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGVsLCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oIFwifFwiICkgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbiggXCJ8XCIgKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSApO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoICggYiA9IGIucGFyZW50Tm9kZSApICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCggIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSApICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRpZiAoIGEgPT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09IHByZWZlcnJlZERvYyAmJlxuXHRcdFx0XHRjb250YWlucyggcHJlZmVycmVkRG9jLCBhICkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdGlmICggYiA9PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT0gcHJlZmVycmVkRG9jICYmXG5cdFx0XHRcdGNvbnRhaW5zKCBwcmVmZXJyZWREb2MsIGIgKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cblx0XHRcdHJldHVybiBhID09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKCBjdXIgPSBjdXIucGFyZW50Tm9kZSApICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGN1ci5wYXJlbnROb2RlICkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbIGkgXSA9PT0gYnBbIGkgXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFsgaSBdLCBicFsgaSBdICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cblx0XHRcdGFwWyBpIF0gPT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbIGkgXSA9PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHRzZXREb2N1bWVudCggZWxlbSApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXG5cdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIGV4cHIsIHRydWUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQoIHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApICkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oIHNlbCApIHtcblx0cmV0dXJuICggc2VsICsgXCJcIiApLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoICggZWxlbSA9IHJlc3VsdHNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKCBub2RlID0gZWxlbVsgaSsrIF0gKSApIHtcblxuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbIDEgXSA9IG1hdGNoWyAxIF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWyAzIF0gPSAoIG1hdGNoWyAzIF0gfHwgbWF0Y2hbIDQgXSB8fFxuXHRcdFx0XHRtYXRjaFsgNSBdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWyAyIF0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbIDMgXSA9IFwiIFwiICsgbWF0Y2hbIDMgXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsgMSBdID0gbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWyAxIF0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblxuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbIDAgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbIDQgXSA9ICsoIG1hdGNoWyA0IF0gP1xuXHRcdFx0XHRcdG1hdGNoWyA1IF0gKyAoIG1hdGNoWyA2IF0gfHwgMSApIDpcblx0XHRcdFx0XHQyICogKCBtYXRjaFsgMyBdID09PSBcImV2ZW5cIiB8fCBtYXRjaFsgMyBdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbIDUgXSA9ICsoICggbWF0Y2hbIDcgXSArIG1hdGNoWyA4IF0gKSB8fCBtYXRjaFsgMyBdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFsgNiBdICYmIG1hdGNoWyAyIF07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByWyBcIkNISUxEXCIgXS50ZXN0KCBtYXRjaFsgMCBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRtYXRjaFsgMiBdID0gbWF0Y2hbIDQgXSB8fCBtYXRjaFsgNSBdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoIGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApICkgJiZcblxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KCBleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGggKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFsgMCBdID0gbWF0Y2hbIDAgXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWyAyIF0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQoIHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcdFx0XCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkgKSAmJiBjbGFzc0NhY2hlKFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdChcblx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHxcblx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fFxuXHRcdFx0XHRcdFx0XHRcdFwiXCJcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIF9hcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSBub2RlWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8ICggbm9kZVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdCggb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KCBkaWZmID0gbm9kZUluZGV4ID0gMCApIHx8IHN0YXJ0LnBvcCgpICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAoIG5vZGVbIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdCggb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdCggZGlmZiA9IG5vZGVJbmRleCA9IDAgKSB8fCBzdGFydC5wb3AoKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCBub2RlWyBleHBhbmRvIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkWyBpIF0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbIGkgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblxuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gdW5tYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaSBdID0gISggbWF0Y2hlc1sgaSBdID0gZWxlbSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFsgMCBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblxuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdCggbGFuZyB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoIGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBcInhtbDpsYW5nXCIgKSB8fCBlbGVtLmdldEF0dHJpYnV0ZSggXCJsYW5nXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKCBlbGVtID0gZWxlbS5wYXJlbnROb2RlICkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmXG5cdFx0XHRcdCggIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkgKSAmJlxuXHRcdFx0XHQhISggZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCApO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXG5cdFx0XCJkaXNhYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkICkgfHxcblx0XHRcdFx0KCBub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQgKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1sgXCJlbXB0eVwiIF0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoIGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSApID09IG51bGwgfHxcblx0XHRcdFx0XHRhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0gKSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggX21hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0gKSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIF9tYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSApLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgP1xuXHRcdFx0XHRhcmd1bWVudCArIGxlbmd0aCA6XG5cdFx0XHRcdGFyZ3VtZW50ID4gbGVuZ3RoID9cblx0XHRcdFx0XHRsZW5ndGggOlxuXHRcdFx0XHRcdGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1sgXCJudGhcIiBdID0gRXhwci5wc2V1ZG9zWyBcImVxXCIgXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKCBtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApICkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWyAwIF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKCB0b2tlbnMgPSBbXSApICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoICggbWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSApICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCgge1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbIDAgXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSApO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKCBtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkgKSAmJiAoICFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KCBtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSApICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCgge1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1sgaSBdLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8ICggZWxlbVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKCBvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBrZXkgXSApICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuICggbmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAoIG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzWyBpIF0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbIDAgXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1sgaSBdLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoIGVsZW0gPSB1bm1hdGNoZWRbIGkgXSApICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyhcblx0XHRcdFx0c2VsZWN0b3IgfHwgXCIqXCIsXG5cdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsXG5cdFx0XHRcdFtdXG5cdFx0XHQpLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICggZWxlbSA9IHRlbXBbIGkgXSApICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbIGkgXSBdID0gISggbWF0Y2hlckluWyBwb3N0TWFwWyBpIF0gXSA9IGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblxuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IG1hdGNoZXJPdXRbIGkgXSApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKCBtYXRjaGVySW5bIGkgXSA9IGVsZW0gKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAoIG1hdGNoZXJPdXQgPSBbXSApLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBtYXRjaGVyT3V0WyBpIF0gKSAmJlxuXHRcdFx0XHRcdFx0KCB0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFsgaSBdICkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFsgdGVtcCBdID0gISggcmVzdWx0c1sgdGVtcCBdID0gZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgMCBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbIFwiIFwiIF0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdCggY2hlY2tDb250ZXh0ID0gY29udGV4dCApLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKCBtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyBpIF0udHlwZSBdICkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvciggZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIgKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1sgaSBdLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zWyBpIF0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyBqIF0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cblx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdHRva2Vuc1xuXHRcdFx0XHRcdFx0LnNsaWNlKCAwLCBpIC0gMSApXG5cdFx0XHRcdFx0XHQuY29uY2F0KCB7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSApXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAoIHRva2VucyA9IHRva2Vucy5zbGljZSggaiApICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kWyBcIlRBR1wiIF0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKCBkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSApLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKCBlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSApICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKCBtYXRjaGVyID0gc2V0TWF0Y2hlcnNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblxuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKCB1bm1hdGNoZWRbIGkgXSB8fCBzZXRNYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkWyBpIF0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblxuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFsgaSBdICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKFxuXHRcdFx0c2VsZWN0b3IsXG5cdFx0XHRtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKVxuXHRcdCk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoICggc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvciApICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbIDAgXSA9IG1hdGNoWyAwIF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICggdG9rZW4gPSB0b2tlbnNbIDAgXSApLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIDEgXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFsgXCJJRFwiIF0oIHRva2VuLm1hdGNoZXNbIDAgXVxuXHRcdFx0XHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSwgY29udGV4dCApIHx8IFtdIClbIDAgXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbIFwibmVlZHNDb250ZXh0XCIgXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1sgaSBdO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICggdHlwZSA9IHRva2VuLnR5cGUgKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKCBmaW5kID0gRXhwci5maW5kWyB0eXBlIF0gKSApIHtcblxuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoIHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbIDAgXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1sgMCBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHRcblx0XHRcdFx0KSApICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KCBcIlwiICkuc29ydCggc29ydE9yZGVyICkuam9pbiggXCJcIiApID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZmllbGRzZXRcIiApICkgJiAxO1xufSApO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcImhyZWZcIiApID09PSBcIiNcIjtcbn0gKSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0gKTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59ICkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgX25hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSApO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0cmV0dXJuIGVsLmdldEF0dHJpYnV0ZSggXCJkaXNhYmxlZFwiICkgPT0gbnVsbDtcbn0gKSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0KCB2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSApICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0gKTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSApKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cblx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn1cbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSApO1xuXG5cblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNpbmdsZSBlbGVtZW50XG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBBcnJheWxpa2Ugb2YgZWxlbWVudHMgKGpRdWVyeSwgYXJndW1lbnRzLCBBcnJheSlcblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBGaWx0ZXJlZCBkaXJlY3RseSBmb3IgYm90aCBzaW1wbGUgYW5kIGNvbXBsZXggc2VsZWN0b3JzXG5cdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdGlmICggZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCByZXQsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIHJldCApIDogcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdH07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xuXG5cbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHR0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoIHNlbGVjdG9ycyApO1xuXG5cdFx0Ly8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxuXHRcdGlmICggIXJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggdGFyZ2V0cyA/XG5cdFx0XHRcdFx0XHR0YXJnZXRzLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXG5cdFx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cblx0XHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKCB7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgX2ksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgX2ksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdGlmICggZWxlbS5jb250ZW50RG9jdW1lbnQgIT0gbnVsbCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMStcblx0XHRcdC8vIDxvYmplY3Q+IGVsZW1lbnRzIHdpdGggbm8gYGRhdGFgIGF0dHJpYnV0ZSBoYXMgYW4gb2JqZWN0XG5cdFx0XHQvLyBgY29udGVudERvY3VtZW50YCB3aXRoIGEgYG51bGxgIHByb3RvdHlwZS5cblx0XHRcdGdldFByb3RvKCBlbGVtLmNvbnRlbnREb2N1bWVudCApICkge1xuXG5cdFx0XHRyZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHksIGlPUyA3IG9ubHksIEFuZHJvaWQgQnJvd3NlciA8PTQuMyBvbmx5XG5cdFx0Ly8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XG5cdFx0Ly8gZG9uJ3Qgc3VwcG9ydCBpdC5cblx0XHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRlbXBsYXRlXCIgKSApIHtcblx0XHRcdGVsZW0gPSBlbGVtLmNvbnRlbnQgfHwgZWxlbTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdGh0bWx3aGl0ZSA9ICggL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gbG9ja2VkIHx8IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0b1R5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5mdW5jdGlvbiBJZGVudGl0eSggdiApIHtcblx0cmV0dXJuIHY7XG59XG5mdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcblx0dGhyb3cgZXg7XG59XG5cbmZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QsIG5vVmFsdWUgKSB7XG5cdHZhciBtZXRob2Q7XG5cblx0dHJ5IHtcblxuXHRcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3Jcblx0XHRpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUgKS5kb25lKCByZXNvbHZlICkuZmFpbCggcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciB0aGVuYWJsZXNcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb250cm9sIGByZXNvbHZlYCBhcmd1bWVudHMgYnkgbGV0dGluZyBBcnJheSNzbGljZSBjYXN0IGJvb2xlYW4gYG5vVmFsdWVgIHRvIGludGVnZXI6XG5cdFx0XHQvLyAqIGZhbHNlOiBbIHZhbHVlIF0uc2xpY2UoIDAgKSA9PiByZXNvbHZlKCB2YWx1ZSApXG5cdFx0XHQvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxuXHRcdFx0cmVzb2x2ZS5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0uc2xpY2UoIG5vVmFsdWUgKSApO1xuXHRcdH1cblxuXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcblx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuXHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuXHR9IGNhdGNoICggdmFsdWUgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdHJlamVjdC5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0gKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcblx0XHRcdFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMSwgXCJyZWplY3RlZFwiIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjYXRjaFwiOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIF9pLCB0dXBsZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0gaXNGdW5jdGlvbiggZm5zWyB0dXBsZVsgNCBdIF0gKSAmJiBmbnNbIHR1cGxlWyA0IF0gXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmZhaWwoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVqZWN0IH0pXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0dmFyIG1heERlcHRoID0gMDtcblx0XHRcdFx0XHRmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCwgdGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggPCBtYXhEZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhlbiA9IHJldHVybmVkICYmXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgcmV0dXJuZWQgPT09IFwiZnVuY3Rpb25cIiApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoZW4gKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhEZXB0aCsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGggKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGFsbCBvdGhlciByZXR1cm5lZCB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIHJldHVybmVkIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZhdWx0IHByb2Nlc3MgaXMgcmVzb2x2ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHNwZWNpYWwgfHwgZGVmZXJyZWQucmVzb2x2ZVdpdGggKSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzID0gc3BlY2lhbCA/XG5cdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93IDpcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3coKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soIGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKyAxID49IG1heERlcHRoICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gVGhyb3dlciApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgZSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG5cdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG5cdFx0XHRcdFx0XHRcdC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cblx0XHRcdFx0XHRcdFx0Ly8gc3Vic2VxdWVudCBlcnJvcnNcblx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzKCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDYWxsIGFuIG9wdGlvbmFsIGhvb2sgdG8gcmVjb3JkIHRoZSBzdGFjaywgaW4gY2FzZSBvZiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHQvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBwcm9jZXNzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXG5cdFx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUHJvZ3Jlc3MgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblByb2dyZXNzIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLm5vdGlmeVdpdGhcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkZ1bGZpbGxlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDIgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblJlamVjdGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdFRocm93ZXJcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyA1IF07XG5cblx0XHRcdC8vIHByb21pc2UucHJvZ3Jlc3MgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZmFpbCA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlc29sdmVkXCIgKGkuZS4sIGZ1bGZpbGxlZClcblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZWplY3RlZFwiXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMiBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDMgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMiBdLmxvY2ssXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5sb2NrXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXG5cdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5maXJlXG5cdFx0XHRsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5ub3RpZnlXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmVXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc2luZ2xlVmFsdWUgKSB7XG5cdFx0dmFyXG5cblx0XHRcdC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXG5cdFx0XHRpID0gcmVtYWluaW5nLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBBcnJheSggaSApLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXG5cdFx0XHQvLyB0aGUgcHJpbWFyeSBEZWZlcnJlZFxuXHRcdFx0cHJpbWFyeSA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRwcmltYXJ5LnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXG5cdFx0Ly8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG5cdFx0aWYgKCByZW1haW5pbmcgPD0gMSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHNpbmdsZVZhbHVlLCBwcmltYXJ5LmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIHByaW1hcnkucmVqZWN0LFxuXHRcdFx0XHQhcmVtYWluaW5nICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggcHJpbWFyeS5zdGF0ZSgpID09PSBcInBlbmRpbmdcIiB8fFxuXHRcdFx0XHRpc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgcmVzb2x2ZVZhbHVlc1sgaSBdLnRoZW4gKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gcHJpbWFyeS50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBwcmltYXJ5LnJlamVjdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBwcmltYXJ5LnByb21pc2UoKTtcblx0fVxufSApO1xuXG5cbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxuLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG52YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcblxualF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiggZXJyb3IsIHN0YWNrICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcblx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcblx0aWYgKCB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoIGVycm9yLm5hbWUgKSApIHtcblx0XHR3aW5kb3cuY29uc29sZS53YXJuKCBcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2ssIHN0YWNrICk7XG5cdH1cbn07XG5cblxuXG5cbmpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdHRocm93IGVycm9yO1xuXHR9ICk7XG59O1xuXG5cblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG5cdHJlYWR5TGlzdFxuXHRcdC50aGVuKCBmbiApXG5cblx0XHQvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuXHRcdC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xuXHRcdC8vIHJlZ2lzdHJhdGlvbi5cblx0XHQuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcblx0XHRcdGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiggZXJyb3IgKTtcblx0XHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XG5cbi8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbi8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG4vLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDEwIG9ubHlcbi8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxufSBlbHNlIHtcblxuXHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xufVxuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIHRvVHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwgX2tleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggY2hhaW5hYmxlICkge1xuXHRcdHJldHVybiBlbGVtcztcblx0fVxuXG5cdC8vIEdldHNcblx0aWYgKCBidWxrICkge1xuXHRcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xuXHR9XG5cblx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcblxuXG4vLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcbnZhciBybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2c7XG5cbi8vIFVzZWQgYnkgY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuZnVuY3Rpb24gZmNhbWVsQ2FzZSggX2FsbCwgbGV0dGVyICkge1xuXHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcbi8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3MilcbmZ1bmN0aW9uIGNhbWVsQ2FzZSggc3RyaW5nICkge1xuXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcbn1cbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG5cdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBjYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cblx0XHRcdFx0a2V5ID0ga2V5Lm1hcCggY2FtZWxDYXNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgPSBjYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuXHRpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcImZhbHNlXCIgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcIlwiICkge1xuXHRcdHJldHVybiArZGF0YTtcblx0fVxuXG5cdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG52YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuXHR2YXIgaXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cdFx0fSxcblx0XHRjb21wb3NlZCA9IHsgY29tcG9zZWQ6IHRydWUgfTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrLCBpT1MgMTAuMCAtIDEwLjIgb25seVxuXHQvLyBDaGVjayBhdHRhY2htZW50IGFjcm9zcyBzaGFkb3cgRE9NIGJvdW5kYXJpZXMgd2hlbiBwb3NzaWJsZSAoZ2gtMzUwNClcblx0Ly8gU3VwcG9ydDogaU9TIDEwLjAtMTAuMiBvbmx5XG5cdC8vIEVhcmx5IGlPUyAxMCB2ZXJzaW9ucyBzdXBwb3J0IGBhdHRhY2hTaGFkb3dgIGJ1dCBub3QgYGdldFJvb3ROb2RlYCxcblx0Ly8gbGVhZGluZyB0byBlcnJvcnMuIFdlIG5lZWQgdG8gY2hlY2sgZm9yIGBnZXRSb290Tm9kZWAuXG5cdGlmICggZG9jdW1lbnRFbGVtZW50LmdldFJvb3ROb2RlICkge1xuXHRcdGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Um9vdE5vZGUoIGNvbXBvc2VkICkgPT09IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHR9O1xuXHR9XG52YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cblx0XHQvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxuXHRcdHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcblx0XHRcdC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xuXHRcdFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0aXNBdHRhY2hlZCggZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLCBzY2FsZSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSBlbGVtLm5vZGVUeXBlICYmXG5cdFx0XHQoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdFx0Ly8gSGFsdmUgdGhlIGl0ZXJhdGlvbiB0YXJnZXQgdmFsdWUgdG8gcHJldmVudCBpbnRlcmZlcmVuY2UgZnJvbSBDU1MgdXBwZXIgYm91bmRzIChnaC0yMTQ0KVxuXHRcdGluaXRpYWwgPSBpbml0aWFsIC8gMjtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0d2hpbGUgKCBtYXhJdGVyYXRpb25zLS0gKSB7XG5cblx0XHRcdC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXG5cdFx0XHQvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cdFx0XHRpZiAoICggMSAtIHNjYWxlICkgKiAoIDEgLSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSApICkgPD0gMCApIHtcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuXHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKikvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHQvLyBJRSA8PTkgcmVwbGFjZXMgPG9wdGlvbj4gdGFncyB3aXRoIHRoZWlyIGNvbnRlbnRzIHdoZW4gaW5zZXJ0ZWQgb3V0c2lkZSBvZlxuXHQvLyB0aGUgc2VsZWN0IGVsZW1lbnQuXG5cdGRpdi5pbm5lckhUTUwgPSBcIjxvcHRpb24+PC9vcHRpb24+XCI7XG5cdHN1cHBvcnQub3B0aW9uID0gISFkaXYubGFzdENoaWxkO1xufSApKCk7XG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuaWYgKCAhc3VwcG9ydC5vcHRpb24gKSB7XG5cdHdyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbiA9IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXTtcbn1cblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBhdHRhY2hlZCwgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIHRvVHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0YXR0YWNoZWQgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGF0dGFjaGVkICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG52YXIgcnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXG4vLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91cywgZXhjZXB0IHdoZW4gdGhleSBhcmUgbm8tb3AuXG4vLyBTbyBleHBlY3QgZm9jdXMgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGFjdGl2ZSxcbi8vIGFuZCBibHVyIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgbm90IGFscmVhZHkgYWN0aXZlLlxuLy8gKGZvY3VzIGFuZCBibHVyIGFyZSBhbHdheXMgc3luY2hyb25vdXMgaW4gb3RoZXIgc3VwcG9ydGVkIGJyb3dzZXJzLFxuLy8gdGhpcyBqdXN0IGRlZmluZXMgd2hlbiB3ZSBjYW4gY291bnQgb24gaXQpLlxuZnVuY3Rpb24gZXhwZWN0U3luYyggZWxlbSwgdHlwZSApIHtcblx0cmV0dXJuICggZWxlbSA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSApID09PSAoIHR5cGUgPT09IFwiZm9jdXNcIiApO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gQWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIHRocm93IHVuZXhwZWN0ZWRseVxuLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzkzXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIE9ubHkgYXR0YWNoIGV2ZW50cyB0byBvYmplY3RzIHRoYXQgYWNjZXB0IGRhdGFcblx0XHRpZiAoICFhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApO1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXG5cdFx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKSxcblxuXHRcdFx0aGFuZGxlcnMgPSAoXG5cdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0KVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbIDAgXSA9IGV2ZW50O1xuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcblx0XHR9XG5cblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGV2ZW50IGlzIG5hbWVzcGFjZWQsIHRoZW4gZWFjaCBoYW5kbGVyIGlzIG9ubHkgaW52b2tlZCBpZiBpdCBpc1xuXHRcdFx0XHQvLyBzcGVjaWFsbHkgdW5pdmVyc2FsIG9yIGl0cyBuYW1lc3BhY2VzIGFyZSBhIHN1cGVyc2V0IG9mIHRoZSBldmVudCdzLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGhhbmRsZU9iai5uYW1lc3BhY2UgPT09IGZhbHNlIHx8XG5cdFx0XHRcdFx0ZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIGhhbmRsZU9iaiwgc2VsLCBtYXRjaGVkSGFuZGxlcnMsIG1hdGNoZWRTZWxlY3RvcnMsXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTlcblx0XHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICh0cmFjLTEzMTgwKVxuXHRcdFx0Y3VyLm5vZGVUeXBlICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuXHRcdFx0Ly8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1jbGlja1xuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0Ly8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXCJjbGlja3NcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxuXHRcdFx0ISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxICkgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xuXHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycyA9IFtdO1xuXHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlZEhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZWRIYW5kbGVycyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGN1ciA9IHRoaXM7XG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHRhZGRQcm9wOiBmdW5jdGlvbiggbmFtZSwgaG9vayApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGpRdWVyeS5FdmVudC5wcm90b3R5cGUsIG5hbWUsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cblx0XHRcdGdldDogaXNGdW5jdGlvbiggaG9vayApID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcblx0XHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRvcmlnaW5hbEV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgdG8gZW5zdXJlIGNvcnJlY3Qgc3RhdGUgZm9yIGNoZWNrYWJsZSBpbnB1dHNcblx0XHRcdHNldHVwOiBmdW5jdGlvbiggZGF0YSApIHtcblxuXHRcdFx0XHQvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cblx0XHRcdFx0Ly8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cblx0XHRcdFx0dmFyIGVsID0gdGhpcyB8fCBkYXRhO1xuXG5cdFx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdC8vIGRhdGFQcml2LnNldCggZWwsIFwiY2xpY2tcIiwgLi4uIClcblx0XHRcdFx0XHRsZXZlcmFnZU5hdGl2ZSggZWwsIFwiY2xpY2tcIiwgcmV0dXJuVHJ1ZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJpbmcgYSBjbGlja1xuXHRcdFx0XHRpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsLnR5cGUgKSAmJlxuXHRcdFx0XHRcdGVsLmNsaWNrICYmIG5vZGVOYW1lKCBlbCwgXCJpbnB1dFwiICkgKSB7XG5cblx0XHRcdFx0XHRsZXZlcmFnZU5hdGl2ZSggZWwsIFwiY2xpY2tcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBzdXBwcmVzcyBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdC8vIEFsc28gcHJldmVudCBpdCBpZiB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlIGEgbGV2ZXJhZ2VkIG5hdGl2ZS1ldmVudCBzdGFja1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblx0XHRcdFx0cmV0dXJuIHJjaGVja2FibGVUeXBlLnRlc3QoIHRhcmdldC50eXBlICkgJiZcblx0XHRcdFx0XHR0YXJnZXQuY2xpY2sgJiYgbm9kZU5hbWUoIHRhcmdldCwgXCJpbnB1dFwiICkgJiZcblx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRhcmdldCwgXCJjbGlja1wiICkgfHxcblx0XHRcdFx0XHRub2RlTmFtZSggdGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIEVuc3VyZSB0aGUgcHJlc2VuY2Ugb2YgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBoYW5kbGVzIG1hbnVhbGx5LXRyaWdnZXJlZFxuLy8gc3ludGhldGljIGV2ZW50cyBieSBpbnRlcnJ1cHRpbmcgcHJvZ3Jlc3MgdW50aWwgcmVpbnZva2VkIGluIHJlc3BvbnNlIHRvXG4vLyAqbmF0aXZlKiBldmVudHMgdGhhdCBpdCBmaXJlcyBkaXJlY3RseSwgZW5zdXJpbmcgdGhhdCBzdGF0ZSBjaGFuZ2VzIGhhdmVcbi8vIGFscmVhZHkgb2NjdXJyZWQgYmVmb3JlIG90aGVyIGxpc3RlbmVycyBhcmUgaW52b2tlZC5cbmZ1bmN0aW9uIGxldmVyYWdlTmF0aXZlKCBlbCwgdHlwZSwgZXhwZWN0U3luYyApIHtcblxuXHQvLyBNaXNzaW5nIGV4cGVjdFN5bmMgaW5kaWNhdGVzIGEgdHJpZ2dlciBjYWxsLCB3aGljaCBtdXN0IGZvcmNlIHNldHVwIHRocm91Z2ggalF1ZXJ5LmV2ZW50LmFkZFxuXHRpZiAoICFleHBlY3RTeW5jICkge1xuXHRcdGlmICggZGF0YVByaXYuZ2V0KCBlbCwgdHlwZSApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBlbCwgdHlwZSwgcmV0dXJuVHJ1ZSApO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZWdpc3RlciB0aGUgY29udHJvbGxlciBhcyBhIHNwZWNpYWwgdW5pdmVyc2FsIGhhbmRsZXIgZm9yIGFsbCBldmVudCBuYW1lc3BhY2VzXG5cdGRhdGFQcml2LnNldCggZWwsIHR5cGUsIGZhbHNlICk7XG5cdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCB7XG5cdFx0bmFtZXNwYWNlOiBmYWxzZSxcblx0XHRoYW5kbGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgbm90QXN5bmMsIHJlc3VsdCxcblx0XHRcdFx0c2F2ZWQgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0aWYgKCAoIGV2ZW50LmlzVHJpZ2dlciAmIDEgKSAmJiB0aGlzWyB0eXBlIF0gKSB7XG5cblx0XHRcdFx0Ly8gSW50ZXJydXB0IHByb2Nlc3Npbmcgb2YgdGhlIG91dGVyIHN5bnRoZXRpYyAudHJpZ2dlcigpZWQgZXZlbnRcblx0XHRcdFx0Ly8gU2F2ZWQgZGF0YSBzaG91bGQgYmUgZmFsc2UgaW4gc3VjaCBjYXNlcywgYnV0IG1pZ2h0IGJlIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3Rcblx0XHRcdFx0Ly8gZnJvbSBhbiBhc3luYyBuYXRpdmUgaGFuZGxlciAoZ2gtNDM1MClcblx0XHRcdFx0aWYgKCAhc2F2ZWQubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgYXJndW1lbnRzIGZvciB1c2Ugd2hlbiBoYW5kbGluZyB0aGUgaW5uZXIgbmF0aXZlIGV2ZW50XG5cdFx0XHRcdFx0Ly8gVGhlcmUgd2lsbCBhbHdheXMgYmUgYXQgbGVhc3Qgb25lIGFyZ3VtZW50IChhbiBldmVudCBvYmplY3QpLCBzbyB0aGlzIGFycmF5XG5cdFx0XHRcdFx0Ly8gd2lsbCBub3QgYmUgY29uZnVzZWQgd2l0aCBhIGxlZnRvdmVyIGNhcHR1cmUgb2JqZWN0LlxuXHRcdFx0XHRcdHNhdmVkID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBzYXZlZCApO1xuXG5cdFx0XHRcdFx0Ly8gVHJpZ2dlciB0aGUgbmF0aXZlIGV2ZW50IGFuZCBjYXB0dXJlIGl0cyByZXN1bHRcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcblx0XHRcdFx0XHQvLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91c1xuXHRcdFx0XHRcdG5vdEFzeW5jID0gZXhwZWN0U3luYyggdGhpcywgdHlwZSApO1xuXHRcdFx0XHRcdHRoaXNbIHR5cGUgXSgpO1xuXHRcdFx0XHRcdHJlc3VsdCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXHRcdFx0XHRcdGlmICggc2F2ZWQgIT09IHJlc3VsdCB8fCBub3RBc3luYyApIHtcblx0XHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgZmFsc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc2F2ZWQgIT09IHJlc3VsdCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSBvdXRlciBzeW50aGV0aWMgZXZlbnRcblx0XHRcdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDg2K1xuXHRcdFx0XHRcdFx0Ly8gSW4gQ2hyb21lLCBpZiBhbiBlbGVtZW50IGhhdmluZyBhIGZvY3Vzb3V0IGhhbmRsZXIgaXMgYmx1cnJlZCBieVxuXHRcdFx0XHRcdFx0Ly8gY2xpY2tpbmcgb3V0c2lkZSBvZiBpdCwgaXQgaW52b2tlcyB0aGUgaGFuZGxlciBzeW5jaHJvbm91c2x5LiBJZlxuXHRcdFx0XHRcdFx0Ly8gdGhhdCBoYW5kbGVyIGNhbGxzIGAucmVtb3ZlKClgIG9uIHRoZSBlbGVtZW50LCB0aGUgZGF0YSBpcyBjbGVhcmVkLFxuXHRcdFx0XHRcdFx0Ly8gbGVhdmluZyBgcmVzdWx0YCB1bmRlZmluZWQuIFdlIG5lZWQgdG8gZ3VhcmQgYWdhaW5zdCB0aGlzLlxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdCAmJiByZXN1bHQudmFsdWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoaXMgaXMgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IGZvciBhbiBldmVudCB3aXRoIGEgYnViYmxpbmcgc3Vycm9nYXRlXG5cdFx0XHRcdC8vIChmb2N1cyBvciBibHVyKSwgYXNzdW1lIHRoYXQgdGhlIHN1cnJvZ2F0ZSBhbHJlYWR5IHByb3BhZ2F0ZWQgZnJvbSB0cmlnZ2VyaW5nIHRoZVxuXHRcdFx0XHQvLyBuYXRpdmUgZXZlbnQgYW5kIHByZXZlbnQgdGhhdCBmcm9tIGhhcHBlbmluZyBhZ2FpbiBoZXJlLlxuXHRcdFx0XHQvLyBUaGlzIHRlY2huaWNhbGx5IGdldHMgdGhlIG9yZGVyaW5nIHdyb25nIHcuci50LiB0byBgLnRyaWdnZXIoKWAgKGluIHdoaWNoIHRoZVxuXHRcdFx0XHQvLyBidWJibGluZyBzdXJyb2dhdGUgcHJvcGFnYXRlcyAqYWZ0ZXIqIHRoZSBub24tYnViYmxpbmcgYmFzZSksIGJ1dCB0aGF0IHNlZW1zXG5cdFx0XHRcdC8vIGxlc3MgYmFkIHRoYW4gZHVwbGljYXRpb24uXG5cdFx0XHRcdH0gZWxzZSBpZiAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fSApLmRlbGVnYXRlVHlwZSApIHtcblx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgbmF0aXZlIGV2ZW50IHRyaWdnZXJlZCBhYm92ZSwgZXZlcnl0aGluZyBpcyBub3cgaW4gb3JkZXJcblx0XHRcdC8vIEZpcmUgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IHdpdGggdGhlIG9yaWdpbmFsIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggc2F2ZWQubGVuZ3RoICkge1xuXG5cdFx0XHRcdC8vIC4uLmFuZCBjYXB0dXJlIHRoZSByZXN1bHRcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCB7XG5cdFx0XHRcdFx0dmFsdWU6IGpRdWVyeS5ldmVudC50cmlnZ2VyKFxuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcblx0XHRcdFx0XHRcdC8vIEV4dGVuZCB3aXRoIHRoZSBwcm90b3R5cGUgdG8gcmVzZXQgdGhlIGFib3ZlIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG5cdFx0XHRcdFx0XHRqUXVlcnkuZXh0ZW5kKCBzYXZlZFsgMCBdLCBqUXVlcnkuRXZlbnQucHJvdG90eXBlICksXG5cdFx0XHRcdFx0XHRzYXZlZC5zbGljZSggMSApLFxuXHRcdFx0XHRcdFx0dGhpc1xuXHRcdFx0XHRcdClcblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIEFib3J0IGhhbmRsaW5nIG9mIHRoZSBuYXRpdmUgZXZlbnRcblx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG59XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y29kZTogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cdHdoaWNoOiB0cnVlXG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG5qUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggdHlwZSwgZGVsZWdhdGVUeXBlICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdID0ge1xuXG5cdFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDbGFpbSB0aGUgZmlyc3QgaGFuZGxlclxuXHRcdFx0Ly8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImZvY3VzXCIsIC4uLiApXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiYmx1clwiLCAuLi4gKVxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUsIGV4cGVjdFN5bmMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlclxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIFN1cHByZXNzIG5hdGl2ZSBmb2N1cyBvciBibHVyIGFzIGl0J3MgYWxyZWFkeSBiZWluZyBmaXJlZFxuXHRcdC8vIGluIGxldmVyYWdlTmF0aXZlLlxuXHRcdF9kZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRkZWxlZ2F0ZVR5cGU6IGRlbGVnYXRlVHlwZVxuXHR9O1xufSApO1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzIG9ubHlcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG4vLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSApIHtcblxuXHRcdHJldHVybiBqUXVlcnkoIGVsZW0gKS5jaGlsZHJlbiggXCJ0Ym9keVwiIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdGlmICggKCBlbGVtLnR5cGUgfHwgXCJcIiApLnNsaWNlKCAwLCA1ICkgPT09IFwidHJ1ZS9cIiApIHtcblx0XHRlbGVtLnR5cGUgPSBlbGVtLnR5cGUuc2xpY2UoIDUgKTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YVByaXYuZ2V0KCBzcmMgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZGVzdCwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGZsYXQoIGFyZ3MgKTtcblxuXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuXHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gfHxcblx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgJiYgKCBub2RlLnR5cGUgfHwgXCJcIiApLnRvTG93ZXJDYXNlKCkgICE9PSBcIm1vZHVsZVwiICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICYmICFub2RlLm5vTW9kdWxlICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMsIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5vbmNlOiBub2RlLm5vbmNlIHx8IG5vZGUuZ2V0QXR0cmlidXRlKCBcIm5vbmNlXCIgKVxuXHRcdFx0XHRcdFx0XHRcdH0sIGRvYyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBub2RlLCBkb2MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGlzQXR0YWNoZWQoIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suY2FsbCggZWxlbSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG52YXIgcmJveFN0eWxlID0gbmV3IFJlZ0V4cCggY3NzRXhwYW5kLmpvaW4oIFwifFwiICksIFwiaVwiICk7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuXHRcdC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2Vcblx0XHRpZiAoICFkaXYgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDtcIiArXG5cdFx0XHRcIm1hcmdpbi10b3A6MXB4O3BhZGRpbmc6MDtib3JkZXI6MFwiO1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6c2Nyb2xsO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcIndpZHRoOjYwJTt0b3A6MSVcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5tYXJnaW5MZWZ0ICkgPT09IDEyO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgU2FmYXJpIDw9OS4xIC0gMTAuMSwgaU9TIDw9Ny4wIC0gOS4zXG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLnJpZ2h0ID0gXCI2MCVcIjtcblx0XHRwaXhlbEJveFN0eWxlc1ZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUucmlnaHQgKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHRcdC8vIERldGVjdCBtaXNyZXBvcnRpbmcgb2YgY29udGVudCBkaW1lbnNpb25zIGZvciBib3gtc2l6aW5nOmJvcmRlci1ib3ggZWxlbWVudHNcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUud2lkdGggKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHQvLyBEZXRlY3Qgb3ZlcmZsb3c6c2Nyb2xsIHNjcmV3aW5lc3MgKGdoLTM2OTkpXG5cdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9NjRcblx0XHQvLyBEb24ndCBnZXQgdHJpY2tlZCB3aGVuIHpvb20gYWZmZWN0cyBvZmZzZXRXaWR0aCAoZ2gtNDAyOSlcblx0XHRkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0c2Nyb2xsYm94U2l6ZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2Lm9mZnNldFdpZHRoIC8gMyApID09PSAxMjtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHQvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG5cdFx0Ly8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxuXHRcdGRpdiA9IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiByb3VuZFBpeGVsTWVhc3VyZXMoIG1lYXN1cmUgKSB7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQoIHBhcnNlRmxvYXQoIG1lYXN1cmUgKSApO1xuXHR9XG5cblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBzY3JvbGxib3hTaXplVmFsLCBwaXhlbEJveFN0eWxlc1ZhbCxcblx0XHRyZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCwgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0fSxcblx0XHRwaXhlbEJveFN0eWxlczogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsQm94U3R5bGVzVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fSxcblx0XHRzY3JvbGxib3hTaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gc2Nyb2xsYm94U2l6ZVZhbDtcblx0XHR9LFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxNSAtIDE4K1xuXHRcdC8vIElFL0VkZ2UgbWlzcmVwb3J0IGBnZXRDb21wdXRlZFN0eWxlYCBvZiB0YWJsZSByb3dzIHdpdGggd2lkdGgvaGVpZ2h0XG5cdFx0Ly8gc2V0IGluIENTUyB3aGlsZSBgb2Zmc2V0KmAgcHJvcGVydGllcyByZXBvcnQgY29ycmVjdCB2YWx1ZXMuXG5cdFx0Ly8gQmVoYXZpb3IgaW4gSUUgOSBpcyBtb3JlIHN1YnRsZSB0aGFuIGluIG5ld2VyIHZlcnNpb25zICYgaXQgcGFzc2VzXG5cdFx0Ly8gc29tZSB2ZXJzaW9ucyBvZiB0aGlzIHRlc3Q7IG1ha2Ugc3VyZSBub3QgdG8gbWFrZSBpdCBwYXNzIHRoZXJlIVxuXHRcdC8vXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA3MCtcblx0XHQvLyBPbmx5IEZpcmVmb3ggaW5jbHVkZXMgYm9yZGVyIHdpZHRoc1xuXHRcdC8vIGluIGNvbXB1dGVkIGRpbWVuc2lvbnMuIChnaC00NTI5KVxuXHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0YWJsZSwgdHIsIHRyQ2hpbGQsIHRyU3R5bGU7XG5cdFx0XHRpZiAoIHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJ0YWJsZVwiICk7XG5cdFx0XHRcdHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJ0clwiICk7XG5cdFx0XHRcdHRyQ2hpbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0XHRcdFx0dGFibGUuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDtib3JkZXItY29sbGFwc2U6c2VwYXJhdGVcIjtcblx0XHRcdFx0dHIuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjFweCBzb2xpZFwiO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA4Nitcblx0XHRcdFx0Ly8gSGVpZ2h0IHNldCB0aHJvdWdoIGNzc1RleHQgZG9lcyBub3QgZ2V0IGFwcGxpZWQuXG5cdFx0XHRcdC8vIENvbXB1dGVkIGhlaWdodCB0aGVuIGNvbWVzIGJhY2sgYXMgMC5cblx0XHRcdFx0dHIuc3R5bGUuaGVpZ2h0ID0gXCIxcHhcIjtcblx0XHRcdFx0dHJDaGlsZC5zdHlsZS5oZWlnaHQgPSBcIjlweFwiO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgOCBDaHJvbWUgODYrXG5cdFx0XHRcdC8vIEluIG91ciBib2R5QmFja2dyb3VuZC5odG1sIGlmcmFtZSxcblx0XHRcdFx0Ly8gZGlzcGxheSBmb3IgYWxsIGRpdiBlbGVtZW50cyBpcyBzZXQgdG8gXCJpbmxpbmVcIixcblx0XHRcdFx0Ly8gd2hpY2ggY2F1c2VzIGEgcHJvYmxlbSBvbmx5IGluIEFuZHJvaWQgOCBDaHJvbWUgODYuXG5cdFx0XHRcdC8vIEVuc3VyaW5nIHRoZSBkaXYgaXMgZGlzcGxheTogYmxvY2tcblx0XHRcdFx0Ly8gZ2V0cyBhcm91bmQgdGhpcyBpc3N1ZS5cblx0XHRcdFx0dHJDaGlsZC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG5cdFx0XHRcdGRvY3VtZW50RWxlbWVudFxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdGFibGUgKVxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdHIgKVxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdHJDaGlsZCApO1xuXG5cdFx0XHRcdHRyU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggdHIgKTtcblx0XHRcdFx0cmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPSAoIHBhcnNlSW50KCB0clN0eWxlLmhlaWdodCwgMTAgKSArXG5cdFx0XHRcdFx0cGFyc2VJbnQoIHRyU3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwICkgK1xuXHRcdFx0XHRcdHBhcnNlSW50KCB0clN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCApICkgPT09IHRyLm9mZnNldEhlaWdodDtcblxuXHRcdFx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIHRhYmxlICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVUckRpbWVuc2lvbnNWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcblx0XHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG5cdFx0Ly8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuXHRcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxuXHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcblx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoIzMxNDQpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhaXNBdHRhY2hlZCggZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbEJveFN0eWxlcygpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiByYm94U3R5bGUudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXIgY3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlLFxuXHR2ZW5kb3JQcm9wcyA9IHt9O1xuXG4vLyBSZXR1cm4gYSB2ZW5kb3ItcHJlZml4ZWQgcHJvcGVydHkgb3IgdW5kZWZpbmVkXG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gUmV0dXJuIGEgcG90ZW50aWFsbHktbWFwcGVkIGpRdWVyeS5jc3NQcm9wcyBvciB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG5cdHZhciBmaW5hbCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdIHx8IHZlbmRvclByb3BzWyBuYW1lIF07XG5cblx0aWYgKCBmaW5hbCApIHtcblx0XHRyZXR1cm4gZmluYWw7XG5cdH1cblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblx0cmV0dXJuIHZlbmRvclByb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cmN1c3RvbVByb3AgPSAvXi0tLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH07XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBfZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgYm94LCBpc0JvcmRlckJveCwgc3R5bGVzLCBjb21wdXRlZFZhbCApIHtcblx0dmFyIGkgPSBkaW1lbnNpb24gPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXHRcdGV4dHJhID0gMCxcblx0XHRkZWx0YSA9IDA7XG5cblx0Ly8gQWRqdXN0bWVudCBtYXkgbm90IGJlIG5lY2Vzc2FyeVxuXHRpZiAoIGJveCA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApICkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luXG5cdFx0aWYgKCBib3ggPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBib3ggKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGNvbnRlbnQtYm94LCB3ZSdyZSBzZWVraW5nIFwicGFkZGluZ1wiIG9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIlxuXHRcdGlmICggIWlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBBZGQgcGFkZGluZ1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEZvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCIsIGFkZCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQnV0IHN0aWxsIGtlZXAgdHJhY2sgb2YgaXQgb3RoZXJ3aXNlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRleHRyYSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGJvcmRlci1ib3ggKGNvbnRlbnQgKyBwYWRkaW5nICsgYm9yZGVyKSwgd2UncmUgc2Vla2luZyBcImNvbnRlbnRcIiBvclxuXHRcdC8vIFwicGFkZGluZ1wiIG9yIFwibWFyZ2luXCJcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIsIHN1YnRyYWN0IHBhZGRpbmdcblx0XHRcdGlmICggYm94ID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiBvciBcInBhZGRpbmdcIiwgc3VidHJhY3QgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBY2NvdW50IGZvciBwb3NpdGl2ZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyIHdoZW4gcmVxdWVzdGVkIGJ5IHByb3ZpZGluZyBjb21wdXRlZFZhbFxuXHRpZiAoICFpc0JvcmRlckJveCAmJiBjb21wdXRlZFZhbCA+PSAwICkge1xuXG5cdFx0Ly8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIGEgcm91bmRlZCBzdW0gb2YgY29udGVudCwgcGFkZGluZywgc2Nyb2xsIGd1dHRlciwgYW5kIGJvcmRlclxuXHRcdC8vIEFzc3VtaW5nIGludGVnZXIgc2Nyb2xsIGd1dHRlciwgc3VidHJhY3QgdGhlIHJlc3QgYW5kIHJvdW5kIGRvd25cblx0XHRkZWx0YSArPSBNYXRoLm1heCggMCwgTWF0aC5jZWlsKFxuXHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdGNvbXB1dGVkVmFsIC1cblx0XHRcdGRlbHRhIC1cblx0XHRcdGV4dHJhIC1cblx0XHRcdDAuNVxuXG5cdFx0Ly8gSWYgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIHVua25vd24sIHRoZW4gd2UgY2FuJ3QgZGV0ZXJtaW5lIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXJcblx0XHQvLyBVc2UgYW4gZXhwbGljaXQgemVybyB0byBhdm9pZCBOYU4gKGdoLTM5NjQpXG5cdFx0KSApIHx8IDA7XG5cdH1cblxuXHRyZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBjb21wdXRlZCBzdHlsZVxuXHR2YXIgc3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cblx0XHQvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC00MzIyKS5cblx0XHQvLyBGYWtlIGNvbnRlbnQtYm94IHVudGlsIHdlIGtub3cgaXQncyBuZWVkZWQgdG8ga25vdyB0aGUgdHJ1ZSB2YWx1ZS5cblx0XHRib3hTaXppbmdOZWVkZWQgPSAhc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IGV4dHJhLFxuXHRcdGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCxcblxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgZGltZW5zaW9uLCBzdHlsZXMgKSxcblx0XHRvZmZzZXRQcm9wID0gXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKTtcblxuXHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0Ly8gUmV0dXJuIGEgY29uZm91bmRpbmcgbm9uLXBpeGVsIHZhbHVlIG9yIGZlaWduIGlnbm9yYW5jZSwgYXMgYXBwcm9wcmlhdGUuXG5cdGlmICggcm51bW5vbnB4LnRlc3QoIHZhbCApICkge1xuXHRcdGlmICggIWV4dHJhICkge1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cdFx0dmFsID0gXCJhdXRvXCI7XG5cdH1cblxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIFVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIHdoZW4gYm94IHNpemluZyBpcyB1bnJlbGlhYmxlLlxuXHQvLyBJbiB0aG9zZSBjYXNlcywgdGhlIGNvbXB1dGVkIHZhbHVlIGNhbiBiZSB0cnVzdGVkIHRvIGJlIGJvcmRlci1ib3guXG5cdGlmICggKCAhc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpICYmIGlzQm9yZGVyQm94IHx8XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMCAtIDExKywgRWRnZSAxNSAtIDE4K1xuXHRcdC8vIElFL0VkZ2UgbWlzcmVwb3J0IGBnZXRDb21wdXRlZFN0eWxlYCBvZiB0YWJsZSByb3dzIHdpdGggd2lkdGgvaGVpZ2h0XG5cdFx0Ly8gc2V0IGluIENTUyB3aGlsZSBgb2Zmc2V0KmAgcHJvcGVydGllcyByZXBvcnQgY29ycmVjdCB2YWx1ZXMuXG5cdFx0Ly8gSW50ZXJlc3RpbmdseSwgaW4gc29tZSBjYXNlcyBJRSA5IGRvZXNuJ3Qgc3VmZmVyIGZyb20gdGhpcyBpc3N1ZS5cblx0XHQhc3VwcG9ydC5yZWxpYWJsZVRyRGltZW5zaW9ucygpICYmIG5vZGVOYW1lKCBlbGVtLCBcInRyXCIgKSB8fFxuXG5cdFx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG5cdFx0Ly8gVGhpcyBoYXBwZW5zIGZvciBpbmxpbmUgZWxlbWVudHMgd2l0aCBubyBleHBsaWNpdCBzZXR0aW5nIChnaC0zNTcxKVxuXHRcdHZhbCA9PT0gXCJhdXRvXCIgfHxcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgLSA0LjMgb25seVxuXHRcdC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXG5cdFx0IXBhcnNlRmxvYXQoIHZhbCApICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiaW5saW5lXCIgKSAmJlxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoZSBlbGVtZW50IGlzIHZpc2libGUgJiBjb25uZWN0ZWRcblx0XHRlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdFx0Ly8gV2hlcmUgYXZhaWxhYmxlLCBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgYXBwcm94aW1hdGUgYm9yZGVyIGJveCBkaW1lbnNpb25zLlxuXHRcdC8vIFdoZXJlIG5vdCBhdmFpbGFibGUgKGUuZy4sIFNWRyksIGFzc3VtZSB1bnJlbGlhYmxlIGJveC1zaXppbmcgYW5kIGludGVycHJldCB0aGVcblx0XHQvLyByZXRyaWV2ZWQgdmFsdWUgYXMgYSBjb250ZW50IGJveCBkaW1lbnNpb24uXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IG9mZnNldFByb3AgaW4gZWxlbTtcblx0XHRpZiAoIHZhbHVlSXNCb3JkZXJCb3ggKSB7XG5cdFx0XHR2YWwgPSBlbGVtWyBvZmZzZXRQcm9wIF07XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIFwiXCIgYW5kIGF1dG9cblx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblxuXHQvLyBBZGp1c3QgZm9yIHRoZSBlbGVtZW50J3MgYm94IG1vZGVsXG5cdHJldHVybiAoIHZhbCArXG5cdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0ZWxlbSxcblx0XHRcdGRpbWVuc2lvbixcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXMsXG5cblx0XHRcdC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgY29tcHV0ZWQgc2l6ZSB0byByZXF1ZXN0IHNjcm9sbCBndXR0ZXIgY2FsY3VsYXRpb24gKGdoLTM1ODkpXG5cdFx0XHR2YWxcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImdyaWRBcmVhXCI6IHRydWUsXG5cdFx0XCJncmlkQ29sdW1uXCI6IHRydWUsXG5cdFx0XCJncmlkQ29sdW1uRW5kXCI6IHRydWUsXG5cdFx0XCJncmlkQ29sdW1uU3RhcnRcIjogdHJ1ZSxcblx0XHRcImdyaWRSb3dcIjogdHJ1ZSxcblx0XHRcImdyaWRSb3dFbmRcIjogdHJ1ZSxcblx0XHRcImdyaWRSb3dTdGFydFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHt9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gcXVlcnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0Ly8gVGhlIGlzQ3VzdG9tUHJvcCBjaGVjayBjYW4gYmUgcmVtb3ZlZCBpbiBqUXVlcnkgNC4wIHdoZW4gd2Ugb25seSBhdXRvLWFwcGVuZFxuXHRcdFx0Ly8gXCJweFwiIHRvIGEgZmV3IGhhcmRjb2RlZCB2YWx1ZXMuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG5cdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRpZiAoIGlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0XHRzdHlsZS5zZXRQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gbW9kaWZ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggX2ksIGRpbWVuc2lvbiApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBkaW1lbnNpb24gXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrXG5cdFx0XHRcdFx0Ly8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cblx0XHRcdFx0XHQvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHRcdFx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0XHRcdFx0KCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdFx0XHQvLyBPbmx5IHJlYWQgc3R5bGVzLnBvc2l0aW9uIGlmIHRoZSB0ZXN0IGhhcyBhIGNoYW5jZSB0byBmYWlsXG5cdFx0XHRcdC8vIHRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3cuXG5cdFx0XHRcdHNjcm9sbGJveFNpemVCdWdneSA9ICFzdXBwb3J0LnNjcm9sbGJveFNpemUoKSAmJlxuXHRcdFx0XHRcdHN0eWxlcy5wb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiLFxuXG5cdFx0XHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTM5OTEpXG5cdFx0XHRcdGJveFNpemluZ05lZWRlZCA9IHNjcm9sbGJveFNpemVCdWdneSB8fCBleHRyYSxcblx0XHRcdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhID9cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0XHRpc0JvcmRlckJveCxcblx0XHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHRcdCkgOlxuXHRcdFx0XHRcdDA7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuXHRcdFx0Ly8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcblx0XHRcdGlmICggaXNCb3JkZXJCb3ggJiYgc2Nyb2xsYm94U2l6ZUJ1Z2d5ICkge1xuXHRcdFx0XHRzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXG5cdFx0XHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdFx0XHRwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBcImJvcmRlclwiLCBmYWxzZSwgc3R5bGVzICkgLVxuXHRcdFx0XHRcdDAuNVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgZGltZW5zaW9uICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggcHJlZml4ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gfHxcblx0XHRcdFx0XHR0d2Vlbi5lbGVtLnN0eWxlWyBmaW5hbFByb3BOYW1lKCB0d2Vlbi5wcm9wICkgXSAhPSBudWxsICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH0sXG5cdF9kZWZhdWx0OiBcInN3aW5nXCJcbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCBpblByb2dyZXNzLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbmZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0aWYgKCBkb2N1bWVudC5oaWRkZW4gPT09IGZhbHNlICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBzY2hlZHVsZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dCggc2NoZWR1bGUsIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHRcdH1cblxuXHRcdGpRdWVyeS5meC50aWNrKCk7XG5cdH1cbn1cblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IERhdGUubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcblx0XHRpc0JveCA9IFwid2lkdGhcIiBpbiBwcm9wcyB8fCBcImhlaWdodFwiIGluIHByb3BzLFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXG5cdFx0XHRcdC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxuXHRwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3BzICk7XG5cdGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuXHRpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXG5cdFx0Ly8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1kgYW5kIEVkZ2UganVzdCBtaXJyb3JzXG5cdFx0Ly8gdGhlIG92ZXJmbG93WCB2YWx1ZSB0aGVyZS5cblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxuXHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcblx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHR9XG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgKSB7XG5cdFx0XHRcdGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gR2V0IG5vbmVtcHR5IHZhbHVlKHMpIGJ5IHRlbXBvcmFyaWx5IGZvcmNpbmcgdmlzaWJpbGl0eVxuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwiaW5saW5lXCIgfHwgZGlzcGxheSA9PT0gXCJpbmxpbmUtYmxvY2tcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0XHRcdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuXHRcdFx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRwcm9wVHdlZW4gPSBmYWxzZTtcblx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXG5cdFx0Ly8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cblx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwgeyBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSB9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxuXHRcdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBjYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cblx0XHRcdGlmICggIWxlbmd0aCApIHtcblx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRyZXN1bHQuc3RvcC5iaW5kKCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHQvLyBBdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRhbmltYXRpb25cblx0XHQucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdHJldHVybiBhbmltYXRpb247XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyczoge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XG5cdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fSxcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0aXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFpc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHQvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmZcblx0aWYgKCBqUXVlcnkuZngub2ZmICkge1xuXHRcdG9wdC5kdXJhdGlvbiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHRpZiAoIHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRpZiAoIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzICkge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuXHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBEYXRlLm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGpRdWVyeS5meC5zdGFydCgpO1xufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRzY2hlZHVsZSgpO1xufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aW5Qcm9ncmVzcyA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblxuXHRcdFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZSxcblx0XHRcdGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRsb3dlcmNhc2VOYW1lIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRpZiAoIHRhYmluZGV4ICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXJzZUludCggdGFiaW5kZXgsIDEwICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxuXHRcdFx0XHRcdGVsZW0uaHJlZlxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuLy8gZXNsaW50IHJ1bGUgXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXG4vLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG5cdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcblx0Ly8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS1hc2NpaS13aGl0ZXNwYWNlXG5cdGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UoIHZhbHVlICkge1xuXHRcdHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHRcdHJldHVybiB0b2tlbnMuam9pbiggXCIgXCIgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApIHtcblx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0fVxuXHRyZXR1cm4gW107XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlLFxuXHRcdFx0aXNWYWxpZFZhbHVlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIGlzVmFsaWRWYWx1ZSApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIGlzVmFsaWRWYWx1ZSApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRpID0gMDtcblx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXHRcdFx0XHRjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRcdFx0d2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0c3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiggZSApIHtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGxhc3RFbGVtZW50ID0gY3VyO1xuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCBPYmplY3QuY3JlYXRlKCBudWxsICkgKVsgZXZlbnQudHlwZSBdICYmXG5cdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcblx0XHRcdFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcblx0XHRcdFx0YWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcblx0Ly8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWVcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuLy9cbi8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5pZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XG5cdGpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xuXHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gSGFuZGxlOiByZWd1bGFyIG5vZGVzICh2aWEgYHRoaXMub3duZXJEb2N1bWVudGApLCB3aW5kb3dcblx0XHRcdFx0Ly8gKHZpYSBgdGhpcy5kb2N1bWVudGApICYgZG9jdW1lbnQgKHZpYSBgdGhpc2ApLlxuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLmRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0geyBndWlkOiBEYXRlLm5vdygpIH07XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbCwgcGFyc2VyRXJyb3JFbGVtO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdHBhcnNlckVycm9yRWxlbSA9IHhtbCAmJiB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApWyAwIF07XG5cdGlmICggIXhtbCB8fCBwYXJzZXJFcnJvckVsZW0gKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIChcblx0XHRcdHBhcnNlckVycm9yRWxlbSA/XG5cdFx0XHRcdGpRdWVyeS5tYXAoIHBhcnNlckVycm9yRWxlbS5jaGlsZE5vZGVzLCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsLnRleHRDb250ZW50O1xuXHRcdFx0XHR9ICkuam9pbiggXCJcXG5cIiApIDpcblx0XHRcdFx0ZGF0YVxuXHRcdCkgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIHRvVHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG5cdFx0XHR2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHRpZiAoIGEgPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gXCJcIjtcblx0fVxuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9ICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApLm1hcCggZnVuY3Rpb24oIF9pLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5vcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdGpRdWVyeS5ldmVudCxcblxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdID1cblx0XHRcdFx0XHRcdFx0XHRcdCggcmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdIHx8IFtdIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmNvbmNhdCggbWF0Y2hbIDIgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaC5qb2luKCBcIiwgXCIgKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xuXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9ICggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0dXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcblx0XHRcdC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHQvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKCByaGFzaCwgXCJcIiApO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xuXHRcdFx0dW5jYWNoZWQgPSBzLnVybC5zbGljZSggY2FjaGVVUkwubGVuZ3RoICk7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlIGFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICYmICggcy5wcm9jZXNzRGF0YSB8fCB0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICkgKSB7XG5cdFx0XHRcdGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UoIHJhbnRpQ2FjaGUsIFwiJDFcIiApO1xuXHRcdFx0XHR1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyAoIG5vbmNlLmd1aWQrKyApICtcblx0XHRcdFx0XHR1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXNlIGEgbm9vcCBjb252ZXJ0ZXIgZm9yIG1pc3Npbmcgc2NyaXB0IGJ1dCBub3QgaWYganNvbnBcblx0XHRcdGlmICggIWlzU3VjY2VzcyAmJlxuXHRcdFx0XHRqUXVlcnkuaW5BcnJheSggXCJzY3JpcHRcIiwgcy5kYXRhVHlwZXMgKSA+IC0xICYmXG5cdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBcImpzb25cIiwgcy5kYXRhVHlwZXMgKSA8IDAgKSB7XG5cdFx0XHRcdHMuY29udmVydGVyc1sgXCJ0ZXh0IHNjcmlwdFwiIF0gPSBmdW5jdGlvbigpIHt9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBfaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdHZhciBpO1xuXHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRpZiAoIGkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb250ZW50LXR5cGVcIiApIHtcblx0XHRcdHMuY29udGVudFR5cGUgPSBzLmhlYWRlcnNbIGkgXSB8fCBcIlwiO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMsIGRvYyApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXG5cdFx0Ly8gT25seSBldmFsdWF0ZSB0aGUgcmVzcG9uc2UgaWYgaXQgaXMgc3VjY2Vzc2Z1bCAoZ2gtNDEyNilcblx0XHQvLyBkYXRhRmlsdGVyIGlzIG5vdCBpbnZva2VkIGZvciBmYWlsdXJlIHJlc3BvbnNlcywgc28gdXNpbmcgaXQgaW5zdGVhZFxuXHRcdC8vIG9mIHRoZSBkZWZhdWx0IGNvbnZlcnRlciBpcyBrbHVkZ3kgYnV0IGl0IHdvcmtzLlxuXHRcdGNvbnZlcnRlcnM6IHtcblx0XHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oKSB7fVxuXHRcdH0sXG5cdFx0ZGF0YUZpbHRlcjogZnVuY3Rpb24oIHJlc3BvbnNlICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHJlc3BvbnNlLCBvcHRpb25zLCBkb2MgKTtcblx0XHR9XG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGh0bWxJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnRpbWVvdXQgPVxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IHhoci5vbnRpbWVvdXQgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gb3IgZm9yY2VkLWJ5LWF0dHJzIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiB8fCBzLnNjcmlwdEF0dHJzICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiIClcblx0XHRcdFx0XHQuYXR0ciggcy5zY3JpcHRBdHRycyB8fCB7fSApXG5cdFx0XHRcdFx0LnByb3AoIHsgY2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LCBzcmM6IHMudXJsIH0gKVxuXHRcdFx0XHRcdC5vbiggXCJsb2FkIGVycm9yXCIsIGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZS5ndWlkKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1Jcblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XG5cdC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuXHRcdFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxuXHRcdFx0XHQoIG9mZnNldFBhcmVudCA9PT0gZG9jLmJvZHkgfHwgb2Zmc2V0UGFyZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkgJiZcblx0XHRcdFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblxuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGlmICggb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBfaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCgge1xuXHRcdHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsXG5cdFx0Y29udGVudDogdHlwZSxcblx0XHRcIlwiOiBcIm91dGVyXCIgKyBuYW1lXG5cdH0sIGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuXHRcdFx0XHRcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG5cdFx0XHRcdFx0XHRlbGVtWyBcImlubmVyXCIgKyBuYW1lIF0gOlxuXHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIF9pLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fSxcblxuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goXG5cdCggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cblx0XHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRcdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHRcdH07XG5cdH1cbik7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuLy8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG52YXIgcnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2c7XG5cbi8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuLy8gYXJndW1lbnRzLlxuLy8galF1ZXJ5LnByb3h5IGlzIGRlcHJlY2F0ZWQgdG8gcHJvbW90ZSBzdGFuZGFyZHMgKHNwZWNpZmljYWxseSBGdW5jdGlvbiNiaW5kKVxuLy8gSG93ZXZlciwgaXQgaXMgbm90IHNsYXRlZCBmb3IgcmVtb3ZhbCBhbnkgdGltZSBzb29uXG5qUXVlcnkucHJveHkgPSBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRjb250ZXh0ID0gZm47XG5cdFx0Zm4gPSB0bXA7XG5cdH1cblxuXHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRpZiAoICFpc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBTaW11bGF0ZWQgYmluZFxuXHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdH07XG5cblx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdHJldHVybiBwcm94eTtcbn07XG5cbmpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiggaG9sZCApIHtcblx0aWYgKCBob2xkICkge1xuXHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0fVxufTtcbmpRdWVyeS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xualF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XG5qUXVlcnkuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5qUXVlcnkuaXNXaW5kb3cgPSBpc1dpbmRvdztcbmpRdWVyeS5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG5qUXVlcnkudHlwZSA9IHRvVHlwZTtcblxualF1ZXJ5Lm5vdyA9IERhdGUubm93O1xuXG5qUXVlcnkuaXNOdW1lcmljID0gZnVuY3Rpb24oIG9iaiApIHtcblxuXHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuXHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcbn07XG5cbmpRdWVyeS50cmltID0gZnVuY3Rpb24oIHRleHQgKSB7XG5cdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFwiXCIgOlxuXHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xufTtcblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoIHR5cGVvZiBub0dsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJtb2R1bGUiLCJfdHlwZW9mIiwiZXhwb3J0cyIsImRvY3VtZW50IiwidyIsIkVycm9yIiwid2luZG93Iiwibm9HbG9iYWwiLCJhcnIiLCJnZXRQcm90byIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwic2xpY2UiLCJmbGF0IiwiYXJyYXkiLCJjYWxsIiwiY29uY2F0IiwiYXBwbHkiLCJwdXNoIiwiaW5kZXhPZiIsImNsYXNzMnR5cGUiLCJ0b1N0cmluZyIsImhhc093biIsImhhc093blByb3BlcnR5IiwiZm5Ub1N0cmluZyIsIk9iamVjdEZ1bmN0aW9uU3RyaW5nIiwic3VwcG9ydCIsImlzRnVuY3Rpb24iLCJvYmoiLCJub2RlVHlwZSIsIml0ZW0iLCJpc1dpbmRvdyIsInByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMiLCJ0eXBlIiwic3JjIiwibm9uY2UiLCJub01vZHVsZSIsIkRPTUV2YWwiLCJjb2RlIiwibm9kZSIsImRvYyIsImkiLCJ2YWwiLCJzY3JpcHQiLCJjcmVhdGVFbGVtZW50IiwidGV4dCIsImdldEF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsImhlYWQiLCJhcHBlbmRDaGlsZCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsInRvVHlwZSIsInZlcnNpb24iLCJqUXVlcnkiLCJzZWxlY3RvciIsImNvbnRleHQiLCJmbiIsImluaXQiLCJwcm90b3R5cGUiLCJqcXVlcnkiLCJjb25zdHJ1Y3RvciIsImxlbmd0aCIsInRvQXJyYXkiLCJnZXQiLCJudW0iLCJwdXNoU3RhY2siLCJlbGVtcyIsInJldCIsIm1lcmdlIiwicHJldk9iamVjdCIsImVhY2giLCJjYWxsYmFjayIsIm1hcCIsImVsZW0iLCJhcmd1bWVudHMiLCJmaXJzdCIsImVxIiwibGFzdCIsImV2ZW4iLCJncmVwIiwiX2VsZW0iLCJvZGQiLCJsZW4iLCJqIiwiZW5kIiwic29ydCIsInNwbGljZSIsImV4dGVuZCIsIm9wdGlvbnMiLCJuYW1lIiwiY29weSIsImNvcHlJc0FycmF5IiwiY2xvbmUiLCJ0YXJnZXQiLCJkZWVwIiwiaXNQbGFpbk9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsInVuZGVmaW5lZCIsImV4cGFuZG8iLCJNYXRoIiwicmFuZG9tIiwicmVwbGFjZSIsImlzUmVhZHkiLCJlcnJvciIsIm1zZyIsIm5vb3AiLCJwcm90byIsIkN0b3IiLCJpc0VtcHR5T2JqZWN0IiwiZ2xvYmFsRXZhbCIsImlzQXJyYXlMaWtlIiwibWFrZUFycmF5IiwicmVzdWx0cyIsImluQXJyYXkiLCJzZWNvbmQiLCJpbnZlcnQiLCJjYWxsYmFja0ludmVyc2UiLCJtYXRjaGVzIiwiY2FsbGJhY2tFeHBlY3QiLCJhcmciLCJ2YWx1ZSIsImd1aWQiLCJTeW1ib2wiLCJpdGVyYXRvciIsInNwbGl0IiwiX2kiLCJ0b0xvd2VyQ2FzZSIsIlNpenpsZSIsIkV4cHIiLCJnZXRUZXh0IiwiaXNYTUwiLCJ0b2tlbml6ZSIsImNvbXBpbGUiLCJzZWxlY3QiLCJvdXRlcm1vc3RDb250ZXh0Iiwic29ydElucHV0IiwiaGFzRHVwbGljYXRlIiwic2V0RG9jdW1lbnQiLCJkb2NFbGVtIiwiZG9jdW1lbnRJc0hUTUwiLCJyYnVnZ3lRU0EiLCJyYnVnZ3lNYXRjaGVzIiwiY29udGFpbnMiLCJEYXRlIiwicHJlZmVycmVkRG9jIiwiZGlycnVucyIsImRvbmUiLCJjbGFzc0NhY2hlIiwiY3JlYXRlQ2FjaGUiLCJ0b2tlbkNhY2hlIiwiY29tcGlsZXJDYWNoZSIsIm5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUiLCJzb3J0T3JkZXIiLCJhIiwiYiIsInBvcCIsInB1c2hOYXRpdmUiLCJsaXN0IiwiYm9vbGVhbnMiLCJ3aGl0ZXNwYWNlIiwiaWRlbnRpZmllciIsImF0dHJpYnV0ZXMiLCJwc2V1ZG9zIiwicndoaXRlc3BhY2UiLCJSZWdFeHAiLCJydHJpbSIsInJjb21tYSIsInJjb21iaW5hdG9ycyIsInJkZXNjZW5kIiwicnBzZXVkbyIsInJpZGVudGlmaWVyIiwibWF0Y2hFeHByIiwicmh0bWwiLCJyaW5wdXRzIiwicmhlYWRlciIsInJuYXRpdmUiLCJycXVpY2tFeHByIiwicnNpYmxpbmciLCJydW5lc2NhcGUiLCJmdW5lc2NhcGUiLCJlc2NhcGUiLCJub25IZXgiLCJoaWdoIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwicmNzc2VzY2FwZSIsImZjc3Nlc2NhcGUiLCJjaCIsImFzQ29kZVBvaW50IiwiY2hhckNvZGVBdCIsInVubG9hZEhhbmRsZXIiLCJpbkRpc2FibGVkRmllbGRzZXQiLCJhZGRDb21iaW5hdG9yIiwiZGlzYWJsZWQiLCJub2RlTmFtZSIsImRpciIsIm5leHQiLCJjaGlsZE5vZGVzIiwiZSIsImVscyIsInNlZWQiLCJtIiwibmlkIiwibWF0Y2giLCJncm91cHMiLCJuZXdTZWxlY3RvciIsIm5ld0NvbnRleHQiLCJvd25lckRvY3VtZW50IiwiZXhlYyIsImdldEVsZW1lbnRCeUlkIiwiaWQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJxc2EiLCJ0ZXN0IiwidGVzdENvbnRleHQiLCJzY29wZSIsInRvU2VsZWN0b3IiLCJqb2luIiwicXVlcnlTZWxlY3RvckFsbCIsInFzYUVycm9yIiwicmVtb3ZlQXR0cmlidXRlIiwia2V5cyIsImNhY2hlIiwia2V5IiwiY2FjaGVMZW5ndGgiLCJzaGlmdCIsIm1hcmtGdW5jdGlvbiIsImFzc2VydCIsImVsIiwiYWRkSGFuZGxlIiwiYXR0cnMiLCJoYW5kbGVyIiwiYXR0ckhhbmRsZSIsInNpYmxpbmdDaGVjayIsImN1ciIsImRpZmYiLCJzb3VyY2VJbmRleCIsIm5leHRTaWJsaW5nIiwiY3JlYXRlSW5wdXRQc2V1ZG8iLCJjcmVhdGVCdXR0b25Qc2V1ZG8iLCJjcmVhdGVEaXNhYmxlZFBzZXVkbyIsImlzRGlzYWJsZWQiLCJjcmVhdGVQb3NpdGlvbmFsUHNldWRvIiwiYXJndW1lbnQiLCJtYXRjaEluZGV4ZXMiLCJuYW1lc3BhY2UiLCJuYW1lc3BhY2VVUkkiLCJkb2N1bWVudEVsZW1lbnQiLCJoYXNDb21wYXJlIiwic3ViV2luZG93IiwiZGVmYXVsdFZpZXciLCJ0b3AiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJjbGFzc05hbWUiLCJjcmVhdGVDb21tZW50IiwiZ2V0QnlJZCIsImdldEVsZW1lbnRzQnlOYW1lIiwiZmlsdGVyIiwiYXR0cklkIiwiZmluZCIsImdldEF0dHJpYnV0ZU5vZGUiLCJ0YWciLCJ0bXAiLCJpbnB1dCIsImlubmVySFRNTCIsIm1hdGNoZXNTZWxlY3RvciIsIndlYmtpdE1hdGNoZXNTZWxlY3RvciIsIm1vek1hdGNoZXNTZWxlY3RvciIsIm9NYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsImRpc2Nvbm5lY3RlZE1hdGNoIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJhZG93biIsImJ1cCIsImNvbXBhcmUiLCJzb3J0RGV0YWNoZWQiLCJhdXAiLCJhcCIsImJwIiwidW5zaGlmdCIsImV4cHIiLCJlbGVtZW50cyIsImF0dHIiLCJzcGVjaWZpZWQiLCJzZWwiLCJ1bmlxdWVTb3J0IiwiZHVwbGljYXRlcyIsImRldGVjdER1cGxpY2F0ZXMiLCJzb3J0U3RhYmxlIiwidGV4dENvbnRlbnQiLCJmaXJzdENoaWxkIiwibm9kZVZhbHVlIiwic2VsZWN0b3JzIiwiY3JlYXRlUHNldWRvIiwicmVsYXRpdmUiLCJwcmVGaWx0ZXIiLCJBVFRSIiwiQ0hJTEQiLCJQU0VVRE8iLCJleGNlc3MiLCJ1bnF1b3RlZCIsIlRBRyIsIm5vZGVOYW1lU2VsZWN0b3IiLCJDTEFTUyIsInBhdHRlcm4iLCJvcGVyYXRvciIsImNoZWNrIiwicmVzdWx0Iiwid2hhdCIsIl9hcmd1bWVudCIsInNpbXBsZSIsImZvcndhcmQiLCJvZlR5cGUiLCJfY29udGV4dCIsInhtbCIsInVuaXF1ZUNhY2hlIiwib3V0ZXJDYWNoZSIsIm5vZGVJbmRleCIsInN0YXJ0IiwicGFyZW50IiwidXNlQ2FjaGUiLCJsYXN0Q2hpbGQiLCJ1bmlxdWVJRCIsInBzZXVkbyIsImFyZ3MiLCJzZXRGaWx0ZXJzIiwiaWR4IiwibWF0Y2hlZCIsIm1hdGNoZXIiLCJ1bm1hdGNoZWQiLCJsYW5nIiwiZWxlbUxhbmciLCJoYXNoIiwibG9jYXRpb24iLCJyb290IiwiZm9jdXMiLCJhY3RpdmVFbGVtZW50IiwiaGFzRm9jdXMiLCJocmVmIiwidGFiSW5kZXgiLCJjaGVja2VkIiwic2VsZWN0ZWQiLCJzZWxlY3RlZEluZGV4IiwiZW1wdHkiLCJoZWFkZXIiLCJidXR0b24iLCJfbWF0Y2hJbmRleGVzIiwicmFkaW8iLCJjaGVja2JveCIsImZpbGUiLCJwYXNzd29yZCIsImltYWdlIiwic3VibWl0IiwicmVzZXQiLCJmaWx0ZXJzIiwicGFyc2VPbmx5IiwidG9rZW5zIiwic29GYXIiLCJwcmVGaWx0ZXJzIiwiY2FjaGVkIiwiY29tYmluYXRvciIsImJhc2UiLCJza2lwIiwiY2hlY2tOb25FbGVtZW50cyIsImRvbmVOYW1lIiwib2xkQ2FjaGUiLCJuZXdDYWNoZSIsImVsZW1lbnRNYXRjaGVyIiwibWF0Y2hlcnMiLCJtdWx0aXBsZUNvbnRleHRzIiwiY29udGV4dHMiLCJjb25kZW5zZSIsIm5ld1VubWF0Y2hlZCIsIm1hcHBlZCIsInNldE1hdGNoZXIiLCJwb3N0RmlsdGVyIiwicG9zdEZpbmRlciIsInBvc3RTZWxlY3RvciIsInRlbXAiLCJwcmVNYXAiLCJwb3N0TWFwIiwicHJlZXhpc3RpbmciLCJtYXRjaGVySW4iLCJtYXRjaGVyT3V0IiwibWF0Y2hlckZyb21Ub2tlbnMiLCJjaGVja0NvbnRleHQiLCJsZWFkaW5nUmVsYXRpdmUiLCJpbXBsaWNpdFJlbGF0aXZlIiwibWF0Y2hDb250ZXh0IiwibWF0Y2hBbnlDb250ZXh0IiwibWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzIiwiZWxlbWVudE1hdGNoZXJzIiwic2V0TWF0Y2hlcnMiLCJieVNldCIsImJ5RWxlbWVudCIsInN1cGVyTWF0Y2hlciIsIm91dGVybW9zdCIsIm1hdGNoZWRDb3VudCIsInNldE1hdGNoZWQiLCJjb250ZXh0QmFja3VwIiwiZGlycnVuc1VuaXF1ZSIsInRva2VuIiwiY29tcGlsZWQiLCJfbmFtZSIsImRlZmF1bHRWYWx1ZSIsInVuaXF1ZSIsImlzWE1MRG9jIiwiZXNjYXBlU2VsZWN0b3IiLCJ1bnRpbCIsInRydW5jYXRlIiwiaXMiLCJzaWJsaW5ncyIsIm4iLCJybmVlZHNDb250ZXh0IiwibmVlZHNDb250ZXh0IiwicnNpbmdsZVRhZyIsIndpbm5vdyIsInF1YWxpZmllciIsIm5vdCIsInNlbGYiLCJyb290alF1ZXJ5IiwicGFyc2VIVE1MIiwicmVhZHkiLCJycGFyZW50c3ByZXYiLCJndWFyYW50ZWVkVW5pcXVlIiwiY2hpbGRyZW4iLCJjb250ZW50cyIsInByZXYiLCJoYXMiLCJ0YXJnZXRzIiwibCIsImNsb3Nlc3QiLCJpbmRleCIsInByZXZBbGwiLCJhZGQiLCJhZGRCYWNrIiwic2libGluZyIsInBhcmVudHMiLCJwYXJlbnRzVW50aWwiLCJuZXh0QWxsIiwibmV4dFVudGlsIiwicHJldlVudGlsIiwiY29udGVudERvY3VtZW50IiwiY29udGVudCIsInJldmVyc2UiLCJybm90aHRtbHdoaXRlIiwiY3JlYXRlT3B0aW9ucyIsIm9iamVjdCIsIl8iLCJmbGFnIiwiQ2FsbGJhY2tzIiwiZmlyaW5nIiwibWVtb3J5IiwiZmlyZWQiLCJsb2NrZWQiLCJxdWV1ZSIsImZpcmluZ0luZGV4IiwiZmlyZSIsIm9uY2UiLCJzdG9wT25GYWxzZSIsInJlbW92ZSIsImRpc2FibGUiLCJsb2NrIiwiZmlyZVdpdGgiLCJJZGVudGl0eSIsInYiLCJUaHJvd2VyIiwiZXgiLCJhZG9wdFZhbHVlIiwicmVzb2x2ZSIsInJlamVjdCIsIm5vVmFsdWUiLCJtZXRob2QiLCJwcm9taXNlIiwiZmFpbCIsInRoZW4iLCJEZWZlcnJlZCIsImZ1bmMiLCJ0dXBsZXMiLCJzdGF0ZSIsImFsd2F5cyIsImRlZmVycmVkIiwiX2NhdGNoIiwicGlwZSIsImZucyIsIm5ld0RlZmVyIiwidHVwbGUiLCJyZXR1cm5lZCIsInByb2dyZXNzIiwibm90aWZ5Iiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwib25Qcm9ncmVzcyIsIm1heERlcHRoIiwiZGVwdGgiLCJzcGVjaWFsIiwidGhhdCIsIm1pZ2h0VGhyb3ciLCJUeXBlRXJyb3IiLCJub3RpZnlXaXRoIiwicmVzb2x2ZVdpdGgiLCJwcm9jZXNzIiwiZXhjZXB0aW9uSG9vayIsInN0YWNrVHJhY2UiLCJyZWplY3RXaXRoIiwiZ2V0U3RhY2tIb29rIiwic2V0VGltZW91dCIsInN0YXRlU3RyaW5nIiwid2hlbiIsInNpbmdsZVZhbHVlIiwicmVtYWluaW5nIiwicmVzb2x2ZUNvbnRleHRzIiwicmVzb2x2ZVZhbHVlcyIsInByaW1hcnkiLCJ1cGRhdGVGdW5jIiwicmVycm9yTmFtZXMiLCJzdGFjayIsImNvbnNvbGUiLCJ3YXJuIiwibWVzc2FnZSIsInJlYWR5RXhjZXB0aW9uIiwicmVhZHlMaXN0IiwicmVhZHlXYWl0Iiwid2FpdCIsImNvbXBsZXRlZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZWFkeVN0YXRlIiwiZG9TY3JvbGwiLCJhY2Nlc3MiLCJjaGFpbmFibGUiLCJlbXB0eUdldCIsInJhdyIsImJ1bGsiLCJfa2V5Iiwicm1zUHJlZml4IiwicmRhc2hBbHBoYSIsImZjYW1lbENhc2UiLCJfYWxsIiwibGV0dGVyIiwidG9VcHBlckNhc2UiLCJjYW1lbENhc2UiLCJzdHJpbmciLCJhY2NlcHREYXRhIiwib3duZXIiLCJEYXRhIiwidWlkIiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJzZXQiLCJkYXRhIiwicHJvcCIsImhhc0RhdGEiLCJkYXRhUHJpdiIsImRhdGFVc2VyIiwicmJyYWNlIiwicm11bHRpRGFzaCIsImdldERhdGEiLCJKU09OIiwicGFyc2UiLCJkYXRhQXR0ciIsInJlbW92ZURhdGEiLCJfZGF0YSIsIl9yZW1vdmVEYXRhIiwiZGVxdWV1ZSIsInN0YXJ0TGVuZ3RoIiwiaG9va3MiLCJfcXVldWVIb29rcyIsInN0b3AiLCJzZXR0ZXIiLCJjbGVhclF1ZXVlIiwiY291bnQiLCJkZWZlciIsInBudW0iLCJzb3VyY2UiLCJyY3NzTnVtIiwiY3NzRXhwYW5kIiwiaXNBdHRhY2hlZCIsImNvbXBvc2VkIiwiZ2V0Um9vdE5vZGUiLCJpc0hpZGRlbldpdGhpblRyZWUiLCJzdHlsZSIsImRpc3BsYXkiLCJjc3MiLCJhZGp1c3RDU1MiLCJ2YWx1ZVBhcnRzIiwidHdlZW4iLCJhZGp1c3RlZCIsInNjYWxlIiwibWF4SXRlcmF0aW9ucyIsImN1cnJlbnRWYWx1ZSIsImluaXRpYWwiLCJ1bml0IiwiY3NzTnVtYmVyIiwiaW5pdGlhbEluVW5pdCIsImRlZmF1bHREaXNwbGF5TWFwIiwiZ2V0RGVmYXVsdERpc3BsYXkiLCJib2R5Iiwic2hvd0hpZGUiLCJzaG93IiwidmFsdWVzIiwiaGlkZSIsInRvZ2dsZSIsInJjaGVja2FibGVUeXBlIiwicnRhZ05hbWUiLCJyc2NyaXB0VHlwZSIsImZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImRpdiIsImNoZWNrQ2xvbmUiLCJjbG9uZU5vZGUiLCJub0Nsb25lQ2hlY2tlZCIsIm9wdGlvbiIsIndyYXBNYXAiLCJ0aGVhZCIsImNvbCIsInRyIiwidGQiLCJfZGVmYXVsdCIsInRib2R5IiwidGZvb3QiLCJjb2xncm91cCIsImNhcHRpb24iLCJ0aCIsIm9wdGdyb3VwIiwiZ2V0QWxsIiwic2V0R2xvYmFsRXZhbCIsInJlZkVsZW1lbnRzIiwiYnVpbGRGcmFnbWVudCIsInNjcmlwdHMiLCJzZWxlY3Rpb24iLCJpZ25vcmVkIiwid3JhcCIsImF0dGFjaGVkIiwibm9kZXMiLCJjcmVhdGVUZXh0Tm9kZSIsImh0bWxQcmVmaWx0ZXIiLCJydHlwZW5hbWVzcGFjZSIsInJldHVyblRydWUiLCJyZXR1cm5GYWxzZSIsImV4cGVjdFN5bmMiLCJzYWZlQWN0aXZlRWxlbWVudCIsImVyciIsIm9uIiwidHlwZXMiLCJvbmUiLCJvcmlnRm4iLCJldmVudCIsIm9mZiIsImhhbmRsZU9iakluIiwiZXZlbnRIYW5kbGUiLCJldmVudHMiLCJ0IiwiaGFuZGxlT2JqIiwiaGFuZGxlcnMiLCJuYW1lc3BhY2VzIiwib3JpZ1R5cGUiLCJlbGVtRGF0YSIsImNyZWF0ZSIsImhhbmRsZSIsInRyaWdnZXJlZCIsImRpc3BhdGNoIiwiZGVsZWdhdGVUeXBlIiwiYmluZFR5cGUiLCJkZWxlZ2F0ZUNvdW50Iiwic2V0dXAiLCJtYXBwZWRUeXBlcyIsIm9yaWdDb3VudCIsInRlYXJkb3duIiwicmVtb3ZlRXZlbnQiLCJuYXRpdmVFdmVudCIsImhhbmRsZXJRdWV1ZSIsImZpeCIsImRlbGVnYXRlVGFyZ2V0IiwicHJlRGlzcGF0Y2giLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImN1cnJlbnRUYXJnZXQiLCJpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCIsInJuYW1lc3BhY2UiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsInBvc3REaXNwYXRjaCIsIm1hdGNoZWRIYW5kbGVycyIsIm1hdGNoZWRTZWxlY3RvcnMiLCJhZGRQcm9wIiwiaG9vayIsIkV2ZW50IiwiZW51bWVyYWJsZSIsIm9yaWdpbmFsRXZlbnQiLCJ3cml0YWJsZSIsImxvYWQiLCJub0J1YmJsZSIsImNsaWNrIiwibGV2ZXJhZ2VOYXRpdmUiLCJ0cmlnZ2VyIiwiYmVmb3JldW5sb2FkIiwicmV0dXJuVmFsdWUiLCJub3RBc3luYyIsInNhdmVkIiwiaXNUcmlnZ2VyIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwicHJvcHMiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJkZWZhdWx0UHJldmVudGVkIiwicmVsYXRlZFRhcmdldCIsInRpbWVTdGFtcCIsIm5vdyIsImlzU2ltdWxhdGVkIiwiYWx0S2V5IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJjaGFuZ2VkVG91Y2hlcyIsImN0cmxLZXkiLCJkZXRhaWwiLCJldmVudFBoYXNlIiwibWV0YUtleSIsInBhZ2VYIiwicGFnZVkiLCJzaGlmdEtleSIsInZpZXciLCJjaGFyQ29kZSIsImtleUNvZGUiLCJidXR0b25zIiwiY2xpZW50WCIsImNsaWVudFkiLCJvZmZzZXRYIiwib2Zmc2V0WSIsInBvaW50ZXJJZCIsInBvaW50ZXJUeXBlIiwic2NyZWVuWCIsInNjcmVlblkiLCJ0YXJnZXRUb3VjaGVzIiwidG9FbGVtZW50IiwidG91Y2hlcyIsIndoaWNoIiwiYmx1ciIsIm1vdXNlZW50ZXIiLCJtb3VzZWxlYXZlIiwicG9pbnRlcmVudGVyIiwicG9pbnRlcmxlYXZlIiwib3JpZyIsInJlbGF0ZWQiLCJybm9Jbm5lcmh0bWwiLCJyY2hlY2tlZCIsInJjbGVhblNjcmlwdCIsIm1hbmlwdWxhdGlvblRhcmdldCIsImRpc2FibGVTY3JpcHQiLCJyZXN0b3JlU2NyaXB0IiwiY2xvbmVDb3B5RXZlbnQiLCJkZXN0IiwicGRhdGFPbGQiLCJ1ZGF0YU9sZCIsInVkYXRhQ3VyIiwiZml4SW5wdXQiLCJkb21NYW5pcCIsImNvbGxlY3Rpb24iLCJoYXNTY3JpcHRzIiwiaU5vQ2xvbmUiLCJ2YWx1ZUlzRnVuY3Rpb24iLCJodG1sIiwiX2V2YWxVcmwiLCJrZWVwRGF0YSIsImNsZWFuRGF0YSIsImRhdGFBbmRFdmVudHMiLCJkZWVwRGF0YUFuZEV2ZW50cyIsInNyY0VsZW1lbnRzIiwiZGVzdEVsZW1lbnRzIiwiaW5QYWdlIiwiZGV0YWNoIiwiYXBwZW5kIiwicHJlcGVuZCIsImluc2VydEJlZm9yZSIsImJlZm9yZSIsImFmdGVyIiwicmVwbGFjZVdpdGgiLCJyZXBsYWNlQ2hpbGQiLCJhcHBlbmRUbyIsInByZXBlbmRUbyIsImluc2VydEFmdGVyIiwicmVwbGFjZUFsbCIsIm9yaWdpbmFsIiwiaW5zZXJ0Iiwicm51bW5vbnB4IiwiZ2V0U3R5bGVzIiwib3BlbmVyIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInN3YXAiLCJvbGQiLCJyYm94U3R5bGUiLCJjb21wdXRlU3R5bGVUZXN0cyIsImNvbnRhaW5lciIsImNzc1RleHQiLCJkaXZTdHlsZSIsInBpeGVsUG9zaXRpb25WYWwiLCJyZWxpYWJsZU1hcmdpbkxlZnRWYWwiLCJyb3VuZFBpeGVsTWVhc3VyZXMiLCJtYXJnaW5MZWZ0IiwicmlnaHQiLCJwaXhlbEJveFN0eWxlc1ZhbCIsImJveFNpemluZ1JlbGlhYmxlVmFsIiwid2lkdGgiLCJwb3NpdGlvbiIsInNjcm9sbGJveFNpemVWYWwiLCJvZmZzZXRXaWR0aCIsIm1lYXN1cmUiLCJyb3VuZCIsInBhcnNlRmxvYXQiLCJyZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCIsImJhY2tncm91bmRDbGlwIiwiY2xlYXJDbG9uZVN0eWxlIiwiYm94U2l6aW5nUmVsaWFibGUiLCJwaXhlbEJveFN0eWxlcyIsInBpeGVsUG9zaXRpb24iLCJyZWxpYWJsZU1hcmdpbkxlZnQiLCJzY3JvbGxib3hTaXplIiwicmVsaWFibGVUckRpbWVuc2lvbnMiLCJ0YWJsZSIsInRyQ2hpbGQiLCJ0clN0eWxlIiwiaGVpZ2h0IiwicGFyc2VJbnQiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckJvdHRvbVdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiY3VyQ1NTIiwiY29tcHV0ZWQiLCJtaW5XaWR0aCIsIm1heFdpZHRoIiwiZ2V0UHJvcGVydHlWYWx1ZSIsImFkZEdldEhvb2tJZiIsImNvbmRpdGlvbkZuIiwiaG9va0ZuIiwiY3NzUHJlZml4ZXMiLCJlbXB0eVN0eWxlIiwidmVuZG9yUHJvcHMiLCJ2ZW5kb3JQcm9wTmFtZSIsImNhcE5hbWUiLCJmaW5hbFByb3BOYW1lIiwiZmluYWwiLCJjc3NQcm9wcyIsInJkaXNwbGF5c3dhcCIsInJjdXN0b21Qcm9wIiwiY3NzU2hvdyIsInZpc2liaWxpdHkiLCJjc3NOb3JtYWxUcmFuc2Zvcm0iLCJsZXR0ZXJTcGFjaW5nIiwiZm9udFdlaWdodCIsInNldFBvc2l0aXZlTnVtYmVyIiwic3VidHJhY3QiLCJtYXgiLCJib3hNb2RlbEFkanVzdG1lbnQiLCJkaW1lbnNpb24iLCJib3giLCJpc0JvcmRlckJveCIsInN0eWxlcyIsImNvbXB1dGVkVmFsIiwiZXh0cmEiLCJkZWx0YSIsImNlaWwiLCJnZXRXaWR0aE9ySGVpZ2h0IiwiYm94U2l6aW5nTmVlZGVkIiwidmFsdWVJc0JvcmRlckJveCIsIm9mZnNldFByb3AiLCJnZXRDbGllbnRSZWN0cyIsImNzc0hvb2tzIiwib3BhY2l0eSIsIm9yaWdOYW1lIiwiaXNDdXN0b21Qcm9wIiwic2V0UHJvcGVydHkiLCJpc0Zpbml0ZSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNjcm9sbGJveFNpemVCdWdneSIsImxlZnQiLCJtYXJnaW4iLCJwYWRkaW5nIiwiYm9yZGVyIiwicHJlZml4Iiwic3VmZml4IiwiZXhwYW5kIiwiZXhwYW5kZWQiLCJwYXJ0cyIsIlR3ZWVuIiwiZWFzaW5nIiwicHJvcEhvb2tzIiwicnVuIiwicGVyY2VudCIsImVhc2VkIiwiZHVyYXRpb24iLCJwb3MiLCJzdGVwIiwiZngiLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0IiwibGluZWFyIiwicCIsInN3aW5nIiwiY29zIiwiUEkiLCJmeE5vdyIsImluUHJvZ3Jlc3MiLCJyZnh0eXBlcyIsInJydW4iLCJzY2hlZHVsZSIsImhpZGRlbiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImludGVydmFsIiwidGljayIsImNyZWF0ZUZ4Tm93IiwiZ2VuRngiLCJpbmNsdWRlV2lkdGgiLCJjcmVhdGVUd2VlbiIsImFuaW1hdGlvbiIsIkFuaW1hdGlvbiIsInR3ZWVuZXJzIiwiZGVmYXVsdFByZWZpbHRlciIsIm9wdHMiLCJvbGRmaXJlIiwicHJvcFR3ZWVuIiwicmVzdG9yZURpc3BsYXkiLCJpc0JveCIsImFuaW0iLCJkYXRhU2hvdyIsInVucXVldWVkIiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJwcm9wRmlsdGVyIiwic3BlY2lhbEVhc2luZyIsInByb3BlcnRpZXMiLCJzdG9wcGVkIiwicHJlZmlsdGVycyIsImN1cnJlbnRUaW1lIiwic3RhcnRUaW1lIiwidHdlZW5zIiwib3JpZ2luYWxQcm9wZXJ0aWVzIiwib3JpZ2luYWxPcHRpb25zIiwiZ290b0VuZCIsImJpbmQiLCJjb21wbGV0ZSIsInRpbWVyIiwidHdlZW5lciIsInByZWZpbHRlciIsInNwZWVkIiwib3B0Iiwic3BlZWRzIiwiZmFkZVRvIiwidG8iLCJhbmltYXRlIiwib3B0YWxsIiwiZG9BbmltYXRpb24iLCJmaW5pc2giLCJzdG9wUXVldWUiLCJ0aW1lcnMiLCJjc3NGbiIsInNsaWRlRG93biIsInNsaWRlVXAiLCJzbGlkZVRvZ2dsZSIsImZhZGVJbiIsImZhZGVPdXQiLCJmYWRlVG9nZ2xlIiwic2xvdyIsImZhc3QiLCJkZWxheSIsInRpbWUiLCJ0aW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiY2hlY2tPbiIsIm9wdFNlbGVjdGVkIiwicmFkaW9WYWx1ZSIsImJvb2xIb29rIiwicmVtb3ZlQXR0ciIsIm5UeXBlIiwiYXR0ckhvb2tzIiwiYm9vbCIsImF0dHJOYW1lcyIsImdldHRlciIsImxvd2VyY2FzZU5hbWUiLCJyZm9jdXNhYmxlIiwicmNsaWNrYWJsZSIsInJlbW92ZVByb3AiLCJwcm9wRml4IiwidGFiaW5kZXgiLCJzdHJpcEFuZENvbGxhcHNlIiwiZ2V0Q2xhc3MiLCJjbGFzc2VzVG9BcnJheSIsImFkZENsYXNzIiwiY2xhc3NlcyIsImN1clZhbHVlIiwiY2xhenoiLCJmaW5hbFZhbHVlIiwicmVtb3ZlQ2xhc3MiLCJ0b2dnbGVDbGFzcyIsInN0YXRlVmFsIiwiaXNWYWxpZFZhbHVlIiwiY2xhc3NOYW1lcyIsImhhc0NsYXNzIiwicnJldHVybiIsInZhbEhvb2tzIiwib3B0aW9uU2V0IiwiZm9jdXNpbiIsInJmb2N1c01vcnBoIiwic3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2siLCJvbmx5SGFuZGxlcnMiLCJidWJibGVUeXBlIiwib250eXBlIiwibGFzdEVsZW1lbnQiLCJldmVudFBhdGgiLCJwYXJlbnRXaW5kb3ciLCJzaW11bGF0ZSIsInRyaWdnZXJIYW5kbGVyIiwiYXR0YWNoZXMiLCJycXVlcnkiLCJwYXJzZVhNTCIsInBhcnNlckVycm9yRWxlbSIsIkRPTVBhcnNlciIsInBhcnNlRnJvbVN0cmluZyIsInJicmFja2V0IiwickNSTEYiLCJyc3VibWl0dGVyVHlwZXMiLCJyc3VibWl0dGFibGUiLCJidWlsZFBhcmFtcyIsInRyYWRpdGlvbmFsIiwicGFyYW0iLCJzIiwidmFsdWVPckZ1bmN0aW9uIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic2VyaWFsaXplIiwic2VyaWFsaXplQXJyYXkiLCJyMjAiLCJyaGFzaCIsInJhbnRpQ2FjaGUiLCJyaGVhZGVycyIsInJsb2NhbFByb3RvY29sIiwicm5vQ29udGVudCIsInJwcm90b2NvbCIsInRyYW5zcG9ydHMiLCJhbGxUeXBlcyIsIm9yaWdpbkFuY2hvciIsImFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyIsInN0cnVjdHVyZSIsImRhdGFUeXBlRXhwcmVzc2lvbiIsImRhdGFUeXBlIiwiZGF0YVR5cGVzIiwiaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMiLCJqcVhIUiIsImluc3BlY3RlZCIsInNlZWtpbmdUcmFuc3BvcnQiLCJpbnNwZWN0IiwicHJlZmlsdGVyT3JGYWN0b3J5IiwiZGF0YVR5cGVPclRyYW5zcG9ydCIsImFqYXhFeHRlbmQiLCJmbGF0T3B0aW9ucyIsImFqYXhTZXR0aW5ncyIsImFqYXhIYW5kbGVSZXNwb25zZXMiLCJyZXNwb25zZXMiLCJjdCIsImZpbmFsRGF0YVR5cGUiLCJmaXJzdERhdGFUeXBlIiwibWltZVR5cGUiLCJnZXRSZXNwb25zZUhlYWRlciIsImNvbnZlcnRlcnMiLCJhamF4Q29udmVydCIsInJlc3BvbnNlIiwiaXNTdWNjZXNzIiwiY29udjIiLCJjdXJyZW50IiwiY29udiIsInJlc3BvbnNlRmllbGRzIiwiZGF0YUZpbHRlciIsImFjdGl2ZSIsImxhc3RNb2RpZmllZCIsImV0YWciLCJ1cmwiLCJpc0xvY2FsIiwicHJvdG9jb2wiLCJwcm9jZXNzRGF0YSIsImFzeW5jIiwiY29udGVudFR5cGUiLCJhY2NlcHRzIiwianNvbiIsImFqYXhTZXR1cCIsInNldHRpbmdzIiwiYWpheFByZWZpbHRlciIsImFqYXhUcmFuc3BvcnQiLCJhamF4IiwidHJhbnNwb3J0IiwiY2FjaGVVUkwiLCJyZXNwb25zZUhlYWRlcnNTdHJpbmciLCJyZXNwb25zZUhlYWRlcnMiLCJ0aW1lb3V0VGltZXIiLCJ1cmxBbmNob3IiLCJmaXJlR2xvYmFscyIsInVuY2FjaGVkIiwiY2FsbGJhY2tDb250ZXh0IiwiZ2xvYmFsRXZlbnRDb250ZXh0IiwiY29tcGxldGVEZWZlcnJlZCIsInN0YXR1c0NvZGUiLCJyZXF1ZXN0SGVhZGVycyIsInJlcXVlc3RIZWFkZXJzTmFtZXMiLCJzdHJBYm9ydCIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInNldFJlcXVlc3RIZWFkZXIiLCJvdmVycmlkZU1pbWVUeXBlIiwic3RhdHVzIiwiYWJvcnQiLCJzdGF0dXNUZXh0IiwiZmluYWxUZXh0IiwiY3Jvc3NEb21haW4iLCJob3N0IiwiaGFzQ29udGVudCIsImlmTW9kaWZpZWQiLCJoZWFkZXJzIiwiYmVmb3JlU2VuZCIsInN1Y2Nlc3MiLCJzZW5kIiwibmF0aXZlU3RhdHVzVGV4dCIsIm1vZGlmaWVkIiwiZ2V0SlNPTiIsImdldFNjcmlwdCIsInRleHRTY3JpcHQiLCJ3cmFwQWxsIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJ3cmFwSW5uZXIiLCJodG1sSXNGdW5jdGlvbiIsInVud3JhcCIsInZpc2libGUiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsInhoclN1Y2Nlc3NTdGF0dXMiLCJ4aHJTdXBwb3J0ZWQiLCJjb3JzIiwiZXJyb3JDYWxsYmFjayIsIm9wZW4iLCJ1c2VybmFtZSIsInhockZpZWxkcyIsIm9ubG9hZCIsIm9uZXJyb3IiLCJvbmFib3J0Iiwib250aW1lb3V0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVzcG9uc2VUeXBlIiwicmVzcG9uc2VUZXh0IiwiYmluYXJ5Iiwic2NyaXB0QXR0cnMiLCJjaGFyc2V0Iiwic2NyaXB0Q2hhcnNldCIsImV2dCIsIm9sZENhbGxiYWNrcyIsInJqc29ucCIsImpzb25wIiwianNvbnBDYWxsYmFjayIsIm9yaWdpbmFsU2V0dGluZ3MiLCJjYWxsYmFja05hbWUiLCJvdmVyd3JpdHRlbiIsInJlc3BvbnNlQ29udGFpbmVyIiwianNvblByb3AiLCJjcmVhdGVIVE1MRG9jdW1lbnQiLCJpbXBsZW1lbnRhdGlvbiIsImtlZXBTY3JpcHRzIiwicGFyc2VkIiwicGFyYW1zIiwiYW5pbWF0ZWQiLCJvZmZzZXQiLCJzZXRPZmZzZXQiLCJjdXJQb3NpdGlvbiIsImN1ckxlZnQiLCJjdXJDU1NUb3AiLCJjdXJUb3AiLCJjdXJPZmZzZXQiLCJjdXJDU1NMZWZ0IiwiY2FsY3VsYXRlUG9zaXRpb24iLCJjdXJFbGVtIiwidXNpbmciLCJyZWN0Iiwid2luIiwicGFnZVlPZmZzZXQiLCJwYWdlWE9mZnNldCIsIm9mZnNldFBhcmVudCIsInBhcmVudE9mZnNldCIsInNjcm9sbFRvIiwiSGVpZ2h0IiwiV2lkdGgiLCJkZWZhdWx0RXh0cmEiLCJmdW5jTmFtZSIsInVuYmluZCIsImRlbGVnYXRlIiwidW5kZWxlZ2F0ZSIsImhvdmVyIiwiZm5PdmVyIiwiZm5PdXQiLCJwcm94eSIsImhvbGRSZWFkeSIsImhvbGQiLCJwYXJzZUpTT04iLCJpc051bWVyaWMiLCJpc05hTiIsInRyaW0iLCJkZWZpbmUiLCJhbWQiLCJfalF1ZXJ5IiwiXyQiLCIkIiwibm9Db25mbGljdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/themes/bootstrap/vendor/jquery/jquery.js\n");

/***/ }),

/***/ "./resources/sass/app.scss":
/*!*********************************!*\
  !*** ./resources/sass/app.scss ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvc2Fzcy9hcHAuc2Nzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Fzcy9hcHAuc2Nzcz9hODBiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/sass/app.scss\n");

/***/ }),

/***/ "./node_modules/pusher-js/dist/web/pusher.js":
/*!***************************************************!*\
  !*** ./node_modules/pusher-js/dist/web/pusher.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/*!\n * Pusher JavaScript Library v8.0.2\n * https://pusher.com/\n *\n * Copyright 2020, Pusher\n * Released under the MIT licence.\n */\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(window, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_669__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_669__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_669__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_669__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_669__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_669__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nested_webpack_require_669__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nested_webpack_require_669__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_669__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nested_webpack_require_669__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_669__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_669__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_669__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_669__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_669__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_669__(__nested_webpack_require_669__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Package base64 implements Base64 encoding and decoding.\n */\n// Invalid character used in decoding to indicate\n// that the character to decode is out of range of\n// alphabet and cannot be decoded.\nvar INVALID_BYTE = 256;\n/**\n * Implements standard Base64 encoding.\n *\n * Operates in constant time.\n */\nvar Coder = /** @class */ (function () {\n    // TODO(dchest): methods to encode chunk-by-chunk.\n    function Coder(_paddingCharacter) {\n        if (_paddingCharacter === void 0) { _paddingCharacter = \"=\"; }\n        this._paddingCharacter = _paddingCharacter;\n    }\n    Coder.prototype.encodedLength = function (length) {\n        if (!this._paddingCharacter) {\n            return (length * 8 + 5) / 6 | 0;\n        }\n        return (length + 2) / 3 * 4 | 0;\n    };\n    Coder.prototype.encode = function (data) {\n        var out = \"\";\n        var i = 0;\n        for (; i < data.length - 2; i += 3) {\n            var c = (data[i] << 16) | (data[i + 1] << 8) | (data[i + 2]);\n            out += this._encodeByte((c >>> 3 * 6) & 63);\n            out += this._encodeByte((c >>> 2 * 6) & 63);\n            out += this._encodeByte((c >>> 1 * 6) & 63);\n            out += this._encodeByte((c >>> 0 * 6) & 63);\n        }\n        var left = data.length - i;\n        if (left > 0) {\n            var c = (data[i] << 16) | (left === 2 ? data[i + 1] << 8 : 0);\n            out += this._encodeByte((c >>> 3 * 6) & 63);\n            out += this._encodeByte((c >>> 2 * 6) & 63);\n            if (left === 2) {\n                out += this._encodeByte((c >>> 1 * 6) & 63);\n            }\n            else {\n                out += this._paddingCharacter || \"\";\n            }\n            out += this._paddingCharacter || \"\";\n        }\n        return out;\n    };\n    Coder.prototype.maxDecodedLength = function (length) {\n        if (!this._paddingCharacter) {\n            return (length * 6 + 7) / 8 | 0;\n        }\n        return length / 4 * 3 | 0;\n    };\n    Coder.prototype.decodedLength = function (s) {\n        return this.maxDecodedLength(s.length - this._getPaddingLength(s));\n    };\n    Coder.prototype.decode = function (s) {\n        if (s.length === 0) {\n            return new Uint8Array(0);\n        }\n        var paddingLength = this._getPaddingLength(s);\n        var length = s.length - paddingLength;\n        var out = new Uint8Array(this.maxDecodedLength(length));\n        var op = 0;\n        var i = 0;\n        var haveBad = 0;\n        var v0 = 0, v1 = 0, v2 = 0, v3 = 0;\n        for (; i < length - 4; i += 4) {\n            v0 = this._decodeChar(s.charCodeAt(i + 0));\n            v1 = this._decodeChar(s.charCodeAt(i + 1));\n            v2 = this._decodeChar(s.charCodeAt(i + 2));\n            v3 = this._decodeChar(s.charCodeAt(i + 3));\n            out[op++] = (v0 << 2) | (v1 >>> 4);\n            out[op++] = (v1 << 4) | (v2 >>> 2);\n            out[op++] = (v2 << 6) | v3;\n            haveBad |= v0 & INVALID_BYTE;\n            haveBad |= v1 & INVALID_BYTE;\n            haveBad |= v2 & INVALID_BYTE;\n            haveBad |= v3 & INVALID_BYTE;\n        }\n        if (i < length - 1) {\n            v0 = this._decodeChar(s.charCodeAt(i));\n            v1 = this._decodeChar(s.charCodeAt(i + 1));\n            out[op++] = (v0 << 2) | (v1 >>> 4);\n            haveBad |= v0 & INVALID_BYTE;\n            haveBad |= v1 & INVALID_BYTE;\n        }\n        if (i < length - 2) {\n            v2 = this._decodeChar(s.charCodeAt(i + 2));\n            out[op++] = (v1 << 4) | (v2 >>> 2);\n            haveBad |= v2 & INVALID_BYTE;\n        }\n        if (i < length - 3) {\n            v3 = this._decodeChar(s.charCodeAt(i + 3));\n            out[op++] = (v2 << 6) | v3;\n            haveBad |= v3 & INVALID_BYTE;\n        }\n        if (haveBad !== 0) {\n            throw new Error(\"Base64Coder: incorrect characters for decoding\");\n        }\n        return out;\n    };\n    // Standard encoding have the following encoded/decoded ranges,\n    // which we need to convert between.\n    //\n    // ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789  +   /\n    // Index:   0 - 25                    26 - 51              52 - 61   62  63\n    // ASCII:  65 - 90                    97 - 122             48 - 57   43  47\n    //\n    // Encode 6 bits in b into a new character.\n    Coder.prototype._encodeByte = function (b) {\n        // Encoding uses constant time operations as follows:\n        //\n        // 1. Define comparison of A with B using (A - B) >>> 8:\n        //          if A > B, then result is positive integer\n        //          if A <= B, then result is 0\n        //\n        // 2. Define selection of C or 0 using bitwise AND: X & C:\n        //          if X == 0, then result is 0\n        //          if X != 0, then result is C\n        //\n        // 3. Start with the smallest comparison (b >= 0), which is always\n        //    true, so set the result to the starting ASCII value (65).\n        //\n        // 4. Continue comparing b to higher ASCII values, and selecting\n        //    zero if comparison isn't true, otherwise selecting a value\n        //    to add to result, which:\n        //\n        //          a) undoes the previous addition\n        //          b) provides new value to add\n        //\n        var result = b;\n        // b >= 0\n        result += 65;\n        // b > 25\n        result += ((25 - b) >>> 8) & ((0 - 65) - 26 + 97);\n        // b > 51\n        result += ((51 - b) >>> 8) & ((26 - 97) - 52 + 48);\n        // b > 61\n        result += ((61 - b) >>> 8) & ((52 - 48) - 62 + 43);\n        // b > 62\n        result += ((62 - b) >>> 8) & ((62 - 43) - 63 + 47);\n        return String.fromCharCode(result);\n    };\n    // Decode a character code into a byte.\n    // Must return 256 if character is out of alphabet range.\n    Coder.prototype._decodeChar = function (c) {\n        // Decoding works similar to encoding: using the same comparison\n        // function, but now it works on ranges: result is always incremented\n        // by value, but this value becomes zero if the range is not\n        // satisfied.\n        //\n        // Decoding starts with invalid value, 256, which is then\n        // subtracted when the range is satisfied. If none of the ranges\n        // apply, the function returns 256, which is then checked by\n        // the caller to throw error.\n        var result = INVALID_BYTE; // start with invalid character\n        // c == 43 (c > 42 and c < 44)\n        result += (((42 - c) & (c - 44)) >>> 8) & (-INVALID_BYTE + c - 43 + 62);\n        // c == 47 (c > 46 and c < 48)\n        result += (((46 - c) & (c - 48)) >>> 8) & (-INVALID_BYTE + c - 47 + 63);\n        // c > 47 and c < 58\n        result += (((47 - c) & (c - 58)) >>> 8) & (-INVALID_BYTE + c - 48 + 52);\n        // c > 64 and c < 91\n        result += (((64 - c) & (c - 91)) >>> 8) & (-INVALID_BYTE + c - 65 + 0);\n        // c > 96 and c < 123\n        result += (((96 - c) & (c - 123)) >>> 8) & (-INVALID_BYTE + c - 97 + 26);\n        return result;\n    };\n    Coder.prototype._getPaddingLength = function (s) {\n        var paddingLength = 0;\n        if (this._paddingCharacter) {\n            for (var i = s.length - 1; i >= 0; i--) {\n                if (s[i] !== this._paddingCharacter) {\n                    break;\n                }\n                paddingLength++;\n            }\n            if (s.length < 4 || paddingLength > 2) {\n                throw new Error(\"Base64Coder: incorrect padding\");\n            }\n        }\n        return paddingLength;\n    };\n    return Coder;\n}());\nexports.Coder = Coder;\nvar stdCoder = new Coder();\nfunction encode(data) {\n    return stdCoder.encode(data);\n}\nexports.encode = encode;\nfunction decode(s) {\n    return stdCoder.decode(s);\n}\nexports.decode = decode;\n/**\n * Implements URL-safe Base64 encoding.\n * (Same as Base64, but '+' is replaced with '-', and '/' with '_').\n *\n * Operates in constant time.\n */\nvar URLSafeCoder = /** @class */ (function (_super) {\n    __extends(URLSafeCoder, _super);\n    function URLSafeCoder() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    // URL-safe encoding have the following encoded/decoded ranges:\n    //\n    // ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789  -   _\n    // Index:   0 - 25                    26 - 51              52 - 61   62  63\n    // ASCII:  65 - 90                    97 - 122             48 - 57   45  95\n    //\n    URLSafeCoder.prototype._encodeByte = function (b) {\n        var result = b;\n        // b >= 0\n        result += 65;\n        // b > 25\n        result += ((25 - b) >>> 8) & ((0 - 65) - 26 + 97);\n        // b > 51\n        result += ((51 - b) >>> 8) & ((26 - 97) - 52 + 48);\n        // b > 61\n        result += ((61 - b) >>> 8) & ((52 - 48) - 62 + 45);\n        // b > 62\n        result += ((62 - b) >>> 8) & ((62 - 45) - 63 + 95);\n        return String.fromCharCode(result);\n    };\n    URLSafeCoder.prototype._decodeChar = function (c) {\n        var result = INVALID_BYTE;\n        // c == 45 (c > 44 and c < 46)\n        result += (((44 - c) & (c - 46)) >>> 8) & (-INVALID_BYTE + c - 45 + 62);\n        // c == 95 (c > 94 and c < 96)\n        result += (((94 - c) & (c - 96)) >>> 8) & (-INVALID_BYTE + c - 95 + 63);\n        // c > 47 and c < 58\n        result += (((47 - c) & (c - 58)) >>> 8) & (-INVALID_BYTE + c - 48 + 52);\n        // c > 64 and c < 91\n        result += (((64 - c) & (c - 91)) >>> 8) & (-INVALID_BYTE + c - 65 + 0);\n        // c > 96 and c < 123\n        result += (((96 - c) & (c - 123)) >>> 8) & (-INVALID_BYTE + c - 97 + 26);\n        return result;\n    };\n    return URLSafeCoder;\n}(Coder));\nexports.URLSafeCoder = URLSafeCoder;\nvar urlSafeCoder = new URLSafeCoder();\nfunction encodeURLSafe(data) {\n    return urlSafeCoder.encode(data);\n}\nexports.encodeURLSafe = encodeURLSafe;\nfunction decodeURLSafe(s) {\n    return urlSafeCoder.decode(s);\n}\nexports.decodeURLSafe = decodeURLSafe;\nexports.encodedLength = function (length) {\n    return stdCoder.encodedLength(length);\n};\nexports.maxDecodedLength = function (length) {\n    return stdCoder.maxDecodedLength(length);\n};\nexports.decodedLength = function (s) {\n    return stdCoder.decodedLength(s);\n};\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Package utf8 implements UTF-8 encoding and decoding.\n */\nvar INVALID_UTF16 = \"utf8: invalid string\";\nvar INVALID_UTF8 = \"utf8: invalid source encoding\";\n/**\n * Encodes the given string into UTF-8 byte array.\n * Throws if the source string has invalid UTF-16 encoding.\n */\nfunction encode(s) {\n    // Calculate result length and allocate output array.\n    // encodedLength() also validates string and throws errors,\n    // so we don't need repeat validation here.\n    var arr = new Uint8Array(encodedLength(s));\n    var pos = 0;\n    for (var i = 0; i < s.length; i++) {\n        var c = s.charCodeAt(i);\n        if (c < 0x80) {\n            arr[pos++] = c;\n        }\n        else if (c < 0x800) {\n            arr[pos++] = 0xc0 | c >> 6;\n            arr[pos++] = 0x80 | c & 0x3f;\n        }\n        else if (c < 0xd800) {\n            arr[pos++] = 0xe0 | c >> 12;\n            arr[pos++] = 0x80 | (c >> 6) & 0x3f;\n            arr[pos++] = 0x80 | c & 0x3f;\n        }\n        else {\n            i++; // get one more character\n            c = (c & 0x3ff) << 10;\n            c |= s.charCodeAt(i) & 0x3ff;\n            c += 0x10000;\n            arr[pos++] = 0xf0 | c >> 18;\n            arr[pos++] = 0x80 | (c >> 12) & 0x3f;\n            arr[pos++] = 0x80 | (c >> 6) & 0x3f;\n            arr[pos++] = 0x80 | c & 0x3f;\n        }\n    }\n    return arr;\n}\nexports.encode = encode;\n/**\n * Returns the number of bytes required to encode the given string into UTF-8.\n * Throws if the source string has invalid UTF-16 encoding.\n */\nfunction encodedLength(s) {\n    var result = 0;\n    for (var i = 0; i < s.length; i++) {\n        var c = s.charCodeAt(i);\n        if (c < 0x80) {\n            result += 1;\n        }\n        else if (c < 0x800) {\n            result += 2;\n        }\n        else if (c < 0xd800) {\n            result += 3;\n        }\n        else if (c <= 0xdfff) {\n            if (i >= s.length - 1) {\n                throw new Error(INVALID_UTF16);\n            }\n            i++; // \"eat\" next character\n            result += 4;\n        }\n        else {\n            throw new Error(INVALID_UTF16);\n        }\n    }\n    return result;\n}\nexports.encodedLength = encodedLength;\n/**\n * Decodes the given byte array from UTF-8 into a string.\n * Throws if encoding is invalid.\n */\nfunction decode(arr) {\n    var chars = [];\n    for (var i = 0; i < arr.length; i++) {\n        var b = arr[i];\n        if (b & 0x80) {\n            var min = void 0;\n            if (b < 0xe0) {\n                // Need 1 more byte.\n                if (i >= arr.length) {\n                    throw new Error(INVALID_UTF8);\n                }\n                var n1 = arr[++i];\n                if ((n1 & 0xc0) !== 0x80) {\n                    throw new Error(INVALID_UTF8);\n                }\n                b = (b & 0x1f) << 6 | (n1 & 0x3f);\n                min = 0x80;\n            }\n            else if (b < 0xf0) {\n                // Need 2 more bytes.\n                if (i >= arr.length - 1) {\n                    throw new Error(INVALID_UTF8);\n                }\n                var n1 = arr[++i];\n                var n2 = arr[++i];\n                if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80) {\n                    throw new Error(INVALID_UTF8);\n                }\n                b = (b & 0x0f) << 12 | (n1 & 0x3f) << 6 | (n2 & 0x3f);\n                min = 0x800;\n            }\n            else if (b < 0xf8) {\n                // Need 3 more bytes.\n                if (i >= arr.length - 2) {\n                    throw new Error(INVALID_UTF8);\n                }\n                var n1 = arr[++i];\n                var n2 = arr[++i];\n                var n3 = arr[++i];\n                if ((n1 & 0xc0) !== 0x80 || (n2 & 0xc0) !== 0x80 || (n3 & 0xc0) !== 0x80) {\n                    throw new Error(INVALID_UTF8);\n                }\n                b = (b & 0x0f) << 18 | (n1 & 0x3f) << 12 | (n2 & 0x3f) << 6 | (n3 & 0x3f);\n                min = 0x10000;\n            }\n            else {\n                throw new Error(INVALID_UTF8);\n            }\n            if (b < min || (b >= 0xd800 && b <= 0xdfff)) {\n                throw new Error(INVALID_UTF8);\n            }\n            if (b >= 0x10000) {\n                // Surrogate pair.\n                if (b > 0x10ffff) {\n                    throw new Error(INVALID_UTF8);\n                }\n                b -= 0x10000;\n                chars.push(String.fromCharCode(0xd800 | (b >> 10)));\n                b = 0xdc00 | (b & 0x3ff);\n            }\n        }\n        chars.push(String.fromCharCode(b));\n    }\n    return chars.join(\"\");\n}\nexports.decode = decode;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __nested_webpack_require_19901__) {\n\n// required so we don't have to do require('pusher').default etc.\nmodule.exports = __nested_webpack_require_19901__(3).default;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_20105__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__nested_webpack_require_20105__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/runtimes/web/dom/script_receiver_factory.ts\nvar ScriptReceiverFactory = (function () {\n    function ScriptReceiverFactory(prefix, name) {\n        this.lastId = 0;\n        this.prefix = prefix;\n        this.name = name;\n    }\n    ScriptReceiverFactory.prototype.create = function (callback) {\n        this.lastId++;\n        var number = this.lastId;\n        var id = this.prefix + number;\n        var name = this.name + '[' + number + ']';\n        var called = false;\n        var callbackWrapper = function () {\n            if (!called) {\n                callback.apply(null, arguments);\n                called = true;\n            }\n        };\n        this[number] = callbackWrapper;\n        return { number: number, id: id, name: name, callback: callbackWrapper };\n    };\n    ScriptReceiverFactory.prototype.remove = function (receiver) {\n        delete this[receiver.number];\n    };\n    return ScriptReceiverFactory;\n}());\n\nvar ScriptReceivers = new ScriptReceiverFactory('_pusher_script_', 'Pusher.ScriptReceivers');\n\n// CONCATENATED MODULE: ./src/core/defaults.ts\nvar Defaults = {\n    VERSION: \"8.0.2\",\n    PROTOCOL: 7,\n    wsPort: 80,\n    wssPort: 443,\n    wsPath: '',\n    httpHost: 'sockjs.pusher.com',\n    httpPort: 80,\n    httpsPort: 443,\n    httpPath: '/pusher',\n    stats_host: 'stats.pusher.com',\n    authEndpoint: '/pusher/auth',\n    authTransport: 'ajax',\n    activityTimeout: 120000,\n    pongTimeout: 30000,\n    unavailableTimeout: 10000,\n    userAuthentication: {\n        endpoint: '/pusher/user-auth',\n        transport: 'ajax'\n    },\n    channelAuthorization: {\n        endpoint: '/pusher/auth',\n        transport: 'ajax'\n    },\n    cdn_http: \"http://js.pusher.com\",\n    cdn_https: \"https://js.pusher.com\",\n    dependency_suffix: \"\"\n};\n/* harmony default export */ var defaults = (Defaults);\n\n// CONCATENATED MODULE: ./src/runtimes/web/dom/dependency_loader.ts\n\n\nvar dependency_loader_DependencyLoader = (function () {\n    function DependencyLoader(options) {\n        this.options = options;\n        this.receivers = options.receivers || ScriptReceivers;\n        this.loading = {};\n    }\n    DependencyLoader.prototype.load = function (name, options, callback) {\n        var self = this;\n        if (self.loading[name] && self.loading[name].length > 0) {\n            self.loading[name].push(callback);\n        }\n        else {\n            self.loading[name] = [callback];\n            var request = runtime.createScriptRequest(self.getPath(name, options));\n            var receiver = self.receivers.create(function (error) {\n                self.receivers.remove(receiver);\n                if (self.loading[name]) {\n                    var callbacks = self.loading[name];\n                    delete self.loading[name];\n                    var successCallback = function (wasSuccessful) {\n                        if (!wasSuccessful) {\n                            request.cleanup();\n                        }\n                    };\n                    for (var i = 0; i < callbacks.length; i++) {\n                        callbacks[i](error, successCallback);\n                    }\n                }\n            });\n            request.send(receiver);\n        }\n    };\n    DependencyLoader.prototype.getRoot = function (options) {\n        var cdn;\n        var protocol = runtime.getDocument().location.protocol;\n        if ((options && options.useTLS) || protocol === 'https:') {\n            cdn = this.options.cdn_https;\n        }\n        else {\n            cdn = this.options.cdn_http;\n        }\n        return cdn.replace(/\\/*$/, '') + '/' + this.options.version;\n    };\n    DependencyLoader.prototype.getPath = function (name, options) {\n        return this.getRoot(options) + '/' + name + this.options.suffix + '.js';\n    };\n    return DependencyLoader;\n}());\n/* harmony default export */ var dependency_loader = (dependency_loader_DependencyLoader);\n\n// CONCATENATED MODULE: ./src/runtimes/web/dom/dependencies.ts\n\n\n\nvar DependenciesReceivers = new ScriptReceiverFactory('_pusher_dependencies', 'Pusher.DependenciesReceivers');\nvar Dependencies = new dependency_loader({\n    cdn_http: defaults.cdn_http,\n    cdn_https: defaults.cdn_https,\n    version: defaults.VERSION,\n    suffix: defaults.dependency_suffix,\n    receivers: DependenciesReceivers\n});\n\n// CONCATENATED MODULE: ./src/core/utils/url_store.ts\nvar urlStore = {\n    baseUrl: 'https://pusher.com',\n    urls: {\n        authenticationEndpoint: {\n            path: '/docs/channels/server_api/authenticating_users'\n        },\n        authorizationEndpoint: {\n            path: '/docs/channels/server_api/authorizing-users/'\n        },\n        javascriptQuickStart: {\n            path: '/docs/javascript_quick_start'\n        },\n        triggeringClientEvents: {\n            path: '/docs/client_api_guide/client_events#trigger-events'\n        },\n        encryptedChannelSupport: {\n            fullUrl: 'https://github.com/pusher/pusher-js/tree/cc491015371a4bde5743d1c87a0fbac0feb53195#encrypted-channel-support'\n        }\n    }\n};\nvar buildLogSuffix = function (key) {\n    var urlPrefix = 'See:';\n    var urlObj = urlStore.urls[key];\n    if (!urlObj)\n        return '';\n    var url;\n    if (urlObj.fullUrl) {\n        url = urlObj.fullUrl;\n    }\n    else if (urlObj.path) {\n        url = urlStore.baseUrl + urlObj.path;\n    }\n    if (!url)\n        return '';\n    return urlPrefix + \" \" + url;\n};\n/* harmony default export */ var url_store = ({ buildLogSuffix: buildLogSuffix });\n\n// CONCATENATED MODULE: ./src/core/auth/options.ts\nvar AuthRequestType;\n(function (AuthRequestType) {\n    AuthRequestType[\"UserAuthentication\"] = \"user-authentication\";\n    AuthRequestType[\"ChannelAuthorization\"] = \"channel-authorization\";\n})(AuthRequestType || (AuthRequestType = {}));\n\n// CONCATENATED MODULE: ./src/core/errors.ts\nvar __extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar BadEventName = (function (_super) {\n    __extends(BadEventName, _super);\n    function BadEventName(msg) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, msg) || this;\n        Object.setPrototypeOf(_this, _newTarget.prototype);\n        return _this;\n    }\n    return BadEventName;\n}(Error));\n\nvar BadChannelName = (function (_super) {\n    __extends(BadChannelName, _super);\n    function BadChannelName(msg) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, msg) || this;\n        Object.setPrototypeOf(_this, _newTarget.prototype);\n        return _this;\n    }\n    return BadChannelName;\n}(Error));\n\nvar RequestTimedOut = (function (_super) {\n    __extends(RequestTimedOut, _super);\n    function RequestTimedOut(msg) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, msg) || this;\n        Object.setPrototypeOf(_this, _newTarget.prototype);\n        return _this;\n    }\n    return RequestTimedOut;\n}(Error));\n\nvar TransportPriorityTooLow = (function (_super) {\n    __extends(TransportPriorityTooLow, _super);\n    function TransportPriorityTooLow(msg) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, msg) || this;\n        Object.setPrototypeOf(_this, _newTarget.prototype);\n        return _this;\n    }\n    return TransportPriorityTooLow;\n}(Error));\n\nvar TransportClosed = (function (_super) {\n    __extends(TransportClosed, _super);\n    function TransportClosed(msg) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, msg) || this;\n        Object.setPrototypeOf(_this, _newTarget.prototype);\n        return _this;\n    }\n    return TransportClosed;\n}(Error));\n\nvar UnsupportedFeature = (function (_super) {\n    __extends(UnsupportedFeature, _super);\n    function UnsupportedFeature(msg) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, msg) || this;\n        Object.setPrototypeOf(_this, _newTarget.prototype);\n        return _this;\n    }\n    return UnsupportedFeature;\n}(Error));\n\nvar UnsupportedTransport = (function (_super) {\n    __extends(UnsupportedTransport, _super);\n    function UnsupportedTransport(msg) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, msg) || this;\n        Object.setPrototypeOf(_this, _newTarget.prototype);\n        return _this;\n    }\n    return UnsupportedTransport;\n}(Error));\n\nvar UnsupportedStrategy = (function (_super) {\n    __extends(UnsupportedStrategy, _super);\n    function UnsupportedStrategy(msg) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, msg) || this;\n        Object.setPrototypeOf(_this, _newTarget.prototype);\n        return _this;\n    }\n    return UnsupportedStrategy;\n}(Error));\n\nvar HTTPAuthError = (function (_super) {\n    __extends(HTTPAuthError, _super);\n    function HTTPAuthError(status, msg) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, msg) || this;\n        _this.status = status;\n        Object.setPrototypeOf(_this, _newTarget.prototype);\n        return _this;\n    }\n    return HTTPAuthError;\n}(Error));\n\n\n// CONCATENATED MODULE: ./src/runtimes/isomorphic/auth/xhr_auth.ts\n\n\n\n\nvar ajax = function (context, query, authOptions, authRequestType, callback) {\n    var xhr = runtime.createXHR();\n    xhr.open('POST', authOptions.endpoint, true);\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    for (var headerName in authOptions.headers) {\n        xhr.setRequestHeader(headerName, authOptions.headers[headerName]);\n    }\n    if (authOptions.headersProvider != null) {\n        var dynamicHeaders = authOptions.headersProvider();\n        for (var headerName in dynamicHeaders) {\n            xhr.setRequestHeader(headerName, dynamicHeaders[headerName]);\n        }\n    }\n    xhr.onreadystatechange = function () {\n        if (xhr.readyState === 4) {\n            if (xhr.status === 200) {\n                var data = void 0;\n                var parsed = false;\n                try {\n                    data = JSON.parse(xhr.responseText);\n                    parsed = true;\n                }\n                catch (e) {\n                    callback(new HTTPAuthError(200, \"JSON returned from \" + authRequestType.toString() + \" endpoint was invalid, yet status code was 200. Data was: \" + xhr.responseText), null);\n                }\n                if (parsed) {\n                    callback(null, data);\n                }\n            }\n            else {\n                var suffix = '';\n                switch (authRequestType) {\n                    case AuthRequestType.UserAuthentication:\n                        suffix = url_store.buildLogSuffix('authenticationEndpoint');\n                        break;\n                    case AuthRequestType.ChannelAuthorization:\n                        suffix = \"Clients must be authorized to join private or presence channels. \" + url_store.buildLogSuffix('authorizationEndpoint');\n                        break;\n                }\n                callback(new HTTPAuthError(xhr.status, \"Unable to retrieve auth string from \" + authRequestType.toString() + \" endpoint - \" +\n                    (\"received status: \" + xhr.status + \" from \" + authOptions.endpoint + \". \" + suffix)), null);\n            }\n        }\n    };\n    xhr.send(query);\n    return xhr;\n};\n/* harmony default export */ var xhr_auth = (ajax);\n\n// CONCATENATED MODULE: ./src/core/base64.ts\nfunction encode(s) {\n    return btoa(utob(s));\n}\nvar fromCharCode = String.fromCharCode;\nvar b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nvar b64tab = {};\nfor (var base64_i = 0, l = b64chars.length; base64_i < l; base64_i++) {\n    b64tab[b64chars.charAt(base64_i)] = base64_i;\n}\nvar cb_utob = function (c) {\n    var cc = c.charCodeAt(0);\n    return cc < 0x80\n        ? c\n        : cc < 0x800\n            ? fromCharCode(0xc0 | (cc >>> 6)) + fromCharCode(0x80 | (cc & 0x3f))\n            : fromCharCode(0xe0 | ((cc >>> 12) & 0x0f)) +\n                fromCharCode(0x80 | ((cc >>> 6) & 0x3f)) +\n                fromCharCode(0x80 | (cc & 0x3f));\n};\nvar utob = function (u) {\n    return u.replace(/[^\\x00-\\x7F]/g, cb_utob);\n};\nvar cb_encode = function (ccc) {\n    var padlen = [0, 2, 1][ccc.length % 3];\n    var ord = (ccc.charCodeAt(0) << 16) |\n        ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8) |\n        (ccc.length > 2 ? ccc.charCodeAt(2) : 0);\n    var chars = [\n        b64chars.charAt(ord >>> 18),\n        b64chars.charAt((ord >>> 12) & 63),\n        padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),\n        padlen >= 1 ? '=' : b64chars.charAt(ord & 63)\n    ];\n    return chars.join('');\n};\nvar btoa = window.btoa ||\n    function (b) {\n        return b.replace(/[\\s\\S]{1,3}/g, cb_encode);\n    };\n\n// CONCATENATED MODULE: ./src/core/utils/timers/abstract_timer.ts\nvar Timer = (function () {\n    function Timer(set, clear, delay, callback) {\n        var _this = this;\n        this.clear = clear;\n        this.timer = set(function () {\n            if (_this.timer) {\n                _this.timer = callback(_this.timer);\n            }\n        }, delay);\n    }\n    Timer.prototype.isRunning = function () {\n        return this.timer !== null;\n    };\n    Timer.prototype.ensureAborted = function () {\n        if (this.timer) {\n            this.clear(this.timer);\n            this.timer = null;\n        }\n    };\n    return Timer;\n}());\n/* harmony default export */ var abstract_timer = (Timer);\n\n// CONCATENATED MODULE: ./src/core/utils/timers/index.ts\nvar timers_extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\nfunction timers_clearTimeout(timer) {\n    window.clearTimeout(timer);\n}\nfunction timers_clearInterval(timer) {\n    window.clearInterval(timer);\n}\nvar OneOffTimer = (function (_super) {\n    timers_extends(OneOffTimer, _super);\n    function OneOffTimer(delay, callback) {\n        return _super.call(this, setTimeout, timers_clearTimeout, delay, function (timer) {\n            callback();\n            return null;\n        }) || this;\n    }\n    return OneOffTimer;\n}(abstract_timer));\n\nvar PeriodicTimer = (function (_super) {\n    timers_extends(PeriodicTimer, _super);\n    function PeriodicTimer(delay, callback) {\n        return _super.call(this, setInterval, timers_clearInterval, delay, function (timer) {\n            callback();\n            return timer;\n        }) || this;\n    }\n    return PeriodicTimer;\n}(abstract_timer));\n\n\n// CONCATENATED MODULE: ./src/core/util.ts\n\nvar Util = {\n    now: function () {\n        if (Date.now) {\n            return Date.now();\n        }\n        else {\n            return new Date().valueOf();\n        }\n    },\n    defer: function (callback) {\n        return new OneOffTimer(0, callback);\n    },\n    method: function (name) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var boundArguments = Array.prototype.slice.call(arguments, 1);\n        return function (object) {\n            return object[name].apply(object, boundArguments.concat(arguments));\n        };\n    }\n};\n/* harmony default export */ var util = (Util);\n\n// CONCATENATED MODULE: ./src/core/utils/collections.ts\n\n\nfunction extend(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < sources.length; i++) {\n        var extensions = sources[i];\n        for (var property in extensions) {\n            if (extensions[property] &&\n                extensions[property].constructor &&\n                extensions[property].constructor === Object) {\n                target[property] = extend(target[property] || {}, extensions[property]);\n            }\n            else {\n                target[property] = extensions[property];\n            }\n        }\n    }\n    return target;\n}\nfunction stringify() {\n    var m = ['Pusher'];\n    for (var i = 0; i < arguments.length; i++) {\n        if (typeof arguments[i] === 'string') {\n            m.push(arguments[i]);\n        }\n        else {\n            m.push(safeJSONStringify(arguments[i]));\n        }\n    }\n    return m.join(' : ');\n}\nfunction arrayIndexOf(array, item) {\n    var nativeIndexOf = Array.prototype.indexOf;\n    if (array === null) {\n        return -1;\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) {\n        return array.indexOf(item);\n    }\n    for (var i = 0, l = array.length; i < l; i++) {\n        if (array[i] === item) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction objectApply(object, f) {\n    for (var key in object) {\n        if (Object.prototype.hasOwnProperty.call(object, key)) {\n            f(object[key], key, object);\n        }\n    }\n}\nfunction keys(object) {\n    var keys = [];\n    objectApply(object, function (_, key) {\n        keys.push(key);\n    });\n    return keys;\n}\nfunction values(object) {\n    var values = [];\n    objectApply(object, function (value) {\n        values.push(value);\n    });\n    return values;\n}\nfunction apply(array, f, context) {\n    for (var i = 0; i < array.length; i++) {\n        f.call(context || window, array[i], i, array);\n    }\n}\nfunction map(array, f) {\n    var result = [];\n    for (var i = 0; i < array.length; i++) {\n        result.push(f(array[i], i, array, result));\n    }\n    return result;\n}\nfunction mapObject(object, f) {\n    var result = {};\n    objectApply(object, function (value, key) {\n        result[key] = f(value);\n    });\n    return result;\n}\nfunction filter(array, test) {\n    test =\n        test ||\n            function (value) {\n                return !!value;\n            };\n    var result = [];\n    for (var i = 0; i < array.length; i++) {\n        if (test(array[i], i, array, result)) {\n            result.push(array[i]);\n        }\n    }\n    return result;\n}\nfunction filterObject(object, test) {\n    var result = {};\n    objectApply(object, function (value, key) {\n        if ((test && test(value, key, object, result)) || Boolean(value)) {\n            result[key] = value;\n        }\n    });\n    return result;\n}\nfunction flatten(object) {\n    var result = [];\n    objectApply(object, function (value, key) {\n        result.push([key, value]);\n    });\n    return result;\n}\nfunction any(array, test) {\n    for (var i = 0; i < array.length; i++) {\n        if (test(array[i], i, array)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction collections_all(array, test) {\n    for (var i = 0; i < array.length; i++) {\n        if (!test(array[i], i, array)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction encodeParamsObject(data) {\n    return mapObject(data, function (value) {\n        if (typeof value === 'object') {\n            value = safeJSONStringify(value);\n        }\n        return encodeURIComponent(encode(value.toString()));\n    });\n}\nfunction buildQueryString(data) {\n    var params = filterObject(data, function (value) {\n        return value !== undefined;\n    });\n    var query = map(flatten(encodeParamsObject(params)), util.method('join', '=')).join('&');\n    return query;\n}\nfunction decycleObject(object) {\n    var objects = [], paths = [];\n    return (function derez(value, path) {\n        var i, name, nu;\n        switch (typeof value) {\n            case 'object':\n                if (!value) {\n                    return null;\n                }\n                for (i = 0; i < objects.length; i += 1) {\n                    if (objects[i] === value) {\n                        return { $ref: paths[i] };\n                    }\n                }\n                objects.push(value);\n                paths.push(path);\n                if (Object.prototype.toString.apply(value) === '[object Array]') {\n                    nu = [];\n                    for (i = 0; i < value.length; i += 1) {\n                        nu[i] = derez(value[i], path + '[' + i + ']');\n                    }\n                }\n                else {\n                    nu = {};\n                    for (name in value) {\n                        if (Object.prototype.hasOwnProperty.call(value, name)) {\n                            nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');\n                        }\n                    }\n                }\n                return nu;\n            case 'number':\n            case 'string':\n            case 'boolean':\n                return value;\n        }\n    })(object, '$');\n}\nfunction safeJSONStringify(source) {\n    try {\n        return JSON.stringify(source);\n    }\n    catch (e) {\n        return JSON.stringify(decycleObject(source));\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/logger.ts\n\n\nvar logger_Logger = (function () {\n    function Logger() {\n        this.globalLog = function (message) {\n            if (window.console && window.console.log) {\n                window.console.log(message);\n            }\n        };\n    }\n    Logger.prototype.debug = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this.log(this.globalLog, args);\n    };\n    Logger.prototype.warn = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this.log(this.globalLogWarn, args);\n    };\n    Logger.prototype.error = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this.log(this.globalLogError, args);\n    };\n    Logger.prototype.globalLogWarn = function (message) {\n        if (window.console && window.console.warn) {\n            window.console.warn(message);\n        }\n        else {\n            this.globalLog(message);\n        }\n    };\n    Logger.prototype.globalLogError = function (message) {\n        if (window.console && window.console.error) {\n            window.console.error(message);\n        }\n        else {\n            this.globalLogWarn(message);\n        }\n    };\n    Logger.prototype.log = function (defaultLoggingFunction) {\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        var message = stringify.apply(this, arguments);\n        if (core_pusher.log) {\n            core_pusher.log(message);\n        }\n        else if (core_pusher.logToConsole) {\n            var log = defaultLoggingFunction.bind(this);\n            log(message);\n        }\n    };\n    return Logger;\n}());\n/* harmony default export */ var logger = (new logger_Logger());\n\n// CONCATENATED MODULE: ./src/runtimes/web/auth/jsonp_auth.ts\n\nvar jsonp = function (context, query, authOptions, authRequestType, callback) {\n    if (authOptions.headers !== undefined ||\n        authOptions.headersProvider != null) {\n        logger.warn(\"To send headers with the \" + authRequestType.toString() + \" request, you must use AJAX, rather than JSONP.\");\n    }\n    var callbackName = context.nextAuthCallbackID.toString();\n    context.nextAuthCallbackID++;\n    var document = context.getDocument();\n    var script = document.createElement('script');\n    context.auth_callbacks[callbackName] = function (data) {\n        callback(null, data);\n    };\n    var callback_name = \"Pusher.auth_callbacks['\" + callbackName + \"']\";\n    script.src =\n        authOptions.endpoint +\n            '?callback=' +\n            encodeURIComponent(callback_name) +\n            '&' +\n            query;\n    var head = document.getElementsByTagName('head')[0] || document.documentElement;\n    head.insertBefore(script, head.firstChild);\n};\n/* harmony default export */ var jsonp_auth = (jsonp);\n\n// CONCATENATED MODULE: ./src/runtimes/web/dom/script_request.ts\nvar ScriptRequest = (function () {\n    function ScriptRequest(src) {\n        this.src = src;\n    }\n    ScriptRequest.prototype.send = function (receiver) {\n        var self = this;\n        var errorString = 'Error loading ' + self.src;\n        self.script = document.createElement('script');\n        self.script.id = receiver.id;\n        self.script.src = self.src;\n        self.script.type = 'text/javascript';\n        self.script.charset = 'UTF-8';\n        if (self.script.addEventListener) {\n            self.script.onerror = function () {\n                receiver.callback(errorString);\n            };\n            self.script.onload = function () {\n                receiver.callback(null);\n            };\n        }\n        else {\n            self.script.onreadystatechange = function () {\n                if (self.script.readyState === 'loaded' ||\n                    self.script.readyState === 'complete') {\n                    receiver.callback(null);\n                }\n            };\n        }\n        if (self.script.async === undefined &&\n            document.attachEvent &&\n            /opera/i.test(navigator.userAgent)) {\n            self.errorScript = document.createElement('script');\n            self.errorScript.id = receiver.id + '_error';\n            self.errorScript.text = receiver.name + \"('\" + errorString + \"');\";\n            self.script.async = self.errorScript.async = false;\n        }\n        else {\n            self.script.async = true;\n        }\n        var head = document.getElementsByTagName('head')[0];\n        head.insertBefore(self.script, head.firstChild);\n        if (self.errorScript) {\n            head.insertBefore(self.errorScript, self.script.nextSibling);\n        }\n    };\n    ScriptRequest.prototype.cleanup = function () {\n        if (this.script) {\n            this.script.onload = this.script.onerror = null;\n            this.script.onreadystatechange = null;\n        }\n        if (this.script && this.script.parentNode) {\n            this.script.parentNode.removeChild(this.script);\n        }\n        if (this.errorScript && this.errorScript.parentNode) {\n            this.errorScript.parentNode.removeChild(this.errorScript);\n        }\n        this.script = null;\n        this.errorScript = null;\n    };\n    return ScriptRequest;\n}());\n/* harmony default export */ var script_request = (ScriptRequest);\n\n// CONCATENATED MODULE: ./src/runtimes/web/dom/jsonp_request.ts\n\n\nvar jsonp_request_JSONPRequest = (function () {\n    function JSONPRequest(url, data) {\n        this.url = url;\n        this.data = data;\n    }\n    JSONPRequest.prototype.send = function (receiver) {\n        if (this.request) {\n            return;\n        }\n        var query = buildQueryString(this.data);\n        var url = this.url + '/' + receiver.number + '?' + query;\n        this.request = runtime.createScriptRequest(url);\n        this.request.send(receiver);\n    };\n    JSONPRequest.prototype.cleanup = function () {\n        if (this.request) {\n            this.request.cleanup();\n        }\n    };\n    return JSONPRequest;\n}());\n/* harmony default export */ var jsonp_request = (jsonp_request_JSONPRequest);\n\n// CONCATENATED MODULE: ./src/runtimes/web/timeline/jsonp_timeline.ts\n\n\nvar getAgent = function (sender, useTLS) {\n    return function (data, callback) {\n        var scheme = 'http' + (useTLS ? 's' : '') + '://';\n        var url = scheme + (sender.host || sender.options.host) + sender.options.path;\n        var request = runtime.createJSONPRequest(url, data);\n        var receiver = runtime.ScriptReceivers.create(function (error, result) {\n            ScriptReceivers.remove(receiver);\n            request.cleanup();\n            if (result && result.host) {\n                sender.host = result.host;\n            }\n            if (callback) {\n                callback(error, result);\n            }\n        });\n        request.send(receiver);\n    };\n};\nvar jsonp_timeline_jsonp = {\n    name: 'jsonp',\n    getAgent: getAgent\n};\n/* harmony default export */ var jsonp_timeline = (jsonp_timeline_jsonp);\n\n// CONCATENATED MODULE: ./src/core/transports/url_schemes.ts\n\nfunction getGenericURL(baseScheme, params, path) {\n    var scheme = baseScheme + (params.useTLS ? 's' : '');\n    var host = params.useTLS ? params.hostTLS : params.hostNonTLS;\n    return scheme + '://' + host + path;\n}\nfunction getGenericPath(key, queryString) {\n    var path = '/app/' + key;\n    var query = '?protocol=' +\n        defaults.PROTOCOL +\n        '&client=js' +\n        '&version=' +\n        defaults.VERSION +\n        (queryString ? '&' + queryString : '');\n    return path + query;\n}\nvar ws = {\n    getInitial: function (key, params) {\n        var path = (params.httpPath || '') + getGenericPath(key, 'flash=false');\n        return getGenericURL('ws', params, path);\n    }\n};\nvar http = {\n    getInitial: function (key, params) {\n        var path = (params.httpPath || '/pusher') + getGenericPath(key);\n        return getGenericURL('http', params, path);\n    }\n};\nvar sockjs = {\n    getInitial: function (key, params) {\n        return getGenericURL('http', params, params.httpPath || '/pusher');\n    },\n    getPath: function (key, params) {\n        return getGenericPath(key);\n    }\n};\n\n// CONCATENATED MODULE: ./src/core/events/callback_registry.ts\n\nvar callback_registry_CallbackRegistry = (function () {\n    function CallbackRegistry() {\n        this._callbacks = {};\n    }\n    CallbackRegistry.prototype.get = function (name) {\n        return this._callbacks[prefix(name)];\n    };\n    CallbackRegistry.prototype.add = function (name, callback, context) {\n        var prefixedEventName = prefix(name);\n        this._callbacks[prefixedEventName] =\n            this._callbacks[prefixedEventName] || [];\n        this._callbacks[prefixedEventName].push({\n            fn: callback,\n            context: context\n        });\n    };\n    CallbackRegistry.prototype.remove = function (name, callback, context) {\n        if (!name && !callback && !context) {\n            this._callbacks = {};\n            return;\n        }\n        var names = name ? [prefix(name)] : keys(this._callbacks);\n        if (callback || context) {\n            this.removeCallback(names, callback, context);\n        }\n        else {\n            this.removeAllCallbacks(names);\n        }\n    };\n    CallbackRegistry.prototype.removeCallback = function (names, callback, context) {\n        apply(names, function (name) {\n            this._callbacks[name] = filter(this._callbacks[name] || [], function (binding) {\n                return ((callback && callback !== binding.fn) ||\n                    (context && context !== binding.context));\n            });\n            if (this._callbacks[name].length === 0) {\n                delete this._callbacks[name];\n            }\n        }, this);\n    };\n    CallbackRegistry.prototype.removeAllCallbacks = function (names) {\n        apply(names, function (name) {\n            delete this._callbacks[name];\n        }, this);\n    };\n    return CallbackRegistry;\n}());\n/* harmony default export */ var callback_registry = (callback_registry_CallbackRegistry);\nfunction prefix(name) {\n    return '_' + name;\n}\n\n// CONCATENATED MODULE: ./src/core/events/dispatcher.ts\n\n\nvar dispatcher_Dispatcher = (function () {\n    function Dispatcher(failThrough) {\n        this.callbacks = new callback_registry();\n        this.global_callbacks = [];\n        this.failThrough = failThrough;\n    }\n    Dispatcher.prototype.bind = function (eventName, callback, context) {\n        this.callbacks.add(eventName, callback, context);\n        return this;\n    };\n    Dispatcher.prototype.bind_global = function (callback) {\n        this.global_callbacks.push(callback);\n        return this;\n    };\n    Dispatcher.prototype.unbind = function (eventName, callback, context) {\n        this.callbacks.remove(eventName, callback, context);\n        return this;\n    };\n    Dispatcher.prototype.unbind_global = function (callback) {\n        if (!callback) {\n            this.global_callbacks = [];\n            return this;\n        }\n        this.global_callbacks = filter(this.global_callbacks || [], function (c) { return c !== callback; });\n        return this;\n    };\n    Dispatcher.prototype.unbind_all = function () {\n        this.unbind();\n        this.unbind_global();\n        return this;\n    };\n    Dispatcher.prototype.emit = function (eventName, data, metadata) {\n        for (var i = 0; i < this.global_callbacks.length; i++) {\n            this.global_callbacks[i](eventName, data);\n        }\n        var callbacks = this.callbacks.get(eventName);\n        var args = [];\n        if (metadata) {\n            args.push(data, metadata);\n        }\n        else if (data) {\n            args.push(data);\n        }\n        if (callbacks && callbacks.length > 0) {\n            for (var i = 0; i < callbacks.length; i++) {\n                callbacks[i].fn.apply(callbacks[i].context || window, args);\n            }\n        }\n        else if (this.failThrough) {\n            this.failThrough(eventName, data);\n        }\n        return this;\n    };\n    return Dispatcher;\n}());\n/* harmony default export */ var dispatcher = (dispatcher_Dispatcher);\n\n// CONCATENATED MODULE: ./src/core/transports/transport_connection.ts\nvar transport_connection_extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\nvar transport_connection_TransportConnection = (function (_super) {\n    transport_connection_extends(TransportConnection, _super);\n    function TransportConnection(hooks, name, priority, key, options) {\n        var _this = _super.call(this) || this;\n        _this.initialize = runtime.transportConnectionInitializer;\n        _this.hooks = hooks;\n        _this.name = name;\n        _this.priority = priority;\n        _this.key = key;\n        _this.options = options;\n        _this.state = 'new';\n        _this.timeline = options.timeline;\n        _this.activityTimeout = options.activityTimeout;\n        _this.id = _this.timeline.generateUniqueID();\n        return _this;\n    }\n    TransportConnection.prototype.handlesActivityChecks = function () {\n        return Boolean(this.hooks.handlesActivityChecks);\n    };\n    TransportConnection.prototype.supportsPing = function () {\n        return Boolean(this.hooks.supportsPing);\n    };\n    TransportConnection.prototype.connect = function () {\n        var _this = this;\n        if (this.socket || this.state !== 'initialized') {\n            return false;\n        }\n        var url = this.hooks.urls.getInitial(this.key, this.options);\n        try {\n            this.socket = this.hooks.getSocket(url, this.options);\n        }\n        catch (e) {\n            util.defer(function () {\n                _this.onError(e);\n                _this.changeState('closed');\n            });\n            return false;\n        }\n        this.bindListeners();\n        logger.debug('Connecting', { transport: this.name, url: url });\n        this.changeState('connecting');\n        return true;\n    };\n    TransportConnection.prototype.close = function () {\n        if (this.socket) {\n            this.socket.close();\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    TransportConnection.prototype.send = function (data) {\n        var _this = this;\n        if (this.state === 'open') {\n            util.defer(function () {\n                if (_this.socket) {\n                    _this.socket.send(data);\n                }\n            });\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    TransportConnection.prototype.ping = function () {\n        if (this.state === 'open' && this.supportsPing()) {\n            this.socket.ping();\n        }\n    };\n    TransportConnection.prototype.onOpen = function () {\n        if (this.hooks.beforeOpen) {\n            this.hooks.beforeOpen(this.socket, this.hooks.urls.getPath(this.key, this.options));\n        }\n        this.changeState('open');\n        this.socket.onopen = undefined;\n    };\n    TransportConnection.prototype.onError = function (error) {\n        this.emit('error', { type: 'WebSocketError', error: error });\n        this.timeline.error(this.buildTimelineMessage({ error: error.toString() }));\n    };\n    TransportConnection.prototype.onClose = function (closeEvent) {\n        if (closeEvent) {\n            this.changeState('closed', {\n                code: closeEvent.code,\n                reason: closeEvent.reason,\n                wasClean: closeEvent.wasClean\n            });\n        }\n        else {\n            this.changeState('closed');\n        }\n        this.unbindListeners();\n        this.socket = undefined;\n    };\n    TransportConnection.prototype.onMessage = function (message) {\n        this.emit('message', message);\n    };\n    TransportConnection.prototype.onActivity = function () {\n        this.emit('activity');\n    };\n    TransportConnection.prototype.bindListeners = function () {\n        var _this = this;\n        this.socket.onopen = function () {\n            _this.onOpen();\n        };\n        this.socket.onerror = function (error) {\n            _this.onError(error);\n        };\n        this.socket.onclose = function (closeEvent) {\n            _this.onClose(closeEvent);\n        };\n        this.socket.onmessage = function (message) {\n            _this.onMessage(message);\n        };\n        if (this.supportsPing()) {\n            this.socket.onactivity = function () {\n                _this.onActivity();\n            };\n        }\n    };\n    TransportConnection.prototype.unbindListeners = function () {\n        if (this.socket) {\n            this.socket.onopen = undefined;\n            this.socket.onerror = undefined;\n            this.socket.onclose = undefined;\n            this.socket.onmessage = undefined;\n            if (this.supportsPing()) {\n                this.socket.onactivity = undefined;\n            }\n        }\n    };\n    TransportConnection.prototype.changeState = function (state, params) {\n        this.state = state;\n        this.timeline.info(this.buildTimelineMessage({\n            state: state,\n            params: params\n        }));\n        this.emit(state, params);\n    };\n    TransportConnection.prototype.buildTimelineMessage = function (message) {\n        return extend({ cid: this.id }, message);\n    };\n    return TransportConnection;\n}(dispatcher));\n/* harmony default export */ var transport_connection = (transport_connection_TransportConnection);\n\n// CONCATENATED MODULE: ./src/core/transports/transport.ts\n\nvar transport_Transport = (function () {\n    function Transport(hooks) {\n        this.hooks = hooks;\n    }\n    Transport.prototype.isSupported = function (environment) {\n        return this.hooks.isSupported(environment);\n    };\n    Transport.prototype.createConnection = function (name, priority, key, options) {\n        return new transport_connection(this.hooks, name, priority, key, options);\n    };\n    return Transport;\n}());\n/* harmony default export */ var transports_transport = (transport_Transport);\n\n// CONCATENATED MODULE: ./src/runtimes/isomorphic/transports/transports.ts\n\n\n\n\nvar WSTransport = new transports_transport({\n    urls: ws,\n    handlesActivityChecks: false,\n    supportsPing: false,\n    isInitialized: function () {\n        return Boolean(runtime.getWebSocketAPI());\n    },\n    isSupported: function () {\n        return Boolean(runtime.getWebSocketAPI());\n    },\n    getSocket: function (url) {\n        return runtime.createWebSocket(url);\n    }\n});\nvar httpConfiguration = {\n    urls: http,\n    handlesActivityChecks: false,\n    supportsPing: true,\n    isInitialized: function () {\n        return true;\n    }\n};\nvar streamingConfiguration = extend({\n    getSocket: function (url) {\n        return runtime.HTTPFactory.createStreamingSocket(url);\n    }\n}, httpConfiguration);\nvar pollingConfiguration = extend({\n    getSocket: function (url) {\n        return runtime.HTTPFactory.createPollingSocket(url);\n    }\n}, httpConfiguration);\nvar xhrConfiguration = {\n    isSupported: function () {\n        return runtime.isXHRSupported();\n    }\n};\nvar XHRStreamingTransport = new transports_transport((extend({}, streamingConfiguration, xhrConfiguration)));\nvar XHRPollingTransport = new transports_transport(extend({}, pollingConfiguration, xhrConfiguration));\nvar Transports = {\n    ws: WSTransport,\n    xhr_streaming: XHRStreamingTransport,\n    xhr_polling: XHRPollingTransport\n};\n/* harmony default export */ var transports = (Transports);\n\n// CONCATENATED MODULE: ./src/runtimes/web/transports/transports.ts\n\n\n\n\n\n\nvar SockJSTransport = new transports_transport({\n    file: 'sockjs',\n    urls: sockjs,\n    handlesActivityChecks: true,\n    supportsPing: false,\n    isSupported: function () {\n        return true;\n    },\n    isInitialized: function () {\n        return window.SockJS !== undefined;\n    },\n    getSocket: function (url, options) {\n        return new window.SockJS(url, null, {\n            js_path: Dependencies.getPath('sockjs', {\n                useTLS: options.useTLS\n            }),\n            ignore_null_origin: options.ignoreNullOrigin\n        });\n    },\n    beforeOpen: function (socket, path) {\n        socket.send(JSON.stringify({\n            path: path\n        }));\n    }\n});\nvar xdrConfiguration = {\n    isSupported: function (environment) {\n        var yes = runtime.isXDRSupported(environment.useTLS);\n        return yes;\n    }\n};\nvar XDRStreamingTransport = new transports_transport((extend({}, streamingConfiguration, xdrConfiguration)));\nvar XDRPollingTransport = new transports_transport(extend({}, pollingConfiguration, xdrConfiguration));\ntransports.xdr_streaming = XDRStreamingTransport;\ntransports.xdr_polling = XDRPollingTransport;\ntransports.sockjs = SockJSTransport;\n/* harmony default export */ var transports_transports = (transports);\n\n// CONCATENATED MODULE: ./src/runtimes/web/net_info.ts\nvar net_info_extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\nvar NetInfo = (function (_super) {\n    net_info_extends(NetInfo, _super);\n    function NetInfo() {\n        var _this = _super.call(this) || this;\n        var self = _this;\n        if (window.addEventListener !== undefined) {\n            window.addEventListener('online', function () {\n                self.emit('online');\n            }, false);\n            window.addEventListener('offline', function () {\n                self.emit('offline');\n            }, false);\n        }\n        return _this;\n    }\n    NetInfo.prototype.isOnline = function () {\n        if (window.navigator.onLine === undefined) {\n            return true;\n        }\n        else {\n            return window.navigator.onLine;\n        }\n    };\n    return NetInfo;\n}(dispatcher));\n\nvar net_info_Network = new NetInfo();\n\n// CONCATENATED MODULE: ./src/core/transports/assistant_to_the_transport_manager.ts\n\n\nvar assistant_to_the_transport_manager_AssistantToTheTransportManager = (function () {\n    function AssistantToTheTransportManager(manager, transport, options) {\n        this.manager = manager;\n        this.transport = transport;\n        this.minPingDelay = options.minPingDelay;\n        this.maxPingDelay = options.maxPingDelay;\n        this.pingDelay = undefined;\n    }\n    AssistantToTheTransportManager.prototype.createConnection = function (name, priority, key, options) {\n        var _this = this;\n        options = extend({}, options, {\n            activityTimeout: this.pingDelay\n        });\n        var connection = this.transport.createConnection(name, priority, key, options);\n        var openTimestamp = null;\n        var onOpen = function () {\n            connection.unbind('open', onOpen);\n            connection.bind('closed', onClosed);\n            openTimestamp = util.now();\n        };\n        var onClosed = function (closeEvent) {\n            connection.unbind('closed', onClosed);\n            if (closeEvent.code === 1002 || closeEvent.code === 1003) {\n                _this.manager.reportDeath();\n            }\n            else if (!closeEvent.wasClean && openTimestamp) {\n                var lifespan = util.now() - openTimestamp;\n                if (lifespan < 2 * _this.maxPingDelay) {\n                    _this.manager.reportDeath();\n                    _this.pingDelay = Math.max(lifespan / 2, _this.minPingDelay);\n                }\n            }\n        };\n        connection.bind('open', onOpen);\n        return connection;\n    };\n    AssistantToTheTransportManager.prototype.isSupported = function (environment) {\n        return this.manager.isAlive() && this.transport.isSupported(environment);\n    };\n    return AssistantToTheTransportManager;\n}());\n/* harmony default export */ var assistant_to_the_transport_manager = (assistant_to_the_transport_manager_AssistantToTheTransportManager);\n\n// CONCATENATED MODULE: ./src/core/connection/protocol/protocol.ts\nvar Protocol = {\n    decodeMessage: function (messageEvent) {\n        try {\n            var messageData = JSON.parse(messageEvent.data);\n            var pusherEventData = messageData.data;\n            if (typeof pusherEventData === 'string') {\n                try {\n                    pusherEventData = JSON.parse(messageData.data);\n                }\n                catch (e) { }\n            }\n            var pusherEvent = {\n                event: messageData.event,\n                channel: messageData.channel,\n                data: pusherEventData\n            };\n            if (messageData.user_id) {\n                pusherEvent.user_id = messageData.user_id;\n            }\n            return pusherEvent;\n        }\n        catch (e) {\n            throw { type: 'MessageParseError', error: e, data: messageEvent.data };\n        }\n    },\n    encodeMessage: function (event) {\n        return JSON.stringify(event);\n    },\n    processHandshake: function (messageEvent) {\n        var message = Protocol.decodeMessage(messageEvent);\n        if (message.event === 'pusher:connection_established') {\n            if (!message.data.activity_timeout) {\n                throw 'No activity timeout specified in handshake';\n            }\n            return {\n                action: 'connected',\n                id: message.data.socket_id,\n                activityTimeout: message.data.activity_timeout * 1000\n            };\n        }\n        else if (message.event === 'pusher:error') {\n            return {\n                action: this.getCloseAction(message.data),\n                error: this.getCloseError(message.data)\n            };\n        }\n        else {\n            throw 'Invalid handshake';\n        }\n    },\n    getCloseAction: function (closeEvent) {\n        if (closeEvent.code < 4000) {\n            if (closeEvent.code >= 1002 && closeEvent.code <= 1004) {\n                return 'backoff';\n            }\n            else {\n                return null;\n            }\n        }\n        else if (closeEvent.code === 4000) {\n            return 'tls_only';\n        }\n        else if (closeEvent.code < 4100) {\n            return 'refused';\n        }\n        else if (closeEvent.code < 4200) {\n            return 'backoff';\n        }\n        else if (closeEvent.code < 4300) {\n            return 'retry';\n        }\n        else {\n            return 'refused';\n        }\n    },\n    getCloseError: function (closeEvent) {\n        if (closeEvent.code !== 1000 && closeEvent.code !== 1001) {\n            return {\n                type: 'PusherError',\n                data: {\n                    code: closeEvent.code,\n                    message: closeEvent.reason || closeEvent.message\n                }\n            };\n        }\n        else {\n            return null;\n        }\n    }\n};\n/* harmony default export */ var protocol_protocol = (Protocol);\n\n// CONCATENATED MODULE: ./src/core/connection/connection.ts\nvar connection_extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\nvar connection_Connection = (function (_super) {\n    connection_extends(Connection, _super);\n    function Connection(id, transport) {\n        var _this = _super.call(this) || this;\n        _this.id = id;\n        _this.transport = transport;\n        _this.activityTimeout = transport.activityTimeout;\n        _this.bindListeners();\n        return _this;\n    }\n    Connection.prototype.handlesActivityChecks = function () {\n        return this.transport.handlesActivityChecks();\n    };\n    Connection.prototype.send = function (data) {\n        return this.transport.send(data);\n    };\n    Connection.prototype.send_event = function (name, data, channel) {\n        var event = { event: name, data: data };\n        if (channel) {\n            event.channel = channel;\n        }\n        logger.debug('Event sent', event);\n        return this.send(protocol_protocol.encodeMessage(event));\n    };\n    Connection.prototype.ping = function () {\n        if (this.transport.supportsPing()) {\n            this.transport.ping();\n        }\n        else {\n            this.send_event('pusher:ping', {});\n        }\n    };\n    Connection.prototype.close = function () {\n        this.transport.close();\n    };\n    Connection.prototype.bindListeners = function () {\n        var _this = this;\n        var listeners = {\n            message: function (messageEvent) {\n                var pusherEvent;\n                try {\n                    pusherEvent = protocol_protocol.decodeMessage(messageEvent);\n                }\n                catch (e) {\n                    _this.emit('error', {\n                        type: 'MessageParseError',\n                        error: e,\n                        data: messageEvent.data\n                    });\n                }\n                if (pusherEvent !== undefined) {\n                    logger.debug('Event recd', pusherEvent);\n                    switch (pusherEvent.event) {\n                        case 'pusher:error':\n                            _this.emit('error', {\n                                type: 'PusherError',\n                                data: pusherEvent.data\n                            });\n                            break;\n                        case 'pusher:ping':\n                            _this.emit('ping');\n                            break;\n                        case 'pusher:pong':\n                            _this.emit('pong');\n                            break;\n                    }\n                    _this.emit('message', pusherEvent);\n                }\n            },\n            activity: function () {\n                _this.emit('activity');\n            },\n            error: function (error) {\n                _this.emit('error', error);\n            },\n            closed: function (closeEvent) {\n                unbindListeners();\n                if (closeEvent && closeEvent.code) {\n                    _this.handleCloseEvent(closeEvent);\n                }\n                _this.transport = null;\n                _this.emit('closed');\n            }\n        };\n        var unbindListeners = function () {\n            objectApply(listeners, function (listener, event) {\n                _this.transport.unbind(event, listener);\n            });\n        };\n        objectApply(listeners, function (listener, event) {\n            _this.transport.bind(event, listener);\n        });\n    };\n    Connection.prototype.handleCloseEvent = function (closeEvent) {\n        var action = protocol_protocol.getCloseAction(closeEvent);\n        var error = protocol_protocol.getCloseError(closeEvent);\n        if (error) {\n            this.emit('error', error);\n        }\n        if (action) {\n            this.emit(action, { action: action, error: error });\n        }\n    };\n    return Connection;\n}(dispatcher));\n/* harmony default export */ var connection_connection = (connection_Connection);\n\n// CONCATENATED MODULE: ./src/core/connection/handshake/index.ts\n\n\n\nvar handshake_Handshake = (function () {\n    function Handshake(transport, callback) {\n        this.transport = transport;\n        this.callback = callback;\n        this.bindListeners();\n    }\n    Handshake.prototype.close = function () {\n        this.unbindListeners();\n        this.transport.close();\n    };\n    Handshake.prototype.bindListeners = function () {\n        var _this = this;\n        this.onMessage = function (m) {\n            _this.unbindListeners();\n            var result;\n            try {\n                result = protocol_protocol.processHandshake(m);\n            }\n            catch (e) {\n                _this.finish('error', { error: e });\n                _this.transport.close();\n                return;\n            }\n            if (result.action === 'connected') {\n                _this.finish('connected', {\n                    connection: new connection_connection(result.id, _this.transport),\n                    activityTimeout: result.activityTimeout\n                });\n            }\n            else {\n                _this.finish(result.action, { error: result.error });\n                _this.transport.close();\n            }\n        };\n        this.onClosed = function (closeEvent) {\n            _this.unbindListeners();\n            var action = protocol_protocol.getCloseAction(closeEvent) || 'backoff';\n            var error = protocol_protocol.getCloseError(closeEvent);\n            _this.finish(action, { error: error });\n        };\n        this.transport.bind('message', this.onMessage);\n        this.transport.bind('closed', this.onClosed);\n    };\n    Handshake.prototype.unbindListeners = function () {\n        this.transport.unbind('message', this.onMessage);\n        this.transport.unbind('closed', this.onClosed);\n    };\n    Handshake.prototype.finish = function (action, params) {\n        this.callback(extend({ transport: this.transport, action: action }, params));\n    };\n    return Handshake;\n}());\n/* harmony default export */ var connection_handshake = (handshake_Handshake);\n\n// CONCATENATED MODULE: ./src/core/timeline/timeline_sender.ts\n\nvar timeline_sender_TimelineSender = (function () {\n    function TimelineSender(timeline, options) {\n        this.timeline = timeline;\n        this.options = options || {};\n    }\n    TimelineSender.prototype.send = function (useTLS, callback) {\n        if (this.timeline.isEmpty()) {\n            return;\n        }\n        this.timeline.send(runtime.TimelineTransport.getAgent(this, useTLS), callback);\n    };\n    return TimelineSender;\n}());\n/* harmony default export */ var timeline_sender = (timeline_sender_TimelineSender);\n\n// CONCATENATED MODULE: ./src/core/channels/channel.ts\nvar channel_extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\nvar channel_Channel = (function (_super) {\n    channel_extends(Channel, _super);\n    function Channel(name, pusher) {\n        var _this = _super.call(this, function (event, data) {\n            logger.debug('No callbacks on ' + name + ' for ' + event);\n        }) || this;\n        _this.name = name;\n        _this.pusher = pusher;\n        _this.subscribed = false;\n        _this.subscriptionPending = false;\n        _this.subscriptionCancelled = false;\n        return _this;\n    }\n    Channel.prototype.authorize = function (socketId, callback) {\n        return callback(null, { auth: '' });\n    };\n    Channel.prototype.trigger = function (event, data) {\n        if (event.indexOf('client-') !== 0) {\n            throw new BadEventName(\"Event '\" + event + \"' does not start with 'client-'\");\n        }\n        if (!this.subscribed) {\n            var suffix = url_store.buildLogSuffix('triggeringClientEvents');\n            logger.warn(\"Client event triggered before channel 'subscription_succeeded' event . \" + suffix);\n        }\n        return this.pusher.send_event(event, data, this.name);\n    };\n    Channel.prototype.disconnect = function () {\n        this.subscribed = false;\n        this.subscriptionPending = false;\n    };\n    Channel.prototype.handleEvent = function (event) {\n        var eventName = event.event;\n        var data = event.data;\n        if (eventName === 'pusher_internal:subscription_succeeded') {\n            this.handleSubscriptionSucceededEvent(event);\n        }\n        else if (eventName === 'pusher_internal:subscription_count') {\n            this.handleSubscriptionCountEvent(event);\n        }\n        else if (eventName.indexOf('pusher_internal:') !== 0) {\n            var metadata = {};\n            this.emit(eventName, data, metadata);\n        }\n    };\n    Channel.prototype.handleSubscriptionSucceededEvent = function (event) {\n        this.subscriptionPending = false;\n        this.subscribed = true;\n        if (this.subscriptionCancelled) {\n            this.pusher.unsubscribe(this.name);\n        }\n        else {\n            this.emit('pusher:subscription_succeeded', event.data);\n        }\n    };\n    Channel.prototype.handleSubscriptionCountEvent = function (event) {\n        if (event.data.subscription_count) {\n            this.subscriptionCount = event.data.subscription_count;\n        }\n        this.emit('pusher:subscription_count', event.data);\n    };\n    Channel.prototype.subscribe = function () {\n        var _this = this;\n        if (this.subscribed) {\n            return;\n        }\n        this.subscriptionPending = true;\n        this.subscriptionCancelled = false;\n        this.authorize(this.pusher.connection.socket_id, function (error, data) {\n            if (error) {\n                _this.subscriptionPending = false;\n                logger.error(error.toString());\n                _this.emit('pusher:subscription_error', Object.assign({}, {\n                    type: 'AuthError',\n                    error: error.message\n                }, error instanceof HTTPAuthError ? { status: error.status } : {}));\n            }\n            else {\n                _this.pusher.send_event('pusher:subscribe', {\n                    auth: data.auth,\n                    channel_data: data.channel_data,\n                    channel: _this.name\n                });\n            }\n        });\n    };\n    Channel.prototype.unsubscribe = function () {\n        this.subscribed = false;\n        this.pusher.send_event('pusher:unsubscribe', {\n            channel: this.name\n        });\n    };\n    Channel.prototype.cancelSubscription = function () {\n        this.subscriptionCancelled = true;\n    };\n    Channel.prototype.reinstateSubscription = function () {\n        this.subscriptionCancelled = false;\n    };\n    return Channel;\n}(dispatcher));\n/* harmony default export */ var channels_channel = (channel_Channel);\n\n// CONCATENATED MODULE: ./src/core/channels/private_channel.ts\nvar private_channel_extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\nvar PrivateChannel = (function (_super) {\n    private_channel_extends(PrivateChannel, _super);\n    function PrivateChannel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PrivateChannel.prototype.authorize = function (socketId, callback) {\n        return this.pusher.config.channelAuthorizer({\n            channelName: this.name,\n            socketId: socketId\n        }, callback);\n    };\n    return PrivateChannel;\n}(channels_channel));\n/* harmony default export */ var private_channel = (PrivateChannel);\n\n// CONCATENATED MODULE: ./src/core/channels/members.ts\n\nvar members_Members = (function () {\n    function Members() {\n        this.reset();\n    }\n    Members.prototype.get = function (id) {\n        if (Object.prototype.hasOwnProperty.call(this.members, id)) {\n            return {\n                id: id,\n                info: this.members[id]\n            };\n        }\n        else {\n            return null;\n        }\n    };\n    Members.prototype.each = function (callback) {\n        var _this = this;\n        objectApply(this.members, function (member, id) {\n            callback(_this.get(id));\n        });\n    };\n    Members.prototype.setMyID = function (id) {\n        this.myID = id;\n    };\n    Members.prototype.onSubscription = function (subscriptionData) {\n        this.members = subscriptionData.presence.hash;\n        this.count = subscriptionData.presence.count;\n        this.me = this.get(this.myID);\n    };\n    Members.prototype.addMember = function (memberData) {\n        if (this.get(memberData.user_id) === null) {\n            this.count++;\n        }\n        this.members[memberData.user_id] = memberData.user_info;\n        return this.get(memberData.user_id);\n    };\n    Members.prototype.removeMember = function (memberData) {\n        var member = this.get(memberData.user_id);\n        if (member) {\n            delete this.members[memberData.user_id];\n            this.count--;\n        }\n        return member;\n    };\n    Members.prototype.reset = function () {\n        this.members = {};\n        this.count = 0;\n        this.myID = null;\n        this.me = null;\n    };\n    return Members;\n}());\n/* harmony default export */ var members = (members_Members);\n\n// CONCATENATED MODULE: ./src/core/channels/presence_channel.ts\nvar presence_channel_extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = ( false) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = ( false) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\n\nvar presence_channel_PresenceChannel = (function (_super) {\n    presence_channel_extends(PresenceChannel, _super);\n    function PresenceChannel(name, pusher) {\n        var _this = _super.call(this, name, pusher) || this;\n        _this.members = new members();\n        return _this;\n    }\n    PresenceChannel.prototype.authorize = function (socketId, callback) {\n        var _this = this;\n        _super.prototype.authorize.call(this, socketId, function (error, authData) { return __awaiter(_this, void 0, void 0, function () {\n            var channelData, suffix;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!!error) return [3, 3];\n                        authData = authData;\n                        if (!(authData.channel_data != null)) return [3, 1];\n                        channelData = JSON.parse(authData.channel_data);\n                        this.members.setMyID(channelData.user_id);\n                        return [3, 3];\n                    case 1: return [4, this.pusher.user.signinDonePromise];\n                    case 2:\n                        _a.sent();\n                        if (this.pusher.user.user_data != null) {\n                            this.members.setMyID(this.pusher.user.user_data.id);\n                        }\n                        else {\n                            suffix = url_store.buildLogSuffix('authorizationEndpoint');\n                            logger.error(\"Invalid auth response for channel '\" + this.name + \"', \" +\n                                (\"expected 'channel_data' field. \" + suffix + \", \") +\n                                \"or the user should be signed in.\");\n                            callback('Invalid auth response');\n                            return [2];\n                        }\n                        _a.label = 3;\n                    case 3:\n                        callback(error, authData);\n                        return [2];\n                }\n            });\n        }); });\n    };\n    PresenceChannel.prototype.handleEvent = function (event) {\n        var eventName = event.event;\n        if (eventName.indexOf('pusher_internal:') === 0) {\n            this.handleInternalEvent(event);\n        }\n        else {\n            var data = event.data;\n            var metadata = {};\n            if (event.user_id) {\n                metadata.user_id = event.user_id;\n            }\n            this.emit(eventName, data, metadata);\n        }\n    };\n    PresenceChannel.prototype.handleInternalEvent = function (event) {\n        var eventName = event.event;\n        var data = event.data;\n        switch (eventName) {\n            case 'pusher_internal:subscription_succeeded':\n                this.handleSubscriptionSucceededEvent(event);\n                break;\n            case 'pusher_internal:subscription_count':\n                this.handleSubscriptionCountEvent(event);\n                break;\n            case 'pusher_internal:member_added':\n                var addedMember = this.members.addMember(data);\n                this.emit('pusher:member_added', addedMember);\n                break;\n            case 'pusher_internal:member_removed':\n                var removedMember = this.members.removeMember(data);\n                if (removedMember) {\n                    this.emit('pusher:member_removed', removedMember);\n                }\n                break;\n        }\n    };\n    PresenceChannel.prototype.handleSubscriptionSucceededEvent = function (event) {\n        this.subscriptionPending = false;\n        this.subscribed = true;\n        if (this.subscriptionCancelled) {\n            this.pusher.unsubscribe(this.name);\n        }\n        else {\n            this.members.onSubscription(event.data);\n            this.emit('pusher:subscription_succeeded', this.members);\n        }\n    };\n    PresenceChannel.prototype.disconnect = function () {\n        this.members.reset();\n        _super.prototype.disconnect.call(this);\n    };\n    return PresenceChannel;\n}(private_channel));\n/* harmony default export */ var presence_channel = (presence_channel_PresenceChannel);\n\n// EXTERNAL MODULE: ./node_modules/@stablelib/utf8/lib/utf8.js\nvar utf8 = __nested_webpack_require_20105__(1);\n\n// EXTERNAL MODULE: ./node_modules/@stablelib/base64/lib/base64.js\nvar base64 = __nested_webpack_require_20105__(0);\n\n// CONCATENATED MODULE: ./src/core/channels/encrypted_channel.ts\nvar encrypted_channel_extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\nvar encrypted_channel_EncryptedChannel = (function (_super) {\n    encrypted_channel_extends(EncryptedChannel, _super);\n    function EncryptedChannel(name, pusher, nacl) {\n        var _this = _super.call(this, name, pusher) || this;\n        _this.key = null;\n        _this.nacl = nacl;\n        return _this;\n    }\n    EncryptedChannel.prototype.authorize = function (socketId, callback) {\n        var _this = this;\n        _super.prototype.authorize.call(this, socketId, function (error, authData) {\n            if (error) {\n                callback(error, authData);\n                return;\n            }\n            var sharedSecret = authData['shared_secret'];\n            if (!sharedSecret) {\n                callback(new Error(\"No shared_secret key in auth payload for encrypted channel: \" + _this.name), null);\n                return;\n            }\n            _this.key = Object(base64[\"decode\"])(sharedSecret);\n            delete authData['shared_secret'];\n            callback(null, authData);\n        });\n    };\n    EncryptedChannel.prototype.trigger = function (event, data) {\n        throw new UnsupportedFeature('Client events are not currently supported for encrypted channels');\n    };\n    EncryptedChannel.prototype.handleEvent = function (event) {\n        var eventName = event.event;\n        var data = event.data;\n        if (eventName.indexOf('pusher_internal:') === 0 ||\n            eventName.indexOf('pusher:') === 0) {\n            _super.prototype.handleEvent.call(this, event);\n            return;\n        }\n        this.handleEncryptedEvent(eventName, data);\n    };\n    EncryptedChannel.prototype.handleEncryptedEvent = function (event, data) {\n        var _this = this;\n        if (!this.key) {\n            logger.debug('Received encrypted event before key has been retrieved from the authEndpoint');\n            return;\n        }\n        if (!data.ciphertext || !data.nonce) {\n            logger.error('Unexpected format for encrypted event, expected object with `ciphertext` and `nonce` fields, got: ' +\n                data);\n            return;\n        }\n        var cipherText = Object(base64[\"decode\"])(data.ciphertext);\n        if (cipherText.length < this.nacl.secretbox.overheadLength) {\n            logger.error(\"Expected encrypted event ciphertext length to be \" + this.nacl.secretbox.overheadLength + \", got: \" + cipherText.length);\n            return;\n        }\n        var nonce = Object(base64[\"decode\"])(data.nonce);\n        if (nonce.length < this.nacl.secretbox.nonceLength) {\n            logger.error(\"Expected encrypted event nonce length to be \" + this.nacl.secretbox.nonceLength + \", got: \" + nonce.length);\n            return;\n        }\n        var bytes = this.nacl.secretbox.open(cipherText, nonce, this.key);\n        if (bytes === null) {\n            logger.debug('Failed to decrypt an event, probably because it was encrypted with a different key. Fetching a new key from the authEndpoint...');\n            this.authorize(this.pusher.connection.socket_id, function (error, authData) {\n                if (error) {\n                    logger.error(\"Failed to make a request to the authEndpoint: \" + authData + \". Unable to fetch new key, so dropping encrypted event\");\n                    return;\n                }\n                bytes = _this.nacl.secretbox.open(cipherText, nonce, _this.key);\n                if (bytes === null) {\n                    logger.error(\"Failed to decrypt event with new key. Dropping encrypted event\");\n                    return;\n                }\n                _this.emit(event, _this.getDataToEmit(bytes));\n                return;\n            });\n            return;\n        }\n        this.emit(event, this.getDataToEmit(bytes));\n    };\n    EncryptedChannel.prototype.getDataToEmit = function (bytes) {\n        var raw = Object(utf8[\"decode\"])(bytes);\n        try {\n            return JSON.parse(raw);\n        }\n        catch (_a) {\n            return raw;\n        }\n    };\n    return EncryptedChannel;\n}(private_channel));\n/* harmony default export */ var encrypted_channel = (encrypted_channel_EncryptedChannel);\n\n// CONCATENATED MODULE: ./src/core/connection/connection_manager.ts\nvar connection_manager_extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\nvar connection_manager_ConnectionManager = (function (_super) {\n    connection_manager_extends(ConnectionManager, _super);\n    function ConnectionManager(key, options) {\n        var _this = _super.call(this) || this;\n        _this.state = 'initialized';\n        _this.connection = null;\n        _this.key = key;\n        _this.options = options;\n        _this.timeline = _this.options.timeline;\n        _this.usingTLS = _this.options.useTLS;\n        _this.errorCallbacks = _this.buildErrorCallbacks();\n        _this.connectionCallbacks = _this.buildConnectionCallbacks(_this.errorCallbacks);\n        _this.handshakeCallbacks = _this.buildHandshakeCallbacks(_this.errorCallbacks);\n        var Network = runtime.getNetwork();\n        Network.bind('online', function () {\n            _this.timeline.info({ netinfo: 'online' });\n            if (_this.state === 'connecting' || _this.state === 'unavailable') {\n                _this.retryIn(0);\n            }\n        });\n        Network.bind('offline', function () {\n            _this.timeline.info({ netinfo: 'offline' });\n            if (_this.connection) {\n                _this.sendActivityCheck();\n            }\n        });\n        _this.updateStrategy();\n        return _this;\n    }\n    ConnectionManager.prototype.connect = function () {\n        if (this.connection || this.runner) {\n            return;\n        }\n        if (!this.strategy.isSupported()) {\n            this.updateState('failed');\n            return;\n        }\n        this.updateState('connecting');\n        this.startConnecting();\n        this.setUnavailableTimer();\n    };\n    ConnectionManager.prototype.send = function (data) {\n        if (this.connection) {\n            return this.connection.send(data);\n        }\n        else {\n            return false;\n        }\n    };\n    ConnectionManager.prototype.send_event = function (name, data, channel) {\n        if (this.connection) {\n            return this.connection.send_event(name, data, channel);\n        }\n        else {\n            return false;\n        }\n    };\n    ConnectionManager.prototype.disconnect = function () {\n        this.disconnectInternally();\n        this.updateState('disconnected');\n    };\n    ConnectionManager.prototype.isUsingTLS = function () {\n        return this.usingTLS;\n    };\n    ConnectionManager.prototype.startConnecting = function () {\n        var _this = this;\n        var callback = function (error, handshake) {\n            if (error) {\n                _this.runner = _this.strategy.connect(0, callback);\n            }\n            else {\n                if (handshake.action === 'error') {\n                    _this.emit('error', {\n                        type: 'HandshakeError',\n                        error: handshake.error\n                    });\n                    _this.timeline.error({ handshakeError: handshake.error });\n                }\n                else {\n                    _this.abortConnecting();\n                    _this.handshakeCallbacks[handshake.action](handshake);\n                }\n            }\n        };\n        this.runner = this.strategy.connect(0, callback);\n    };\n    ConnectionManager.prototype.abortConnecting = function () {\n        if (this.runner) {\n            this.runner.abort();\n            this.runner = null;\n        }\n    };\n    ConnectionManager.prototype.disconnectInternally = function () {\n        this.abortConnecting();\n        this.clearRetryTimer();\n        this.clearUnavailableTimer();\n        if (this.connection) {\n            var connection = this.abandonConnection();\n            connection.close();\n        }\n    };\n    ConnectionManager.prototype.updateStrategy = function () {\n        this.strategy = this.options.getStrategy({\n            key: this.key,\n            timeline: this.timeline,\n            useTLS: this.usingTLS\n        });\n    };\n    ConnectionManager.prototype.retryIn = function (delay) {\n        var _this = this;\n        this.timeline.info({ action: 'retry', delay: delay });\n        if (delay > 0) {\n            this.emit('connecting_in', Math.round(delay / 1000));\n        }\n        this.retryTimer = new OneOffTimer(delay || 0, function () {\n            _this.disconnectInternally();\n            _this.connect();\n        });\n    };\n    ConnectionManager.prototype.clearRetryTimer = function () {\n        if (this.retryTimer) {\n            this.retryTimer.ensureAborted();\n            this.retryTimer = null;\n        }\n    };\n    ConnectionManager.prototype.setUnavailableTimer = function () {\n        var _this = this;\n        this.unavailableTimer = new OneOffTimer(this.options.unavailableTimeout, function () {\n            _this.updateState('unavailable');\n        });\n    };\n    ConnectionManager.prototype.clearUnavailableTimer = function () {\n        if (this.unavailableTimer) {\n            this.unavailableTimer.ensureAborted();\n        }\n    };\n    ConnectionManager.prototype.sendActivityCheck = function () {\n        var _this = this;\n        this.stopActivityCheck();\n        this.connection.ping();\n        this.activityTimer = new OneOffTimer(this.options.pongTimeout, function () {\n            _this.timeline.error({ pong_timed_out: _this.options.pongTimeout });\n            _this.retryIn(0);\n        });\n    };\n    ConnectionManager.prototype.resetActivityCheck = function () {\n        var _this = this;\n        this.stopActivityCheck();\n        if (this.connection && !this.connection.handlesActivityChecks()) {\n            this.activityTimer = new OneOffTimer(this.activityTimeout, function () {\n                _this.sendActivityCheck();\n            });\n        }\n    };\n    ConnectionManager.prototype.stopActivityCheck = function () {\n        if (this.activityTimer) {\n            this.activityTimer.ensureAborted();\n        }\n    };\n    ConnectionManager.prototype.buildConnectionCallbacks = function (errorCallbacks) {\n        var _this = this;\n        return extend({}, errorCallbacks, {\n            message: function (message) {\n                _this.resetActivityCheck();\n                _this.emit('message', message);\n            },\n            ping: function () {\n                _this.send_event('pusher:pong', {});\n            },\n            activity: function () {\n                _this.resetActivityCheck();\n            },\n            error: function (error) {\n                _this.emit('error', error);\n            },\n            closed: function () {\n                _this.abandonConnection();\n                if (_this.shouldRetry()) {\n                    _this.retryIn(1000);\n                }\n            }\n        });\n    };\n    ConnectionManager.prototype.buildHandshakeCallbacks = function (errorCallbacks) {\n        var _this = this;\n        return extend({}, errorCallbacks, {\n            connected: function (handshake) {\n                _this.activityTimeout = Math.min(_this.options.activityTimeout, handshake.activityTimeout, handshake.connection.activityTimeout || Infinity);\n                _this.clearUnavailableTimer();\n                _this.setConnection(handshake.connection);\n                _this.socket_id = _this.connection.id;\n                _this.updateState('connected', { socket_id: _this.socket_id });\n            }\n        });\n    };\n    ConnectionManager.prototype.buildErrorCallbacks = function () {\n        var _this = this;\n        var withErrorEmitted = function (callback) {\n            return function (result) {\n                if (result.error) {\n                    _this.emit('error', { type: 'WebSocketError', error: result.error });\n                }\n                callback(result);\n            };\n        };\n        return {\n            tls_only: withErrorEmitted(function () {\n                _this.usingTLS = true;\n                _this.updateStrategy();\n                _this.retryIn(0);\n            }),\n            refused: withErrorEmitted(function () {\n                _this.disconnect();\n            }),\n            backoff: withErrorEmitted(function () {\n                _this.retryIn(1000);\n            }),\n            retry: withErrorEmitted(function () {\n                _this.retryIn(0);\n            })\n        };\n    };\n    ConnectionManager.prototype.setConnection = function (connection) {\n        this.connection = connection;\n        for (var event in this.connectionCallbacks) {\n            this.connection.bind(event, this.connectionCallbacks[event]);\n        }\n        this.resetActivityCheck();\n    };\n    ConnectionManager.prototype.abandonConnection = function () {\n        if (!this.connection) {\n            return;\n        }\n        this.stopActivityCheck();\n        for (var event in this.connectionCallbacks) {\n            this.connection.unbind(event, this.connectionCallbacks[event]);\n        }\n        var connection = this.connection;\n        this.connection = null;\n        return connection;\n    };\n    ConnectionManager.prototype.updateState = function (newState, data) {\n        var previousState = this.state;\n        this.state = newState;\n        if (previousState !== newState) {\n            var newStateDescription = newState;\n            if (newStateDescription === 'connected') {\n                newStateDescription += ' with new socket ID ' + data.socket_id;\n            }\n            logger.debug('State changed', previousState + ' -> ' + newStateDescription);\n            this.timeline.info({ state: newState, params: data });\n            this.emit('state_change', { previous: previousState, current: newState });\n            this.emit(newState, data);\n        }\n    };\n    ConnectionManager.prototype.shouldRetry = function () {\n        return this.state === 'connecting' || this.state === 'connected';\n    };\n    return ConnectionManager;\n}(dispatcher));\n/* harmony default export */ var connection_manager = (connection_manager_ConnectionManager);\n\n// CONCATENATED MODULE: ./src/core/channels/channels.ts\n\n\n\n\nvar channels_Channels = (function () {\n    function Channels() {\n        this.channels = {};\n    }\n    Channels.prototype.add = function (name, pusher) {\n        if (!this.channels[name]) {\n            this.channels[name] = createChannel(name, pusher);\n        }\n        return this.channels[name];\n    };\n    Channels.prototype.all = function () {\n        return values(this.channels);\n    };\n    Channels.prototype.find = function (name) {\n        return this.channels[name];\n    };\n    Channels.prototype.remove = function (name) {\n        var channel = this.channels[name];\n        delete this.channels[name];\n        return channel;\n    };\n    Channels.prototype.disconnect = function () {\n        objectApply(this.channels, function (channel) {\n            channel.disconnect();\n        });\n    };\n    return Channels;\n}());\n/* harmony default export */ var channels = (channels_Channels);\nfunction createChannel(name, pusher) {\n    if (name.indexOf('private-encrypted-') === 0) {\n        if (pusher.config.nacl) {\n            return factory.createEncryptedChannel(name, pusher, pusher.config.nacl);\n        }\n        var errMsg = 'Tried to subscribe to a private-encrypted- channel but no nacl implementation available';\n        var suffix = url_store.buildLogSuffix('encryptedChannelSupport');\n        throw new UnsupportedFeature(errMsg + \". \" + suffix);\n    }\n    else if (name.indexOf('private-') === 0) {\n        return factory.createPrivateChannel(name, pusher);\n    }\n    else if (name.indexOf('presence-') === 0) {\n        return factory.createPresenceChannel(name, pusher);\n    }\n    else if (name.indexOf('#') === 0) {\n        throw new BadChannelName('Cannot create a channel with name \"' + name + '\".');\n    }\n    else {\n        return factory.createChannel(name, pusher);\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/utils/factory.ts\n\n\n\n\n\n\n\n\n\nvar Factory = {\n    createChannels: function () {\n        return new channels();\n    },\n    createConnectionManager: function (key, options) {\n        return new connection_manager(key, options);\n    },\n    createChannel: function (name, pusher) {\n        return new channels_channel(name, pusher);\n    },\n    createPrivateChannel: function (name, pusher) {\n        return new private_channel(name, pusher);\n    },\n    createPresenceChannel: function (name, pusher) {\n        return new presence_channel(name, pusher);\n    },\n    createEncryptedChannel: function (name, pusher, nacl) {\n        return new encrypted_channel(name, pusher, nacl);\n    },\n    createTimelineSender: function (timeline, options) {\n        return new timeline_sender(timeline, options);\n    },\n    createHandshake: function (transport, callback) {\n        return new connection_handshake(transport, callback);\n    },\n    createAssistantToTheTransportManager: function (manager, transport, options) {\n        return new assistant_to_the_transport_manager(manager, transport, options);\n    }\n};\n/* harmony default export */ var factory = (Factory);\n\n// CONCATENATED MODULE: ./src/core/transports/transport_manager.ts\n\nvar transport_manager_TransportManager = (function () {\n    function TransportManager(options) {\n        this.options = options || {};\n        this.livesLeft = this.options.lives || Infinity;\n    }\n    TransportManager.prototype.getAssistant = function (transport) {\n        return factory.createAssistantToTheTransportManager(this, transport, {\n            minPingDelay: this.options.minPingDelay,\n            maxPingDelay: this.options.maxPingDelay\n        });\n    };\n    TransportManager.prototype.isAlive = function () {\n        return this.livesLeft > 0;\n    };\n    TransportManager.prototype.reportDeath = function () {\n        this.livesLeft -= 1;\n    };\n    return TransportManager;\n}());\n/* harmony default export */ var transport_manager = (transport_manager_TransportManager);\n\n// CONCATENATED MODULE: ./src/core/strategies/sequential_strategy.ts\n\n\n\nvar sequential_strategy_SequentialStrategy = (function () {\n    function SequentialStrategy(strategies, options) {\n        this.strategies = strategies;\n        this.loop = Boolean(options.loop);\n        this.failFast = Boolean(options.failFast);\n        this.timeout = options.timeout;\n        this.timeoutLimit = options.timeoutLimit;\n    }\n    SequentialStrategy.prototype.isSupported = function () {\n        return any(this.strategies, util.method('isSupported'));\n    };\n    SequentialStrategy.prototype.connect = function (minPriority, callback) {\n        var _this = this;\n        var strategies = this.strategies;\n        var current = 0;\n        var timeout = this.timeout;\n        var runner = null;\n        var tryNextStrategy = function (error, handshake) {\n            if (handshake) {\n                callback(null, handshake);\n            }\n            else {\n                current = current + 1;\n                if (_this.loop) {\n                    current = current % strategies.length;\n                }\n                if (current < strategies.length) {\n                    if (timeout) {\n                        timeout = timeout * 2;\n                        if (_this.timeoutLimit) {\n                            timeout = Math.min(timeout, _this.timeoutLimit);\n                        }\n                    }\n                    runner = _this.tryStrategy(strategies[current], minPriority, { timeout: timeout, failFast: _this.failFast }, tryNextStrategy);\n                }\n                else {\n                    callback(true);\n                }\n            }\n        };\n        runner = this.tryStrategy(strategies[current], minPriority, { timeout: timeout, failFast: this.failFast }, tryNextStrategy);\n        return {\n            abort: function () {\n                runner.abort();\n            },\n            forceMinPriority: function (p) {\n                minPriority = p;\n                if (runner) {\n                    runner.forceMinPriority(p);\n                }\n            }\n        };\n    };\n    SequentialStrategy.prototype.tryStrategy = function (strategy, minPriority, options, callback) {\n        var timer = null;\n        var runner = null;\n        if (options.timeout > 0) {\n            timer = new OneOffTimer(options.timeout, function () {\n                runner.abort();\n                callback(true);\n            });\n        }\n        runner = strategy.connect(minPriority, function (error, handshake) {\n            if (error && timer && timer.isRunning() && !options.failFast) {\n                return;\n            }\n            if (timer) {\n                timer.ensureAborted();\n            }\n            callback(error, handshake);\n        });\n        return {\n            abort: function () {\n                if (timer) {\n                    timer.ensureAborted();\n                }\n                runner.abort();\n            },\n            forceMinPriority: function (p) {\n                runner.forceMinPriority(p);\n            }\n        };\n    };\n    return SequentialStrategy;\n}());\n/* harmony default export */ var sequential_strategy = (sequential_strategy_SequentialStrategy);\n\n// CONCATENATED MODULE: ./src/core/strategies/best_connected_ever_strategy.ts\n\n\nvar best_connected_ever_strategy_BestConnectedEverStrategy = (function () {\n    function BestConnectedEverStrategy(strategies) {\n        this.strategies = strategies;\n    }\n    BestConnectedEverStrategy.prototype.isSupported = function () {\n        return any(this.strategies, util.method('isSupported'));\n    };\n    BestConnectedEverStrategy.prototype.connect = function (minPriority, callback) {\n        return connect(this.strategies, minPriority, function (i, runners) {\n            return function (error, handshake) {\n                runners[i].error = error;\n                if (error) {\n                    if (allRunnersFailed(runners)) {\n                        callback(true);\n                    }\n                    return;\n                }\n                apply(runners, function (runner) {\n                    runner.forceMinPriority(handshake.transport.priority);\n                });\n                callback(null, handshake);\n            };\n        });\n    };\n    return BestConnectedEverStrategy;\n}());\n/* harmony default export */ var best_connected_ever_strategy = (best_connected_ever_strategy_BestConnectedEverStrategy);\nfunction connect(strategies, minPriority, callbackBuilder) {\n    var runners = map(strategies, function (strategy, i, _, rs) {\n        return strategy.connect(minPriority, callbackBuilder(i, rs));\n    });\n    return {\n        abort: function () {\n            apply(runners, abortRunner);\n        },\n        forceMinPriority: function (p) {\n            apply(runners, function (runner) {\n                runner.forceMinPriority(p);\n            });\n        }\n    };\n}\nfunction allRunnersFailed(runners) {\n    return collections_all(runners, function (runner) {\n        return Boolean(runner.error);\n    });\n}\nfunction abortRunner(runner) {\n    if (!runner.error && !runner.aborted) {\n        runner.abort();\n        runner.aborted = true;\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/cached_strategy.ts\n\n\n\n\nvar cached_strategy_CachedStrategy = (function () {\n    function CachedStrategy(strategy, transports, options) {\n        this.strategy = strategy;\n        this.transports = transports;\n        this.ttl = options.ttl || 1800 * 1000;\n        this.usingTLS = options.useTLS;\n        this.timeline = options.timeline;\n    }\n    CachedStrategy.prototype.isSupported = function () {\n        return this.strategy.isSupported();\n    };\n    CachedStrategy.prototype.connect = function (minPriority, callback) {\n        var usingTLS = this.usingTLS;\n        var info = fetchTransportCache(usingTLS);\n        var strategies = [this.strategy];\n        if (info && info.timestamp + this.ttl >= util.now()) {\n            var transport = this.transports[info.transport];\n            if (transport) {\n                this.timeline.info({\n                    cached: true,\n                    transport: info.transport,\n                    latency: info.latency\n                });\n                strategies.push(new sequential_strategy([transport], {\n                    timeout: info.latency * 2 + 1000,\n                    failFast: true\n                }));\n            }\n        }\n        var startTimestamp = util.now();\n        var runner = strategies\n            .pop()\n            .connect(minPriority, function cb(error, handshake) {\n            if (error) {\n                flushTransportCache(usingTLS);\n                if (strategies.length > 0) {\n                    startTimestamp = util.now();\n                    runner = strategies.pop().connect(minPriority, cb);\n                }\n                else {\n                    callback(error);\n                }\n            }\n            else {\n                storeTransportCache(usingTLS, handshake.transport.name, util.now() - startTimestamp);\n                callback(null, handshake);\n            }\n        });\n        return {\n            abort: function () {\n                runner.abort();\n            },\n            forceMinPriority: function (p) {\n                minPriority = p;\n                if (runner) {\n                    runner.forceMinPriority(p);\n                }\n            }\n        };\n    };\n    return CachedStrategy;\n}());\n/* harmony default export */ var cached_strategy = (cached_strategy_CachedStrategy);\nfunction getTransportCacheKey(usingTLS) {\n    return 'pusherTransport' + (usingTLS ? 'TLS' : 'NonTLS');\n}\nfunction fetchTransportCache(usingTLS) {\n    var storage = runtime.getLocalStorage();\n    if (storage) {\n        try {\n            var serializedCache = storage[getTransportCacheKey(usingTLS)];\n            if (serializedCache) {\n                return JSON.parse(serializedCache);\n            }\n        }\n        catch (e) {\n            flushTransportCache(usingTLS);\n        }\n    }\n    return null;\n}\nfunction storeTransportCache(usingTLS, transport, latency) {\n    var storage = runtime.getLocalStorage();\n    if (storage) {\n        try {\n            storage[getTransportCacheKey(usingTLS)] = safeJSONStringify({\n                timestamp: util.now(),\n                transport: transport,\n                latency: latency\n            });\n        }\n        catch (e) {\n        }\n    }\n}\nfunction flushTransportCache(usingTLS) {\n    var storage = runtime.getLocalStorage();\n    if (storage) {\n        try {\n            delete storage[getTransportCacheKey(usingTLS)];\n        }\n        catch (e) {\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/delayed_strategy.ts\n\nvar delayed_strategy_DelayedStrategy = (function () {\n    function DelayedStrategy(strategy, _a) {\n        var number = _a.delay;\n        this.strategy = strategy;\n        this.options = { delay: number };\n    }\n    DelayedStrategy.prototype.isSupported = function () {\n        return this.strategy.isSupported();\n    };\n    DelayedStrategy.prototype.connect = function (minPriority, callback) {\n        var strategy = this.strategy;\n        var runner;\n        var timer = new OneOffTimer(this.options.delay, function () {\n            runner = strategy.connect(minPriority, callback);\n        });\n        return {\n            abort: function () {\n                timer.ensureAborted();\n                if (runner) {\n                    runner.abort();\n                }\n            },\n            forceMinPriority: function (p) {\n                minPriority = p;\n                if (runner) {\n                    runner.forceMinPriority(p);\n                }\n            }\n        };\n    };\n    return DelayedStrategy;\n}());\n/* harmony default export */ var delayed_strategy = (delayed_strategy_DelayedStrategy);\n\n// CONCATENATED MODULE: ./src/core/strategies/if_strategy.ts\nvar IfStrategy = (function () {\n    function IfStrategy(test, trueBranch, falseBranch) {\n        this.test = test;\n        this.trueBranch = trueBranch;\n        this.falseBranch = falseBranch;\n    }\n    IfStrategy.prototype.isSupported = function () {\n        var branch = this.test() ? this.trueBranch : this.falseBranch;\n        return branch.isSupported();\n    };\n    IfStrategy.prototype.connect = function (minPriority, callback) {\n        var branch = this.test() ? this.trueBranch : this.falseBranch;\n        return branch.connect(minPriority, callback);\n    };\n    return IfStrategy;\n}());\n/* harmony default export */ var if_strategy = (IfStrategy);\n\n// CONCATENATED MODULE: ./src/core/strategies/first_connected_strategy.ts\nvar FirstConnectedStrategy = (function () {\n    function FirstConnectedStrategy(strategy) {\n        this.strategy = strategy;\n    }\n    FirstConnectedStrategy.prototype.isSupported = function () {\n        return this.strategy.isSupported();\n    };\n    FirstConnectedStrategy.prototype.connect = function (minPriority, callback) {\n        var runner = this.strategy.connect(minPriority, function (error, handshake) {\n            if (handshake) {\n                runner.abort();\n            }\n            callback(error, handshake);\n        });\n        return runner;\n    };\n    return FirstConnectedStrategy;\n}());\n/* harmony default export */ var first_connected_strategy = (FirstConnectedStrategy);\n\n// CONCATENATED MODULE: ./src/runtimes/web/default_strategy.ts\n\n\n\n\n\n\n\nfunction testSupportsStrategy(strategy) {\n    return function () {\n        return strategy.isSupported();\n    };\n}\nvar getDefaultStrategy = function (config, baseOptions, defineTransport) {\n    var definedTransports = {};\n    function defineTransportStrategy(name, type, priority, options, manager) {\n        var transport = defineTransport(config, name, type, priority, options, manager);\n        definedTransports[name] = transport;\n        return transport;\n    }\n    var ws_options = Object.assign({}, baseOptions, {\n        hostNonTLS: config.wsHost + ':' + config.wsPort,\n        hostTLS: config.wsHost + ':' + config.wssPort,\n        httpPath: config.wsPath\n    });\n    var wss_options = Object.assign({}, ws_options, {\n        useTLS: true\n    });\n    var sockjs_options = Object.assign({}, baseOptions, {\n        hostNonTLS: config.httpHost + ':' + config.httpPort,\n        hostTLS: config.httpHost + ':' + config.httpsPort,\n        httpPath: config.httpPath\n    });\n    var timeouts = {\n        loop: true,\n        timeout: 15000,\n        timeoutLimit: 60000\n    };\n    var ws_manager = new transport_manager({\n        lives: 2,\n        minPingDelay: 10000,\n        maxPingDelay: config.activityTimeout\n    });\n    var streaming_manager = new transport_manager({\n        lives: 2,\n        minPingDelay: 10000,\n        maxPingDelay: config.activityTimeout\n    });\n    var ws_transport = defineTransportStrategy('ws', 'ws', 3, ws_options, ws_manager);\n    var wss_transport = defineTransportStrategy('wss', 'ws', 3, wss_options, ws_manager);\n    var sockjs_transport = defineTransportStrategy('sockjs', 'sockjs', 1, sockjs_options);\n    var xhr_streaming_transport = defineTransportStrategy('xhr_streaming', 'xhr_streaming', 1, sockjs_options, streaming_manager);\n    var xdr_streaming_transport = defineTransportStrategy('xdr_streaming', 'xdr_streaming', 1, sockjs_options, streaming_manager);\n    var xhr_polling_transport = defineTransportStrategy('xhr_polling', 'xhr_polling', 1, sockjs_options);\n    var xdr_polling_transport = defineTransportStrategy('xdr_polling', 'xdr_polling', 1, sockjs_options);\n    var ws_loop = new sequential_strategy([ws_transport], timeouts);\n    var wss_loop = new sequential_strategy([wss_transport], timeouts);\n    var sockjs_loop = new sequential_strategy([sockjs_transport], timeouts);\n    var streaming_loop = new sequential_strategy([\n        new if_strategy(testSupportsStrategy(xhr_streaming_transport), xhr_streaming_transport, xdr_streaming_transport)\n    ], timeouts);\n    var polling_loop = new sequential_strategy([\n        new if_strategy(testSupportsStrategy(xhr_polling_transport), xhr_polling_transport, xdr_polling_transport)\n    ], timeouts);\n    var http_loop = new sequential_strategy([\n        new if_strategy(testSupportsStrategy(streaming_loop), new best_connected_ever_strategy([\n            streaming_loop,\n            new delayed_strategy(polling_loop, { delay: 4000 })\n        ]), polling_loop)\n    ], timeouts);\n    var http_fallback_loop = new if_strategy(testSupportsStrategy(http_loop), http_loop, sockjs_loop);\n    var wsStrategy;\n    if (baseOptions.useTLS) {\n        wsStrategy = new best_connected_ever_strategy([\n            ws_loop,\n            new delayed_strategy(http_fallback_loop, { delay: 2000 })\n        ]);\n    }\n    else {\n        wsStrategy = new best_connected_ever_strategy([\n            ws_loop,\n            new delayed_strategy(wss_loop, { delay: 2000 }),\n            new delayed_strategy(http_fallback_loop, { delay: 5000 })\n        ]);\n    }\n    return new cached_strategy(new first_connected_strategy(new if_strategy(testSupportsStrategy(ws_transport), wsStrategy, http_fallback_loop)), definedTransports, {\n        ttl: 1800000,\n        timeline: baseOptions.timeline,\n        useTLS: baseOptions.useTLS\n    });\n};\n/* harmony default export */ var default_strategy = (getDefaultStrategy);\n\n// CONCATENATED MODULE: ./src/runtimes/web/transports/transport_connection_initializer.ts\n\n/* harmony default export */ var transport_connection_initializer = (function () {\n    var self = this;\n    self.timeline.info(self.buildTimelineMessage({\n        transport: self.name + (self.options.useTLS ? 's' : '')\n    }));\n    if (self.hooks.isInitialized()) {\n        self.changeState('initialized');\n    }\n    else if (self.hooks.file) {\n        self.changeState('initializing');\n        Dependencies.load(self.hooks.file, { useTLS: self.options.useTLS }, function (error, callback) {\n            if (self.hooks.isInitialized()) {\n                self.changeState('initialized');\n                callback(true);\n            }\n            else {\n                if (error) {\n                    self.onError(error);\n                }\n                self.onClose();\n                callback(false);\n            }\n        });\n    }\n    else {\n        self.onClose();\n    }\n});\n\n// CONCATENATED MODULE: ./src/runtimes/web/http/http_xdomain_request.ts\n\nvar http_xdomain_request_hooks = {\n    getRequest: function (socket) {\n        var xdr = new window.XDomainRequest();\n        xdr.ontimeout = function () {\n            socket.emit('error', new RequestTimedOut());\n            socket.close();\n        };\n        xdr.onerror = function (e) {\n            socket.emit('error', e);\n            socket.close();\n        };\n        xdr.onprogress = function () {\n            if (xdr.responseText && xdr.responseText.length > 0) {\n                socket.onChunk(200, xdr.responseText);\n            }\n        };\n        xdr.onload = function () {\n            if (xdr.responseText && xdr.responseText.length > 0) {\n                socket.onChunk(200, xdr.responseText);\n            }\n            socket.emit('finished', 200);\n            socket.close();\n        };\n        return xdr;\n    },\n    abortRequest: function (xdr) {\n        xdr.ontimeout = xdr.onerror = xdr.onprogress = xdr.onload = null;\n        xdr.abort();\n    }\n};\n/* harmony default export */ var http_xdomain_request = (http_xdomain_request_hooks);\n\n// CONCATENATED MODULE: ./src/core/http/http_request.ts\nvar http_request_extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\nvar MAX_BUFFER_LENGTH = 256 * 1024;\nvar http_request_HTTPRequest = (function (_super) {\n    http_request_extends(HTTPRequest, _super);\n    function HTTPRequest(hooks, method, url) {\n        var _this = _super.call(this) || this;\n        _this.hooks = hooks;\n        _this.method = method;\n        _this.url = url;\n        return _this;\n    }\n    HTTPRequest.prototype.start = function (payload) {\n        var _this = this;\n        this.position = 0;\n        this.xhr = this.hooks.getRequest(this);\n        this.unloader = function () {\n            _this.close();\n        };\n        runtime.addUnloadListener(this.unloader);\n        this.xhr.open(this.method, this.url, true);\n        if (this.xhr.setRequestHeader) {\n            this.xhr.setRequestHeader('Content-Type', 'application/json');\n        }\n        this.xhr.send(payload);\n    };\n    HTTPRequest.prototype.close = function () {\n        if (this.unloader) {\n            runtime.removeUnloadListener(this.unloader);\n            this.unloader = null;\n        }\n        if (this.xhr) {\n            this.hooks.abortRequest(this.xhr);\n            this.xhr = null;\n        }\n    };\n    HTTPRequest.prototype.onChunk = function (status, data) {\n        while (true) {\n            var chunk = this.advanceBuffer(data);\n            if (chunk) {\n                this.emit('chunk', { status: status, data: chunk });\n            }\n            else {\n                break;\n            }\n        }\n        if (this.isBufferTooLong(data)) {\n            this.emit('buffer_too_long');\n        }\n    };\n    HTTPRequest.prototype.advanceBuffer = function (buffer) {\n        var unreadData = buffer.slice(this.position);\n        var endOfLinePosition = unreadData.indexOf('\\n');\n        if (endOfLinePosition !== -1) {\n            this.position += endOfLinePosition + 1;\n            return unreadData.slice(0, endOfLinePosition);\n        }\n        else {\n            return null;\n        }\n    };\n    HTTPRequest.prototype.isBufferTooLong = function (buffer) {\n        return this.position === buffer.length && buffer.length > MAX_BUFFER_LENGTH;\n    };\n    return HTTPRequest;\n}(dispatcher));\n/* harmony default export */ var http_request = (http_request_HTTPRequest);\n\n// CONCATENATED MODULE: ./src/core/http/state.ts\nvar State;\n(function (State) {\n    State[State[\"CONNECTING\"] = 0] = \"CONNECTING\";\n    State[State[\"OPEN\"] = 1] = \"OPEN\";\n    State[State[\"CLOSED\"] = 3] = \"CLOSED\";\n})(State || (State = {}));\n/* harmony default export */ var state = (State);\n\n// CONCATENATED MODULE: ./src/core/http/http_socket.ts\n\n\n\nvar autoIncrement = 1;\nvar http_socket_HTTPSocket = (function () {\n    function HTTPSocket(hooks, url) {\n        this.hooks = hooks;\n        this.session = randomNumber(1000) + '/' + randomString(8);\n        this.location = getLocation(url);\n        this.readyState = state.CONNECTING;\n        this.openStream();\n    }\n    HTTPSocket.prototype.send = function (payload) {\n        return this.sendRaw(JSON.stringify([payload]));\n    };\n    HTTPSocket.prototype.ping = function () {\n        this.hooks.sendHeartbeat(this);\n    };\n    HTTPSocket.prototype.close = function (code, reason) {\n        this.onClose(code, reason, true);\n    };\n    HTTPSocket.prototype.sendRaw = function (payload) {\n        if (this.readyState === state.OPEN) {\n            try {\n                runtime.createSocketRequest('POST', getUniqueURL(getSendURL(this.location, this.session))).start(payload);\n                return true;\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    };\n    HTTPSocket.prototype.reconnect = function () {\n        this.closeStream();\n        this.openStream();\n    };\n    HTTPSocket.prototype.onClose = function (code, reason, wasClean) {\n        this.closeStream();\n        this.readyState = state.CLOSED;\n        if (this.onclose) {\n            this.onclose({\n                code: code,\n                reason: reason,\n                wasClean: wasClean\n            });\n        }\n    };\n    HTTPSocket.prototype.onChunk = function (chunk) {\n        if (chunk.status !== 200) {\n            return;\n        }\n        if (this.readyState === state.OPEN) {\n            this.onActivity();\n        }\n        var payload;\n        var type = chunk.data.slice(0, 1);\n        switch (type) {\n            case 'o':\n                payload = JSON.parse(chunk.data.slice(1) || '{}');\n                this.onOpen(payload);\n                break;\n            case 'a':\n                payload = JSON.parse(chunk.data.slice(1) || '[]');\n                for (var i = 0; i < payload.length; i++) {\n                    this.onEvent(payload[i]);\n                }\n                break;\n            case 'm':\n                payload = JSON.parse(chunk.data.slice(1) || 'null');\n                this.onEvent(payload);\n                break;\n            case 'h':\n                this.hooks.onHeartbeat(this);\n                break;\n            case 'c':\n                payload = JSON.parse(chunk.data.slice(1) || '[]');\n                this.onClose(payload[0], payload[1], true);\n                break;\n        }\n    };\n    HTTPSocket.prototype.onOpen = function (options) {\n        if (this.readyState === state.CONNECTING) {\n            if (options && options.hostname) {\n                this.location.base = replaceHost(this.location.base, options.hostname);\n            }\n            this.readyState = state.OPEN;\n            if (this.onopen) {\n                this.onopen();\n            }\n        }\n        else {\n            this.onClose(1006, 'Server lost session', true);\n        }\n    };\n    HTTPSocket.prototype.onEvent = function (event) {\n        if (this.readyState === state.OPEN && this.onmessage) {\n            this.onmessage({ data: event });\n        }\n    };\n    HTTPSocket.prototype.onActivity = function () {\n        if (this.onactivity) {\n            this.onactivity();\n        }\n    };\n    HTTPSocket.prototype.onError = function (error) {\n        if (this.onerror) {\n            this.onerror(error);\n        }\n    };\n    HTTPSocket.prototype.openStream = function () {\n        var _this = this;\n        this.stream = runtime.createSocketRequest('POST', getUniqueURL(this.hooks.getReceiveURL(this.location, this.session)));\n        this.stream.bind('chunk', function (chunk) {\n            _this.onChunk(chunk);\n        });\n        this.stream.bind('finished', function (status) {\n            _this.hooks.onFinished(_this, status);\n        });\n        this.stream.bind('buffer_too_long', function () {\n            _this.reconnect();\n        });\n        try {\n            this.stream.start();\n        }\n        catch (error) {\n            util.defer(function () {\n                _this.onError(error);\n                _this.onClose(1006, 'Could not start streaming', false);\n            });\n        }\n    };\n    HTTPSocket.prototype.closeStream = function () {\n        if (this.stream) {\n            this.stream.unbind_all();\n            this.stream.close();\n            this.stream = null;\n        }\n    };\n    return HTTPSocket;\n}());\nfunction getLocation(url) {\n    var parts = /([^\\?]*)\\/*(\\??.*)/.exec(url);\n    return {\n        base: parts[1],\n        queryString: parts[2]\n    };\n}\nfunction getSendURL(url, session) {\n    return url.base + '/' + session + '/xhr_send';\n}\nfunction getUniqueURL(url) {\n    var separator = url.indexOf('?') === -1 ? '?' : '&';\n    return url + separator + 't=' + +new Date() + '&n=' + autoIncrement++;\n}\nfunction replaceHost(url, hostname) {\n    var urlParts = /(https?:\\/\\/)([^\\/:]+)((\\/|:)?.*)/.exec(url);\n    return urlParts[1] + hostname + urlParts[3];\n}\nfunction randomNumber(max) {\n    return runtime.randomInt(max);\n}\nfunction randomString(length) {\n    var result = [];\n    for (var i = 0; i < length; i++) {\n        result.push(randomNumber(32).toString(32));\n    }\n    return result.join('');\n}\n/* harmony default export */ var http_socket = (http_socket_HTTPSocket);\n\n// CONCATENATED MODULE: ./src/core/http/http_streaming_socket.ts\nvar http_streaming_socket_hooks = {\n    getReceiveURL: function (url, session) {\n        return url.base + '/' + session + '/xhr_streaming' + url.queryString;\n    },\n    onHeartbeat: function (socket) {\n        socket.sendRaw('[]');\n    },\n    sendHeartbeat: function (socket) {\n        socket.sendRaw('[]');\n    },\n    onFinished: function (socket, status) {\n        socket.onClose(1006, 'Connection interrupted (' + status + ')', false);\n    }\n};\n/* harmony default export */ var http_streaming_socket = (http_streaming_socket_hooks);\n\n// CONCATENATED MODULE: ./src/core/http/http_polling_socket.ts\nvar http_polling_socket_hooks = {\n    getReceiveURL: function (url, session) {\n        return url.base + '/' + session + '/xhr' + url.queryString;\n    },\n    onHeartbeat: function () {\n    },\n    sendHeartbeat: function (socket) {\n        socket.sendRaw('[]');\n    },\n    onFinished: function (socket, status) {\n        if (status === 200) {\n            socket.reconnect();\n        }\n        else {\n            socket.onClose(1006, 'Connection interrupted (' + status + ')', false);\n        }\n    }\n};\n/* harmony default export */ var http_polling_socket = (http_polling_socket_hooks);\n\n// CONCATENATED MODULE: ./src/runtimes/isomorphic/http/http_xhr_request.ts\n\nvar http_xhr_request_hooks = {\n    getRequest: function (socket) {\n        var Constructor = runtime.getXHRAPI();\n        var xhr = new Constructor();\n        xhr.onreadystatechange = xhr.onprogress = function () {\n            switch (xhr.readyState) {\n                case 3:\n                    if (xhr.responseText && xhr.responseText.length > 0) {\n                        socket.onChunk(xhr.status, xhr.responseText);\n                    }\n                    break;\n                case 4:\n                    if (xhr.responseText && xhr.responseText.length > 0) {\n                        socket.onChunk(xhr.status, xhr.responseText);\n                    }\n                    socket.emit('finished', xhr.status);\n                    socket.close();\n                    break;\n            }\n        };\n        return xhr;\n    },\n    abortRequest: function (xhr) {\n        xhr.onreadystatechange = null;\n        xhr.abort();\n    }\n};\n/* harmony default export */ var http_xhr_request = (http_xhr_request_hooks);\n\n// CONCATENATED MODULE: ./src/runtimes/isomorphic/http/http.ts\n\n\n\n\n\nvar HTTP = {\n    createStreamingSocket: function (url) {\n        return this.createSocket(http_streaming_socket, url);\n    },\n    createPollingSocket: function (url) {\n        return this.createSocket(http_polling_socket, url);\n    },\n    createSocket: function (hooks, url) {\n        return new http_socket(hooks, url);\n    },\n    createXHR: function (method, url) {\n        return this.createRequest(http_xhr_request, method, url);\n    },\n    createRequest: function (hooks, method, url) {\n        return new http_request(hooks, method, url);\n    }\n};\n/* harmony default export */ var http_http = (HTTP);\n\n// CONCATENATED MODULE: ./src/runtimes/web/http/http.ts\n\n\nhttp_http.createXDR = function (method, url) {\n    return this.createRequest(http_xdomain_request, method, url);\n};\n/* harmony default export */ var web_http_http = (http_http);\n\n// CONCATENATED MODULE: ./src/runtimes/web/runtime.ts\n\n\n\n\n\n\n\n\n\n\n\n\nvar Runtime = {\n    nextAuthCallbackID: 1,\n    auth_callbacks: {},\n    ScriptReceivers: ScriptReceivers,\n    DependenciesReceivers: DependenciesReceivers,\n    getDefaultStrategy: default_strategy,\n    Transports: transports_transports,\n    transportConnectionInitializer: transport_connection_initializer,\n    HTTPFactory: web_http_http,\n    TimelineTransport: jsonp_timeline,\n    getXHRAPI: function () {\n        return window.XMLHttpRequest;\n    },\n    getWebSocketAPI: function () {\n        return window.WebSocket || window.MozWebSocket;\n    },\n    setup: function (PusherClass) {\n        var _this = this;\n        window.Pusher = PusherClass;\n        var initializeOnDocumentBody = function () {\n            _this.onDocumentBody(PusherClass.ready);\n        };\n        if (!window.JSON) {\n            Dependencies.load('json2', {}, initializeOnDocumentBody);\n        }\n        else {\n            initializeOnDocumentBody();\n        }\n    },\n    getDocument: function () {\n        return document;\n    },\n    getProtocol: function () {\n        return this.getDocument().location.protocol;\n    },\n    getAuthorizers: function () {\n        return { ajax: xhr_auth, jsonp: jsonp_auth };\n    },\n    onDocumentBody: function (callback) {\n        var _this = this;\n        if (document.body) {\n            callback();\n        }\n        else {\n            setTimeout(function () {\n                _this.onDocumentBody(callback);\n            }, 0);\n        }\n    },\n    createJSONPRequest: function (url, data) {\n        return new jsonp_request(url, data);\n    },\n    createScriptRequest: function (src) {\n        return new script_request(src);\n    },\n    getLocalStorage: function () {\n        try {\n            return window.localStorage;\n        }\n        catch (e) {\n            return undefined;\n        }\n    },\n    createXHR: function () {\n        if (this.getXHRAPI()) {\n            return this.createXMLHttpRequest();\n        }\n        else {\n            return this.createMicrosoftXHR();\n        }\n    },\n    createXMLHttpRequest: function () {\n        var Constructor = this.getXHRAPI();\n        return new Constructor();\n    },\n    createMicrosoftXHR: function () {\n        return new ActiveXObject('Microsoft.XMLHTTP');\n    },\n    getNetwork: function () {\n        return net_info_Network;\n    },\n    createWebSocket: function (url) {\n        var Constructor = this.getWebSocketAPI();\n        return new Constructor(url);\n    },\n    createSocketRequest: function (method, url) {\n        if (this.isXHRSupported()) {\n            return this.HTTPFactory.createXHR(method, url);\n        }\n        else if (this.isXDRSupported(url.indexOf('https:') === 0)) {\n            return this.HTTPFactory.createXDR(method, url);\n        }\n        else {\n            throw 'Cross-origin HTTP requests are not supported';\n        }\n    },\n    isXHRSupported: function () {\n        var Constructor = this.getXHRAPI();\n        return (Boolean(Constructor) && new Constructor().withCredentials !== undefined);\n    },\n    isXDRSupported: function (useTLS) {\n        var protocol = useTLS ? 'https:' : 'http:';\n        var documentProtocol = this.getProtocol();\n        return (Boolean(window['XDomainRequest']) && documentProtocol === protocol);\n    },\n    addUnloadListener: function (listener) {\n        if (window.addEventListener !== undefined) {\n            window.addEventListener('unload', listener, false);\n        }\n        else if (window.attachEvent !== undefined) {\n            window.attachEvent('onunload', listener);\n        }\n    },\n    removeUnloadListener: function (listener) {\n        if (window.addEventListener !== undefined) {\n            window.removeEventListener('unload', listener, false);\n        }\n        else if (window.detachEvent !== undefined) {\n            window.detachEvent('onunload', listener);\n        }\n    },\n    randomInt: function (max) {\n        var random = function () {\n            var crypto = window.crypto || window['msCrypto'];\n            var random = crypto.getRandomValues(new Uint32Array(1))[0];\n            return random / Math.pow(2, 32);\n        };\n        return Math.floor(random() * max);\n    }\n};\n/* harmony default export */ var runtime = (Runtime);\n\n// CONCATENATED MODULE: ./src/core/timeline/level.ts\nvar TimelineLevel;\n(function (TimelineLevel) {\n    TimelineLevel[TimelineLevel[\"ERROR\"] = 3] = \"ERROR\";\n    TimelineLevel[TimelineLevel[\"INFO\"] = 6] = \"INFO\";\n    TimelineLevel[TimelineLevel[\"DEBUG\"] = 7] = \"DEBUG\";\n})(TimelineLevel || (TimelineLevel = {}));\n/* harmony default export */ var timeline_level = (TimelineLevel);\n\n// CONCATENATED MODULE: ./src/core/timeline/timeline.ts\n\n\n\nvar timeline_Timeline = (function () {\n    function Timeline(key, session, options) {\n        this.key = key;\n        this.session = session;\n        this.events = [];\n        this.options = options || {};\n        this.sent = 0;\n        this.uniqueID = 0;\n    }\n    Timeline.prototype.log = function (level, event) {\n        if (level <= this.options.level) {\n            this.events.push(extend({}, event, { timestamp: util.now() }));\n            if (this.options.limit && this.events.length > this.options.limit) {\n                this.events.shift();\n            }\n        }\n    };\n    Timeline.prototype.error = function (event) {\n        this.log(timeline_level.ERROR, event);\n    };\n    Timeline.prototype.info = function (event) {\n        this.log(timeline_level.INFO, event);\n    };\n    Timeline.prototype.debug = function (event) {\n        this.log(timeline_level.DEBUG, event);\n    };\n    Timeline.prototype.isEmpty = function () {\n        return this.events.length === 0;\n    };\n    Timeline.prototype.send = function (sendfn, callback) {\n        var _this = this;\n        var data = extend({\n            session: this.session,\n            bundle: this.sent + 1,\n            key: this.key,\n            lib: 'js',\n            version: this.options.version,\n            cluster: this.options.cluster,\n            features: this.options.features,\n            timeline: this.events\n        }, this.options.params);\n        this.events = [];\n        sendfn(data, function (error, result) {\n            if (!error) {\n                _this.sent++;\n            }\n            if (callback) {\n                callback(error, result);\n            }\n        });\n        return true;\n    };\n    Timeline.prototype.generateUniqueID = function () {\n        this.uniqueID++;\n        return this.uniqueID;\n    };\n    return Timeline;\n}());\n/* harmony default export */ var timeline_timeline = (timeline_Timeline);\n\n// CONCATENATED MODULE: ./src/core/strategies/transport_strategy.ts\n\n\n\n\nvar transport_strategy_TransportStrategy = (function () {\n    function TransportStrategy(name, priority, transport, options) {\n        this.name = name;\n        this.priority = priority;\n        this.transport = transport;\n        this.options = options || {};\n    }\n    TransportStrategy.prototype.isSupported = function () {\n        return this.transport.isSupported({\n            useTLS: this.options.useTLS\n        });\n    };\n    TransportStrategy.prototype.connect = function (minPriority, callback) {\n        var _this = this;\n        if (!this.isSupported()) {\n            return failAttempt(new UnsupportedStrategy(), callback);\n        }\n        else if (this.priority < minPriority) {\n            return failAttempt(new TransportPriorityTooLow(), callback);\n        }\n        var connected = false;\n        var transport = this.transport.createConnection(this.name, this.priority, this.options.key, this.options);\n        var handshake = null;\n        var onInitialized = function () {\n            transport.unbind('initialized', onInitialized);\n            transport.connect();\n        };\n        var onOpen = function () {\n            handshake = factory.createHandshake(transport, function (result) {\n                connected = true;\n                unbindListeners();\n                callback(null, result);\n            });\n        };\n        var onError = function (error) {\n            unbindListeners();\n            callback(error);\n        };\n        var onClosed = function () {\n            unbindListeners();\n            var serializedTransport;\n            serializedTransport = safeJSONStringify(transport);\n            callback(new TransportClosed(serializedTransport));\n        };\n        var unbindListeners = function () {\n            transport.unbind('initialized', onInitialized);\n            transport.unbind('open', onOpen);\n            transport.unbind('error', onError);\n            transport.unbind('closed', onClosed);\n        };\n        transport.bind('initialized', onInitialized);\n        transport.bind('open', onOpen);\n        transport.bind('error', onError);\n        transport.bind('closed', onClosed);\n        transport.initialize();\n        return {\n            abort: function () {\n                if (connected) {\n                    return;\n                }\n                unbindListeners();\n                if (handshake) {\n                    handshake.close();\n                }\n                else {\n                    transport.close();\n                }\n            },\n            forceMinPriority: function (p) {\n                if (connected) {\n                    return;\n                }\n                if (_this.priority < p) {\n                    if (handshake) {\n                        handshake.close();\n                    }\n                    else {\n                        transport.close();\n                    }\n                }\n            }\n        };\n    };\n    return TransportStrategy;\n}());\n/* harmony default export */ var transport_strategy = (transport_strategy_TransportStrategy);\nfunction failAttempt(error, callback) {\n    util.defer(function () {\n        callback(error);\n    });\n    return {\n        abort: function () { },\n        forceMinPriority: function () { }\n    };\n}\n\n// CONCATENATED MODULE: ./src/core/strategies/strategy_builder.ts\n\n\n\n\n\nvar strategy_builder_Transports = runtime.Transports;\nvar strategy_builder_defineTransport = function (config, name, type, priority, options, manager) {\n    var transportClass = strategy_builder_Transports[type];\n    if (!transportClass) {\n        throw new UnsupportedTransport(type);\n    }\n    var enabled = (!config.enabledTransports ||\n        arrayIndexOf(config.enabledTransports, name) !== -1) &&\n        (!config.disabledTransports ||\n            arrayIndexOf(config.disabledTransports, name) === -1);\n    var transport;\n    if (enabled) {\n        options = Object.assign({ ignoreNullOrigin: config.ignoreNullOrigin }, options);\n        transport = new transport_strategy(name, priority, manager ? manager.getAssistant(transportClass) : transportClass, options);\n    }\n    else {\n        transport = strategy_builder_UnsupportedStrategy;\n    }\n    return transport;\n};\nvar strategy_builder_UnsupportedStrategy = {\n    isSupported: function () {\n        return false;\n    },\n    connect: function (_, callback) {\n        var deferred = util.defer(function () {\n            callback(new UnsupportedStrategy());\n        });\n        return {\n            abort: function () {\n                deferred.ensureAborted();\n            },\n            forceMinPriority: function () { }\n        };\n    }\n};\n\n// CONCATENATED MODULE: ./src/core/options.ts\n\nfunction validateOptions(options) {\n    if (options == null) {\n        throw 'You must pass an options object';\n    }\n    if (options.cluster == null) {\n        throw 'Options object must provide a cluster';\n    }\n    if ('disableStats' in options) {\n        logger.warn('The disableStats option is deprecated in favor of enableStats');\n    }\n}\n\n// CONCATENATED MODULE: ./src/core/auth/user_authenticator.ts\n\n\nvar composeChannelQuery = function (params, authOptions) {\n    var query = 'socket_id=' + encodeURIComponent(params.socketId);\n    for (var key in authOptions.params) {\n        query +=\n            '&' +\n                encodeURIComponent(key) +\n                '=' +\n                encodeURIComponent(authOptions.params[key]);\n    }\n    if (authOptions.paramsProvider != null) {\n        var dynamicParams = authOptions.paramsProvider();\n        for (var key in dynamicParams) {\n            query +=\n                '&' +\n                    encodeURIComponent(key) +\n                    '=' +\n                    encodeURIComponent(dynamicParams[key]);\n        }\n    }\n    return query;\n};\nvar UserAuthenticator = function (authOptions) {\n    if (typeof runtime.getAuthorizers()[authOptions.transport] === 'undefined') {\n        throw \"'\" + authOptions.transport + \"' is not a recognized auth transport\";\n    }\n    return function (params, callback) {\n        var query = composeChannelQuery(params, authOptions);\n        runtime.getAuthorizers()[authOptions.transport](runtime, query, authOptions, AuthRequestType.UserAuthentication, callback);\n    };\n};\n/* harmony default export */ var user_authenticator = (UserAuthenticator);\n\n// CONCATENATED MODULE: ./src/core/auth/channel_authorizer.ts\n\n\nvar channel_authorizer_composeChannelQuery = function (params, authOptions) {\n    var query = 'socket_id=' + encodeURIComponent(params.socketId);\n    query += '&channel_name=' + encodeURIComponent(params.channelName);\n    for (var key in authOptions.params) {\n        query +=\n            '&' +\n                encodeURIComponent(key) +\n                '=' +\n                encodeURIComponent(authOptions.params[key]);\n    }\n    if (authOptions.paramsProvider != null) {\n        var dynamicParams = authOptions.paramsProvider();\n        for (var key in dynamicParams) {\n            query +=\n                '&' +\n                    encodeURIComponent(key) +\n                    '=' +\n                    encodeURIComponent(dynamicParams[key]);\n        }\n    }\n    return query;\n};\nvar ChannelAuthorizer = function (authOptions) {\n    if (typeof runtime.getAuthorizers()[authOptions.transport] === 'undefined') {\n        throw \"'\" + authOptions.transport + \"' is not a recognized auth transport\";\n    }\n    return function (params, callback) {\n        var query = channel_authorizer_composeChannelQuery(params, authOptions);\n        runtime.getAuthorizers()[authOptions.transport](runtime, query, authOptions, AuthRequestType.ChannelAuthorization, callback);\n    };\n};\n/* harmony default export */ var channel_authorizer = (ChannelAuthorizer);\n\n// CONCATENATED MODULE: ./src/core/auth/deprecated_channel_authorizer.ts\nvar ChannelAuthorizerProxy = function (pusher, authOptions, channelAuthorizerGenerator) {\n    var deprecatedAuthorizerOptions = {\n        authTransport: authOptions.transport,\n        authEndpoint: authOptions.endpoint,\n        auth: {\n            params: authOptions.params,\n            headers: authOptions.headers\n        }\n    };\n    return function (params, callback) {\n        var channel = pusher.channel(params.channelName);\n        var channelAuthorizer = channelAuthorizerGenerator(channel, deprecatedAuthorizerOptions);\n        channelAuthorizer.authorize(params.socketId, callback);\n    };\n};\n\n// CONCATENATED MODULE: ./src/core/config.ts\nvar __assign = ( false) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\n\n\n\n\n\nfunction getConfig(opts, pusher) {\n    var config = {\n        activityTimeout: opts.activityTimeout || defaults.activityTimeout,\n        cluster: opts.cluster,\n        httpPath: opts.httpPath || defaults.httpPath,\n        httpPort: opts.httpPort || defaults.httpPort,\n        httpsPort: opts.httpsPort || defaults.httpsPort,\n        pongTimeout: opts.pongTimeout || defaults.pongTimeout,\n        statsHost: opts.statsHost || defaults.stats_host,\n        unavailableTimeout: opts.unavailableTimeout || defaults.unavailableTimeout,\n        wsPath: opts.wsPath || defaults.wsPath,\n        wsPort: opts.wsPort || defaults.wsPort,\n        wssPort: opts.wssPort || defaults.wssPort,\n        enableStats: getEnableStatsConfig(opts),\n        httpHost: getHttpHost(opts),\n        useTLS: shouldUseTLS(opts),\n        wsHost: getWebsocketHost(opts),\n        userAuthenticator: buildUserAuthenticator(opts),\n        channelAuthorizer: buildChannelAuthorizer(opts, pusher)\n    };\n    if ('disabledTransports' in opts)\n        config.disabledTransports = opts.disabledTransports;\n    if ('enabledTransports' in opts)\n        config.enabledTransports = opts.enabledTransports;\n    if ('ignoreNullOrigin' in opts)\n        config.ignoreNullOrigin = opts.ignoreNullOrigin;\n    if ('timelineParams' in opts)\n        config.timelineParams = opts.timelineParams;\n    if ('nacl' in opts) {\n        config.nacl = opts.nacl;\n    }\n    return config;\n}\nfunction getHttpHost(opts) {\n    if (opts.httpHost) {\n        return opts.httpHost;\n    }\n    if (opts.cluster) {\n        return \"sockjs-\" + opts.cluster + \".pusher.com\";\n    }\n    return defaults.httpHost;\n}\nfunction getWebsocketHost(opts) {\n    if (opts.wsHost) {\n        return opts.wsHost;\n    }\n    return getWebsocketHostFromCluster(opts.cluster);\n}\nfunction getWebsocketHostFromCluster(cluster) {\n    return \"ws-\" + cluster + \".pusher.com\";\n}\nfunction shouldUseTLS(opts) {\n    if (runtime.getProtocol() === 'https:') {\n        return true;\n    }\n    else if (opts.forceTLS === false) {\n        return false;\n    }\n    return true;\n}\nfunction getEnableStatsConfig(opts) {\n    if ('enableStats' in opts) {\n        return opts.enableStats;\n    }\n    if ('disableStats' in opts) {\n        return !opts.disableStats;\n    }\n    return false;\n}\nfunction buildUserAuthenticator(opts) {\n    var userAuthentication = __assign(__assign({}, defaults.userAuthentication), opts.userAuthentication);\n    if ('customHandler' in userAuthentication &&\n        userAuthentication['customHandler'] != null) {\n        return userAuthentication['customHandler'];\n    }\n    return user_authenticator(userAuthentication);\n}\nfunction buildChannelAuth(opts, pusher) {\n    var channelAuthorization;\n    if ('channelAuthorization' in opts) {\n        channelAuthorization = __assign(__assign({}, defaults.channelAuthorization), opts.channelAuthorization);\n    }\n    else {\n        channelAuthorization = {\n            transport: opts.authTransport || defaults.authTransport,\n            endpoint: opts.authEndpoint || defaults.authEndpoint\n        };\n        if ('auth' in opts) {\n            if ('params' in opts.auth)\n                channelAuthorization.params = opts.auth.params;\n            if ('headers' in opts.auth)\n                channelAuthorization.headers = opts.auth.headers;\n        }\n        if ('authorizer' in opts)\n            channelAuthorization.customHandler = ChannelAuthorizerProxy(pusher, channelAuthorization, opts.authorizer);\n    }\n    return channelAuthorization;\n}\nfunction buildChannelAuthorizer(opts, pusher) {\n    var channelAuthorization = buildChannelAuth(opts, pusher);\n    if ('customHandler' in channelAuthorization &&\n        channelAuthorization['customHandler'] != null) {\n        return channelAuthorization['customHandler'];\n    }\n    return channel_authorizer(channelAuthorization);\n}\n\n// CONCATENATED MODULE: ./src/core/watchlist.ts\nvar watchlist_extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\nvar watchlist_WatchlistFacade = (function (_super) {\n    watchlist_extends(WatchlistFacade, _super);\n    function WatchlistFacade(pusher) {\n        var _this = _super.call(this, function (eventName, data) {\n            logger.debug(\"No callbacks on watchlist events for \" + eventName);\n        }) || this;\n        _this.pusher = pusher;\n        _this.bindWatchlistInternalEvent();\n        return _this;\n    }\n    WatchlistFacade.prototype.handleEvent = function (pusherEvent) {\n        var _this = this;\n        pusherEvent.data.events.forEach(function (watchlistEvent) {\n            _this.emit(watchlistEvent.name, watchlistEvent);\n        });\n    };\n    WatchlistFacade.prototype.bindWatchlistInternalEvent = function () {\n        var _this = this;\n        this.pusher.connection.bind('message', function (pusherEvent) {\n            var eventName = pusherEvent.event;\n            if (eventName === 'pusher_internal:watchlist_events') {\n                _this.handleEvent(pusherEvent);\n            }\n        });\n    };\n    return WatchlistFacade;\n}(dispatcher));\n/* harmony default export */ var watchlist = (watchlist_WatchlistFacade);\n\n// CONCATENATED MODULE: ./src/core/utils/flat_promise.ts\nfunction flatPromise() {\n    var resolve, reject;\n    var promise = new Promise(function (res, rej) {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise: promise, resolve: resolve, reject: reject };\n}\n/* harmony default export */ var flat_promise = (flatPromise);\n\n// CONCATENATED MODULE: ./src/core/user.ts\nvar user_extends = ( false) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n\n\n\n\nvar user_UserFacade = (function (_super) {\n    user_extends(UserFacade, _super);\n    function UserFacade(pusher) {\n        var _this = _super.call(this, function (eventName, data) {\n            logger.debug('No callbacks on user for ' + eventName);\n        }) || this;\n        _this.signin_requested = false;\n        _this.user_data = null;\n        _this.serverToUserChannel = null;\n        _this.signinDonePromise = null;\n        _this._signinDoneResolve = null;\n        _this._onAuthorize = function (err, authData) {\n            if (err) {\n                logger.warn(\"Error during signin: \" + err);\n                _this._cleanup();\n                return;\n            }\n            _this.pusher.send_event('pusher:signin', {\n                auth: authData.auth,\n                user_data: authData.user_data\n            });\n        };\n        _this.pusher = pusher;\n        _this.pusher.connection.bind('state_change', function (_a) {\n            var previous = _a.previous, current = _a.current;\n            if (previous !== 'connected' && current === 'connected') {\n                _this._signin();\n            }\n            if (previous === 'connected' && current !== 'connected') {\n                _this._cleanup();\n                _this._newSigninPromiseIfNeeded();\n            }\n        });\n        _this.watchlist = new watchlist(pusher);\n        _this.pusher.connection.bind('message', function (event) {\n            var eventName = event.event;\n            if (eventName === 'pusher:signin_success') {\n                _this._onSigninSuccess(event.data);\n            }\n            if (_this.serverToUserChannel &&\n                _this.serverToUserChannel.name === event.channel) {\n                _this.serverToUserChannel.handleEvent(event);\n            }\n        });\n        return _this;\n    }\n    UserFacade.prototype.signin = function () {\n        if (this.signin_requested) {\n            return;\n        }\n        this.signin_requested = true;\n        this._signin();\n    };\n    UserFacade.prototype._signin = function () {\n        if (!this.signin_requested) {\n            return;\n        }\n        this._newSigninPromiseIfNeeded();\n        if (this.pusher.connection.state !== 'connected') {\n            return;\n        }\n        this.pusher.config.userAuthenticator({\n            socketId: this.pusher.connection.socket_id\n        }, this._onAuthorize);\n    };\n    UserFacade.prototype._onSigninSuccess = function (data) {\n        try {\n            this.user_data = JSON.parse(data.user_data);\n        }\n        catch (e) {\n            logger.error(\"Failed parsing user data after signin: \" + data.user_data);\n            this._cleanup();\n            return;\n        }\n        if (typeof this.user_data.id !== 'string' || this.user_data.id === '') {\n            logger.error(\"user_data doesn't contain an id. user_data: \" + this.user_data);\n            this._cleanup();\n            return;\n        }\n        this._signinDoneResolve();\n        this._subscribeChannels();\n    };\n    UserFacade.prototype._subscribeChannels = function () {\n        var _this = this;\n        var ensure_subscribed = function (channel) {\n            if (channel.subscriptionPending && channel.subscriptionCancelled) {\n                channel.reinstateSubscription();\n            }\n            else if (!channel.subscriptionPending &&\n                _this.pusher.connection.state === 'connected') {\n                channel.subscribe();\n            }\n        };\n        this.serverToUserChannel = new channels_channel(\"#server-to-user-\" + this.user_data.id, this.pusher);\n        this.serverToUserChannel.bind_global(function (eventName, data) {\n            if (eventName.indexOf('pusher_internal:') === 0 ||\n                eventName.indexOf('pusher:') === 0) {\n                return;\n            }\n            _this.emit(eventName, data);\n        });\n        ensure_subscribed(this.serverToUserChannel);\n    };\n    UserFacade.prototype._cleanup = function () {\n        this.user_data = null;\n        if (this.serverToUserChannel) {\n            this.serverToUserChannel.unbind_all();\n            this.serverToUserChannel.disconnect();\n            this.serverToUserChannel = null;\n        }\n        if (this.signin_requested) {\n            this._signinDoneResolve();\n        }\n    };\n    UserFacade.prototype._newSigninPromiseIfNeeded = function () {\n        if (!this.signin_requested) {\n            return;\n        }\n        if (this.signinDonePromise && !this.signinDonePromise.done) {\n            return;\n        }\n        var _a = flat_promise(), promise = _a.promise, resolve = _a.resolve, _ = _a.reject;\n        promise.done = false;\n        var setDone = function () {\n            promise.done = true;\n        };\n        promise.then(setDone)[\"catch\"](setDone);\n        this.signinDonePromise = promise;\n        this._signinDoneResolve = resolve;\n    };\n    return UserFacade;\n}(dispatcher));\n/* harmony default export */ var user = (user_UserFacade);\n\n// CONCATENATED MODULE: ./src/core/pusher.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar pusher_Pusher = (function () {\n    function Pusher(app_key, options) {\n        var _this = this;\n        checkAppKey(app_key);\n        validateOptions(options);\n        this.key = app_key;\n        this.config = getConfig(options, this);\n        this.channels = factory.createChannels();\n        this.global_emitter = new dispatcher();\n        this.sessionID = runtime.randomInt(1000000000);\n        this.timeline = new timeline_timeline(this.key, this.sessionID, {\n            cluster: this.config.cluster,\n            features: Pusher.getClientFeatures(),\n            params: this.config.timelineParams || {},\n            limit: 50,\n            level: timeline_level.INFO,\n            version: defaults.VERSION\n        });\n        if (this.config.enableStats) {\n            this.timelineSender = factory.createTimelineSender(this.timeline, {\n                host: this.config.statsHost,\n                path: '/timeline/v2/' + runtime.TimelineTransport.name\n            });\n        }\n        var getStrategy = function (options) {\n            return runtime.getDefaultStrategy(_this.config, options, strategy_builder_defineTransport);\n        };\n        this.connection = factory.createConnectionManager(this.key, {\n            getStrategy: getStrategy,\n            timeline: this.timeline,\n            activityTimeout: this.config.activityTimeout,\n            pongTimeout: this.config.pongTimeout,\n            unavailableTimeout: this.config.unavailableTimeout,\n            useTLS: Boolean(this.config.useTLS)\n        });\n        this.connection.bind('connected', function () {\n            _this.subscribeAll();\n            if (_this.timelineSender) {\n                _this.timelineSender.send(_this.connection.isUsingTLS());\n            }\n        });\n        this.connection.bind('message', function (event) {\n            var eventName = event.event;\n            var internal = eventName.indexOf('pusher_internal:') === 0;\n            if (event.channel) {\n                var channel = _this.channel(event.channel);\n                if (channel) {\n                    channel.handleEvent(event);\n                }\n            }\n            if (!internal) {\n                _this.global_emitter.emit(event.event, event.data);\n            }\n        });\n        this.connection.bind('connecting', function () {\n            _this.channels.disconnect();\n        });\n        this.connection.bind('disconnected', function () {\n            _this.channels.disconnect();\n        });\n        this.connection.bind('error', function (err) {\n            logger.warn(err);\n        });\n        Pusher.instances.push(this);\n        this.timeline.info({ instances: Pusher.instances.length });\n        this.user = new user(this);\n        if (Pusher.isReady) {\n            this.connect();\n        }\n    }\n    Pusher.ready = function () {\n        Pusher.isReady = true;\n        for (var i = 0, l = Pusher.instances.length; i < l; i++) {\n            Pusher.instances[i].connect();\n        }\n    };\n    Pusher.getClientFeatures = function () {\n        return keys(filterObject({ ws: runtime.Transports.ws }, function (t) {\n            return t.isSupported({});\n        }));\n    };\n    Pusher.prototype.channel = function (name) {\n        return this.channels.find(name);\n    };\n    Pusher.prototype.allChannels = function () {\n        return this.channels.all();\n    };\n    Pusher.prototype.connect = function () {\n        this.connection.connect();\n        if (this.timelineSender) {\n            if (!this.timelineSenderTimer) {\n                var usingTLS = this.connection.isUsingTLS();\n                var timelineSender = this.timelineSender;\n                this.timelineSenderTimer = new PeriodicTimer(60000, function () {\n                    timelineSender.send(usingTLS);\n                });\n            }\n        }\n    };\n    Pusher.prototype.disconnect = function () {\n        this.connection.disconnect();\n        if (this.timelineSenderTimer) {\n            this.timelineSenderTimer.ensureAborted();\n            this.timelineSenderTimer = null;\n        }\n    };\n    Pusher.prototype.bind = function (event_name, callback, context) {\n        this.global_emitter.bind(event_name, callback, context);\n        return this;\n    };\n    Pusher.prototype.unbind = function (event_name, callback, context) {\n        this.global_emitter.unbind(event_name, callback, context);\n        return this;\n    };\n    Pusher.prototype.bind_global = function (callback) {\n        this.global_emitter.bind_global(callback);\n        return this;\n    };\n    Pusher.prototype.unbind_global = function (callback) {\n        this.global_emitter.unbind_global(callback);\n        return this;\n    };\n    Pusher.prototype.unbind_all = function (callback) {\n        this.global_emitter.unbind_all();\n        return this;\n    };\n    Pusher.prototype.subscribeAll = function () {\n        var channelName;\n        for (channelName in this.channels.channels) {\n            if (this.channels.channels.hasOwnProperty(channelName)) {\n                this.subscribe(channelName);\n            }\n        }\n    };\n    Pusher.prototype.subscribe = function (channel_name) {\n        var channel = this.channels.add(channel_name, this);\n        if (channel.subscriptionPending && channel.subscriptionCancelled) {\n            channel.reinstateSubscription();\n        }\n        else if (!channel.subscriptionPending &&\n            this.connection.state === 'connected') {\n            channel.subscribe();\n        }\n        return channel;\n    };\n    Pusher.prototype.unsubscribe = function (channel_name) {\n        var channel = this.channels.find(channel_name);\n        if (channel && channel.subscriptionPending) {\n            channel.cancelSubscription();\n        }\n        else {\n            channel = this.channels.remove(channel_name);\n            if (channel && channel.subscribed) {\n                channel.unsubscribe();\n            }\n        }\n    };\n    Pusher.prototype.send_event = function (event_name, data, channel) {\n        return this.connection.send_event(event_name, data, channel);\n    };\n    Pusher.prototype.shouldUseTLS = function () {\n        return this.config.useTLS;\n    };\n    Pusher.prototype.signin = function () {\n        this.user.signin();\n    };\n    Pusher.instances = [];\n    Pusher.isReady = false;\n    Pusher.logToConsole = false;\n    Pusher.Runtime = runtime;\n    Pusher.ScriptReceivers = runtime.ScriptReceivers;\n    Pusher.DependenciesReceivers = runtime.DependenciesReceivers;\n    Pusher.auth_callbacks = runtime.auth_callbacks;\n    return Pusher;\n}());\n/* harmony default export */ var core_pusher = __webpack_exports__[\"default\"] = (pusher_Pusher);\nfunction checkAppKey(key) {\n    if (key === null || key === undefined) {\n        throw 'You must pass your app key when you instantiate Pusher.';\n    }\n}\nruntime.setup(pusher_Pusher);\n\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=pusher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcHVzaGVyLWpzL2Rpc3Qvd2ViL3B1c2hlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksSUFBeUQ7QUFDN0Q7QUFDQSxNQUFNLEVBS3VCO0FBQzdCLENBQUM7QUFDRCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLDhCQUFtQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsZUFBZSw4QkFBbUI7QUFDbEMsbURBQW1ELCtCQUErQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0EsaUVBQWlFLGlCQUFpQjtBQUNsRjtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsZ0NBQWdDLDhCQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhCQUFtQjtBQUM5QixrREFBa0QsZ0NBQWdDO0FBQ2xGLDBFQUEwRSw4QkFBbUIsNEJBQTRCLG9CQUFvQjtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRSwwQ0FBMEM7QUFDMUMsV0FBVyw4QkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQixrQ0FBa0M7QUFDL0Q7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4QkFBbUIsQ0FBQyw4QkFBbUI7QUFDeEQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNELCtDQUErQyxhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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S0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLHdCQUF3QjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JB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QUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsNENBQTRDO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSwyQ0FBMkM7QUFDakg7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGFBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxXQUFXLHVCQUF1QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywyQ0FBMkM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHVzaGVyLWpzL2Rpc3Qvd2ViL3B1c2hlci5qcz9kYzhlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogUHVzaGVyIEphdmFTY3JpcHQgTGlicmFyeSB2OC4wLjJcbiAqIGh0dHBzOi8vcHVzaGVyLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCwgUHVzaGVyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2VuY2UuXG4gKi9cblxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUHVzaGVyXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlB1c2hlclwiXSA9IGZhY3RvcnkoKTtcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIENvcHlyaWdodCAoQykgMjAxNiBEbWl0cnkgQ2hlc3RueWtoXG4vLyBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBmb3IgZGV0YWlscy5cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBQYWNrYWdlIGJhc2U2NCBpbXBsZW1lbnRzIEJhc2U2NCBlbmNvZGluZyBhbmQgZGVjb2RpbmcuXG4gKi9cbi8vIEludmFsaWQgY2hhcmFjdGVyIHVzZWQgaW4gZGVjb2RpbmcgdG8gaW5kaWNhdGVcbi8vIHRoYXQgdGhlIGNoYXJhY3RlciB0byBkZWNvZGUgaXMgb3V0IG9mIHJhbmdlIG9mXG4vLyBhbHBoYWJldCBhbmQgY2Fubm90IGJlIGRlY29kZWQuXG52YXIgSU5WQUxJRF9CWVRFID0gMjU2O1xuLyoqXG4gKiBJbXBsZW1lbnRzIHN0YW5kYXJkIEJhc2U2NCBlbmNvZGluZy5cbiAqXG4gKiBPcGVyYXRlcyBpbiBjb25zdGFudCB0aW1lLlxuICovXG52YXIgQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gVE9ETyhkY2hlc3QpOiBtZXRob2RzIHRvIGVuY29kZSBjaHVuay1ieS1jaHVuay5cbiAgICBmdW5jdGlvbiBDb2RlcihfcGFkZGluZ0NoYXJhY3Rlcikge1xuICAgICAgICBpZiAoX3BhZGRpbmdDaGFyYWN0ZXIgPT09IHZvaWQgMCkgeyBfcGFkZGluZ0NoYXJhY3RlciA9IFwiPVwiOyB9XG4gICAgICAgIHRoaXMuX3BhZGRpbmdDaGFyYWN0ZXIgPSBfcGFkZGluZ0NoYXJhY3RlcjtcbiAgICB9XG4gICAgQ29kZXIucHJvdG90eXBlLmVuY29kZWRMZW5ndGggPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcGFkZGluZ0NoYXJhY3Rlcikge1xuICAgICAgICAgICAgcmV0dXJuIChsZW5ndGggKiA4ICsgNSkgLyA2IHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGxlbmd0aCArIDIpIC8gMyAqIDQgfCAwO1xuICAgIH07XG4gICAgQ29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBvdXQgPSBcIlwiO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgZGF0YS5sZW5ndGggLSAyOyBpICs9IDMpIHtcbiAgICAgICAgICAgIHZhciBjID0gKGRhdGFbaV0gPDwgMTYpIHwgKGRhdGFbaSArIDFdIDw8IDgpIHwgKGRhdGFbaSArIDJdKTtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLl9lbmNvZGVCeXRlKChjID4+PiAzICogNikgJiA2Myk7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5fZW5jb2RlQnl0ZSgoYyA+Pj4gMiAqIDYpICYgNjMpO1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMuX2VuY29kZUJ5dGUoKGMgPj4+IDEgKiA2KSAmIDYzKTtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLl9lbmNvZGVCeXRlKChjID4+PiAwICogNikgJiA2Myk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlZnQgPSBkYXRhLmxlbmd0aCAtIGk7XG4gICAgICAgIGlmIChsZWZ0ID4gMCkge1xuICAgICAgICAgICAgdmFyIGMgPSAoZGF0YVtpXSA8PCAxNikgfCAobGVmdCA9PT0gMiA/IGRhdGFbaSArIDFdIDw8IDggOiAwKTtcbiAgICAgICAgICAgIG91dCArPSB0aGlzLl9lbmNvZGVCeXRlKChjID4+PiAzICogNikgJiA2Myk7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5fZW5jb2RlQnl0ZSgoYyA+Pj4gMiAqIDYpICYgNjMpO1xuICAgICAgICAgICAgaWYgKGxlZnQgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5fZW5jb2RlQnl0ZSgoYyA+Pj4gMSAqIDYpICYgNjMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMuX3BhZGRpbmdDaGFyYWN0ZXIgfHwgXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSB0aGlzLl9wYWRkaW5nQ2hhcmFjdGVyIHx8IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIENvZGVyLnByb3RvdHlwZS5tYXhEZWNvZGVkTGVuZ3RoID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICBpZiAoIXRoaXMuX3BhZGRpbmdDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAobGVuZ3RoICogNiArIDcpIC8gOCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlbmd0aCAvIDQgKiAzIHwgMDtcbiAgICB9O1xuICAgIENvZGVyLnByb3RvdHlwZS5kZWNvZGVkTGVuZ3RoID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4RGVjb2RlZExlbmd0aChzLmxlbmd0aCAtIHRoaXMuX2dldFBhZGRpbmdMZW5ndGgocykpO1xuICAgIH07XG4gICAgQ29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYWRkaW5nTGVuZ3RoID0gdGhpcy5fZ2V0UGFkZGluZ0xlbmd0aChzKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHMubGVuZ3RoIC0gcGFkZGluZ0xlbmd0aDtcbiAgICAgICAgdmFyIG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMubWF4RGVjb2RlZExlbmd0aChsZW5ndGgpKTtcbiAgICAgICAgdmFyIG9wID0gMDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgaGF2ZUJhZCA9IDA7XG4gICAgICAgIHZhciB2MCA9IDAsIHYxID0gMCwgdjIgPSAwLCB2MyA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoIC0gNDsgaSArPSA0KSB7XG4gICAgICAgICAgICB2MCA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAwKSk7XG4gICAgICAgICAgICB2MSA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAxKSk7XG4gICAgICAgICAgICB2MiA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAyKSk7XG4gICAgICAgICAgICB2MyA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAzKSk7XG4gICAgICAgICAgICBvdXRbb3ArK10gPSAodjAgPDwgMikgfCAodjEgPj4+IDQpO1xuICAgICAgICAgICAgb3V0W29wKytdID0gKHYxIDw8IDQpIHwgKHYyID4+PiAyKTtcbiAgICAgICAgICAgIG91dFtvcCsrXSA9ICh2MiA8PCA2KSB8IHYzO1xuICAgICAgICAgICAgaGF2ZUJhZCB8PSB2MCAmIElOVkFMSURfQllURTtcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjEgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgICAgICBoYXZlQmFkIHw9IHYyICYgSU5WQUxJRF9CWVRFO1xuICAgICAgICAgICAgaGF2ZUJhZCB8PSB2MyAmIElOVkFMSURfQllURTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHYwID0gdGhpcy5fZGVjb2RlQ2hhcihzLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgICAgdjEgPSB0aGlzLl9kZWNvZGVDaGFyKHMuY2hhckNvZGVBdChpICsgMSkpO1xuICAgICAgICAgICAgb3V0W29wKytdID0gKHYwIDw8IDIpIHwgKHYxID4+PiA0KTtcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjAgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgICAgICBoYXZlQmFkIHw9IHYxICYgSU5WQUxJRF9CWVRFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpIDwgbGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgdjIgPSB0aGlzLl9kZWNvZGVDaGFyKHMuY2hhckNvZGVBdChpICsgMikpO1xuICAgICAgICAgICAgb3V0W29wKytdID0gKHYxIDw8IDQpIHwgKHYyID4+PiAyKTtcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjIgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCBsZW5ndGggLSAzKSB7XG4gICAgICAgICAgICB2MyA9IHRoaXMuX2RlY29kZUNoYXIocy5jaGFyQ29kZUF0KGkgKyAzKSk7XG4gICAgICAgICAgICBvdXRbb3ArK10gPSAodjIgPDwgNikgfCB2MztcbiAgICAgICAgICAgIGhhdmVCYWQgfD0gdjMgJiBJTlZBTElEX0JZVEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhdmVCYWQgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhc2U2NENvZGVyOiBpbmNvcnJlY3QgY2hhcmFjdGVycyBmb3IgZGVjb2RpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIC8vIFN0YW5kYXJkIGVuY29kaW5nIGhhdmUgdGhlIGZvbGxvd2luZyBlbmNvZGVkL2RlY29kZWQgcmFuZ2VzLFxuICAgIC8vIHdoaWNoIHdlIG5lZWQgdG8gY29udmVydCBiZXR3ZWVuLlxuICAgIC8vXG4gICAgLy8gQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVogYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXogMDEyMzQ1Njc4OSAgKyAgIC9cbiAgICAvLyBJbmRleDogICAwIC0gMjUgICAgICAgICAgICAgICAgICAgIDI2IC0gNTEgICAgICAgICAgICAgIDUyIC0gNjEgICA2MiAgNjNcbiAgICAvLyBBU0NJSTogIDY1IC0gOTAgICAgICAgICAgICAgICAgICAgIDk3IC0gMTIyICAgICAgICAgICAgIDQ4IC0gNTcgICA0MyAgNDdcbiAgICAvL1xuICAgIC8vIEVuY29kZSA2IGJpdHMgaW4gYiBpbnRvIGEgbmV3IGNoYXJhY3Rlci5cbiAgICBDb2Rlci5wcm90b3R5cGUuX2VuY29kZUJ5dGUgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAvLyBFbmNvZGluZyB1c2VzIGNvbnN0YW50IHRpbWUgb3BlcmF0aW9ucyBhcyBmb2xsb3dzOlxuICAgICAgICAvL1xuICAgICAgICAvLyAxLiBEZWZpbmUgY29tcGFyaXNvbiBvZiBBIHdpdGggQiB1c2luZyAoQSAtIEIpID4+PiA4OlxuICAgICAgICAvLyAgICAgICAgICBpZiBBID4gQiwgdGhlbiByZXN1bHQgaXMgcG9zaXRpdmUgaW50ZWdlclxuICAgICAgICAvLyAgICAgICAgICBpZiBBIDw9IEIsIHRoZW4gcmVzdWx0IGlzIDBcbiAgICAgICAgLy9cbiAgICAgICAgLy8gMi4gRGVmaW5lIHNlbGVjdGlvbiBvZiBDIG9yIDAgdXNpbmcgYml0d2lzZSBBTkQ6IFggJiBDOlxuICAgICAgICAvLyAgICAgICAgICBpZiBYID09IDAsIHRoZW4gcmVzdWx0IGlzIDBcbiAgICAgICAgLy8gICAgICAgICAgaWYgWCAhPSAwLCB0aGVuIHJlc3VsdCBpcyBDXG4gICAgICAgIC8vXG4gICAgICAgIC8vIDMuIFN0YXJ0IHdpdGggdGhlIHNtYWxsZXN0IGNvbXBhcmlzb24gKGIgPj0gMCksIHdoaWNoIGlzIGFsd2F5c1xuICAgICAgICAvLyAgICB0cnVlLCBzbyBzZXQgdGhlIHJlc3VsdCB0byB0aGUgc3RhcnRpbmcgQVNDSUkgdmFsdWUgKDY1KS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gNC4gQ29udGludWUgY29tcGFyaW5nIGIgdG8gaGlnaGVyIEFTQ0lJIHZhbHVlcywgYW5kIHNlbGVjdGluZ1xuICAgICAgICAvLyAgICB6ZXJvIGlmIGNvbXBhcmlzb24gaXNuJ3QgdHJ1ZSwgb3RoZXJ3aXNlIHNlbGVjdGluZyBhIHZhbHVlXG4gICAgICAgIC8vICAgIHRvIGFkZCB0byByZXN1bHQsIHdoaWNoOlxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgICBhKSB1bmRvZXMgdGhlIHByZXZpb3VzIGFkZGl0aW9uXG4gICAgICAgIC8vICAgICAgICAgIGIpIHByb3ZpZGVzIG5ldyB2YWx1ZSB0byBhZGRcbiAgICAgICAgLy9cbiAgICAgICAgdmFyIHJlc3VsdCA9IGI7XG4gICAgICAgIC8vIGIgPj0gMFxuICAgICAgICByZXN1bHQgKz0gNjU7XG4gICAgICAgIC8vIGIgPiAyNVxuICAgICAgICByZXN1bHQgKz0gKCgyNSAtIGIpID4+PiA4KSAmICgoMCAtIDY1KSAtIDI2ICsgOTcpO1xuICAgICAgICAvLyBiID4gNTFcbiAgICAgICAgcmVzdWx0ICs9ICgoNTEgLSBiKSA+Pj4gOCkgJiAoKDI2IC0gOTcpIC0gNTIgKyA0OCk7XG4gICAgICAgIC8vIGIgPiA2MVxuICAgICAgICByZXN1bHQgKz0gKCg2MSAtIGIpID4+PiA4KSAmICgoNTIgLSA0OCkgLSA2MiArIDQzKTtcbiAgICAgICAgLy8gYiA+IDYyXG4gICAgICAgIHJlc3VsdCArPSAoKDYyIC0gYikgPj4+IDgpICYgKCg2MiAtIDQzKSAtIDYzICsgNDcpO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShyZXN1bHQpO1xuICAgIH07XG4gICAgLy8gRGVjb2RlIGEgY2hhcmFjdGVyIGNvZGUgaW50byBhIGJ5dGUuXG4gICAgLy8gTXVzdCByZXR1cm4gMjU2IGlmIGNoYXJhY3RlciBpcyBvdXQgb2YgYWxwaGFiZXQgcmFuZ2UuXG4gICAgQ29kZXIucHJvdG90eXBlLl9kZWNvZGVDaGFyID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgLy8gRGVjb2Rpbmcgd29ya3Mgc2ltaWxhciB0byBlbmNvZGluZzogdXNpbmcgdGhlIHNhbWUgY29tcGFyaXNvblxuICAgICAgICAvLyBmdW5jdGlvbiwgYnV0IG5vdyBpdCB3b3JrcyBvbiByYW5nZXM6IHJlc3VsdCBpcyBhbHdheXMgaW5jcmVtZW50ZWRcbiAgICAgICAgLy8gYnkgdmFsdWUsIGJ1dCB0aGlzIHZhbHVlIGJlY29tZXMgemVybyBpZiB0aGUgcmFuZ2UgaXMgbm90XG4gICAgICAgIC8vIHNhdGlzZmllZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRGVjb2Rpbmcgc3RhcnRzIHdpdGggaW52YWxpZCB2YWx1ZSwgMjU2LCB3aGljaCBpcyB0aGVuXG4gICAgICAgIC8vIHN1YnRyYWN0ZWQgd2hlbiB0aGUgcmFuZ2UgaXMgc2F0aXNmaWVkLiBJZiBub25lIG9mIHRoZSByYW5nZXNcbiAgICAgICAgLy8gYXBwbHksIHRoZSBmdW5jdGlvbiByZXR1cm5zIDI1Niwgd2hpY2ggaXMgdGhlbiBjaGVja2VkIGJ5XG4gICAgICAgIC8vIHRoZSBjYWxsZXIgdG8gdGhyb3cgZXJyb3IuXG4gICAgICAgIHZhciByZXN1bHQgPSBJTlZBTElEX0JZVEU7IC8vIHN0YXJ0IHdpdGggaW52YWxpZCBjaGFyYWN0ZXJcbiAgICAgICAgLy8gYyA9PSA0MyAoYyA+IDQyIGFuZCBjIDwgNDQpXG4gICAgICAgIHJlc3VsdCArPSAoKCg0MiAtIGMpICYgKGMgLSA0NCkpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDQzICsgNjIpO1xuICAgICAgICAvLyBjID09IDQ3IChjID4gNDYgYW5kIGMgPCA0OClcbiAgICAgICAgcmVzdWx0ICs9ICgoKDQ2IC0gYykgJiAoYyAtIDQ4KSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gNDcgKyA2Myk7XG4gICAgICAgIC8vIGMgPiA0NyBhbmQgYyA8IDU4XG4gICAgICAgIHJlc3VsdCArPSAoKCg0NyAtIGMpICYgKGMgLSA1OCkpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDQ4ICsgNTIpO1xuICAgICAgICAvLyBjID4gNjQgYW5kIGMgPCA5MVxuICAgICAgICByZXN1bHQgKz0gKCgoNjQgLSBjKSAmIChjIC0gOTEpKSA+Pj4gOCkgJiAoLUlOVkFMSURfQllURSArIGMgLSA2NSArIDApO1xuICAgICAgICAvLyBjID4gOTYgYW5kIGMgPCAxMjNcbiAgICAgICAgcmVzdWx0ICs9ICgoKDk2IC0gYykgJiAoYyAtIDEyMykpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDk3ICsgMjYpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgQ29kZXIucHJvdG90eXBlLl9nZXRQYWRkaW5nTGVuZ3RoID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIHBhZGRpbmdMZW5ndGggPSAwO1xuICAgICAgICBpZiAodGhpcy5fcGFkZGluZ0NoYXJhY3Rlcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoc1tpXSAhPT0gdGhpcy5fcGFkZGluZ0NoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFkZGluZ0xlbmd0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMubGVuZ3RoIDwgNCB8fCBwYWRkaW5nTGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhc2U2NENvZGVyOiBpbmNvcnJlY3QgcGFkZGluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFkZGluZ0xlbmd0aDtcbiAgICB9O1xuICAgIHJldHVybiBDb2Rlcjtcbn0oKSk7XG5leHBvcnRzLkNvZGVyID0gQ29kZXI7XG52YXIgc3RkQ29kZXIgPSBuZXcgQ29kZXIoKTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gICAgcmV0dXJuIHN0ZENvZGVyLmVuY29kZShkYXRhKTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZnVuY3Rpb24gZGVjb2RlKHMpIHtcbiAgICByZXR1cm4gc3RkQ29kZXIuZGVjb2RlKHMpO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4vKipcbiAqIEltcGxlbWVudHMgVVJMLXNhZmUgQmFzZTY0IGVuY29kaW5nLlxuICogKFNhbWUgYXMgQmFzZTY0LCBidXQgJysnIGlzIHJlcGxhY2VkIHdpdGggJy0nLCBhbmQgJy8nIHdpdGggJ18nKS5cbiAqXG4gKiBPcGVyYXRlcyBpbiBjb25zdGFudCB0aW1lLlxuICovXG52YXIgVVJMU2FmZUNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVUkxTYWZlQ29kZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVVJMU2FmZUNvZGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8vIFVSTC1zYWZlIGVuY29kaW5nIGhhdmUgdGhlIGZvbGxvd2luZyBlbmNvZGVkL2RlY29kZWQgcmFuZ2VzOlxuICAgIC8vXG4gICAgLy8gQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVogYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXogMDEyMzQ1Njc4OSAgLSAgIF9cbiAgICAvLyBJbmRleDogICAwIC0gMjUgICAgICAgICAgICAgICAgICAgIDI2IC0gNTEgICAgICAgICAgICAgIDUyIC0gNjEgICA2MiAgNjNcbiAgICAvLyBBU0NJSTogIDY1IC0gOTAgICAgICAgICAgICAgICAgICAgIDk3IC0gMTIyICAgICAgICAgICAgIDQ4IC0gNTcgICA0NSAgOTVcbiAgICAvL1xuICAgIFVSTFNhZmVDb2Rlci5wcm90b3R5cGUuX2VuY29kZUJ5dGUgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gYjtcbiAgICAgICAgLy8gYiA+PSAwXG4gICAgICAgIHJlc3VsdCArPSA2NTtcbiAgICAgICAgLy8gYiA+IDI1XG4gICAgICAgIHJlc3VsdCArPSAoKDI1IC0gYikgPj4+IDgpICYgKCgwIC0gNjUpIC0gMjYgKyA5Nyk7XG4gICAgICAgIC8vIGIgPiA1MVxuICAgICAgICByZXN1bHQgKz0gKCg1MSAtIGIpID4+PiA4KSAmICgoMjYgLSA5NykgLSA1MiArIDQ4KTtcbiAgICAgICAgLy8gYiA+IDYxXG4gICAgICAgIHJlc3VsdCArPSAoKDYxIC0gYikgPj4+IDgpICYgKCg1MiAtIDQ4KSAtIDYyICsgNDUpO1xuICAgICAgICAvLyBiID4gNjJcbiAgICAgICAgcmVzdWx0ICs9ICgoNjIgLSBiKSA+Pj4gOCkgJiAoKDYyIC0gNDUpIC0gNjMgKyA5NSk7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHJlc3VsdCk7XG4gICAgfTtcbiAgICBVUkxTYWZlQ29kZXIucHJvdG90eXBlLl9kZWNvZGVDaGFyID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IElOVkFMSURfQllURTtcbiAgICAgICAgLy8gYyA9PSA0NSAoYyA+IDQ0IGFuZCBjIDwgNDYpXG4gICAgICAgIHJlc3VsdCArPSAoKCg0NCAtIGMpICYgKGMgLSA0NikpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDQ1ICsgNjIpO1xuICAgICAgICAvLyBjID09IDk1IChjID4gOTQgYW5kIGMgPCA5NilcbiAgICAgICAgcmVzdWx0ICs9ICgoKDk0IC0gYykgJiAoYyAtIDk2KSkgPj4+IDgpICYgKC1JTlZBTElEX0JZVEUgKyBjIC0gOTUgKyA2Myk7XG4gICAgICAgIC8vIGMgPiA0NyBhbmQgYyA8IDU4XG4gICAgICAgIHJlc3VsdCArPSAoKCg0NyAtIGMpICYgKGMgLSA1OCkpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDQ4ICsgNTIpO1xuICAgICAgICAvLyBjID4gNjQgYW5kIGMgPCA5MVxuICAgICAgICByZXN1bHQgKz0gKCgoNjQgLSBjKSAmIChjIC0gOTEpKSA+Pj4gOCkgJiAoLUlOVkFMSURfQllURSArIGMgLSA2NSArIDApO1xuICAgICAgICAvLyBjID4gOTYgYW5kIGMgPCAxMjNcbiAgICAgICAgcmVzdWx0ICs9ICgoKDk2IC0gYykgJiAoYyAtIDEyMykpID4+PiA4KSAmICgtSU5WQUxJRF9CWVRFICsgYyAtIDk3ICsgMjYpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFVSTFNhZmVDb2Rlcjtcbn0oQ29kZXIpKTtcbmV4cG9ydHMuVVJMU2FmZUNvZGVyID0gVVJMU2FmZUNvZGVyO1xudmFyIHVybFNhZmVDb2RlciA9IG5ldyBVUkxTYWZlQ29kZXIoKTtcbmZ1bmN0aW9uIGVuY29kZVVSTFNhZmUoZGF0YSkge1xuICAgIHJldHVybiB1cmxTYWZlQ29kZXIuZW5jb2RlKGRhdGEpO1xufVxuZXhwb3J0cy5lbmNvZGVVUkxTYWZlID0gZW5jb2RlVVJMU2FmZTtcbmZ1bmN0aW9uIGRlY29kZVVSTFNhZmUocykge1xuICAgIHJldHVybiB1cmxTYWZlQ29kZXIuZGVjb2RlKHMpO1xufVxuZXhwb3J0cy5kZWNvZGVVUkxTYWZlID0gZGVjb2RlVVJMU2FmZTtcbmV4cG9ydHMuZW5jb2RlZExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICByZXR1cm4gc3RkQ29kZXIuZW5jb2RlZExlbmd0aChsZW5ndGgpO1xufTtcbmV4cG9ydHMubWF4RGVjb2RlZExlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICByZXR1cm4gc3RkQ29kZXIubWF4RGVjb2RlZExlbmd0aChsZW5ndGgpO1xufTtcbmV4cG9ydHMuZGVjb2RlZExlbmd0aCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHN0ZENvZGVyLmRlY29kZWRMZW5ndGgocyk7XG59O1xuXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gQ29weXJpZ2h0IChDKSAyMDE2IERtaXRyeSBDaGVzdG55a2hcbi8vIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGZvciBkZXRhaWxzLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBQYWNrYWdlIHV0ZjggaW1wbGVtZW50cyBVVEYtOCBlbmNvZGluZyBhbmQgZGVjb2RpbmcuXG4gKi9cbnZhciBJTlZBTElEX1VURjE2ID0gXCJ1dGY4OiBpbnZhbGlkIHN0cmluZ1wiO1xudmFyIElOVkFMSURfVVRGOCA9IFwidXRmODogaW52YWxpZCBzb3VyY2UgZW5jb2RpbmdcIjtcbi8qKlxuICogRW5jb2RlcyB0aGUgZ2l2ZW4gc3RyaW5nIGludG8gVVRGLTggYnl0ZSBhcnJheS5cbiAqIFRocm93cyBpZiB0aGUgc291cmNlIHN0cmluZyBoYXMgaW52YWxpZCBVVEYtMTYgZW5jb2RpbmcuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShzKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHJlc3VsdCBsZW5ndGggYW5kIGFsbG9jYXRlIG91dHB1dCBhcnJheS5cbiAgICAvLyBlbmNvZGVkTGVuZ3RoKCkgYWxzbyB2YWxpZGF0ZXMgc3RyaW5nIGFuZCB0aHJvd3MgZXJyb3JzLFxuICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgcmVwZWF0IHZhbGlkYXRpb24gaGVyZS5cbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZExlbmd0aChzKSk7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4YzAgfCBjID4+IDY7XG4gICAgICAgICAgICBhcnJbcG9zKytdID0gMHg4MCB8IGMgJiAweDNmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweGQ4MDApIHtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweGUwIHwgYyA+PiAxMjtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweDgwIHwgKGMgPj4gNikgJiAweDNmO1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ODAgfCBjICYgMHgzZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGkrKzsgLy8gZ2V0IG9uZSBtb3JlIGNoYXJhY3RlclxuICAgICAgICAgICAgYyA9IChjICYgMHgzZmYpIDw8IDEwO1xuICAgICAgICAgICAgYyB8PSBzLmNoYXJDb2RlQXQoaSkgJiAweDNmZjtcbiAgICAgICAgICAgIGMgKz0gMHgxMDAwMDtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweGYwIHwgYyA+PiAxODtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweDgwIHwgKGMgPj4gMTIpICYgMHgzZjtcbiAgICAgICAgICAgIGFycltwb3MrK10gPSAweDgwIHwgKGMgPj4gNikgJiAweDNmO1xuICAgICAgICAgICAgYXJyW3BvcysrXSA9IDB4ODAgfCBjICYgMHgzZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBieXRlcyByZXF1aXJlZCB0byBlbmNvZGUgdGhlIGdpdmVuIHN0cmluZyBpbnRvIFVURi04LlxuICogVGhyb3dzIGlmIHRoZSBzb3VyY2Ugc3RyaW5nIGhhcyBpbnZhbGlkIFVURi0xNiBlbmNvZGluZy5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlZExlbmd0aChzKSB7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ZDgwMCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgIGlmIChpID49IHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKzsgLy8gXCJlYXRcIiBuZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgcmVzdWx0ICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEYxNik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZW5jb2RlZExlbmd0aCA9IGVuY29kZWRMZW5ndGg7XG4vKipcbiAqIERlY29kZXMgdGhlIGdpdmVuIGJ5dGUgYXJyYXkgZnJvbSBVVEYtOCBpbnRvIGEgc3RyaW5nLlxuICogVGhyb3dzIGlmIGVuY29kaW5nIGlzIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShhcnIpIHtcbiAgICB2YXIgY2hhcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYiA9IGFycltpXTtcbiAgICAgICAgaWYgKGIgJiAweDgwKSB7XG4gICAgICAgICAgICB2YXIgbWluID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGIgPCAweGUwKSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCAxIG1vcmUgYnl0ZS5cbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbjEgPSBhcnJbKytpXTtcbiAgICAgICAgICAgICAgICBpZiAoKG4xICYgMHhjMCkgIT09IDB4ODApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGIgPSAoYiAmIDB4MWYpIDw8IDYgfCAobjEgJiAweDNmKTtcbiAgICAgICAgICAgICAgICBtaW4gPSAweDgwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYiA8IDB4ZjApIHtcbiAgICAgICAgICAgICAgICAvLyBOZWVkIDIgbW9yZSBieXRlcy5cbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBhcnIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG4xID0gYXJyWysraV07XG4gICAgICAgICAgICAgICAgdmFyIG4yID0gYXJyWysraV07XG4gICAgICAgICAgICAgICAgaWYgKChuMSAmIDB4YzApICE9PSAweDgwIHx8IChuMiAmIDB4YzApICE9PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX1VURjgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiID0gKGIgJiAweDBmKSA8PCAxMiB8IChuMSAmIDB4M2YpIDw8IDYgfCAobjIgJiAweDNmKTtcbiAgICAgICAgICAgICAgICBtaW4gPSAweDgwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGIgPCAweGY4KSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCAzIG1vcmUgYnl0ZXMuXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gYXJyLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuMSA9IGFyclsrK2ldO1xuICAgICAgICAgICAgICAgIHZhciBuMiA9IGFyclsrK2ldO1xuICAgICAgICAgICAgICAgIHZhciBuMyA9IGFyclsrK2ldO1xuICAgICAgICAgICAgICAgIGlmICgobjEgJiAweGMwKSAhPT0gMHg4MCB8fCAobjIgJiAweGMwKSAhPT0gMHg4MCB8fCAobjMgJiAweGMwKSAhPT0gMHg4MCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYiA9IChiICYgMHgwZikgPDwgMTggfCAobjEgJiAweDNmKSA8PCAxMiB8IChuMiAmIDB4M2YpIDw8IDYgfCAobjMgJiAweDNmKTtcbiAgICAgICAgICAgICAgICBtaW4gPSAweDEwMDAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYiA8IG1pbiB8fCAoYiA+PSAweGQ4MDAgJiYgYiA8PSAweGRmZmYpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfVVRGOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYiA+PSAweDEwMDAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU3Vycm9nYXRlIHBhaXIuXG4gICAgICAgICAgICAgICAgaWYgKGIgPiAweDEwZmZmZikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9VVEY4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYiAtPSAweDEwMDAwO1xuICAgICAgICAgICAgICAgIGNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MDAgfCAoYiA+PiAxMCkpKTtcbiAgICAgICAgICAgICAgICBiID0gMHhkYzAwIHwgKGIgJiAweDNmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oXCJcIik7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcblxuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gcmVxdWlyZWQgc28gd2UgZG9uJ3QgaGF2ZSB0byBkbyByZXF1aXJlKCdwdXNoZXInKS5kZWZhdWx0IGV0Yy5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKS5kZWZhdWx0O1xuXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIEVTTSBDT01QQVQgRkxBR1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvZG9tL3NjcmlwdF9yZWNlaXZlcl9mYWN0b3J5LnRzXG52YXIgU2NyaXB0UmVjZWl2ZXJGYWN0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY3JpcHRSZWNlaXZlckZhY3RvcnkocHJlZml4LCBuYW1lKSB7XG4gICAgICAgIHRoaXMubGFzdElkID0gMDtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIFNjcmlwdFJlY2VpdmVyRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubGFzdElkKys7XG4gICAgICAgIHZhciBudW1iZXIgPSB0aGlzLmxhc3RJZDtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5wcmVmaXggKyBudW1iZXI7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lICsgJ1snICsgbnVtYmVyICsgJ10nO1xuICAgICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBjYWxsYmFja1dyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpc1tudW1iZXJdID0gY2FsbGJhY2tXcmFwcGVyO1xuICAgICAgICByZXR1cm4geyBudW1iZXI6IG51bWJlciwgaWQ6IGlkLCBuYW1lOiBuYW1lLCBjYWxsYmFjazogY2FsbGJhY2tXcmFwcGVyIH07XG4gICAgfTtcbiAgICBTY3JpcHRSZWNlaXZlckZhY3RvcnkucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChyZWNlaXZlcikge1xuICAgICAgICBkZWxldGUgdGhpc1tyZWNlaXZlci5udW1iZXJdO1xuICAgIH07XG4gICAgcmV0dXJuIFNjcmlwdFJlY2VpdmVyRmFjdG9yeTtcbn0oKSk7XG5cbnZhciBTY3JpcHRSZWNlaXZlcnMgPSBuZXcgU2NyaXB0UmVjZWl2ZXJGYWN0b3J5KCdfcHVzaGVyX3NjcmlwdF8nLCAnUHVzaGVyLlNjcmlwdFJlY2VpdmVycycpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2RlZmF1bHRzLnRzXG52YXIgRGVmYXVsdHMgPSB7XG4gICAgVkVSU0lPTjogXCI4LjAuMlwiLFxuICAgIFBST1RPQ09MOiA3LFxuICAgIHdzUG9ydDogODAsXG4gICAgd3NzUG9ydDogNDQzLFxuICAgIHdzUGF0aDogJycsXG4gICAgaHR0cEhvc3Q6ICdzb2NranMucHVzaGVyLmNvbScsXG4gICAgaHR0cFBvcnQ6IDgwLFxuICAgIGh0dHBzUG9ydDogNDQzLFxuICAgIGh0dHBQYXRoOiAnL3B1c2hlcicsXG4gICAgc3RhdHNfaG9zdDogJ3N0YXRzLnB1c2hlci5jb20nLFxuICAgIGF1dGhFbmRwb2ludDogJy9wdXNoZXIvYXV0aCcsXG4gICAgYXV0aFRyYW5zcG9ydDogJ2FqYXgnLFxuICAgIGFjdGl2aXR5VGltZW91dDogMTIwMDAwLFxuICAgIHBvbmdUaW1lb3V0OiAzMDAwMCxcbiAgICB1bmF2YWlsYWJsZVRpbWVvdXQ6IDEwMDAwLFxuICAgIHVzZXJBdXRoZW50aWNhdGlvbjoge1xuICAgICAgICBlbmRwb2ludDogJy9wdXNoZXIvdXNlci1hdXRoJyxcbiAgICAgICAgdHJhbnNwb3J0OiAnYWpheCdcbiAgICB9LFxuICAgIGNoYW5uZWxBdXRob3JpemF0aW9uOiB7XG4gICAgICAgIGVuZHBvaW50OiAnL3B1c2hlci9hdXRoJyxcbiAgICAgICAgdHJhbnNwb3J0OiAnYWpheCdcbiAgICB9LFxuICAgIGNkbl9odHRwOiBcImh0dHA6Ly9qcy5wdXNoZXIuY29tXCIsXG4gICAgY2RuX2h0dHBzOiBcImh0dHBzOi8vanMucHVzaGVyLmNvbVwiLFxuICAgIGRlcGVuZGVuY3lfc3VmZml4OiBcIlwiXG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZGVmYXVsdHMgPSAoRGVmYXVsdHMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvZG9tL2RlcGVuZGVuY3lfbG9hZGVyLnRzXG5cblxudmFyIGRlcGVuZGVuY3lfbG9hZGVyX0RlcGVuZGVuY3lMb2FkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlcGVuZGVuY3lMb2FkZXIob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnJlY2VpdmVycyA9IG9wdGlvbnMucmVjZWl2ZXJzIHx8IFNjcmlwdFJlY2VpdmVycztcbiAgICAgICAgdGhpcy5sb2FkaW5nID0ge307XG4gICAgfVxuICAgIERlcGVuZGVuY3lMb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAobmFtZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZi5sb2FkaW5nW25hbWVdICYmIHNlbGYubG9hZGluZ1tuYW1lXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzZWxmLmxvYWRpbmdbbmFtZV0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmxvYWRpbmdbbmFtZV0gPSBbY2FsbGJhY2tdO1xuICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBydW50aW1lLmNyZWF0ZVNjcmlwdFJlcXVlc3Qoc2VsZi5nZXRQYXRoKG5hbWUsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIHZhciByZWNlaXZlciA9IHNlbGYucmVjZWl2ZXJzLmNyZWF0ZShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlY2VpdmVycy5yZW1vdmUocmVjZWl2ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmxvYWRpbmdbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHNlbGYubG9hZGluZ1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNlbGYubG9hZGluZ1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3NDYWxsYmFjayA9IGZ1bmN0aW9uICh3YXNTdWNjZXNzZnVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdhc1N1Y2Nlc3NmdWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXShlcnJvciwgc3VjY2Vzc0NhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVxdWVzdC5zZW5kKHJlY2VpdmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVwZW5kZW5jeUxvYWRlci5wcm90b3R5cGUuZ2V0Um9vdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBjZG47XG4gICAgICAgIHZhciBwcm90b2NvbCA9IHJ1bnRpbWUuZ2V0RG9jdW1lbnQoKS5sb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgICAgaWYgKChvcHRpb25zICYmIG9wdGlvbnMudXNlVExTKSB8fCBwcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICAgIGNkbiA9IHRoaXMub3B0aW9ucy5jZG5faHR0cHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjZG4gPSB0aGlzLm9wdGlvbnMuY2RuX2h0dHA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNkbi5yZXBsYWNlKC9cXC8qJC8sICcnKSArICcvJyArIHRoaXMub3B0aW9ucy52ZXJzaW9uO1xuICAgIH07XG4gICAgRGVwZW5kZW5jeUxvYWRlci5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uIChuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJvb3Qob3B0aW9ucykgKyAnLycgKyBuYW1lICsgdGhpcy5vcHRpb25zLnN1ZmZpeCArICcuanMnO1xuICAgIH07XG4gICAgcmV0dXJuIERlcGVuZGVuY3lMb2FkZXI7XG59KCkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZGVwZW5kZW5jeV9sb2FkZXIgPSAoZGVwZW5kZW5jeV9sb2FkZXJfRGVwZW5kZW5jeUxvYWRlcik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL3dlYi9kb20vZGVwZW5kZW5jaWVzLnRzXG5cblxuXG52YXIgRGVwZW5kZW5jaWVzUmVjZWl2ZXJzID0gbmV3IFNjcmlwdFJlY2VpdmVyRmFjdG9yeSgnX3B1c2hlcl9kZXBlbmRlbmNpZXMnLCAnUHVzaGVyLkRlcGVuZGVuY2llc1JlY2VpdmVycycpO1xudmFyIERlcGVuZGVuY2llcyA9IG5ldyBkZXBlbmRlbmN5X2xvYWRlcih7XG4gICAgY2RuX2h0dHA6IGRlZmF1bHRzLmNkbl9odHRwLFxuICAgIGNkbl9odHRwczogZGVmYXVsdHMuY2RuX2h0dHBzLFxuICAgIHZlcnNpb246IGRlZmF1bHRzLlZFUlNJT04sXG4gICAgc3VmZml4OiBkZWZhdWx0cy5kZXBlbmRlbmN5X3N1ZmZpeCxcbiAgICByZWNlaXZlcnM6IERlcGVuZGVuY2llc1JlY2VpdmVyc1xufSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdXRpbHMvdXJsX3N0b3JlLnRzXG52YXIgdXJsU3RvcmUgPSB7XG4gICAgYmFzZVVybDogJ2h0dHBzOi8vcHVzaGVyLmNvbScsXG4gICAgdXJsczoge1xuICAgICAgICBhdXRoZW50aWNhdGlvbkVuZHBvaW50OiB7XG4gICAgICAgICAgICBwYXRoOiAnL2RvY3MvY2hhbm5lbHMvc2VydmVyX2FwaS9hdXRoZW50aWNhdGluZ191c2VycydcbiAgICAgICAgfSxcbiAgICAgICAgYXV0aG9yaXphdGlvbkVuZHBvaW50OiB7XG4gICAgICAgICAgICBwYXRoOiAnL2RvY3MvY2hhbm5lbHMvc2VydmVyX2FwaS9hdXRob3JpemluZy11c2Vycy8nXG4gICAgICAgIH0sXG4gICAgICAgIGphdmFzY3JpcHRRdWlja1N0YXJ0OiB7XG4gICAgICAgICAgICBwYXRoOiAnL2RvY3MvamF2YXNjcmlwdF9xdWlja19zdGFydCdcbiAgICAgICAgfSxcbiAgICAgICAgdHJpZ2dlcmluZ0NsaWVudEV2ZW50czoge1xuICAgICAgICAgICAgcGF0aDogJy9kb2NzL2NsaWVudF9hcGlfZ3VpZGUvY2xpZW50X2V2ZW50cyN0cmlnZ2VyLWV2ZW50cydcbiAgICAgICAgfSxcbiAgICAgICAgZW5jcnlwdGVkQ2hhbm5lbFN1cHBvcnQ6IHtcbiAgICAgICAgICAgIGZ1bGxVcmw6ICdodHRwczovL2dpdGh1Yi5jb20vcHVzaGVyL3B1c2hlci1qcy90cmVlL2NjNDkxMDE1MzcxYTRiZGU1NzQzZDFjODdhMGZiYWMwZmViNTMxOTUjZW5jcnlwdGVkLWNoYW5uZWwtc3VwcG9ydCdcbiAgICAgICAgfVxuICAgIH1cbn07XG52YXIgYnVpbGRMb2dTdWZmaXggPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHVybFByZWZpeCA9ICdTZWU6JztcbiAgICB2YXIgdXJsT2JqID0gdXJsU3RvcmUudXJsc1trZXldO1xuICAgIGlmICghdXJsT2JqKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgdmFyIHVybDtcbiAgICBpZiAodXJsT2JqLmZ1bGxVcmwpIHtcbiAgICAgICAgdXJsID0gdXJsT2JqLmZ1bGxVcmw7XG4gICAgfVxuICAgIGVsc2UgaWYgKHVybE9iai5wYXRoKSB7XG4gICAgICAgIHVybCA9IHVybFN0b3JlLmJhc2VVcmwgKyB1cmxPYmoucGF0aDtcbiAgICB9XG4gICAgaWYgKCF1cmwpXG4gICAgICAgIHJldHVybiAnJztcbiAgICByZXR1cm4gdXJsUHJlZml4ICsgXCIgXCIgKyB1cmw7XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdXJsX3N0b3JlID0gKHsgYnVpbGRMb2dTdWZmaXg6IGJ1aWxkTG9nU3VmZml4IH0pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2F1dGgvb3B0aW9ucy50c1xudmFyIEF1dGhSZXF1ZXN0VHlwZTtcbihmdW5jdGlvbiAoQXV0aFJlcXVlc3RUeXBlKSB7XG4gICAgQXV0aFJlcXVlc3RUeXBlW1wiVXNlckF1dGhlbnRpY2F0aW9uXCJdID0gXCJ1c2VyLWF1dGhlbnRpY2F0aW9uXCI7XG4gICAgQXV0aFJlcXVlc3RUeXBlW1wiQ2hhbm5lbEF1dGhvcml6YXRpb25cIl0gPSBcImNoYW5uZWwtYXV0aG9yaXphdGlvblwiO1xufSkoQXV0aFJlcXVlc3RUeXBlIHx8IChBdXRoUmVxdWVzdFR5cGUgPSB7fSkpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2Vycm9ycy50c1xudmFyIF9fZXh0ZW5kcyA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIEJhZEV2ZW50TmFtZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJhZEV2ZW50TmFtZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCYWRFdmVudE5hbWUobXNnKSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbXNnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIF9uZXdUYXJnZXQucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQmFkRXZlbnROYW1lO1xufShFcnJvcikpO1xuXG52YXIgQmFkQ2hhbm5lbE5hbWUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCYWRDaGFubmVsTmFtZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCYWRDaGFubmVsTmFtZShtc2cpIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtc2cpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgX25ld1RhcmdldC5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBCYWRDaGFubmVsTmFtZTtcbn0oRXJyb3IpKTtcblxudmFyIFJlcXVlc3RUaW1lZE91dCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlcXVlc3RUaW1lZE91dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXF1ZXN0VGltZWRPdXQobXNnKSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbXNnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIF9uZXdUYXJnZXQucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmVxdWVzdFRpbWVkT3V0O1xufShFcnJvcikpO1xuXG52YXIgVHJhbnNwb3J0UHJpb3JpdHlUb29Mb3cgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcmFuc3BvcnRQcmlvcml0eVRvb0xvdywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUcmFuc3BvcnRQcmlvcml0eVRvb0xvdyhtc2cpIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtc2cpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgX25ld1RhcmdldC5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBUcmFuc3BvcnRQcmlvcml0eVRvb0xvdztcbn0oRXJyb3IpKTtcblxudmFyIFRyYW5zcG9ydENsb3NlZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRyYW5zcG9ydENsb3NlZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUcmFuc3BvcnRDbG9zZWQobXNnKSB7XG4gICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbXNnKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIF9uZXdUYXJnZXQucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVHJhbnNwb3J0Q2xvc2VkO1xufShFcnJvcikpO1xuXG52YXIgVW5zdXBwb3J0ZWRGZWF0dXJlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVW5zdXBwb3J0ZWRGZWF0dXJlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVuc3VwcG9ydGVkRmVhdHVyZShtc2cpIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtc2cpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgX25ld1RhcmdldC5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBVbnN1cHBvcnRlZEZlYXR1cmU7XG59KEVycm9yKSk7XG5cbnZhciBVbnN1cHBvcnRlZFRyYW5zcG9ydCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFVuc3VwcG9ydGVkVHJhbnNwb3J0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVuc3VwcG9ydGVkVHJhbnNwb3J0KG1zZykge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1zZykgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBfbmV3VGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFVuc3VwcG9ydGVkVHJhbnNwb3J0O1xufShFcnJvcikpO1xuXG52YXIgVW5zdXBwb3J0ZWRTdHJhdGVneSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFVuc3VwcG9ydGVkU3RyYXRlZ3ksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVW5zdXBwb3J0ZWRTdHJhdGVneShtc2cpIHtcbiAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtc2cpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgX25ld1RhcmdldC5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBVbnN1cHBvcnRlZFN0cmF0ZWd5O1xufShFcnJvcikpO1xuXG52YXIgSFRUUEF1dGhFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhUVFBBdXRoRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSFRUUEF1dGhFcnJvcihzdGF0dXMsIG1zZykge1xuICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1zZykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIF9uZXdUYXJnZXQucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSFRUUEF1dGhFcnJvcjtcbn0oRXJyb3IpKTtcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9pc29tb3JwaGljL2F1dGgveGhyX2F1dGgudHNcblxuXG5cblxudmFyIGFqYXggPSBmdW5jdGlvbiAoY29udGV4dCwgcXVlcnksIGF1dGhPcHRpb25zLCBhdXRoUmVxdWVzdFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHhociA9IHJ1bnRpbWUuY3JlYXRlWEhSKCk7XG4gICAgeGhyLm9wZW4oJ1BPU1QnLCBhdXRoT3B0aW9ucy5lbmRwb2ludCwgdHJ1ZSk7XG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICBmb3IgKHZhciBoZWFkZXJOYW1lIGluIGF1dGhPcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSwgYXV0aE9wdGlvbnMuaGVhZGVyc1toZWFkZXJOYW1lXSk7XG4gICAgfVxuICAgIGlmIChhdXRoT3B0aW9ucy5oZWFkZXJzUHJvdmlkZXIgIT0gbnVsbCkge1xuICAgICAgICB2YXIgZHluYW1pY0hlYWRlcnMgPSBhdXRoT3B0aW9ucy5oZWFkZXJzUHJvdmlkZXIoKTtcbiAgICAgICAgZm9yICh2YXIgaGVhZGVyTmFtZSBpbiBkeW5hbWljSGVhZGVycykge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSwgZHluYW1pY0hlYWRlcnNbaGVhZGVyTmFtZV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEhUVFBBdXRoRXJyb3IoMjAwLCBcIkpTT04gcmV0dXJuZWQgZnJvbSBcIiArIGF1dGhSZXF1ZXN0VHlwZS50b1N0cmluZygpICsgXCIgZW5kcG9pbnQgd2FzIGludmFsaWQsIHlldCBzdGF0dXMgY29kZSB3YXMgMjAwLiBEYXRhIHdhczogXCIgKyB4aHIucmVzcG9uc2VUZXh0KSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1ZmZpeCA9ICcnO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYXV0aFJlcXVlc3RUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0aFJlcXVlc3RUeXBlLlVzZXJBdXRoZW50aWNhdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9IHVybF9zdG9yZS5idWlsZExvZ1N1ZmZpeCgnYXV0aGVudGljYXRpb25FbmRwb2ludCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQXV0aFJlcXVlc3RUeXBlLkNoYW5uZWxBdXRob3JpemF0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gXCJDbGllbnRzIG11c3QgYmUgYXV0aG9yaXplZCB0byBqb2luIHByaXZhdGUgb3IgcHJlc2VuY2UgY2hhbm5lbHMuIFwiICsgdXJsX3N0b3JlLmJ1aWxkTG9nU3VmZml4KCdhdXRob3JpemF0aW9uRW5kcG9pbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgSFRUUEF1dGhFcnJvcih4aHIuc3RhdHVzLCBcIlVuYWJsZSB0byByZXRyaWV2ZSBhdXRoIHN0cmluZyBmcm9tIFwiICsgYXV0aFJlcXVlc3RUeXBlLnRvU3RyaW5nKCkgKyBcIiBlbmRwb2ludCAtIFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwicmVjZWl2ZWQgc3RhdHVzOiBcIiArIHhoci5zdGF0dXMgKyBcIiBmcm9tIFwiICsgYXV0aE9wdGlvbnMuZW5kcG9pbnQgKyBcIi4gXCIgKyBzdWZmaXgpKSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHhoci5zZW5kKHF1ZXJ5KTtcbiAgICByZXR1cm4geGhyO1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHhocl9hdXRoID0gKGFqYXgpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2Jhc2U2NC50c1xuZnVuY3Rpb24gZW5jb2RlKHMpIHtcbiAgICByZXR1cm4gYnRvYSh1dG9iKHMpKTtcbn1cbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xudmFyIGI2NGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xudmFyIGI2NHRhYiA9IHt9O1xuZm9yICh2YXIgYmFzZTY0X2kgPSAwLCBsID0gYjY0Y2hhcnMubGVuZ3RoOyBiYXNlNjRfaSA8IGw7IGJhc2U2NF9pKyspIHtcbiAgICBiNjR0YWJbYjY0Y2hhcnMuY2hhckF0KGJhc2U2NF9pKV0gPSBiYXNlNjRfaTtcbn1cbnZhciBjYl91dG9iID0gZnVuY3Rpb24gKGMpIHtcbiAgICB2YXIgY2MgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgcmV0dXJuIGNjIDwgMHg4MFxuICAgICAgICA/IGNcbiAgICAgICAgOiBjYyA8IDB4ODAwXG4gICAgICAgICAgICA/IGZyb21DaGFyQ29kZSgweGMwIHwgKGNjID4+PiA2KSkgKyBmcm9tQ2hhckNvZGUoMHg4MCB8IChjYyAmIDB4M2YpKVxuICAgICAgICAgICAgOiBmcm9tQ2hhckNvZGUoMHhlMCB8ICgoY2MgPj4+IDEyKSAmIDB4MGYpKSArXG4gICAgICAgICAgICAgICAgZnJvbUNoYXJDb2RlKDB4ODAgfCAoKGNjID4+PiA2KSAmIDB4M2YpKSArXG4gICAgICAgICAgICAgICAgZnJvbUNoYXJDb2RlKDB4ODAgfCAoY2MgJiAweDNmKSk7XG59O1xudmFyIHV0b2IgPSBmdW5jdGlvbiAodSkge1xuICAgIHJldHVybiB1LnJlcGxhY2UoL1teXFx4MDAtXFx4N0ZdL2csIGNiX3V0b2IpO1xufTtcbnZhciBjYl9lbmNvZGUgPSBmdW5jdGlvbiAoY2NjKSB7XG4gICAgdmFyIHBhZGxlbiA9IFswLCAyLCAxXVtjY2MubGVuZ3RoICUgM107XG4gICAgdmFyIG9yZCA9IChjY2MuY2hhckNvZGVBdCgwKSA8PCAxNikgfFxuICAgICAgICAoKGNjYy5sZW5ndGggPiAxID8gY2NjLmNoYXJDb2RlQXQoMSkgOiAwKSA8PCA4KSB8XG4gICAgICAgIChjY2MubGVuZ3RoID4gMiA/IGNjYy5jaGFyQ29kZUF0KDIpIDogMCk7XG4gICAgdmFyIGNoYXJzID0gW1xuICAgICAgICBiNjRjaGFycy5jaGFyQXQob3JkID4+PiAxOCksXG4gICAgICAgIGI2NGNoYXJzLmNoYXJBdCgob3JkID4+PiAxMikgJiA2MyksXG4gICAgICAgIHBhZGxlbiA+PSAyID8gJz0nIDogYjY0Y2hhcnMuY2hhckF0KChvcmQgPj4+IDYpICYgNjMpLFxuICAgICAgICBwYWRsZW4gPj0gMSA/ICc9JyA6IGI2NGNoYXJzLmNoYXJBdChvcmQgJiA2MylcbiAgICBdO1xuICAgIHJldHVybiBjaGFycy5qb2luKCcnKTtcbn07XG52YXIgYnRvYSA9IHdpbmRvdy5idG9hIHx8XG4gICAgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIGIucmVwbGFjZSgvW1xcc1xcU117MSwzfS9nLCBjYl9lbmNvZGUpO1xuICAgIH07XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdXRpbHMvdGltZXJzL2Fic3RyYWN0X3RpbWVyLnRzXG52YXIgVGltZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbWVyKHNldCwgY2xlYXIsIGRlbGF5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNsZWFyID0gY2xlYXI7XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudGltZXIgPSBjYWxsYmFjayhfdGhpcy50aW1lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICB9XG4gICAgVGltZXIucHJvdG90eXBlLmlzUnVubmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXIgIT09IG51bGw7XG4gICAgfTtcbiAgICBUaW1lci5wcm90b3R5cGUuZW5zdXJlQWJvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIodGhpcy50aW1lcik7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRpbWVyO1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGFic3RyYWN0X3RpbWVyID0gKFRpbWVyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlscy90aW1lcnMvaW5kZXgudHNcbnZhciB0aW1lcnNfZXh0ZW5kcyA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuXG5mdW5jdGlvbiB0aW1lcnNfY2xlYXJUaW1lb3V0KHRpbWVyKSB7XG4gICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lcik7XG59XG5mdW5jdGlvbiB0aW1lcnNfY2xlYXJJbnRlcnZhbCh0aW1lcikge1xuICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRpbWVyKTtcbn1cbnZhciBPbmVPZmZUaW1lciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdGltZXJzX2V4dGVuZHMoT25lT2ZmVGltZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT25lT2ZmVGltZXIoZGVsYXksIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBzZXRUaW1lb3V0LCB0aW1lcnNfY2xlYXJUaW1lb3V0LCBkZWxheSwgZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBPbmVPZmZUaW1lcjtcbn0oYWJzdHJhY3RfdGltZXIpKTtcblxudmFyIFBlcmlvZGljVGltZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRpbWVyc19leHRlbmRzKFBlcmlvZGljVGltZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGVyaW9kaWNUaW1lcihkZWxheSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHNldEludGVydmFsLCB0aW1lcnNfY2xlYXJJbnRlcnZhbCwgZGVsYXksIGZ1bmN0aW9uICh0aW1lcikge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJldHVybiB0aW1lcjtcbiAgICAgICAgfSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBlcmlvZGljVGltZXI7XG59KGFic3RyYWN0X3RpbWVyKSk7XG5cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlsLnRzXG5cbnZhciBVdGlsID0ge1xuICAgIG5vdzogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoRGF0ZS5ub3cpIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZWZlcjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgT25lT2ZmVGltZXIoMCwgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgbWV0aG9kOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYm91bmRBcmd1bWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFtuYW1lXS5hcHBseShvYmplY3QsIGJvdW5kQXJndW1lbnRzLmNvbmNhdChhcmd1bWVudHMpKTtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdXRpbCA9IChVdGlsKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91dGlscy9jb2xsZWN0aW9ucy50c1xuXG5cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXh0ZW5zaW9ucyA9IHNvdXJjZXNbaV07XG4gICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIGV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgIGlmIChleHRlbnNpb25zW3Byb3BlcnR5XSAmJlxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbnNbcHJvcGVydHldLmNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uc1twcm9wZXJ0eV0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wZXJ0eV0gPSBleHRlbmQodGFyZ2V0W3Byb3BlcnR5XSB8fCB7fSwgZXh0ZW5zaW9uc1twcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IGV4dGVuc2lvbnNbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoKSB7XG4gICAgdmFyIG0gPSBbJ1B1c2hlciddO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbS5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtLnB1c2goc2FmZUpTT05TdHJpbmdpZnkoYXJndW1lbnRzW2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG0uam9pbignIDogJyk7XG59XG5mdW5jdGlvbiBhcnJheUluZGV4T2YoYXJyYXksIGl0ZW0pIHtcbiAgICB2YXIgbmF0aXZlSW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgIGlmIChhcnJheSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIGFycmF5LmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gb2JqZWN0QXBwbHkob2JqZWN0LCBmKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgZihvYmplY3Rba2V5XSwga2V5LCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIG9iamVjdEFwcGx5KG9iamVjdCwgZnVuY3Rpb24gKF8sIGtleSkge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9KTtcbiAgICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgb2JqZWN0QXBwbHkob2JqZWN0LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZXM7XG59XG5mdW5jdGlvbiBhcHBseShhcnJheSwgZiwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZi5jYWxsKGNvbnRleHQgfHwgd2luZG93LCBhcnJheVtpXSwgaSwgYXJyYXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcChhcnJheSwgZikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGYoYXJyYXlbaV0sIGksIGFycmF5LCByZXN1bHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1hcE9iamVjdChvYmplY3QsIGYpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgb2JqZWN0QXBwbHkob2JqZWN0LCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGYodmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaWx0ZXIoYXJyYXksIHRlc3QpIHtcbiAgICB0ZXN0ID1cbiAgICAgICAgdGVzdCB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhdmFsdWU7XG4gICAgICAgICAgICB9O1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0ZXN0KGFycmF5W2ldLCBpLCBhcnJheSwgcmVzdWx0KSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaWx0ZXJPYmplY3Qob2JqZWN0LCB0ZXN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIG9iamVjdEFwcGx5KG9iamVjdCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKCh0ZXN0ICYmIHRlc3QodmFsdWUsIGtleSwgb2JqZWN0LCByZXN1bHQpKSB8fCBCb29sZWFuKHZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmbGF0dGVuKG9iamVjdCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBvYmplY3RBcHBseShvYmplY3QsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFueShhcnJheSwgdGVzdCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRlc3QoYXJyYXlbaV0sIGksIGFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29sbGVjdGlvbnNfYWxsKGFycmF5LCB0ZXN0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXRlc3QoYXJyYXlbaV0sIGksIGFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZW5jb2RlUGFyYW1zT2JqZWN0KGRhdGEpIHtcbiAgICByZXR1cm4gbWFwT2JqZWN0KGRhdGEsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFsdWUgPSBzYWZlSlNPTlN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlbmNvZGUodmFsdWUudG9TdHJpbmcoKSkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRRdWVyeVN0cmluZyhkYXRhKSB7XG4gICAgdmFyIHBhcmFtcyA9IGZpbHRlck9iamVjdChkYXRhLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgdmFyIHF1ZXJ5ID0gbWFwKGZsYXR0ZW4oZW5jb2RlUGFyYW1zT2JqZWN0KHBhcmFtcykpLCB1dGlsLm1ldGhvZCgnam9pbicsICc9JykpLmpvaW4oJyYnKTtcbiAgICByZXR1cm4gcXVlcnk7XG59XG5mdW5jdGlvbiBkZWN5Y2xlT2JqZWN0KG9iamVjdCkge1xuICAgIHZhciBvYmplY3RzID0gW10sIHBhdGhzID0gW107XG4gICAgcmV0dXJuIChmdW5jdGlvbiBkZXJleih2YWx1ZSwgcGF0aCkge1xuICAgICAgICB2YXIgaSwgbmFtZSwgbnU7XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3RzW2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgJHJlZjogcGF0aHNbaV0gfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3RzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgICAgIG51ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVbaV0gPSBkZXJleih2YWx1ZVtpXSwgcGF0aCArICdbJyArIGkgKyAnXScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBudSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKG5hbWUgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVbbmFtZV0gPSBkZXJleih2YWx1ZVtuYW1lXSwgcGF0aCArICdbJyArIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnU7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pKG9iamVjdCwgJyQnKTtcbn1cbmZ1bmN0aW9uIHNhZmVKU09OU3RyaW5naWZ5KHNvdXJjZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzb3VyY2UpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGVjeWNsZU9iamVjdChzb3VyY2UpKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvbG9nZ2VyLnRzXG5cblxudmFyIGxvZ2dlcl9Mb2dnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvZ2dlcigpIHtcbiAgICAgICAgdGhpcy5nbG9iYWxMb2cgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmxvZykge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgTG9nZ2VyLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZyh0aGlzLmdsb2JhbExvZywgYXJncyk7XG4gICAgfTtcbiAgICBMb2dnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2codGhpcy5nbG9iYWxMb2dXYXJuLCBhcmdzKTtcbiAgICB9O1xuICAgIExvZ2dlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2codGhpcy5nbG9iYWxMb2dFcnJvciwgYXJncyk7XG4gICAgfTtcbiAgICBMb2dnZXIucHJvdG90eXBlLmdsb2JhbExvZ1dhcm4gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBpZiAod2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgd2luZG93LmNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMb2dnZXIucHJvdG90eXBlLmdsb2JhbExvZ0Vycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICB3aW5kb3cuY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nV2FybihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9nZ2VyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoZGVmYXVsdExvZ2dpbmdGdW5jdGlvbikge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVzc2FnZSA9IHN0cmluZ2lmeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoY29yZV9wdXNoZXIubG9nKSB7XG4gICAgICAgICAgICBjb3JlX3B1c2hlci5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29yZV9wdXNoZXIubG9nVG9Db25zb2xlKSB7XG4gICAgICAgICAgICB2YXIgbG9nID0gZGVmYXVsdExvZ2dpbmdGdW5jdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgbG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTG9nZ2VyO1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGxvZ2dlciA9IChuZXcgbG9nZ2VyX0xvZ2dlcigpKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvd2ViL2F1dGgvanNvbnBfYXV0aC50c1xuXG52YXIganNvbnAgPSBmdW5jdGlvbiAoY29udGV4dCwgcXVlcnksIGF1dGhPcHRpb25zLCBhdXRoUmVxdWVzdFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGF1dGhPcHRpb25zLmhlYWRlcnMgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBhdXRoT3B0aW9ucy5oZWFkZXJzUHJvdmlkZXIgIT0gbnVsbCkge1xuICAgICAgICBsb2dnZXIud2FybihcIlRvIHNlbmQgaGVhZGVycyB3aXRoIHRoZSBcIiArIGF1dGhSZXF1ZXN0VHlwZS50b1N0cmluZygpICsgXCIgcmVxdWVzdCwgeW91IG11c3QgdXNlIEFKQVgsIHJhdGhlciB0aGFuIEpTT05QLlwiKTtcbiAgICB9XG4gICAgdmFyIGNhbGxiYWNrTmFtZSA9IGNvbnRleHQubmV4dEF1dGhDYWxsYmFja0lELnRvU3RyaW5nKCk7XG4gICAgY29udGV4dC5uZXh0QXV0aENhbGxiYWNrSUQrKztcbiAgICB2YXIgZG9jdW1lbnQgPSBjb250ZXh0LmdldERvY3VtZW50KCk7XG4gICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIGNvbnRleHQuYXV0aF9jYWxsYmFja3NbY2FsbGJhY2tOYW1lXSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH07XG4gICAgdmFyIGNhbGxiYWNrX25hbWUgPSBcIlB1c2hlci5hdXRoX2NhbGxiYWNrc1snXCIgKyBjYWxsYmFja05hbWUgKyBcIiddXCI7XG4gICAgc2NyaXB0LnNyYyA9XG4gICAgICAgIGF1dGhPcHRpb25zLmVuZHBvaW50ICtcbiAgICAgICAgICAgICc/Y2FsbGJhY2s9JyArXG4gICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoY2FsbGJhY2tfbmFtZSkgK1xuICAgICAgICAgICAgJyYnICtcbiAgICAgICAgICAgIHF1ZXJ5O1xuICAgIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQpO1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGpzb25wX2F1dGggPSAoanNvbnApO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvZG9tL3NjcmlwdF9yZXF1ZXN0LnRzXG52YXIgU2NyaXB0UmVxdWVzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2NyaXB0UmVxdWVzdChzcmMpIHtcbiAgICAgICAgdGhpcy5zcmMgPSBzcmM7XG4gICAgfVxuICAgIFNjcmlwdFJlcXVlc3QucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAocmVjZWl2ZXIpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgZXJyb3JTdHJpbmcgPSAnRXJyb3IgbG9hZGluZyAnICsgc2VsZi5zcmM7XG4gICAgICAgIHNlbGYuc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHNlbGYuc2NyaXB0LmlkID0gcmVjZWl2ZXIuaWQ7XG4gICAgICAgIHNlbGYuc2NyaXB0LnNyYyA9IHNlbGYuc3JjO1xuICAgICAgICBzZWxmLnNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNlbGYuc2NyaXB0LmNoYXJzZXQgPSAnVVRGLTgnO1xuICAgICAgICBpZiAoc2VsZi5zY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgc2VsZi5zY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlci5jYWxsYmFjayhlcnJvclN0cmluZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2VsZi5zY3JpcHQub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyLmNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5zY3JpcHQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRlZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zY3JpcHQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZlci5jYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLnNjcmlwdC5hc3luYyA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBkb2N1bWVudC5hdHRhY2hFdmVudCAmJlxuICAgICAgICAgICAgL29wZXJhL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICAgc2VsZi5lcnJvclNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAgICAgc2VsZi5lcnJvclNjcmlwdC5pZCA9IHJlY2VpdmVyLmlkICsgJ19lcnJvcic7XG4gICAgICAgICAgICBzZWxmLmVycm9yU2NyaXB0LnRleHQgPSByZWNlaXZlci5uYW1lICsgXCIoJ1wiICsgZXJyb3JTdHJpbmcgKyBcIicpO1wiO1xuICAgICAgICAgICAgc2VsZi5zY3JpcHQuYXN5bmMgPSBzZWxmLmVycm9yU2NyaXB0LmFzeW5jID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgICAgICBoZWFkLmluc2VydEJlZm9yZShzZWxmLnNjcmlwdCwgaGVhZC5maXJzdENoaWxkKTtcbiAgICAgICAgaWYgKHNlbGYuZXJyb3JTY3JpcHQpIHtcbiAgICAgICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHNlbGYuZXJyb3JTY3JpcHQsIHNlbGYuc2NyaXB0Lm5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2NyaXB0UmVxdWVzdC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgICAgICAgICB0aGlzLnNjcmlwdC5vbmxvYWQgPSB0aGlzLnNjcmlwdC5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2NyaXB0ICYmIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVycm9yU2NyaXB0ICYmIHRoaXMuZXJyb3JTY3JpcHQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvclNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZXJyb3JTY3JpcHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5lcnJvclNjcmlwdCA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gU2NyaXB0UmVxdWVzdDtcbn0oKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzY3JpcHRfcmVxdWVzdCA9IChTY3JpcHRSZXF1ZXN0KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvd2ViL2RvbS9qc29ucF9yZXF1ZXN0LnRzXG5cblxudmFyIGpzb25wX3JlcXVlc3RfSlNPTlBSZXF1ZXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKU09OUFJlcXVlc3QodXJsLCBkYXRhKSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBKU09OUFJlcXVlc3QucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAocmVjZWl2ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBxdWVyeSA9IGJ1aWxkUXVlcnlTdHJpbmcodGhpcy5kYXRhKTtcbiAgICAgICAgdmFyIHVybCA9IHRoaXMudXJsICsgJy8nICsgcmVjZWl2ZXIubnVtYmVyICsgJz8nICsgcXVlcnk7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJ1bnRpbWUuY3JlYXRlU2NyaXB0UmVxdWVzdCh1cmwpO1xuICAgICAgICB0aGlzLnJlcXVlc3Quc2VuZChyZWNlaXZlcik7XG4gICAgfTtcbiAgICBKU09OUFJlcXVlc3QucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3QpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdC5jbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBKU09OUFJlcXVlc3Q7XG59KCkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIganNvbnBfcmVxdWVzdCA9IChqc29ucF9yZXF1ZXN0X0pTT05QUmVxdWVzdCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL3dlYi90aW1lbGluZS9qc29ucF90aW1lbGluZS50c1xuXG5cbnZhciBnZXRBZ2VudCA9IGZ1bmN0aW9uIChzZW5kZXIsIHVzZVRMUykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNjaGVtZSA9ICdodHRwJyArICh1c2VUTFMgPyAncycgOiAnJykgKyAnOi8vJztcbiAgICAgICAgdmFyIHVybCA9IHNjaGVtZSArIChzZW5kZXIuaG9zdCB8fCBzZW5kZXIub3B0aW9ucy5ob3N0KSArIHNlbmRlci5vcHRpb25zLnBhdGg7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gcnVudGltZS5jcmVhdGVKU09OUFJlcXVlc3QodXJsLCBkYXRhKTtcbiAgICAgICAgdmFyIHJlY2VpdmVyID0gcnVudGltZS5TY3JpcHRSZWNlaXZlcnMuY3JlYXRlKGZ1bmN0aW9uIChlcnJvciwgcmVzdWx0KSB7XG4gICAgICAgICAgICBTY3JpcHRSZWNlaXZlcnMucmVtb3ZlKHJlY2VpdmVyKTtcbiAgICAgICAgICAgIHJlcXVlc3QuY2xlYW51cCgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuaG9zdCkge1xuICAgICAgICAgICAgICAgIHNlbmRlci5ob3N0ID0gcmVzdWx0Lmhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3Quc2VuZChyZWNlaXZlcik7XG4gICAgfTtcbn07XG52YXIganNvbnBfdGltZWxpbmVfanNvbnAgPSB7XG4gICAgbmFtZTogJ2pzb25wJyxcbiAgICBnZXRBZ2VudDogZ2V0QWdlbnRcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBqc29ucF90aW1lbGluZSA9IChqc29ucF90aW1lbGluZV9qc29ucCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdHJhbnNwb3J0cy91cmxfc2NoZW1lcy50c1xuXG5mdW5jdGlvbiBnZXRHZW5lcmljVVJMKGJhc2VTY2hlbWUsIHBhcmFtcywgcGF0aCkge1xuICAgIHZhciBzY2hlbWUgPSBiYXNlU2NoZW1lICsgKHBhcmFtcy51c2VUTFMgPyAncycgOiAnJyk7XG4gICAgdmFyIGhvc3QgPSBwYXJhbXMudXNlVExTID8gcGFyYW1zLmhvc3RUTFMgOiBwYXJhbXMuaG9zdE5vblRMUztcbiAgICByZXR1cm4gc2NoZW1lICsgJzovLycgKyBob3N0ICsgcGF0aDtcbn1cbmZ1bmN0aW9uIGdldEdlbmVyaWNQYXRoKGtleSwgcXVlcnlTdHJpbmcpIHtcbiAgICB2YXIgcGF0aCA9ICcvYXBwLycgKyBrZXk7XG4gICAgdmFyIHF1ZXJ5ID0gJz9wcm90b2NvbD0nICtcbiAgICAgICAgZGVmYXVsdHMuUFJPVE9DT0wgK1xuICAgICAgICAnJmNsaWVudD1qcycgK1xuICAgICAgICAnJnZlcnNpb249JyArXG4gICAgICAgIGRlZmF1bHRzLlZFUlNJT04gK1xuICAgICAgICAocXVlcnlTdHJpbmcgPyAnJicgKyBxdWVyeVN0cmluZyA6ICcnKTtcbiAgICByZXR1cm4gcGF0aCArIHF1ZXJ5O1xufVxudmFyIHdzID0ge1xuICAgIGdldEluaXRpYWw6IGZ1bmN0aW9uIChrZXksIHBhcmFtcykge1xuICAgICAgICB2YXIgcGF0aCA9IChwYXJhbXMuaHR0cFBhdGggfHwgJycpICsgZ2V0R2VuZXJpY1BhdGgoa2V5LCAnZmxhc2g9ZmFsc2UnKTtcbiAgICAgICAgcmV0dXJuIGdldEdlbmVyaWNVUkwoJ3dzJywgcGFyYW1zLCBwYXRoKTtcbiAgICB9XG59O1xudmFyIGh0dHAgPSB7XG4gICAgZ2V0SW5pdGlhbDogZnVuY3Rpb24gKGtleSwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBwYXRoID0gKHBhcmFtcy5odHRwUGF0aCB8fCAnL3B1c2hlcicpICsgZ2V0R2VuZXJpY1BhdGgoa2V5KTtcbiAgICAgICAgcmV0dXJuIGdldEdlbmVyaWNVUkwoJ2h0dHAnLCBwYXJhbXMsIHBhdGgpO1xuICAgIH1cbn07XG52YXIgc29ja2pzID0ge1xuICAgIGdldEluaXRpYWw6IGZ1bmN0aW9uIChrZXksIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gZ2V0R2VuZXJpY1VSTCgnaHR0cCcsIHBhcmFtcywgcGFyYW1zLmh0dHBQYXRoIHx8ICcvcHVzaGVyJyk7XG4gICAgfSxcbiAgICBnZXRQYXRoOiBmdW5jdGlvbiAoa2V5LCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGdldEdlbmVyaWNQYXRoKGtleSk7XG4gICAgfVxufTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9ldmVudHMvY2FsbGJhY2tfcmVnaXN0cnkudHNcblxudmFyIGNhbGxiYWNrX3JlZ2lzdHJ5X0NhbGxiYWNrUmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbGxiYWNrUmVnaXN0cnkoKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIH1cbiAgICBDYWxsYmFja1JlZ2lzdHJ5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzW3ByZWZpeChuYW1lKV07XG4gICAgfTtcbiAgICBDYWxsYmFja1JlZ2lzdHJ5LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHByZWZpeGVkRXZlbnROYW1lID0gcHJlZml4KG5hbWUpO1xuICAgICAgICB0aGlzLl9jYWxsYmFja3NbcHJlZml4ZWRFdmVudE5hbWVdID1cbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrc1twcmVmaXhlZEV2ZW50TmFtZV0gfHwgW107XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrc1twcmVmaXhlZEV2ZW50TmFtZV0ucHVzaCh7XG4gICAgICAgICAgICBmbjogY2FsbGJhY2ssXG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FsbGJhY2tSZWdpc3RyeS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghbmFtZSAmJiAhY2FsbGJhY2sgJiYgIWNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lcyA9IG5hbWUgPyBbcHJlZml4KG5hbWUpXSA6IGtleXModGhpcy5fY2FsbGJhY2tzKTtcbiAgICAgICAgaWYgKGNhbGxiYWNrIHx8IGNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2FsbGJhY2sobmFtZXMsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWxsQ2FsbGJhY2tzKG5hbWVzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FsbGJhY2tSZWdpc3RyeS5wcm90b3R5cGUucmVtb3ZlQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZXMsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIGFwcGx5KG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzW25hbWVdID0gZmlsdGVyKHRoaXMuX2NhbGxiYWNrc1tuYW1lXSB8fCBbXSwgZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChjYWxsYmFjayAmJiBjYWxsYmFjayAhPT0gYmluZGluZy5mbikgfHxcbiAgICAgICAgICAgICAgICAgICAgKGNvbnRleHQgJiYgY29udGV4dCAhPT0gYmluZGluZy5jb250ZXh0KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3NbbmFtZV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcbiAgICBDYWxsYmFja1JlZ2lzdHJ5LnByb3RvdHlwZS5yZW1vdmVBbGxDYWxsYmFja3MgPSBmdW5jdGlvbiAobmFtZXMpIHtcbiAgICAgICAgYXBwbHkobmFtZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW25hbWVdO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBDYWxsYmFja1JlZ2lzdHJ5O1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNhbGxiYWNrX3JlZ2lzdHJ5ID0gKGNhbGxiYWNrX3JlZ2lzdHJ5X0NhbGxiYWNrUmVnaXN0cnkpO1xuZnVuY3Rpb24gcHJlZml4KG5hbWUpIHtcbiAgICByZXR1cm4gJ18nICsgbmFtZTtcbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9ldmVudHMvZGlzcGF0Y2hlci50c1xuXG5cbnZhciBkaXNwYXRjaGVyX0Rpc3BhdGNoZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpc3BhdGNoZXIoZmFpbFRocm91Z2gpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBuZXcgY2FsbGJhY2tfcmVnaXN0cnkoKTtcbiAgICAgICAgdGhpcy5nbG9iYWxfY2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMuZmFpbFRocm91Z2ggPSBmYWlsVGhyb3VnaDtcbiAgICB9XG4gICAgRGlzcGF0Y2hlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmFkZChldmVudE5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBEaXNwYXRjaGVyLnByb3RvdHlwZS5iaW5kX2dsb2JhbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmdsb2JhbF9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRGlzcGF0Y2hlci5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MucmVtb3ZlKGV2ZW50TmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIERpc3BhdGNoZXIucHJvdG90eXBlLnVuYmluZF9nbG9iYWwgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxfY2FsbGJhY2tzID0gW107XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdsb2JhbF9jYWxsYmFja3MgPSBmaWx0ZXIodGhpcy5nbG9iYWxfY2FsbGJhY2tzIHx8IFtdLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYyAhPT0gY2FsbGJhY2s7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIERpc3BhdGNoZXIucHJvdG90eXBlLnVuYmluZF9hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudW5iaW5kKCk7XG4gICAgICAgIHRoaXMudW5iaW5kX2dsb2JhbCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIERpc3BhdGNoZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBkYXRhLCBtZXRhZGF0YSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ2xvYmFsX2NhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxfY2FsbGJhY2tzW2ldKGV2ZW50TmFtZSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzLmdldChldmVudE5hbWUpO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChkYXRhLCBtZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YSkge1xuICAgICAgICAgICAgYXJncy5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFja3MgJiYgY2FsbGJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzW2ldLmZuLmFwcGx5KGNhbGxiYWNrc1tpXS5jb250ZXh0IHx8IHdpbmRvdywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5mYWlsVGhyb3VnaCkge1xuICAgICAgICAgICAgdGhpcy5mYWlsVGhyb3VnaChldmVudE5hbWUsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIERpc3BhdGNoZXI7XG59KCkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZGlzcGF0Y2hlciA9IChkaXNwYXRjaGVyX0Rpc3BhdGNoZXIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3RyYW5zcG9ydHMvdHJhbnNwb3J0X2Nvbm5lY3Rpb24udHNcbnZhciB0cmFuc3BvcnRfY29ubmVjdGlvbl9leHRlbmRzID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5cblxuXG5cblxudmFyIHRyYW5zcG9ydF9jb25uZWN0aW9uX1RyYW5zcG9ydENvbm5lY3Rpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRyYW5zcG9ydF9jb25uZWN0aW9uX2V4dGVuZHMoVHJhbnNwb3J0Q29ubmVjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUcmFuc3BvcnRDb25uZWN0aW9uKGhvb2tzLCBuYW1lLCBwcmlvcml0eSwga2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmluaXRpYWxpemUgPSBydW50aW1lLnRyYW5zcG9ydENvbm5lY3Rpb25Jbml0aWFsaXplcjtcbiAgICAgICAgX3RoaXMuaG9va3MgPSBob29rcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgICAgIF90aGlzLmtleSA9IGtleTtcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIF90aGlzLnN0YXRlID0gJ25ldyc7XG4gICAgICAgIF90aGlzLnRpbWVsaW5lID0gb3B0aW9ucy50aW1lbGluZTtcbiAgICAgICAgX3RoaXMuYWN0aXZpdHlUaW1lb3V0ID0gb3B0aW9ucy5hY3Rpdml0eVRpbWVvdXQ7XG4gICAgICAgIF90aGlzLmlkID0gX3RoaXMudGltZWxpbmUuZ2VuZXJhdGVVbmlxdWVJRCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRyYW5zcG9ydENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZXNBY3Rpdml0eUNoZWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5ob29rcy5oYW5kbGVzQWN0aXZpdHlDaGVja3MpO1xuICAgIH07XG4gICAgVHJhbnNwb3J0Q29ubmVjdGlvbi5wcm90b3R5cGUuc3VwcG9ydHNQaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmhvb2tzLnN1cHBvcnRzUGluZyk7XG4gICAgfTtcbiAgICBUcmFuc3BvcnRDb25uZWN0aW9uLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQgfHwgdGhpcy5zdGF0ZSAhPT0gJ2luaXRpYWxpemVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cmwgPSB0aGlzLmhvb2tzLnVybHMuZ2V0SW5pdGlhbCh0aGlzLmtleSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0ID0gdGhpcy5ob29rcy5nZXRTb2NrZXQodXJsLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB1dGlsLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkVycm9yKGUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNoYW5nZVN0YXRlKCdjbG9zZWQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmluZExpc3RlbmVycygpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ0Nvbm5lY3RpbmcnLCB7IHRyYW5zcG9ydDogdGhpcy5uYW1lLCB1cmw6IHVybCB9KTtcbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgnY29ubmVjdGluZycpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydENvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJhbnNwb3J0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgICAgICAgIHV0aWwuZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJhbnNwb3J0Q29ubmVjdGlvbi5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdvcGVuJyAmJiB0aGlzLnN1cHBvcnRzUGluZygpKSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5waW5nKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyYW5zcG9ydENvbm5lY3Rpb24ucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaG9va3MuYmVmb3JlT3Blbikge1xuICAgICAgICAgICAgdGhpcy5ob29rcy5iZWZvcmVPcGVuKHRoaXMuc29ja2V0LCB0aGlzLmhvb2tzLnVybHMuZ2V0UGF0aCh0aGlzLmtleSwgdGhpcy5vcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgnb3BlbicpO1xuICAgICAgICB0aGlzLnNvY2tldC5vbm9wZW4gPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBUcmFuc3BvcnRDb25uZWN0aW9uLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCB7IHR5cGU6ICdXZWJTb2NrZXRFcnJvcicsIGVycm9yOiBlcnJvciB9KTtcbiAgICAgICAgdGhpcy50aW1lbGluZS5lcnJvcih0aGlzLmJ1aWxkVGltZWxpbmVNZXNzYWdlKHsgZXJyb3I6IGVycm9yLnRvU3RyaW5nKCkgfSkpO1xuICAgIH07XG4gICAgVHJhbnNwb3J0Q29ubmVjdGlvbi5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uIChjbG9zZUV2ZW50KSB7XG4gICAgICAgIGlmIChjbG9zZUV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKCdjbG9zZWQnLCB7XG4gICAgICAgICAgICAgICAgY29kZTogY2xvc2VFdmVudC5jb2RlLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogY2xvc2VFdmVudC5yZWFzb24sXG4gICAgICAgICAgICAgICAgd2FzQ2xlYW46IGNsb3NlRXZlbnQud2FzQ2xlYW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgnY2xvc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bmJpbmRMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5zb2NrZXQgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBUcmFuc3BvcnRDb25uZWN0aW9uLnByb3RvdHlwZS5vbk1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydENvbm5lY3Rpb24ucHJvdG90eXBlLm9uQWN0aXZpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnYWN0aXZpdHknKTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydENvbm5lY3Rpb24ucHJvdG90eXBlLmJpbmRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLm9uT3BlbigpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNvY2tldC5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBfdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25jbG9zZSA9IGZ1bmN0aW9uIChjbG9zZUV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5vbkNsb3NlKGNsb3NlRXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgX3RoaXMub25NZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5zdXBwb3J0c1BpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQub25hY3Rpdml0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmFuc3BvcnRDb25uZWN0aW9uLnByb3RvdHlwZS51bmJpbmRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldCkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQub25vcGVuID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQub25lcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uY2xvc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5vbm1lc3NhZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodGhpcy5zdXBwb3J0c1BpbmcoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uYWN0aXZpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyYW5zcG9ydENvbm5lY3Rpb24ucHJvdG90eXBlLmNoYW5nZVN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnRpbWVsaW5lLmluZm8odGhpcy5idWlsZFRpbWVsaW5lTWVzc2FnZSh7XG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuZW1pdChzdGF0ZSwgcGFyYW1zKTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydENvbm5lY3Rpb24ucHJvdG90eXBlLmJ1aWxkVGltZWxpbmVNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7IGNpZDogdGhpcy5pZCB9LCBtZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBUcmFuc3BvcnRDb25uZWN0aW9uO1xufShkaXNwYXRjaGVyKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BvcnRfY29ubmVjdGlvbiA9ICh0cmFuc3BvcnRfY29ubmVjdGlvbl9UcmFuc3BvcnRDb25uZWN0aW9uKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS90cmFuc3BvcnRzL3RyYW5zcG9ydC50c1xuXG52YXIgdHJhbnNwb3J0X1RyYW5zcG9ydCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhbnNwb3J0KGhvb2tzKSB7XG4gICAgICAgIHRoaXMuaG9va3MgPSBob29rcztcbiAgICB9XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob29rcy5pc1N1cHBvcnRlZChlbnZpcm9ubWVudCk7XG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbiAobmFtZSwgcHJpb3JpdHksIGtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IHRyYW5zcG9ydF9jb25uZWN0aW9uKHRoaXMuaG9va3MsIG5hbWUsIHByaW9yaXR5LCBrZXksIG9wdGlvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zcG9ydDtcbn0oKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BvcnRzX3RyYW5zcG9ydCA9ICh0cmFuc3BvcnRfVHJhbnNwb3J0KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvaXNvbW9ycGhpYy90cmFuc3BvcnRzL3RyYW5zcG9ydHMudHNcblxuXG5cblxudmFyIFdTVHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydHNfdHJhbnNwb3J0KHtcbiAgICB1cmxzOiB3cyxcbiAgICBoYW5kbGVzQWN0aXZpdHlDaGVja3M6IGZhbHNlLFxuICAgIHN1cHBvcnRzUGluZzogZmFsc2UsXG4gICAgaXNJbml0aWFsaXplZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihydW50aW1lLmdldFdlYlNvY2tldEFQSSgpKTtcbiAgICB9LFxuICAgIGlzU3VwcG9ydGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHJ1bnRpbWUuZ2V0V2ViU29ja2V0QVBJKCkpO1xuICAgIH0sXG4gICAgZ2V0U29ja2V0OiBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHJldHVybiBydW50aW1lLmNyZWF0ZVdlYlNvY2tldCh1cmwpO1xuICAgIH1cbn0pO1xudmFyIGh0dHBDb25maWd1cmF0aW9uID0ge1xuICAgIHVybHM6IGh0dHAsXG4gICAgaGFuZGxlc0FjdGl2aXR5Q2hlY2tzOiBmYWxzZSxcbiAgICBzdXBwb3J0c1Bpbmc6IHRydWUsXG4gICAgaXNJbml0aWFsaXplZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xudmFyIHN0cmVhbWluZ0NvbmZpZ3VyYXRpb24gPSBleHRlbmQoe1xuICAgIGdldFNvY2tldDogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICByZXR1cm4gcnVudGltZS5IVFRQRmFjdG9yeS5jcmVhdGVTdHJlYW1pbmdTb2NrZXQodXJsKTtcbiAgICB9XG59LCBodHRwQ29uZmlndXJhdGlvbik7XG52YXIgcG9sbGluZ0NvbmZpZ3VyYXRpb24gPSBleHRlbmQoe1xuICAgIGdldFNvY2tldDogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICByZXR1cm4gcnVudGltZS5IVFRQRmFjdG9yeS5jcmVhdGVQb2xsaW5nU29ja2V0KHVybCk7XG4gICAgfVxufSwgaHR0cENvbmZpZ3VyYXRpb24pO1xudmFyIHhockNvbmZpZ3VyYXRpb24gPSB7XG4gICAgaXNTdXBwb3J0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJ1bnRpbWUuaXNYSFJTdXBwb3J0ZWQoKTtcbiAgICB9XG59O1xudmFyIFhIUlN0cmVhbWluZ1RyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzX3RyYW5zcG9ydCgoZXh0ZW5kKHt9LCBzdHJlYW1pbmdDb25maWd1cmF0aW9uLCB4aHJDb25maWd1cmF0aW9uKSkpO1xudmFyIFhIUlBvbGxpbmdUcmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0c190cmFuc3BvcnQoZXh0ZW5kKHt9LCBwb2xsaW5nQ29uZmlndXJhdGlvbiwgeGhyQ29uZmlndXJhdGlvbikpO1xudmFyIFRyYW5zcG9ydHMgPSB7XG4gICAgd3M6IFdTVHJhbnNwb3J0LFxuICAgIHhocl9zdHJlYW1pbmc6IFhIUlN0cmVhbWluZ1RyYW5zcG9ydCxcbiAgICB4aHJfcG9sbGluZzogWEhSUG9sbGluZ1RyYW5zcG9ydFxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyYW5zcG9ydHMgPSAoVHJhbnNwb3J0cyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL3dlYi90cmFuc3BvcnRzL3RyYW5zcG9ydHMudHNcblxuXG5cblxuXG5cbnZhciBTb2NrSlNUcmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0c190cmFuc3BvcnQoe1xuICAgIGZpbGU6ICdzb2NranMnLFxuICAgIHVybHM6IHNvY2tqcyxcbiAgICBoYW5kbGVzQWN0aXZpdHlDaGVja3M6IHRydWUsXG4gICAgc3VwcG9ydHNQaW5nOiBmYWxzZSxcbiAgICBpc1N1cHBvcnRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGlzSW5pdGlhbGl6ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5Tb2NrSlMgIT09IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIGdldFNvY2tldDogZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5Tb2NrSlModXJsLCBudWxsLCB7XG4gICAgICAgICAgICBqc19wYXRoOiBEZXBlbmRlbmNpZXMuZ2V0UGF0aCgnc29ja2pzJywge1xuICAgICAgICAgICAgICAgIHVzZVRMUzogb3B0aW9ucy51c2VUTFNcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgaWdub3JlX251bGxfb3JpZ2luOiBvcHRpb25zLmlnbm9yZU51bGxPcmlnaW5cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBiZWZvcmVPcGVuOiBmdW5jdGlvbiAoc29ja2V0LCBwYXRoKSB7XG4gICAgICAgIHNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGhcbiAgICAgICAgfSkpO1xuICAgIH1cbn0pO1xudmFyIHhkckNvbmZpZ3VyYXRpb24gPSB7XG4gICAgaXNTdXBwb3J0ZWQ6IGZ1bmN0aW9uIChlbnZpcm9ubWVudCkge1xuICAgICAgICB2YXIgeWVzID0gcnVudGltZS5pc1hEUlN1cHBvcnRlZChlbnZpcm9ubWVudC51c2VUTFMpO1xuICAgICAgICByZXR1cm4geWVzO1xuICAgIH1cbn07XG52YXIgWERSU3RyZWFtaW5nVHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydHNfdHJhbnNwb3J0KChleHRlbmQoe30sIHN0cmVhbWluZ0NvbmZpZ3VyYXRpb24sIHhkckNvbmZpZ3VyYXRpb24pKSk7XG52YXIgWERSUG9sbGluZ1RyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzX3RyYW5zcG9ydChleHRlbmQoe30sIHBvbGxpbmdDb25maWd1cmF0aW9uLCB4ZHJDb25maWd1cmF0aW9uKSk7XG50cmFuc3BvcnRzLnhkcl9zdHJlYW1pbmcgPSBYRFJTdHJlYW1pbmdUcmFuc3BvcnQ7XG50cmFuc3BvcnRzLnhkcl9wb2xsaW5nID0gWERSUG9sbGluZ1RyYW5zcG9ydDtcbnRyYW5zcG9ydHMuc29ja2pzID0gU29ja0pTVHJhbnNwb3J0O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwb3J0c190cmFuc3BvcnRzID0gKHRyYW5zcG9ydHMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvbmV0X2luZm8udHNcbnZhciBuZXRfaW5mb19leHRlbmRzID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5cbnZhciBOZXRJbmZvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBuZXRfaW5mb19leHRlbmRzKE5ldEluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmV0SW5mbygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgdmFyIHNlbGYgPSBfdGhpcztcbiAgICAgICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5lbWl0KCdvbmxpbmUnKTtcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvZmZsaW5lJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZW1pdCgnb2ZmbGluZScpO1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTmV0SW5mby5wcm90b3R5cGUuaXNPbmxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLm9uTGluZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLm9uTGluZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE5ldEluZm87XG59KGRpc3BhdGNoZXIpKTtcblxudmFyIG5ldF9pbmZvX05ldHdvcmsgPSBuZXcgTmV0SW5mbygpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3RyYW5zcG9ydHMvYXNzaXN0YW50X3RvX3RoZV90cmFuc3BvcnRfbWFuYWdlci50c1xuXG5cbnZhciBhc3Npc3RhbnRfdG9fdGhlX3RyYW5zcG9ydF9tYW5hZ2VyX0Fzc2lzdGFudFRvVGhlVHJhbnNwb3J0TWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXNzaXN0YW50VG9UaGVUcmFuc3BvcnRNYW5hZ2VyKG1hbmFnZXIsIHRyYW5zcG9ydCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgdGhpcy5taW5QaW5nRGVsYXkgPSBvcHRpb25zLm1pblBpbmdEZWxheTtcbiAgICAgICAgdGhpcy5tYXhQaW5nRGVsYXkgPSBvcHRpb25zLm1heFBpbmdEZWxheTtcbiAgICAgICAgdGhpcy5waW5nRGVsYXkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIEFzc2lzdGFudFRvVGhlVHJhbnNwb3J0TWFuYWdlci5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChuYW1lLCBwcmlvcml0eSwga2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGFjdGl2aXR5VGltZW91dDogdGhpcy5waW5nRGVsYXlcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy50cmFuc3BvcnQuY3JlYXRlQ29ubmVjdGlvbihuYW1lLCBwcmlvcml0eSwga2V5LCBvcHRpb25zKTtcbiAgICAgICAgdmFyIG9wZW5UaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICB2YXIgb25PcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29ubmVjdGlvbi51bmJpbmQoJ29wZW4nLCBvbk9wZW4pO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5iaW5kKCdjbG9zZWQnLCBvbkNsb3NlZCk7XG4gICAgICAgICAgICBvcGVuVGltZXN0YW1wID0gdXRpbC5ub3coKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uQ2xvc2VkID0gZnVuY3Rpb24gKGNsb3NlRXZlbnQpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24udW5iaW5kKCdjbG9zZWQnLCBvbkNsb3NlZCk7XG4gICAgICAgICAgICBpZiAoY2xvc2VFdmVudC5jb2RlID09PSAxMDAyIHx8IGNsb3NlRXZlbnQuY29kZSA9PT0gMTAwMykge1xuICAgICAgICAgICAgICAgIF90aGlzLm1hbmFnZXIucmVwb3J0RGVhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjbG9zZUV2ZW50Lndhc0NsZWFuICYmIG9wZW5UaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlmZXNwYW4gPSB1dGlsLm5vdygpIC0gb3BlblRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBpZiAobGlmZXNwYW4gPCAyICogX3RoaXMubWF4UGluZ0RlbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1hbmFnZXIucmVwb3J0RGVhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGluZ0RlbGF5ID0gTWF0aC5tYXgobGlmZXNwYW4gLyAyLCBfdGhpcy5taW5QaW5nRGVsYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29ubmVjdGlvbi5iaW5kKCdvcGVuJywgb25PcGVuKTtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfTtcbiAgICBBc3Npc3RhbnRUb1RoZVRyYW5zcG9ydE1hbmFnZXIucHJvdG90eXBlLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKGVudmlyb25tZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuaXNBbGl2ZSgpICYmIHRoaXMudHJhbnNwb3J0LmlzU3VwcG9ydGVkKGVudmlyb25tZW50KTtcbiAgICB9O1xuICAgIHJldHVybiBBc3Npc3RhbnRUb1RoZVRyYW5zcG9ydE1hbmFnZXI7XG59KCkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgYXNzaXN0YW50X3RvX3RoZV90cmFuc3BvcnRfbWFuYWdlciA9IChhc3Npc3RhbnRfdG9fdGhlX3RyYW5zcG9ydF9tYW5hZ2VyX0Fzc2lzdGFudFRvVGhlVHJhbnNwb3J0TWFuYWdlcik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY29ubmVjdGlvbi9wcm90b2NvbC9wcm90b2NvbC50c1xudmFyIFByb3RvY29sID0ge1xuICAgIGRlY29kZU1lc3NhZ2U6IGZ1bmN0aW9uIChtZXNzYWdlRXZlbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlRGF0YSA9IEpTT04ucGFyc2UobWVzc2FnZUV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgdmFyIHB1c2hlckV2ZW50RGF0YSA9IG1lc3NhZ2VEYXRhLmRhdGE7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHB1c2hlckV2ZW50RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwdXNoZXJFdmVudERhdGEgPSBKU09OLnBhcnNlKG1lc3NhZ2VEYXRhLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHVzaGVyRXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IG1lc3NhZ2VEYXRhLmV2ZW50LFxuICAgICAgICAgICAgICAgIGNoYW5uZWw6IG1lc3NhZ2VEYXRhLmNoYW5uZWwsXG4gICAgICAgICAgICAgICAgZGF0YTogcHVzaGVyRXZlbnREYXRhXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2VEYXRhLnVzZXJfaWQpIHtcbiAgICAgICAgICAgICAgICBwdXNoZXJFdmVudC51c2VyX2lkID0gbWVzc2FnZURhdGEudXNlcl9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwdXNoZXJFdmVudDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgeyB0eXBlOiAnTWVzc2FnZVBhcnNlRXJyb3InLCBlcnJvcjogZSwgZGF0YTogbWVzc2FnZUV2ZW50LmRhdGEgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZW5jb2RlTWVzc2FnZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShldmVudCk7XG4gICAgfSxcbiAgICBwcm9jZXNzSGFuZHNoYWtlOiBmdW5jdGlvbiAobWVzc2FnZUV2ZW50KSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gUHJvdG9jb2wuZGVjb2RlTWVzc2FnZShtZXNzYWdlRXZlbnQpO1xuICAgICAgICBpZiAobWVzc2FnZS5ldmVudCA9PT0gJ3B1c2hlcjpjb25uZWN0aW9uX2VzdGFibGlzaGVkJykge1xuICAgICAgICAgICAgaWYgKCFtZXNzYWdlLmRhdGEuYWN0aXZpdHlfdGltZW91dCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdObyBhY3Rpdml0eSB0aW1lb3V0IHNwZWNpZmllZCBpbiBoYW5kc2hha2UnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdjb25uZWN0ZWQnLFxuICAgICAgICAgICAgICAgIGlkOiBtZXNzYWdlLmRhdGEuc29ja2V0X2lkLFxuICAgICAgICAgICAgICAgIGFjdGl2aXR5VGltZW91dDogbWVzc2FnZS5kYXRhLmFjdGl2aXR5X3RpbWVvdXQgKiAxMDAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UuZXZlbnQgPT09ICdwdXNoZXI6ZXJyb3InKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogdGhpcy5nZXRDbG9zZUFjdGlvbihtZXNzYWdlLmRhdGEpLFxuICAgICAgICAgICAgICAgIGVycm9yOiB0aGlzLmdldENsb3NlRXJyb3IobWVzc2FnZS5kYXRhKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93ICdJbnZhbGlkIGhhbmRzaGFrZSc7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldENsb3NlQWN0aW9uOiBmdW5jdGlvbiAoY2xvc2VFdmVudCkge1xuICAgICAgICBpZiAoY2xvc2VFdmVudC5jb2RlIDwgNDAwMCkge1xuICAgICAgICAgICAgaWYgKGNsb3NlRXZlbnQuY29kZSA+PSAxMDAyICYmIGNsb3NlRXZlbnQuY29kZSA8PSAxMDA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdiYWNrb2ZmJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsb3NlRXZlbnQuY29kZSA9PT0gNDAwMCkge1xuICAgICAgICAgICAgcmV0dXJuICd0bHNfb25seSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xvc2VFdmVudC5jb2RlIDwgNDEwMCkge1xuICAgICAgICAgICAgcmV0dXJuICdyZWZ1c2VkJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbG9zZUV2ZW50LmNvZGUgPCA0MjAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2JhY2tvZmYnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNsb3NlRXZlbnQuY29kZSA8IDQzMDApIHtcbiAgICAgICAgICAgIHJldHVybiAncmV0cnknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdyZWZ1c2VkJztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZ2V0Q2xvc2VFcnJvcjogZnVuY3Rpb24gKGNsb3NlRXZlbnQpIHtcbiAgICAgICAgaWYgKGNsb3NlRXZlbnQuY29kZSAhPT0gMTAwMCAmJiBjbG9zZUV2ZW50LmNvZGUgIT09IDEwMDEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1B1c2hlckVycm9yJyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNsb3NlRXZlbnQuY29kZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2xvc2VFdmVudC5yZWFzb24gfHwgY2xvc2VFdmVudC5tZXNzYWdlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHByb3RvY29sX3Byb3RvY29sID0gKFByb3RvY29sKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jb25uZWN0aW9uL2Nvbm5lY3Rpb24udHNcbnZhciBjb25uZWN0aW9uX2V4dGVuZHMgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcblxuXG5cblxudmFyIGNvbm5lY3Rpb25fQ29ubmVjdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgY29ubmVjdGlvbl9leHRlbmRzKENvbm5lY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29ubmVjdGlvbihpZCwgdHJhbnNwb3J0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlkID0gaWQ7XG4gICAgICAgIF90aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgX3RoaXMuYWN0aXZpdHlUaW1lb3V0ID0gdHJhbnNwb3J0LmFjdGl2aXR5VGltZW91dDtcbiAgICAgICAgX3RoaXMuYmluZExpc3RlbmVycygpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZXNBY3Rpdml0eUNoZWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LmhhbmRsZXNBY3Rpdml0eUNoZWNrcygpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5zZW5kKGRhdGEpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZF9ldmVudCA9IGZ1bmN0aW9uIChuYW1lLCBkYXRhLCBjaGFubmVsKSB7XG4gICAgICAgIHZhciBldmVudCA9IHsgZXZlbnQ6IG5hbWUsIGRhdGE6IGRhdGEgfTtcbiAgICAgICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgICAgIGV2ZW50LmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnRXZlbnQgc2VudCcsIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChwcm90b2NvbF9wcm90b2NvbC5lbmNvZGVNZXNzYWdlKGV2ZW50KSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnQuc3VwcG9ydHNQaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnBpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZF9ldmVudCgncHVzaGVyOnBpbmcnLCB7fSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuYmluZExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGZ1bmN0aW9uIChtZXNzYWdlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHVzaGVyRXZlbnQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaGVyRXZlbnQgPSBwcm90b2NvbF9wcm90b2NvbC5kZWNvZGVNZXNzYWdlKG1lc3NhZ2VFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01lc3NhZ2VQYXJzZUVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogbWVzc2FnZUV2ZW50LmRhdGFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwdXNoZXJFdmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnRXZlbnQgcmVjZCcsIHB1c2hlckV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwdXNoZXJFdmVudC5ldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHVzaGVyOmVycm9yJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1B1c2hlckVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcHVzaGVyRXZlbnQuZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHVzaGVyOnBpbmcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3BpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3B1c2hlcjpwb25nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdwb25nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnbWVzc2FnZScsIHB1c2hlckV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWN0aXZpdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdhY3Rpdml0eScpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZWQ6IGZ1bmN0aW9uIChjbG9zZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdW5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlRXZlbnQgJiYgY2xvc2VFdmVudC5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZUNsb3NlRXZlbnQoY2xvc2VFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnY2xvc2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciB1bmJpbmRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvYmplY3RBcHBseShsaXN0ZW5lcnMsIGZ1bmN0aW9uIChsaXN0ZW5lciwgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50cmFuc3BvcnQudW5iaW5kKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgb2JqZWN0QXBwbHkobGlzdGVuZXJzLCBmdW5jdGlvbiAobGlzdGVuZXIsIGV2ZW50KSB7XG4gICAgICAgICAgICBfdGhpcy50cmFuc3BvcnQuYmluZChldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZUNsb3NlRXZlbnQgPSBmdW5jdGlvbiAoY2xvc2VFdmVudCkge1xuICAgICAgICB2YXIgYWN0aW9uID0gcHJvdG9jb2xfcHJvdG9jb2wuZ2V0Q2xvc2VBY3Rpb24oY2xvc2VFdmVudCk7XG4gICAgICAgIHZhciBlcnJvciA9IHByb3RvY29sX3Byb3RvY29sLmdldENsb3NlRXJyb3IoY2xvc2VFdmVudCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoYWN0aW9uLCB7IGFjdGlvbjogYWN0aW9uLCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb25uZWN0aW9uO1xufShkaXNwYXRjaGVyKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb25uZWN0aW9uX2Nvbm5lY3Rpb24gPSAoY29ubmVjdGlvbl9Db25uZWN0aW9uKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jb25uZWN0aW9uL2hhbmRzaGFrZS9pbmRleC50c1xuXG5cblxudmFyIGhhbmRzaGFrZV9IYW5kc2hha2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhhbmRzaGFrZSh0cmFuc3BvcnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMuYmluZExpc3RlbmVycygpO1xuICAgIH1cbiAgICBIYW5kc2hha2UucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVuYmluZExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH07XG4gICAgSGFuZHNoYWtlLnByb3RvdHlwZS5iaW5kTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm9uTWVzc2FnZSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICBfdGhpcy51bmJpbmRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByb3RvY29sX3Byb3RvY29sLnByb2Nlc3NIYW5kc2hha2UobSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmZpbmlzaCgnZXJyb3InLCB7IGVycm9yOiBlIH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQuYWN0aW9uID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgIF90aGlzLmZpbmlzaCgnY29ubmVjdGVkJywge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uOiBuZXcgY29ubmVjdGlvbl9jb25uZWN0aW9uKHJlc3VsdC5pZCwgX3RoaXMudHJhbnNwb3J0KSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZpdHlUaW1lb3V0OiByZXN1bHQuYWN0aXZpdHlUaW1lb3V0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5maW5pc2gocmVzdWx0LmFjdGlvbiwgeyBlcnJvcjogcmVzdWx0LmVycm9yIH0pO1xuICAgICAgICAgICAgICAgIF90aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQ2xvc2VkID0gZnVuY3Rpb24gKGNsb3NlRXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLnVuYmluZExpc3RlbmVycygpO1xuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IHByb3RvY29sX3Byb3RvY29sLmdldENsb3NlQWN0aW9uKGNsb3NlRXZlbnQpIHx8ICdiYWNrb2ZmJztcbiAgICAgICAgICAgIHZhciBlcnJvciA9IHByb3RvY29sX3Byb3RvY29sLmdldENsb3NlRXJyb3IoY2xvc2VFdmVudCk7XG4gICAgICAgICAgICBfdGhpcy5maW5pc2goYWN0aW9uLCB7IGVycm9yOiBlcnJvciB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQuYmluZCgnbWVzc2FnZScsIHRoaXMub25NZXNzYWdlKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQuYmluZCgnY2xvc2VkJywgdGhpcy5vbkNsb3NlZCk7XG4gICAgfTtcbiAgICBIYW5kc2hha2UucHJvdG90eXBlLnVuYmluZExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQudW5iaW5kKCdtZXNzYWdlJywgdGhpcy5vbk1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC51bmJpbmQoJ2Nsb3NlZCcsIHRoaXMub25DbG9zZWQpO1xuICAgIH07XG4gICAgSGFuZHNoYWtlLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoYWN0aW9uLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayhleHRlbmQoeyB0cmFuc3BvcnQ6IHRoaXMudHJhbnNwb3J0LCBhY3Rpb246IGFjdGlvbiB9LCBwYXJhbXMpKTtcbiAgICB9O1xuICAgIHJldHVybiBIYW5kc2hha2U7XG59KCkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29ubmVjdGlvbl9oYW5kc2hha2UgPSAoaGFuZHNoYWtlX0hhbmRzaGFrZSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdGltZWxpbmUvdGltZWxpbmVfc2VuZGVyLnRzXG5cbnZhciB0aW1lbGluZV9zZW5kZXJfVGltZWxpbmVTZW5kZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbWVsaW5lU2VuZGVyKHRpbWVsaW5lLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudGltZWxpbmUgPSB0aW1lbGluZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB9XG4gICAgVGltZWxpbmVTZW5kZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAodXNlVExTLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy50aW1lbGluZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVsaW5lLnNlbmQocnVudGltZS5UaW1lbGluZVRyYW5zcG9ydC5nZXRBZ2VudCh0aGlzLCB1c2VUTFMpLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZWxpbmVTZW5kZXI7XG59KCkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdGltZWxpbmVfc2VuZGVyID0gKHRpbWVsaW5lX3NlbmRlcl9UaW1lbGluZVNlbmRlcik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvY2hhbm5lbHMvY2hhbm5lbC50c1xudmFyIGNoYW5uZWxfZXh0ZW5kcyA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuXG5cblxuXG5cbnZhciBjaGFubmVsX0NoYW5uZWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIGNoYW5uZWxfZXh0ZW5kcyhDaGFubmVsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENoYW5uZWwobmFtZSwgcHVzaGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdObyBjYWxsYmFja3Mgb24gJyArIG5hbWUgKyAnIGZvciAnICsgZXZlbnQpO1xuICAgICAgICB9KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMucHVzaGVyID0gcHVzaGVyO1xuICAgICAgICBfdGhpcy5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnN1YnNjcmlwdGlvblBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9uQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2hhbm5lbC5wcm90b3R5cGUuYXV0aG9yaXplID0gZnVuY3Rpb24gKHNvY2tldElkLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgeyBhdXRoOiAnJyB9KTtcbiAgICB9O1xuICAgIENoYW5uZWwucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKGV2ZW50LmluZGV4T2YoJ2NsaWVudC0nKSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJhZEV2ZW50TmFtZShcIkV2ZW50ICdcIiArIGV2ZW50ICsgXCInIGRvZXMgbm90IHN0YXJ0IHdpdGggJ2NsaWVudC0nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gdXJsX3N0b3JlLmJ1aWxkTG9nU3VmZml4KCd0cmlnZ2VyaW5nQ2xpZW50RXZlbnRzJyk7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIkNsaWVudCBldmVudCB0cmlnZ2VyZWQgYmVmb3JlIGNoYW5uZWwgJ3N1YnNjcmlwdGlvbl9zdWNjZWVkZWQnIGV2ZW50IC4gXCIgKyBzdWZmaXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnB1c2hlci5zZW5kX2V2ZW50KGV2ZW50LCBkYXRhLCB0aGlzLm5hbWUpO1xuICAgIH07XG4gICAgQ2hhbm5lbC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uUGVuZGluZyA9IGZhbHNlO1xuICAgIH07XG4gICAgQ2hhbm5lbC5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGV2ZW50LmV2ZW50O1xuICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09ICdwdXNoZXJfaW50ZXJuYWw6c3Vic2NyaXB0aW9uX3N1Y2NlZWRlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uU3VjY2VlZGVkRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ3B1c2hlcl9pbnRlcm5hbDpzdWJzY3JpcHRpb25fY291bnQnKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvbkNvdW50RXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZS5pbmRleE9mKCdwdXNoZXJfaW50ZXJuYWw6JykgIT09IDApIHtcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50TmFtZSwgZGF0YSwgbWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDaGFubmVsLnByb3RvdHlwZS5oYW5kbGVTdWJzY3JpcHRpb25TdWNjZWVkZWRFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvblBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hlci51bnN1YnNjcmliZSh0aGlzLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdwdXNoZXI6c3Vic2NyaXB0aW9uX3N1Y2NlZWRlZCcsIGV2ZW50LmRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDaGFubmVsLnByb3RvdHlwZS5oYW5kbGVTdWJzY3JpcHRpb25Db3VudEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5kYXRhLnN1YnNjcmlwdGlvbl9jb3VudCkge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25Db3VudCA9IGV2ZW50LmRhdGEuc3Vic2NyaXB0aW9uX2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgncHVzaGVyOnN1YnNjcmlwdGlvbl9jb3VudCcsIGV2ZW50LmRhdGEpO1xuICAgIH07XG4gICAgQ2hhbm5lbC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25QZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25DYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hdXRob3JpemUodGhpcy5wdXNoZXIuY29ubmVjdGlvbi5zb2NrZXRfaWQsIGZ1bmN0aW9uIChlcnJvciwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9uUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihlcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdwdXNoZXI6c3Vic2NyaXB0aW9uX2Vycm9yJywgT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQXV0aEVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICB9LCBlcnJvciBpbnN0YW5jZW9mIEhUVFBBdXRoRXJyb3IgPyB7IHN0YXR1czogZXJyb3Iuc3RhdHVzIH0gOiB7fSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHVzaGVyLnNlbmRfZXZlbnQoJ3B1c2hlcjpzdWJzY3JpYmUnLCB7XG4gICAgICAgICAgICAgICAgICAgIGF1dGg6IGRhdGEuYXV0aCxcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbF9kYXRhOiBkYXRhLmNoYW5uZWxfZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogX3RoaXMubmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoYW5uZWwucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wdXNoZXIuc2VuZF9ldmVudCgncHVzaGVyOnVuc3Vic2NyaWJlJywge1xuICAgICAgICAgICAgY2hhbm5lbDogdGhpcy5uYW1lXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2hhbm5lbC5wcm90b3R5cGUuY2FuY2VsU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkNhbmNlbGxlZCA9IHRydWU7XG4gICAgfTtcbiAgICBDaGFubmVsLnByb3RvdHlwZS5yZWluc3RhdGVTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hhbm5lbDtcbn0oZGlzcGF0Y2hlcikpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2hhbm5lbHNfY2hhbm5lbCA9IChjaGFubmVsX0NoYW5uZWwpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2NoYW5uZWxzL3ByaXZhdGVfY2hhbm5lbC50c1xudmFyIHByaXZhdGVfY2hhbm5lbF9leHRlbmRzID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5cbnZhciBQcml2YXRlQ2hhbm5lbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgcHJpdmF0ZV9jaGFubmVsX2V4dGVuZHMoUHJpdmF0ZUNoYW5uZWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJpdmF0ZUNoYW5uZWwoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgUHJpdmF0ZUNoYW5uZWwucHJvdG90eXBlLmF1dGhvcml6ZSA9IGZ1bmN0aW9uIChzb2NrZXRJZCwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaGVyLmNvbmZpZy5jaGFubmVsQXV0aG9yaXplcih7XG4gICAgICAgICAgICBjaGFubmVsTmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgc29ja2V0SWQ6IHNvY2tldElkXG4gICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIHJldHVybiBQcml2YXRlQ2hhbm5lbDtcbn0oY2hhbm5lbHNfY2hhbm5lbCkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcHJpdmF0ZV9jaGFubmVsID0gKFByaXZhdGVDaGFubmVsKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jaGFubmVscy9tZW1iZXJzLnRzXG5cbnZhciBtZW1iZXJzX01lbWJlcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lbWJlcnMoKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gICAgTWVtYmVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5tZW1iZXJzLCBpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIGluZm86IHRoaXMubWVtYmVyc1tpZF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVtYmVycy5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBvYmplY3RBcHBseSh0aGlzLm1lbWJlcnMsIGZ1bmN0aW9uIChtZW1iZXIsIGlkKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhfdGhpcy5nZXQoaWQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNZW1iZXJzLnByb3RvdHlwZS5zZXRNeUlEID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHRoaXMubXlJRCA9IGlkO1xuICAgIH07XG4gICAgTWVtYmVycy5wcm90b3R5cGUub25TdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uRGF0YSkge1xuICAgICAgICB0aGlzLm1lbWJlcnMgPSBzdWJzY3JpcHRpb25EYXRhLnByZXNlbmNlLmhhc2g7XG4gICAgICAgIHRoaXMuY291bnQgPSBzdWJzY3JpcHRpb25EYXRhLnByZXNlbmNlLmNvdW50O1xuICAgICAgICB0aGlzLm1lID0gdGhpcy5nZXQodGhpcy5teUlEKTtcbiAgICB9O1xuICAgIE1lbWJlcnMucHJvdG90eXBlLmFkZE1lbWJlciA9IGZ1bmN0aW9uIChtZW1iZXJEYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmdldChtZW1iZXJEYXRhLnVzZXJfaWQpID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZW1iZXJzW21lbWJlckRhdGEudXNlcl9pZF0gPSBtZW1iZXJEYXRhLnVzZXJfaW5mbztcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KG1lbWJlckRhdGEudXNlcl9pZCk7XG4gICAgfTtcbiAgICBNZW1iZXJzLnByb3RvdHlwZS5yZW1vdmVNZW1iZXIgPSBmdW5jdGlvbiAobWVtYmVyRGF0YSkge1xuICAgICAgICB2YXIgbWVtYmVyID0gdGhpcy5nZXQobWVtYmVyRGF0YS51c2VyX2lkKTtcbiAgICAgICAgaWYgKG1lbWJlcikge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMubWVtYmVyc1ttZW1iZXJEYXRhLnVzZXJfaWRdO1xuICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1iZXI7XG4gICAgfTtcbiAgICBNZW1iZXJzLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0ge307XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLm15SUQgPSBudWxsO1xuICAgICAgICB0aGlzLm1lID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBNZW1iZXJzO1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIG1lbWJlcnMgPSAobWVtYmVyc19NZW1iZXJzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jaGFubmVscy9wcmVzZW5jZV9jaGFubmVsLnRzXG52YXIgcHJlc2VuY2VfY2hhbm5lbF9leHRlbmRzID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hd2FpdGVyID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5cblxuXG5cbnZhciBwcmVzZW5jZV9jaGFubmVsX1ByZXNlbmNlQ2hhbm5lbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgcHJlc2VuY2VfY2hhbm5lbF9leHRlbmRzKFByZXNlbmNlQ2hhbm5lbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcmVzZW5jZUNoYW5uZWwobmFtZSwgcHVzaGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIHB1c2hlcikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubWVtYmVycyA9IG5ldyBtZW1iZXJzKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUHJlc2VuY2VDaGFubmVsLnByb3RvdHlwZS5hdXRob3JpemUgPSBmdW5jdGlvbiAoc29ja2V0SWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYXV0aG9yaXplLmNhbGwodGhpcywgc29ja2V0SWQsIGZ1bmN0aW9uIChlcnJvciwgYXV0aERhdGEpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsRGF0YSwgc3VmZml4O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEhZXJyb3IpIHJldHVybiBbMywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRoRGF0YSA9IGF1dGhEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYXV0aERhdGEuY2hhbm5lbF9kYXRhICE9IG51bGwpKSByZXR1cm4gWzMsIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbERhdGEgPSBKU09OLnBhcnNlKGF1dGhEYXRhLmNoYW5uZWxfZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbWJlcnMuc2V0TXlJRChjaGFubmVsRGF0YS51c2VyX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgM107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFs0LCB0aGlzLnB1c2hlci51c2VyLnNpZ25pbkRvbmVQcm9taXNlXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHVzaGVyLnVzZXIudXNlcl9kYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbWJlcnMuc2V0TXlJRCh0aGlzLnB1c2hlci51c2VyLnVzZXJfZGF0YS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSB1cmxfc3RvcmUuYnVpbGRMb2dTdWZmaXgoJ2F1dGhvcml6YXRpb25FbmRwb2ludCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkludmFsaWQgYXV0aCByZXNwb25zZSBmb3IgY2hhbm5lbCAnXCIgKyB0aGlzLm5hbWUgKyBcIicsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFwiZXhwZWN0ZWQgJ2NoYW5uZWxfZGF0YScgZmllbGQuIFwiICsgc3VmZml4ICsgXCIsIFwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3IgdGhlIHVzZXIgc2hvdWxkIGJlIHNpZ25lZCBpbi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soJ0ludmFsaWQgYXV0aCByZXNwb25zZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBhdXRoRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgfSk7XG4gICAgfTtcbiAgICBQcmVzZW5jZUNoYW5uZWwucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSBldmVudC5ldmVudDtcbiAgICAgICAgaWYgKGV2ZW50TmFtZS5pbmRleE9mKCdwdXNoZXJfaW50ZXJuYWw6JykgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSW50ZXJuYWxFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGEgPSB7fTtcbiAgICAgICAgICAgIGlmIChldmVudC51c2VyX2lkKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEudXNlcl9pZCA9IGV2ZW50LnVzZXJfaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnROYW1lLCBkYXRhLCBtZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFByZXNlbmNlQ2hhbm5lbC5wcm90b3R5cGUuaGFuZGxlSW50ZXJuYWxFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnQuZXZlbnQ7XG4gICAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgICAgc3dpdGNoIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3B1c2hlcl9pbnRlcm5hbDpzdWJzY3JpcHRpb25fc3VjY2VlZGVkJzpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvblN1Y2NlZWRlZEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3B1c2hlcl9pbnRlcm5hbDpzdWJzY3JpcHRpb25fY291bnQnOlxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU3Vic2NyaXB0aW9uQ291bnRFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwdXNoZXJfaW50ZXJuYWw6bWVtYmVyX2FkZGVkJzpcbiAgICAgICAgICAgICAgICB2YXIgYWRkZWRNZW1iZXIgPSB0aGlzLm1lbWJlcnMuYWRkTWVtYmVyKGRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncHVzaGVyOm1lbWJlcl9hZGRlZCcsIGFkZGVkTWVtYmVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3B1c2hlcl9pbnRlcm5hbDptZW1iZXJfcmVtb3ZlZCc6XG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZWRNZW1iZXIgPSB0aGlzLm1lbWJlcnMucmVtb3ZlTWVtYmVyKGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkTWVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncHVzaGVyOm1lbWJlcl9yZW1vdmVkJywgcmVtb3ZlZE1lbWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQcmVzZW5jZUNoYW5uZWwucHJvdG90eXBlLmhhbmRsZVN1YnNjcmlwdGlvblN1Y2NlZWRlZEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25DYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaGVyLnVuc3Vic2NyaWJlKHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1lbWJlcnMub25TdWJzY3JpcHRpb24oZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3B1c2hlcjpzdWJzY3JpcHRpb25fc3VjY2VlZGVkJywgdGhpcy5tZW1iZXJzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHJlc2VuY2VDaGFubmVsLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1lbWJlcnMucmVzZXQoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNjb25uZWN0LmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gUHJlc2VuY2VDaGFubmVsO1xufShwcml2YXRlX2NoYW5uZWwpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHByZXNlbmNlX2NoYW5uZWwgPSAocHJlc2VuY2VfY2hhbm5lbF9QcmVzZW5jZUNoYW5uZWwpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BzdGFibGVsaWIvdXRmOC9saWIvdXRmOC5qc1xudmFyIHV0ZjggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BzdGFibGVsaWIvYmFzZTY0L2xpYi9iYXNlNjQuanNcbnZhciBiYXNlNjQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2NoYW5uZWxzL2VuY3J5cHRlZF9jaGFubmVsLnRzXG52YXIgZW5jcnlwdGVkX2NoYW5uZWxfZXh0ZW5kcyA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuXG5cblxuXG5cbnZhciBlbmNyeXB0ZWRfY2hhbm5lbF9FbmNyeXB0ZWRDaGFubmVsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBlbmNyeXB0ZWRfY2hhbm5lbF9leHRlbmRzKEVuY3J5cHRlZENoYW5uZWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW5jcnlwdGVkQ2hhbm5lbChuYW1lLCBwdXNoZXIsIG5hY2wpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgcHVzaGVyKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5rZXkgPSBudWxsO1xuICAgICAgICBfdGhpcy5uYWNsID0gbmFjbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFbmNyeXB0ZWRDaGFubmVsLnByb3RvdHlwZS5hdXRob3JpemUgPSBmdW5jdGlvbiAoc29ja2V0SWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYXV0aG9yaXplLmNhbGwodGhpcywgc29ja2V0SWQsIGZ1bmN0aW9uIChlcnJvciwgYXV0aERhdGEpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBhdXRoRGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNoYXJlZFNlY3JldCA9IGF1dGhEYXRhWydzaGFyZWRfc2VjcmV0J107XG4gICAgICAgICAgICBpZiAoIXNoYXJlZFNlY3JldCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihcIk5vIHNoYXJlZF9zZWNyZXQga2V5IGluIGF1dGggcGF5bG9hZCBmb3IgZW5jcnlwdGVkIGNoYW5uZWw6IFwiICsgX3RoaXMubmFtZSksIG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmtleSA9IE9iamVjdChiYXNlNjRbXCJkZWNvZGVcIl0pKHNoYXJlZFNlY3JldCk7XG4gICAgICAgICAgICBkZWxldGUgYXV0aERhdGFbJ3NoYXJlZF9zZWNyZXQnXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGF1dGhEYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFbmNyeXB0ZWRDaGFubmVsLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZlYXR1cmUoJ0NsaWVudCBldmVudHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGZvciBlbmNyeXB0ZWQgY2hhbm5lbHMnKTtcbiAgICB9O1xuICAgIEVuY3J5cHRlZENoYW5uZWwucHJvdG90eXBlLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSBldmVudC5ldmVudDtcbiAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgICBpZiAoZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcl9pbnRlcm5hbDonKSA9PT0gMCB8fFxuICAgICAgICAgICAgZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcjonKSA9PT0gMCkge1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5oYW5kbGVFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZUVuY3J5cHRlZEV2ZW50KGV2ZW50TmFtZSwgZGF0YSk7XG4gICAgfTtcbiAgICBFbmNyeXB0ZWRDaGFubmVsLnByb3RvdHlwZS5oYW5kbGVFbmNyeXB0ZWRFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMua2V5KSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ1JlY2VpdmVkIGVuY3J5cHRlZCBldmVudCBiZWZvcmUga2V5IGhhcyBiZWVuIHJldHJpZXZlZCBmcm9tIHRoZSBhdXRoRW5kcG9pbnQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGEuY2lwaGVydGV4dCB8fCAhZGF0YS5ub25jZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdVbmV4cGVjdGVkIGZvcm1hdCBmb3IgZW5jcnlwdGVkIGV2ZW50LCBleHBlY3RlZCBvYmplY3Qgd2l0aCBgY2lwaGVydGV4dGAgYW5kIGBub25jZWAgZmllbGRzLCBnb3Q6ICcgK1xuICAgICAgICAgICAgICAgIGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaXBoZXJUZXh0ID0gT2JqZWN0KGJhc2U2NFtcImRlY29kZVwiXSkoZGF0YS5jaXBoZXJ0ZXh0KTtcbiAgICAgICAgaWYgKGNpcGhlclRleHQubGVuZ3RoIDwgdGhpcy5uYWNsLnNlY3JldGJveC5vdmVyaGVhZExlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRXhwZWN0ZWQgZW5jcnlwdGVkIGV2ZW50IGNpcGhlcnRleHQgbGVuZ3RoIHRvIGJlIFwiICsgdGhpcy5uYWNsLnNlY3JldGJveC5vdmVyaGVhZExlbmd0aCArIFwiLCBnb3Q6IFwiICsgY2lwaGVyVGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub25jZSA9IE9iamVjdChiYXNlNjRbXCJkZWNvZGVcIl0pKGRhdGEubm9uY2UpO1xuICAgICAgICBpZiAobm9uY2UubGVuZ3RoIDwgdGhpcy5uYWNsLnNlY3JldGJveC5ub25jZUxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRXhwZWN0ZWQgZW5jcnlwdGVkIGV2ZW50IG5vbmNlIGxlbmd0aCB0byBiZSBcIiArIHRoaXMubmFjbC5zZWNyZXRib3gubm9uY2VMZW5ndGggKyBcIiwgZ290OiBcIiArIG5vbmNlLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzID0gdGhpcy5uYWNsLnNlY3JldGJveC5vcGVuKGNpcGhlclRleHQsIG5vbmNlLCB0aGlzLmtleSk7XG4gICAgICAgIGlmIChieXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdGYWlsZWQgdG8gZGVjcnlwdCBhbiBldmVudCwgcHJvYmFibHkgYmVjYXVzZSBpdCB3YXMgZW5jcnlwdGVkIHdpdGggYSBkaWZmZXJlbnQga2V5LiBGZXRjaGluZyBhIG5ldyBrZXkgZnJvbSB0aGUgYXV0aEVuZHBvaW50Li4uJyk7XG4gICAgICAgICAgICB0aGlzLmF1dGhvcml6ZSh0aGlzLnB1c2hlci5jb25uZWN0aW9uLnNvY2tldF9pZCwgZnVuY3Rpb24gKGVycm9yLCBhdXRoRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gbWFrZSBhIHJlcXVlc3QgdG8gdGhlIGF1dGhFbmRwb2ludDogXCIgKyBhdXRoRGF0YSArIFwiLiBVbmFibGUgdG8gZmV0Y2ggbmV3IGtleSwgc28gZHJvcHBpbmcgZW5jcnlwdGVkIGV2ZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ5dGVzID0gX3RoaXMubmFjbC5zZWNyZXRib3gub3BlbihjaXBoZXJUZXh0LCBub25jZSwgX3RoaXMua2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGRlY3J5cHQgZXZlbnQgd2l0aCBuZXcga2V5LiBEcm9wcGluZyBlbmNyeXB0ZWQgZXZlbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdChldmVudCwgX3RoaXMuZ2V0RGF0YVRvRW1pdChieXRlcykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChldmVudCwgdGhpcy5nZXREYXRhVG9FbWl0KGJ5dGVzKSk7XG4gICAgfTtcbiAgICBFbmNyeXB0ZWRDaGFubmVsLnByb3RvdHlwZS5nZXREYXRhVG9FbWl0ID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgIHZhciByYXcgPSBPYmplY3QodXRmOFtcImRlY29kZVwiXSkoYnl0ZXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmF3KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiByYXc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBFbmNyeXB0ZWRDaGFubmVsO1xufShwcml2YXRlX2NoYW5uZWwpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGVuY3J5cHRlZF9jaGFubmVsID0gKGVuY3J5cHRlZF9jaGFubmVsX0VuY3J5cHRlZENoYW5uZWwpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2Nvbm5lY3Rpb24vY29ubmVjdGlvbl9tYW5hZ2VyLnRzXG52YXIgY29ubmVjdGlvbl9tYW5hZ2VyX2V4dGVuZHMgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcblxuXG5cblxuXG52YXIgY29ubmVjdGlvbl9tYW5hZ2VyX0Nvbm5lY3Rpb25NYW5hZ2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBjb25uZWN0aW9uX21hbmFnZXJfZXh0ZW5kcyhDb25uZWN0aW9uTWFuYWdlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25uZWN0aW9uTWFuYWdlcihrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGUgPSAnaW5pdGlhbGl6ZWQnO1xuICAgICAgICBfdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgX3RoaXMua2V5ID0ga2V5O1xuICAgICAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgX3RoaXMudGltZWxpbmUgPSBfdGhpcy5vcHRpb25zLnRpbWVsaW5lO1xuICAgICAgICBfdGhpcy51c2luZ1RMUyA9IF90aGlzLm9wdGlvbnMudXNlVExTO1xuICAgICAgICBfdGhpcy5lcnJvckNhbGxiYWNrcyA9IF90aGlzLmJ1aWxkRXJyb3JDYWxsYmFja3MoKTtcbiAgICAgICAgX3RoaXMuY29ubmVjdGlvbkNhbGxiYWNrcyA9IF90aGlzLmJ1aWxkQ29ubmVjdGlvbkNhbGxiYWNrcyhfdGhpcy5lcnJvckNhbGxiYWNrcyk7XG4gICAgICAgIF90aGlzLmhhbmRzaGFrZUNhbGxiYWNrcyA9IF90aGlzLmJ1aWxkSGFuZHNoYWtlQ2FsbGJhY2tzKF90aGlzLmVycm9yQ2FsbGJhY2tzKTtcbiAgICAgICAgdmFyIE5ldHdvcmsgPSBydW50aW1lLmdldE5ldHdvcmsoKTtcbiAgICAgICAgTmV0d29yay5iaW5kKCdvbmxpbmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy50aW1lbGluZS5pbmZvKHsgbmV0aW5mbzogJ29ubGluZScgfSk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUgPT09ICdjb25uZWN0aW5nJyB8fCBfdGhpcy5zdGF0ZSA9PT0gJ3VuYXZhaWxhYmxlJykge1xuICAgICAgICAgICAgICAgIF90aGlzLnJldHJ5SW4oMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBOZXR3b3JrLmJpbmQoJ29mZmxpbmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy50aW1lbGluZS5pbmZvKHsgbmV0aW5mbzogJ29mZmxpbmUnIH0pO1xuICAgICAgICAgICAgaWYgKF90aGlzLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZW5kQWN0aXZpdHlDaGVjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMudXBkYXRlU3RyYXRlZ3koKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbiB8fCB0aGlzLnJ1bm5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zdHJhdGVneS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCdmYWlsZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCdjb25uZWN0aW5nJyk7XG4gICAgICAgIHRoaXMuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgIHRoaXMuc2V0VW5hdmFpbGFibGVUaW1lcigpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZW5kX2V2ZW50ID0gZnVuY3Rpb24gKG5hbWUsIGRhdGEsIGNoYW5uZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5zZW5kX2V2ZW50KG5hbWUsIGRhdGEsIGNoYW5uZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0SW50ZXJuYWxseSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCdkaXNjb25uZWN0ZWQnKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5pc1VzaW5nVExTID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51c2luZ1RMUztcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zdGFydENvbm5lY3RpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIChlcnJvciwgaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5ydW5uZXIgPSBfdGhpcy5zdHJhdGVneS5jb25uZWN0KDAsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChoYW5kc2hha2UuYWN0aW9uID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0hhbmRzaGFrZUVycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBoYW5kc2hha2UuZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRpbWVsaW5lLmVycm9yKHsgaGFuZHNoYWtlRXJyb3I6IGhhbmRzaGFrZS5lcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFib3J0Q29ubmVjdGluZygpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kc2hha2VDYWxsYmFja3NbaGFuZHNoYWtlLmFjdGlvbl0oaGFuZHNoYWtlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVubmVyID0gdGhpcy5zdHJhdGVneS5jb25uZWN0KDAsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5hYm9ydENvbm5lY3RpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJ1bm5lcikge1xuICAgICAgICAgICAgdGhpcy5ydW5uZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIHRoaXMucnVubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3RJbnRlcm5hbGx5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFib3J0Q29ubmVjdGluZygpO1xuICAgICAgICB0aGlzLmNsZWFyUmV0cnlUaW1lcigpO1xuICAgICAgICB0aGlzLmNsZWFyVW5hdmFpbGFibGVUaW1lcigpO1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuYWJhbmRvbkNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVN0cmF0ZWd5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gdGhpcy5vcHRpb25zLmdldFN0cmF0ZWd5KHtcbiAgICAgICAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICAgICAgICB0aW1lbGluZTogdGhpcy50aW1lbGluZSxcbiAgICAgICAgICAgIHVzZVRMUzogdGhpcy51c2luZ1RMU1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZXRyeUluID0gZnVuY3Rpb24gKGRlbGF5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGltZWxpbmUuaW5mbyh7IGFjdGlvbjogJ3JldHJ5JywgZGVsYXk6IGRlbGF5IH0pO1xuICAgICAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3RpbmdfaW4nLCBNYXRoLnJvdW5kKGRlbGF5IC8gMTAwMCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmV0cnlUaW1lciA9IG5ldyBPbmVPZmZUaW1lcihkZWxheSB8fCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5kaXNjb25uZWN0SW50ZXJuYWxseSgpO1xuICAgICAgICAgICAgX3RoaXMuY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jbGVhclJldHJ5VGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJldHJ5VGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmV0cnlUaW1lci5lbnN1cmVBYm9ydGVkKCk7XG4gICAgICAgICAgICB0aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0VW5hdmFpbGFibGVUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy51bmF2YWlsYWJsZVRpbWVyID0gbmV3IE9uZU9mZlRpbWVyKHRoaXMub3B0aW9ucy51bmF2YWlsYWJsZVRpbWVvdXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZVN0YXRlKCd1bmF2YWlsYWJsZScpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jbGVhclVuYXZhaWxhYmxlVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnVuYXZhaWxhYmxlVGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMudW5hdmFpbGFibGVUaW1lci5lbnN1cmVBYm9ydGVkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZW5kQWN0aXZpdHlDaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdG9wQWN0aXZpdHlDaGVjaygpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ucGluZygpO1xuICAgICAgICB0aGlzLmFjdGl2aXR5VGltZXIgPSBuZXcgT25lT2ZmVGltZXIodGhpcy5vcHRpb25zLnBvbmdUaW1lb3V0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy50aW1lbGluZS5lcnJvcih7IHBvbmdfdGltZWRfb3V0OiBfdGhpcy5vcHRpb25zLnBvbmdUaW1lb3V0IH0pO1xuICAgICAgICAgICAgX3RoaXMucmV0cnlJbigwKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVzZXRBY3Rpdml0eUNoZWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnN0b3BBY3Rpdml0eUNoZWNrKCk7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24gJiYgIXRoaXMuY29ubmVjdGlvbi5oYW5kbGVzQWN0aXZpdHlDaGVja3MoKSkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpdml0eVRpbWVyID0gbmV3IE9uZU9mZlRpbWVyKHRoaXMuYWN0aXZpdHlUaW1lb3V0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VuZEFjdGl2aXR5Q2hlY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc3RvcEFjdGl2aXR5Q2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2aXR5VGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZpdHlUaW1lci5lbnN1cmVBYm9ydGVkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5idWlsZENvbm5lY3Rpb25DYWxsYmFja3MgPSBmdW5jdGlvbiAoZXJyb3JDYWxsYmFja3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZXJyb3JDYWxsYmFja3MsIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVzZXRBY3Rpdml0eUNoZWNrKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZW5kX2V2ZW50KCdwdXNoZXI6cG9uZycsIHt9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhY3Rpdml0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc2V0QWN0aXZpdHlDaGVjaygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hYmFuZG9uQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zaG91bGRSZXRyeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJldHJ5SW4oMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5idWlsZEhhbmRzaGFrZUNhbGxiYWNrcyA9IGZ1bmN0aW9uIChlcnJvckNhbGxiYWNrcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBlcnJvckNhbGxiYWNrcywge1xuICAgICAgICAgICAgY29ubmVjdGVkOiBmdW5jdGlvbiAoaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZpdHlUaW1lb3V0ID0gTWF0aC5taW4oX3RoaXMub3B0aW9ucy5hY3Rpdml0eVRpbWVvdXQsIGhhbmRzaGFrZS5hY3Rpdml0eVRpbWVvdXQsIGhhbmRzaGFrZS5jb25uZWN0aW9uLmFjdGl2aXR5VGltZW91dCB8fCBJbmZpbml0eSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2xlYXJVbmF2YWlsYWJsZVRpbWVyKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0Q29ubmVjdGlvbihoYW5kc2hha2UuY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgX3RoaXMuc29ja2V0X2lkID0gX3RoaXMuY29ubmVjdGlvbi5pZDtcbiAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVTdGF0ZSgnY29ubmVjdGVkJywgeyBzb2NrZXRfaWQ6IF90aGlzLnNvY2tldF9pZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYnVpbGRFcnJvckNhbGxiYWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHdpdGhFcnJvckVtaXR0ZWQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdlcnJvcicsIHsgdHlwZTogJ1dlYlNvY2tldEVycm9yJywgZXJyb3I6IHJlc3VsdC5lcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0bHNfb25seTogd2l0aEVycm9yRW1pdHRlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudXNpbmdUTFMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVN0cmF0ZWd5KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMucmV0cnlJbigwKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcmVmdXNlZDogd2l0aEVycm9yRW1pdHRlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBiYWNrb2ZmOiB3aXRoRXJyb3JFbWl0dGVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXRyeUluKDEwMDApO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByZXRyeTogd2l0aEVycm9yRW1pdHRlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmV0cnlJbigwKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIGZvciAodmFyIGV2ZW50IGluIHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmJpbmQoZXZlbnQsIHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrc1tldmVudF0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzZXRBY3Rpdml0eUNoZWNrKCk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYWJhbmRvbkNvbm5lY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9wQWN0aXZpdHlDaGVjaygpO1xuICAgICAgICBmb3IgKHZhciBldmVudCBpbiB0aGlzLmNvbm5lY3Rpb25DYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi51bmJpbmQoZXZlbnQsIHRoaXMuY29ubmVjdGlvbkNhbGxiYWNrc1tldmVudF0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy5jb25uZWN0aW9uO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVTdGF0ZSA9IGZ1bmN0aW9uIChuZXdTdGF0ZSwgZGF0YSkge1xuICAgICAgICB2YXIgcHJldmlvdXNTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IG5ld1N0YXRlKSB7XG4gICAgICAgICAgICB2YXIgbmV3U3RhdGVEZXNjcmlwdGlvbiA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgaWYgKG5ld1N0YXRlRGVzY3JpcHRpb24gPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGVEZXNjcmlwdGlvbiArPSAnIHdpdGggbmV3IHNvY2tldCBJRCAnICsgZGF0YS5zb2NrZXRfaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ1N0YXRlIGNoYW5nZWQnLCBwcmV2aW91c1N0YXRlICsgJyAtPiAnICsgbmV3U3RhdGVEZXNjcmlwdGlvbik7XG4gICAgICAgICAgICB0aGlzLnRpbWVsaW5lLmluZm8oeyBzdGF0ZTogbmV3U3RhdGUsIHBhcmFtczogZGF0YSB9KTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RhdGVfY2hhbmdlJywgeyBwcmV2aW91czogcHJldmlvdXNTdGF0ZSwgY3VycmVudDogbmV3U3RhdGUgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQobmV3U3RhdGUsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2hvdWxkUmV0cnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSAnY29ubmVjdGluZycgfHwgdGhpcy5zdGF0ZSA9PT0gJ2Nvbm5lY3RlZCc7XG4gICAgfTtcbiAgICByZXR1cm4gQ29ubmVjdGlvbk1hbmFnZXI7XG59KGRpc3BhdGNoZXIpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbm5lY3Rpb25fbWFuYWdlciA9IChjb25uZWN0aW9uX21hbmFnZXJfQ29ubmVjdGlvbk1hbmFnZXIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2NoYW5uZWxzL2NoYW5uZWxzLnRzXG5cblxuXG5cbnZhciBjaGFubmVsc19DaGFubmVscyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhbm5lbHMoKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSB7fTtcbiAgICB9XG4gICAgQ2hhbm5lbHMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChuYW1lLCBwdXNoZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoYW5uZWxzW25hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzW25hbWVdID0gY3JlYXRlQ2hhbm5lbChuYW1lLCBwdXNoZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzW25hbWVdO1xuICAgIH07XG4gICAgQ2hhbm5lbHMucHJvdG90eXBlLmFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcyh0aGlzLmNoYW5uZWxzKTtcbiAgICB9O1xuICAgIENoYW5uZWxzLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNbbmFtZV07XG4gICAgfTtcbiAgICBDaGFubmVscy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW25hbWVdO1xuICAgICAgICBkZWxldGUgdGhpcy5jaGFubmVsc1tuYW1lXTtcbiAgICAgICAgcmV0dXJuIGNoYW5uZWw7XG4gICAgfTtcbiAgICBDaGFubmVscy5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2JqZWN0QXBwbHkodGhpcy5jaGFubmVscywgZnVuY3Rpb24gKGNoYW5uZWwpIHtcbiAgICAgICAgICAgIGNoYW5uZWwuZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDaGFubmVscztcbn0oKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjaGFubmVscyA9IChjaGFubmVsc19DaGFubmVscyk7XG5mdW5jdGlvbiBjcmVhdGVDaGFubmVsKG5hbWUsIHB1c2hlcikge1xuICAgIGlmIChuYW1lLmluZGV4T2YoJ3ByaXZhdGUtZW5jcnlwdGVkLScpID09PSAwKSB7XG4gICAgICAgIGlmIChwdXNoZXIuY29uZmlnLm5hY2wpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZUVuY3J5cHRlZENoYW5uZWwobmFtZSwgcHVzaGVyLCBwdXNoZXIuY29uZmlnLm5hY2wpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJNc2cgPSAnVHJpZWQgdG8gc3Vic2NyaWJlIHRvIGEgcHJpdmF0ZS1lbmNyeXB0ZWQtIGNoYW5uZWwgYnV0IG5vIG5hY2wgaW1wbGVtZW50YXRpb24gYXZhaWxhYmxlJztcbiAgICAgICAgdmFyIHN1ZmZpeCA9IHVybF9zdG9yZS5idWlsZExvZ1N1ZmZpeCgnZW5jcnlwdGVkQ2hhbm5lbFN1cHBvcnQnKTtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRmVhdHVyZShlcnJNc2cgKyBcIi4gXCIgKyBzdWZmaXgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lLmluZGV4T2YoJ3ByaXZhdGUtJykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlUHJpdmF0ZUNoYW5uZWwobmFtZSwgcHVzaGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCdwcmVzZW5jZS0nKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGVQcmVzZW5jZUNoYW5uZWwobmFtZSwgcHVzaGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5pbmRleE9mKCcjJykgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEJhZENoYW5uZWxOYW1lKCdDYW5ub3QgY3JlYXRlIGEgY2hhbm5lbCB3aXRoIG5hbWUgXCInICsgbmFtZSArICdcIi4nKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZUNoYW5uZWwobmFtZSwgcHVzaGVyKTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdXRpbHMvZmFjdG9yeS50c1xuXG5cblxuXG5cblxuXG5cblxudmFyIEZhY3RvcnkgPSB7XG4gICAgY3JlYXRlQ2hhbm5lbHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjaGFubmVscygpO1xuICAgIH0sXG4gICAgY3JlYXRlQ29ubmVjdGlvbk1hbmFnZXI6IGZ1bmN0aW9uIChrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjb25uZWN0aW9uX21hbmFnZXIoa2V5LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGNyZWF0ZUNoYW5uZWw6IGZ1bmN0aW9uIChuYW1lLCBwdXNoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjaGFubmVsc19jaGFubmVsKG5hbWUsIHB1c2hlcik7XG4gICAgfSxcbiAgICBjcmVhdGVQcml2YXRlQ2hhbm5lbDogZnVuY3Rpb24gKG5hbWUsIHB1c2hlcikge1xuICAgICAgICByZXR1cm4gbmV3IHByaXZhdGVfY2hhbm5lbChuYW1lLCBwdXNoZXIpO1xuICAgIH0sXG4gICAgY3JlYXRlUHJlc2VuY2VDaGFubmVsOiBmdW5jdGlvbiAobmFtZSwgcHVzaGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgcHJlc2VuY2VfY2hhbm5lbChuYW1lLCBwdXNoZXIpO1xuICAgIH0sXG4gICAgY3JlYXRlRW5jcnlwdGVkQ2hhbm5lbDogZnVuY3Rpb24gKG5hbWUsIHB1c2hlciwgbmFjbCkge1xuICAgICAgICByZXR1cm4gbmV3IGVuY3J5cHRlZF9jaGFubmVsKG5hbWUsIHB1c2hlciwgbmFjbCk7XG4gICAgfSxcbiAgICBjcmVhdGVUaW1lbGluZVNlbmRlcjogZnVuY3Rpb24gKHRpbWVsaW5lLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGltZWxpbmVfc2VuZGVyKHRpbWVsaW5lLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGNyZWF0ZUhhbmRzaGFrZTogZnVuY3Rpb24gKHRyYW5zcG9ydCwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBjb25uZWN0aW9uX2hhbmRzaGFrZSh0cmFuc3BvcnQsIGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIGNyZWF0ZUFzc2lzdGFudFRvVGhlVHJhbnNwb3J0TWFuYWdlcjogZnVuY3Rpb24gKG1hbmFnZXIsIHRyYW5zcG9ydCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IGFzc2lzdGFudF90b190aGVfdHJhbnNwb3J0X21hbmFnZXIobWFuYWdlciwgdHJhbnNwb3J0LCBvcHRpb25zKTtcbiAgICB9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZmFjdG9yeSA9IChGYWN0b3J5KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS90cmFuc3BvcnRzL3RyYW5zcG9ydF9tYW5hZ2VyLnRzXG5cbnZhciB0cmFuc3BvcnRfbWFuYWdlcl9UcmFuc3BvcnRNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmFuc3BvcnRNYW5hZ2VyKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5saXZlc0xlZnQgPSB0aGlzLm9wdGlvbnMubGl2ZXMgfHwgSW5maW5pdHk7XG4gICAgfVxuICAgIFRyYW5zcG9ydE1hbmFnZXIucHJvdG90eXBlLmdldEFzc2lzdGFudCA9IGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlQXNzaXN0YW50VG9UaGVUcmFuc3BvcnRNYW5hZ2VyKHRoaXMsIHRyYW5zcG9ydCwge1xuICAgICAgICAgICAgbWluUGluZ0RlbGF5OiB0aGlzLm9wdGlvbnMubWluUGluZ0RlbGF5LFxuICAgICAgICAgICAgbWF4UGluZ0RlbGF5OiB0aGlzLm9wdGlvbnMubWF4UGluZ0RlbGF5XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVHJhbnNwb3J0TWFuYWdlci5wcm90b3R5cGUuaXNBbGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGl2ZXNMZWZ0ID4gMDtcbiAgICB9O1xuICAgIFRyYW5zcG9ydE1hbmFnZXIucHJvdG90eXBlLnJlcG9ydERlYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxpdmVzTGVmdCAtPSAxO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zcG9ydE1hbmFnZXI7XG59KCkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdHJhbnNwb3J0X21hbmFnZXIgPSAodHJhbnNwb3J0X21hbmFnZXJfVHJhbnNwb3J0TWFuYWdlcik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvc3RyYXRlZ2llcy9zZXF1ZW50aWFsX3N0cmF0ZWd5LnRzXG5cblxuXG52YXIgc2VxdWVudGlhbF9zdHJhdGVneV9TZXF1ZW50aWFsU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcXVlbnRpYWxTdHJhdGVneShzdHJhdGVnaWVzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3RyYXRlZ2llcyA9IHN0cmF0ZWdpZXM7XG4gICAgICAgIHRoaXMubG9vcCA9IEJvb2xlYW4ob3B0aW9ucy5sb29wKTtcbiAgICAgICAgdGhpcy5mYWlsRmFzdCA9IEJvb2xlYW4ob3B0aW9ucy5mYWlsRmFzdCk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICAgICAgdGhpcy50aW1lb3V0TGltaXQgPSBvcHRpb25zLnRpbWVvdXRMaW1pdDtcbiAgICB9XG4gICAgU2VxdWVudGlhbFN0cmF0ZWd5LnByb3RvdHlwZS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFueSh0aGlzLnN0cmF0ZWdpZXMsIHV0aWwubWV0aG9kKCdpc1N1cHBvcnRlZCcpKTtcbiAgICB9O1xuICAgIFNlcXVlbnRpYWxTdHJhdGVneS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChtaW5Qcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN0cmF0ZWdpZXMgPSB0aGlzLnN0cmF0ZWdpZXM7XG4gICAgICAgIHZhciBjdXJyZW50ID0gMDtcbiAgICAgICAgdmFyIHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgICAgIHZhciBydW5uZXIgPSBudWxsO1xuICAgICAgICB2YXIgdHJ5TmV4dFN0cmF0ZWd5ID0gZnVuY3Rpb24gKGVycm9yLCBoYW5kc2hha2UpIHtcbiAgICAgICAgICAgIGlmIChoYW5kc2hha2UpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBoYW5kc2hha2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQgKyAxO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5sb29wKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50ICUgc3RyYXRlZ2llcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50IDwgc3RyYXRlZ2llcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSB0aW1lb3V0ICogMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy50aW1lb3V0TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gTWF0aC5taW4odGltZW91dCwgX3RoaXMudGltZW91dExpbWl0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBydW5uZXIgPSBfdGhpcy50cnlTdHJhdGVneShzdHJhdGVnaWVzW2N1cnJlbnRdLCBtaW5Qcmlvcml0eSwgeyB0aW1lb3V0OiB0aW1lb3V0LCBmYWlsRmFzdDogX3RoaXMuZmFpbEZhc3QgfSwgdHJ5TmV4dFN0cmF0ZWd5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcnVubmVyID0gdGhpcy50cnlTdHJhdGVneShzdHJhdGVnaWVzW2N1cnJlbnRdLCBtaW5Qcmlvcml0eSwgeyB0aW1lb3V0OiB0aW1lb3V0LCBmYWlsRmFzdDogdGhpcy5mYWlsRmFzdCB9LCB0cnlOZXh0U3RyYXRlZ3kpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5uZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JjZU1pblByaW9yaXR5OiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIG1pblByaW9yaXR5ID0gcDtcbiAgICAgICAgICAgICAgICBpZiAocnVubmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5lci5mb3JjZU1pblByaW9yaXR5KHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFNlcXVlbnRpYWxTdHJhdGVneS5wcm90b3R5cGUudHJ5U3RyYXRlZ3kgPSBmdW5jdGlvbiAoc3RyYXRlZ3ksIG1pblByaW9yaXR5LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgdGltZXIgPSBudWxsO1xuICAgICAgICB2YXIgcnVubmVyID0gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnMudGltZW91dCA+IDApIHtcbiAgICAgICAgICAgIHRpbWVyID0gbmV3IE9uZU9mZlRpbWVyKG9wdGlvbnMudGltZW91dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bm5lci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcnVubmVyID0gc3RyYXRlZ3kuY29ubmVjdChtaW5Qcmlvcml0eSwgZnVuY3Rpb24gKGVycm9yLCBoYW5kc2hha2UpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiB0aW1lciAmJiB0aW1lci5pc1J1bm5pbmcoKSAmJiAhb3B0aW9ucy5mYWlsRmFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgIHRpbWVyLmVuc3VyZUFib3J0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCBoYW5kc2hha2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyLmVuc3VyZUFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnVubmVyLmFib3J0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yY2VNaW5Qcmlvcml0eTogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICBydW5uZXIuZm9yY2VNaW5Qcmlvcml0eShwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBTZXF1ZW50aWFsU3RyYXRlZ3k7XG59KCkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc2VxdWVudGlhbF9zdHJhdGVneSA9IChzZXF1ZW50aWFsX3N0cmF0ZWd5X1NlcXVlbnRpYWxTdHJhdGVneSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvc3RyYXRlZ2llcy9iZXN0X2Nvbm5lY3RlZF9ldmVyX3N0cmF0ZWd5LnRzXG5cblxudmFyIGJlc3RfY29ubmVjdGVkX2V2ZXJfc3RyYXRlZ3lfQmVzdENvbm5lY3RlZEV2ZXJTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmVzdENvbm5lY3RlZEV2ZXJTdHJhdGVneShzdHJhdGVnaWVzKSB7XG4gICAgICAgIHRoaXMuc3RyYXRlZ2llcyA9IHN0cmF0ZWdpZXM7XG4gICAgfVxuICAgIEJlc3RDb25uZWN0ZWRFdmVyU3RyYXRlZ3kucHJvdG90eXBlLmlzU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYW55KHRoaXMuc3RyYXRlZ2llcywgdXRpbC5tZXRob2QoJ2lzU3VwcG9ydGVkJykpO1xuICAgIH07XG4gICAgQmVzdENvbm5lY3RlZEV2ZXJTdHJhdGVneS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChtaW5Qcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3QodGhpcy5zdHJhdGVnaWVzLCBtaW5Qcmlvcml0eSwgZnVuY3Rpb24gKGksIHJ1bm5lcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXJyb3IsIGhhbmRzaGFrZSkge1xuICAgICAgICAgICAgICAgIHJ1bm5lcnNbaV0uZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbFJ1bm5lcnNGYWlsZWQocnVubmVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXBwbHkocnVubmVycywgZnVuY3Rpb24gKHJ1bm5lcikge1xuICAgICAgICAgICAgICAgICAgICBydW5uZXIuZm9yY2VNaW5Qcmlvcml0eShoYW5kc2hha2UudHJhbnNwb3J0LnByaW9yaXR5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBoYW5kc2hha2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQmVzdENvbm5lY3RlZEV2ZXJTdHJhdGVneTtcbn0oKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBiZXN0X2Nvbm5lY3RlZF9ldmVyX3N0cmF0ZWd5ID0gKGJlc3RfY29ubmVjdGVkX2V2ZXJfc3RyYXRlZ3lfQmVzdENvbm5lY3RlZEV2ZXJTdHJhdGVneSk7XG5mdW5jdGlvbiBjb25uZWN0KHN0cmF0ZWdpZXMsIG1pblByaW9yaXR5LCBjYWxsYmFja0J1aWxkZXIpIHtcbiAgICB2YXIgcnVubmVycyA9IG1hcChzdHJhdGVnaWVzLCBmdW5jdGlvbiAoc3RyYXRlZ3ksIGksIF8sIHJzKSB7XG4gICAgICAgIHJldHVybiBzdHJhdGVneS5jb25uZWN0KG1pblByaW9yaXR5LCBjYWxsYmFja0J1aWxkZXIoaSwgcnMpKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXBwbHkocnVubmVycywgYWJvcnRSdW5uZXIpO1xuICAgICAgICB9LFxuICAgICAgICBmb3JjZU1pblByaW9yaXR5OiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgYXBwbHkocnVubmVycywgZnVuY3Rpb24gKHJ1bm5lcikge1xuICAgICAgICAgICAgICAgIHJ1bm5lci5mb3JjZU1pblByaW9yaXR5KHApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gYWxsUnVubmVyc0ZhaWxlZChydW5uZXJzKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb25zX2FsbChydW5uZXJzLCBmdW5jdGlvbiAocnVubmVyKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHJ1bm5lci5lcnJvcik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBhYm9ydFJ1bm5lcihydW5uZXIpIHtcbiAgICBpZiAoIXJ1bm5lci5lcnJvciAmJiAhcnVubmVyLmFib3J0ZWQpIHtcbiAgICAgICAgcnVubmVyLmFib3J0KCk7XG4gICAgICAgIHJ1bm5lci5hYm9ydGVkID0gdHJ1ZTtcbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvc3RyYXRlZ2llcy9jYWNoZWRfc3RyYXRlZ3kudHNcblxuXG5cblxudmFyIGNhY2hlZF9zdHJhdGVneV9DYWNoZWRTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FjaGVkU3RyYXRlZ3koc3RyYXRlZ3ksIHRyYW5zcG9ydHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgICAgICB0aGlzLnRyYW5zcG9ydHMgPSB0cmFuc3BvcnRzO1xuICAgICAgICB0aGlzLnR0bCA9IG9wdGlvbnMudHRsIHx8IDE4MDAgKiAxMDAwO1xuICAgICAgICB0aGlzLnVzaW5nVExTID0gb3B0aW9ucy51c2VUTFM7XG4gICAgICAgIHRoaXMudGltZWxpbmUgPSBvcHRpb25zLnRpbWVsaW5lO1xuICAgIH1cbiAgICBDYWNoZWRTdHJhdGVneS5wcm90b3R5cGUuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmF0ZWd5LmlzU3VwcG9ydGVkKCk7XG4gICAgfTtcbiAgICBDYWNoZWRTdHJhdGVneS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChtaW5Qcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHVzaW5nVExTID0gdGhpcy51c2luZ1RMUztcbiAgICAgICAgdmFyIGluZm8gPSBmZXRjaFRyYW5zcG9ydENhY2hlKHVzaW5nVExTKTtcbiAgICAgICAgdmFyIHN0cmF0ZWdpZXMgPSBbdGhpcy5zdHJhdGVneV07XG4gICAgICAgIGlmIChpbmZvICYmIGluZm8udGltZXN0YW1wICsgdGhpcy50dGwgPj0gdXRpbC5ub3coKSkge1xuICAgICAgICAgICAgdmFyIHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0c1tpbmZvLnRyYW5zcG9ydF07XG4gICAgICAgICAgICBpZiAodHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lbGluZS5pbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6IGluZm8udHJhbnNwb3J0LFxuICAgICAgICAgICAgICAgICAgICBsYXRlbmN5OiBpbmZvLmxhdGVuY3lcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdHJhdGVnaWVzLnB1c2gobmV3IHNlcXVlbnRpYWxfc3RyYXRlZ3koW3RyYW5zcG9ydF0sIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dDogaW5mby5sYXRlbmN5ICogMiArIDEwMDAsXG4gICAgICAgICAgICAgICAgICAgIGZhaWxGYXN0OiB0cnVlXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydFRpbWVzdGFtcCA9IHV0aWwubm93KCk7XG4gICAgICAgIHZhciBydW5uZXIgPSBzdHJhdGVnaWVzXG4gICAgICAgICAgICAucG9wKClcbiAgICAgICAgICAgIC5jb25uZWN0KG1pblByaW9yaXR5LCBmdW5jdGlvbiBjYihlcnJvciwgaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBmbHVzaFRyYW5zcG9ydENhY2hlKHVzaW5nVExTKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyYXRlZ2llcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wID0gdXRpbC5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgcnVubmVyID0gc3RyYXRlZ2llcy5wb3AoKS5jb25uZWN0KG1pblByaW9yaXR5LCBjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RvcmVUcmFuc3BvcnRDYWNoZSh1c2luZ1RMUywgaGFuZHNoYWtlLnRyYW5zcG9ydC5uYW1lLCB1dGlsLm5vdygpIC0gc3RhcnRUaW1lc3RhbXApO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGhhbmRzaGFrZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5uZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JjZU1pblByaW9yaXR5OiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIG1pblByaW9yaXR5ID0gcDtcbiAgICAgICAgICAgICAgICBpZiAocnVubmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5lci5mb3JjZU1pblByaW9yaXR5KHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBDYWNoZWRTdHJhdGVneTtcbn0oKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjYWNoZWRfc3RyYXRlZ3kgPSAoY2FjaGVkX3N0cmF0ZWd5X0NhY2hlZFN0cmF0ZWd5KTtcbmZ1bmN0aW9uIGdldFRyYW5zcG9ydENhY2hlS2V5KHVzaW5nVExTKSB7XG4gICAgcmV0dXJuICdwdXNoZXJUcmFuc3BvcnQnICsgKHVzaW5nVExTID8gJ1RMUycgOiAnTm9uVExTJyk7XG59XG5mdW5jdGlvbiBmZXRjaFRyYW5zcG9ydENhY2hlKHVzaW5nVExTKSB7XG4gICAgdmFyIHN0b3JhZ2UgPSBydW50aW1lLmdldExvY2FsU3RvcmFnZSgpO1xuICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgc2VyaWFsaXplZENhY2hlID0gc3RvcmFnZVtnZXRUcmFuc3BvcnRDYWNoZUtleSh1c2luZ1RMUyldO1xuICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWRDYWNoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHNlcmlhbGl6ZWRDYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGZsdXNoVHJhbnNwb3J0Q2FjaGUodXNpbmdUTFMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc3RvcmVUcmFuc3BvcnRDYWNoZSh1c2luZ1RMUywgdHJhbnNwb3J0LCBsYXRlbmN5KSB7XG4gICAgdmFyIHN0b3JhZ2UgPSBydW50aW1lLmdldExvY2FsU3RvcmFnZSgpO1xuICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdG9yYWdlW2dldFRyYW5zcG9ydENhY2hlS2V5KHVzaW5nVExTKV0gPSBzYWZlSlNPTlN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdGltZXN0YW1wOiB1dGlsLm5vdygpLFxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydDogdHJhbnNwb3J0LFxuICAgICAgICAgICAgICAgIGxhdGVuY3k6IGxhdGVuY3lcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBmbHVzaFRyYW5zcG9ydENhY2hlKHVzaW5nVExTKSB7XG4gICAgdmFyIHN0b3JhZ2UgPSBydW50aW1lLmdldExvY2FsU3RvcmFnZSgpO1xuICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWxldGUgc3RvcmFnZVtnZXRUcmFuc3BvcnRDYWNoZUtleSh1c2luZ1RMUyldO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvc3RyYXRlZ2llcy9kZWxheWVkX3N0cmF0ZWd5LnRzXG5cbnZhciBkZWxheWVkX3N0cmF0ZWd5X0RlbGF5ZWRTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVsYXllZFN0cmF0ZWd5KHN0cmF0ZWd5LCBfYSkge1xuICAgICAgICB2YXIgbnVtYmVyID0gX2EuZGVsYXk7XG4gICAgICAgIHRoaXMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0geyBkZWxheTogbnVtYmVyIH07XG4gICAgfVxuICAgIERlbGF5ZWRTdHJhdGVneS5wcm90b3R5cGUuaXNTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmF0ZWd5LmlzU3VwcG9ydGVkKCk7XG4gICAgfTtcbiAgICBEZWxheWVkU3RyYXRlZ3kucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAobWluUHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzdHJhdGVneSA9IHRoaXMuc3RyYXRlZ3k7XG4gICAgICAgIHZhciBydW5uZXI7XG4gICAgICAgIHZhciB0aW1lciA9IG5ldyBPbmVPZmZUaW1lcih0aGlzLm9wdGlvbnMuZGVsYXksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJ1bm5lciA9IHN0cmF0ZWd5LmNvbm5lY3QobWluUHJpb3JpdHksIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRpbWVyLmVuc3VyZUFib3J0ZWQoKTtcbiAgICAgICAgICAgICAgICBpZiAocnVubmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5lci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JjZU1pblByaW9yaXR5OiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIG1pblByaW9yaXR5ID0gcDtcbiAgICAgICAgICAgICAgICBpZiAocnVubmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5lci5mb3JjZU1pblByaW9yaXR5KHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBEZWxheWVkU3RyYXRlZ3k7XG59KCkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZGVsYXllZF9zdHJhdGVneSA9IChkZWxheWVkX3N0cmF0ZWd5X0RlbGF5ZWRTdHJhdGVneSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvc3RyYXRlZ2llcy9pZl9zdHJhdGVneS50c1xudmFyIElmU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElmU3RyYXRlZ3kodGVzdCwgdHJ1ZUJyYW5jaCwgZmFsc2VCcmFuY2gpIHtcbiAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcbiAgICAgICAgdGhpcy50cnVlQnJhbmNoID0gdHJ1ZUJyYW5jaDtcbiAgICAgICAgdGhpcy5mYWxzZUJyYW5jaCA9IGZhbHNlQnJhbmNoO1xuICAgIH1cbiAgICBJZlN0cmF0ZWd5LnByb3RvdHlwZS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJyYW5jaCA9IHRoaXMudGVzdCgpID8gdGhpcy50cnVlQnJhbmNoIDogdGhpcy5mYWxzZUJyYW5jaDtcbiAgICAgICAgcmV0dXJuIGJyYW5jaC5pc1N1cHBvcnRlZCgpO1xuICAgIH07XG4gICAgSWZTdHJhdGVneS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChtaW5Qcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGJyYW5jaCA9IHRoaXMudGVzdCgpID8gdGhpcy50cnVlQnJhbmNoIDogdGhpcy5mYWxzZUJyYW5jaDtcbiAgICAgICAgcmV0dXJuIGJyYW5jaC5jb25uZWN0KG1pblByaW9yaXR5LCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICByZXR1cm4gSWZTdHJhdGVneTtcbn0oKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBpZl9zdHJhdGVneSA9IChJZlN0cmF0ZWd5KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9zdHJhdGVnaWVzL2ZpcnN0X2Nvbm5lY3RlZF9zdHJhdGVneS50c1xudmFyIEZpcnN0Q29ubmVjdGVkU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpcnN0Q29ubmVjdGVkU3RyYXRlZ3koc3RyYXRlZ3kpIHtcbiAgICAgICAgdGhpcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgIH1cbiAgICBGaXJzdENvbm5lY3RlZFN0cmF0ZWd5LnByb3RvdHlwZS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyYXRlZ3kuaXNTdXBwb3J0ZWQoKTtcbiAgICB9O1xuICAgIEZpcnN0Q29ubmVjdGVkU3RyYXRlZ3kucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAobWluUHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBydW5uZXIgPSB0aGlzLnN0cmF0ZWd5LmNvbm5lY3QobWluUHJpb3JpdHksIGZ1bmN0aW9uIChlcnJvciwgaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICBpZiAoaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICAgICAgcnVubmVyLmFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgaGFuZHNoYWtlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfTtcbiAgICByZXR1cm4gRmlyc3RDb25uZWN0ZWRTdHJhdGVneTtcbn0oKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBmaXJzdF9jb25uZWN0ZWRfc3RyYXRlZ3kgPSAoRmlyc3RDb25uZWN0ZWRTdHJhdGVneSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL3dlYi9kZWZhdWx0X3N0cmF0ZWd5LnRzXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIHRlc3RTdXBwb3J0c1N0cmF0ZWd5KHN0cmF0ZWd5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmF0ZWd5LmlzU3VwcG9ydGVkKCk7XG4gICAgfTtcbn1cbnZhciBnZXREZWZhdWx0U3RyYXRlZ3kgPSBmdW5jdGlvbiAoY29uZmlnLCBiYXNlT3B0aW9ucywgZGVmaW5lVHJhbnNwb3J0KSB7XG4gICAgdmFyIGRlZmluZWRUcmFuc3BvcnRzID0ge307XG4gICAgZnVuY3Rpb24gZGVmaW5lVHJhbnNwb3J0U3RyYXRlZ3kobmFtZSwgdHlwZSwgcHJpb3JpdHksIG9wdGlvbnMsIG1hbmFnZXIpIHtcbiAgICAgICAgdmFyIHRyYW5zcG9ydCA9IGRlZmluZVRyYW5zcG9ydChjb25maWcsIG5hbWUsIHR5cGUsIHByaW9yaXR5LCBvcHRpb25zLCBtYW5hZ2VyKTtcbiAgICAgICAgZGVmaW5lZFRyYW5zcG9ydHNbbmFtZV0gPSB0cmFuc3BvcnQ7XG4gICAgICAgIHJldHVybiB0cmFuc3BvcnQ7XG4gICAgfVxuICAgIHZhciB3c19vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgYmFzZU9wdGlvbnMsIHtcbiAgICAgICAgaG9zdE5vblRMUzogY29uZmlnLndzSG9zdCArICc6JyArIGNvbmZpZy53c1BvcnQsXG4gICAgICAgIGhvc3RUTFM6IGNvbmZpZy53c0hvc3QgKyAnOicgKyBjb25maWcud3NzUG9ydCxcbiAgICAgICAgaHR0cFBhdGg6IGNvbmZpZy53c1BhdGhcbiAgICB9KTtcbiAgICB2YXIgd3NzX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB3c19vcHRpb25zLCB7XG4gICAgICAgIHVzZVRMUzogdHJ1ZVxuICAgIH0pO1xuICAgIHZhciBzb2NranNfb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2VPcHRpb25zLCB7XG4gICAgICAgIGhvc3ROb25UTFM6IGNvbmZpZy5odHRwSG9zdCArICc6JyArIGNvbmZpZy5odHRwUG9ydCxcbiAgICAgICAgaG9zdFRMUzogY29uZmlnLmh0dHBIb3N0ICsgJzonICsgY29uZmlnLmh0dHBzUG9ydCxcbiAgICAgICAgaHR0cFBhdGg6IGNvbmZpZy5odHRwUGF0aFxuICAgIH0pO1xuICAgIHZhciB0aW1lb3V0cyA9IHtcbiAgICAgICAgbG9vcDogdHJ1ZSxcbiAgICAgICAgdGltZW91dDogMTUwMDAsXG4gICAgICAgIHRpbWVvdXRMaW1pdDogNjAwMDBcbiAgICB9O1xuICAgIHZhciB3c19tYW5hZ2VyID0gbmV3IHRyYW5zcG9ydF9tYW5hZ2VyKHtcbiAgICAgICAgbGl2ZXM6IDIsXG4gICAgICAgIG1pblBpbmdEZWxheTogMTAwMDAsXG4gICAgICAgIG1heFBpbmdEZWxheTogY29uZmlnLmFjdGl2aXR5VGltZW91dFxuICAgIH0pO1xuICAgIHZhciBzdHJlYW1pbmdfbWFuYWdlciA9IG5ldyB0cmFuc3BvcnRfbWFuYWdlcih7XG4gICAgICAgIGxpdmVzOiAyLFxuICAgICAgICBtaW5QaW5nRGVsYXk6IDEwMDAwLFxuICAgICAgICBtYXhQaW5nRGVsYXk6IGNvbmZpZy5hY3Rpdml0eVRpbWVvdXRcbiAgICB9KTtcbiAgICB2YXIgd3NfdHJhbnNwb3J0ID0gZGVmaW5lVHJhbnNwb3J0U3RyYXRlZ3koJ3dzJywgJ3dzJywgMywgd3Nfb3B0aW9ucywgd3NfbWFuYWdlcik7XG4gICAgdmFyIHdzc190cmFuc3BvcnQgPSBkZWZpbmVUcmFuc3BvcnRTdHJhdGVneSgnd3NzJywgJ3dzJywgMywgd3NzX29wdGlvbnMsIHdzX21hbmFnZXIpO1xuICAgIHZhciBzb2NranNfdHJhbnNwb3J0ID0gZGVmaW5lVHJhbnNwb3J0U3RyYXRlZ3koJ3NvY2tqcycsICdzb2NranMnLCAxLCBzb2NranNfb3B0aW9ucyk7XG4gICAgdmFyIHhocl9zdHJlYW1pbmdfdHJhbnNwb3J0ID0gZGVmaW5lVHJhbnNwb3J0U3RyYXRlZ3koJ3hocl9zdHJlYW1pbmcnLCAneGhyX3N0cmVhbWluZycsIDEsIHNvY2tqc19vcHRpb25zLCBzdHJlYW1pbmdfbWFuYWdlcik7XG4gICAgdmFyIHhkcl9zdHJlYW1pbmdfdHJhbnNwb3J0ID0gZGVmaW5lVHJhbnNwb3J0U3RyYXRlZ3koJ3hkcl9zdHJlYW1pbmcnLCAneGRyX3N0cmVhbWluZycsIDEsIHNvY2tqc19vcHRpb25zLCBzdHJlYW1pbmdfbWFuYWdlcik7XG4gICAgdmFyIHhocl9wb2xsaW5nX3RyYW5zcG9ydCA9IGRlZmluZVRyYW5zcG9ydFN0cmF0ZWd5KCd4aHJfcG9sbGluZycsICd4aHJfcG9sbGluZycsIDEsIHNvY2tqc19vcHRpb25zKTtcbiAgICB2YXIgeGRyX3BvbGxpbmdfdHJhbnNwb3J0ID0gZGVmaW5lVHJhbnNwb3J0U3RyYXRlZ3koJ3hkcl9wb2xsaW5nJywgJ3hkcl9wb2xsaW5nJywgMSwgc29ja2pzX29wdGlvbnMpO1xuICAgIHZhciB3c19sb29wID0gbmV3IHNlcXVlbnRpYWxfc3RyYXRlZ3koW3dzX3RyYW5zcG9ydF0sIHRpbWVvdXRzKTtcbiAgICB2YXIgd3NzX2xvb3AgPSBuZXcgc2VxdWVudGlhbF9zdHJhdGVneShbd3NzX3RyYW5zcG9ydF0sIHRpbWVvdXRzKTtcbiAgICB2YXIgc29ja2pzX2xvb3AgPSBuZXcgc2VxdWVudGlhbF9zdHJhdGVneShbc29ja2pzX3RyYW5zcG9ydF0sIHRpbWVvdXRzKTtcbiAgICB2YXIgc3RyZWFtaW5nX2xvb3AgPSBuZXcgc2VxdWVudGlhbF9zdHJhdGVneShbXG4gICAgICAgIG5ldyBpZl9zdHJhdGVneSh0ZXN0U3VwcG9ydHNTdHJhdGVneSh4aHJfc3RyZWFtaW5nX3RyYW5zcG9ydCksIHhocl9zdHJlYW1pbmdfdHJhbnNwb3J0LCB4ZHJfc3RyZWFtaW5nX3RyYW5zcG9ydClcbiAgICBdLCB0aW1lb3V0cyk7XG4gICAgdmFyIHBvbGxpbmdfbG9vcCA9IG5ldyBzZXF1ZW50aWFsX3N0cmF0ZWd5KFtcbiAgICAgICAgbmV3IGlmX3N0cmF0ZWd5KHRlc3RTdXBwb3J0c1N0cmF0ZWd5KHhocl9wb2xsaW5nX3RyYW5zcG9ydCksIHhocl9wb2xsaW5nX3RyYW5zcG9ydCwgeGRyX3BvbGxpbmdfdHJhbnNwb3J0KVxuICAgIF0sIHRpbWVvdXRzKTtcbiAgICB2YXIgaHR0cF9sb29wID0gbmV3IHNlcXVlbnRpYWxfc3RyYXRlZ3koW1xuICAgICAgICBuZXcgaWZfc3RyYXRlZ3kodGVzdFN1cHBvcnRzU3RyYXRlZ3koc3RyZWFtaW5nX2xvb3ApLCBuZXcgYmVzdF9jb25uZWN0ZWRfZXZlcl9zdHJhdGVneShbXG4gICAgICAgICAgICBzdHJlYW1pbmdfbG9vcCxcbiAgICAgICAgICAgIG5ldyBkZWxheWVkX3N0cmF0ZWd5KHBvbGxpbmdfbG9vcCwgeyBkZWxheTogNDAwMCB9KVxuICAgICAgICBdKSwgcG9sbGluZ19sb29wKVxuICAgIF0sIHRpbWVvdXRzKTtcbiAgICB2YXIgaHR0cF9mYWxsYmFja19sb29wID0gbmV3IGlmX3N0cmF0ZWd5KHRlc3RTdXBwb3J0c1N0cmF0ZWd5KGh0dHBfbG9vcCksIGh0dHBfbG9vcCwgc29ja2pzX2xvb3ApO1xuICAgIHZhciB3c1N0cmF0ZWd5O1xuICAgIGlmIChiYXNlT3B0aW9ucy51c2VUTFMpIHtcbiAgICAgICAgd3NTdHJhdGVneSA9IG5ldyBiZXN0X2Nvbm5lY3RlZF9ldmVyX3N0cmF0ZWd5KFtcbiAgICAgICAgICAgIHdzX2xvb3AsXG4gICAgICAgICAgICBuZXcgZGVsYXllZF9zdHJhdGVneShodHRwX2ZhbGxiYWNrX2xvb3AsIHsgZGVsYXk6IDIwMDAgfSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3c1N0cmF0ZWd5ID0gbmV3IGJlc3RfY29ubmVjdGVkX2V2ZXJfc3RyYXRlZ3koW1xuICAgICAgICAgICAgd3NfbG9vcCxcbiAgICAgICAgICAgIG5ldyBkZWxheWVkX3N0cmF0ZWd5KHdzc19sb29wLCB7IGRlbGF5OiAyMDAwIH0pLFxuICAgICAgICAgICAgbmV3IGRlbGF5ZWRfc3RyYXRlZ3koaHR0cF9mYWxsYmFja19sb29wLCB7IGRlbGF5OiA1MDAwIH0pXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGNhY2hlZF9zdHJhdGVneShuZXcgZmlyc3RfY29ubmVjdGVkX3N0cmF0ZWd5KG5ldyBpZl9zdHJhdGVneSh0ZXN0U3VwcG9ydHNTdHJhdGVneSh3c190cmFuc3BvcnQpLCB3c1N0cmF0ZWd5LCBodHRwX2ZhbGxiYWNrX2xvb3ApKSwgZGVmaW5lZFRyYW5zcG9ydHMsIHtcbiAgICAgICAgdHRsOiAxODAwMDAwLFxuICAgICAgICB0aW1lbGluZTogYmFzZU9wdGlvbnMudGltZWxpbmUsXG4gICAgICAgIHVzZVRMUzogYmFzZU9wdGlvbnMudXNlVExTXG4gICAgfSk7XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZGVmYXVsdF9zdHJhdGVneSA9IChnZXREZWZhdWx0U3RyYXRlZ3kpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvdHJhbnNwb3J0cy90cmFuc3BvcnRfY29ubmVjdGlvbl9pbml0aWFsaXplci50c1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BvcnRfY29ubmVjdGlvbl9pbml0aWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYudGltZWxpbmUuaW5mbyhzZWxmLmJ1aWxkVGltZWxpbmVNZXNzYWdlKHtcbiAgICAgICAgdHJhbnNwb3J0OiBzZWxmLm5hbWUgKyAoc2VsZi5vcHRpb25zLnVzZVRMUyA/ICdzJyA6ICcnKVxuICAgIH0pKTtcbiAgICBpZiAoc2VsZi5ob29rcy5pc0luaXRpYWxpemVkKCkpIHtcbiAgICAgICAgc2VsZi5jaGFuZ2VTdGF0ZSgnaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VsZi5ob29rcy5maWxlKSB7XG4gICAgICAgIHNlbGYuY2hhbmdlU3RhdGUoJ2luaXRpYWxpemluZycpO1xuICAgICAgICBEZXBlbmRlbmNpZXMubG9hZChzZWxmLmhvb2tzLmZpbGUsIHsgdXNlVExTOiBzZWxmLm9wdGlvbnMudXNlVExTIH0sIGZ1bmN0aW9uIChlcnJvciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmhvb2tzLmlzSW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY2hhbmdlU3RhdGUoJ2luaXRpYWxpemVkJyk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNlbGYub25DbG9zZSgpO1xuICAgIH1cbn0pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy93ZWIvaHR0cC9odHRwX3hkb21haW5fcmVxdWVzdC50c1xuXG52YXIgaHR0cF94ZG9tYWluX3JlcXVlc3RfaG9va3MgPSB7XG4gICAgZ2V0UmVxdWVzdDogZnVuY3Rpb24gKHNvY2tldCkge1xuICAgICAgICB2YXIgeGRyID0gbmV3IHdpbmRvdy5YRG9tYWluUmVxdWVzdCgpO1xuICAgICAgICB4ZHIub250aW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc29ja2V0LmVtaXQoJ2Vycm9yJywgbmV3IFJlcXVlc3RUaW1lZE91dCgpKTtcbiAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICB4ZHIub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCBlKTtcbiAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICB4ZHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh4ZHIucmVzcG9uc2VUZXh0ICYmIHhkci5yZXNwb25zZVRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNvY2tldC5vbkNodW5rKDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhkci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoeGRyLnJlc3BvbnNlVGV4dCAmJiB4ZHIucmVzcG9uc2VUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQub25DaHVuaygyMDAsIHhkci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc29ja2V0LmVtaXQoJ2ZpbmlzaGVkJywgMjAwKTtcbiAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geGRyO1xuICAgIH0sXG4gICAgYWJvcnRSZXF1ZXN0OiBmdW5jdGlvbiAoeGRyKSB7XG4gICAgICAgIHhkci5vbnRpbWVvdXQgPSB4ZHIub25lcnJvciA9IHhkci5vbnByb2dyZXNzID0geGRyLm9ubG9hZCA9IG51bGw7XG4gICAgICAgIHhkci5hYm9ydCgpO1xuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBodHRwX3hkb21haW5fcmVxdWVzdCA9IChodHRwX3hkb21haW5fcmVxdWVzdF9ob29rcyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvaHR0cC9odHRwX3JlcXVlc3QudHNcbnZhciBodHRwX3JlcXVlc3RfZXh0ZW5kcyA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuXG5cbnZhciBNQVhfQlVGRkVSX0xFTkdUSCA9IDI1NiAqIDEwMjQ7XG52YXIgaHR0cF9yZXF1ZXN0X0hUVFBSZXF1ZXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBodHRwX3JlcXVlc3RfZXh0ZW5kcyhIVFRQUmVxdWVzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIVFRQUmVxdWVzdChob29rcywgbWV0aG9kLCB1cmwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaG9va3MgPSBob29rcztcbiAgICAgICAgX3RoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICBfdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSFRUUFJlcXVlc3QucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgICAgIHRoaXMueGhyID0gdGhpcy5ob29rcy5nZXRSZXF1ZXN0KHRoaXMpO1xuICAgICAgICB0aGlzLnVubG9hZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcnVudGltZS5hZGRVbmxvYWRMaXN0ZW5lcih0aGlzLnVubG9hZGVyKTtcbiAgICAgICAgdGhpcy54aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUpO1xuICAgICAgICBpZiAodGhpcy54aHIuc2V0UmVxdWVzdEhlYWRlcikge1xuICAgICAgICAgICAgdGhpcy54aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnhoci5zZW5kKHBheWxvYWQpO1xuICAgIH07XG4gICAgSFRUUFJlcXVlc3QucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy51bmxvYWRlcikge1xuICAgICAgICAgICAgcnVudGltZS5yZW1vdmVVbmxvYWRMaXN0ZW5lcih0aGlzLnVubG9hZGVyKTtcbiAgICAgICAgICAgIHRoaXMudW5sb2FkZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnhocikge1xuICAgICAgICAgICAgdGhpcy5ob29rcy5hYm9ydFJlcXVlc3QodGhpcy54aHIpO1xuICAgICAgICAgICAgdGhpcy54aHIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIVFRQUmVxdWVzdC5wcm90b3R5cGUub25DaHVuayA9IGZ1bmN0aW9uIChzdGF0dXMsIGRhdGEpIHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciBjaHVuayA9IHRoaXMuYWR2YW5jZUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgICAgIGlmIChjaHVuaykge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY2h1bmsnLCB7IHN0YXR1czogc3RhdHVzLCBkYXRhOiBjaHVuayB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzQnVmZmVyVG9vTG9uZyhkYXRhKSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdidWZmZXJfdG9vX2xvbmcnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSFRUUFJlcXVlc3QucHJvdG90eXBlLmFkdmFuY2VCdWZmZXIgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIHZhciB1bnJlYWREYXRhID0gYnVmZmVyLnNsaWNlKHRoaXMucG9zaXRpb24pO1xuICAgICAgICB2YXIgZW5kT2ZMaW5lUG9zaXRpb24gPSB1bnJlYWREYXRhLmluZGV4T2YoJ1xcbicpO1xuICAgICAgICBpZiAoZW5kT2ZMaW5lUG9zaXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uICs9IGVuZE9mTGluZVBvc2l0aW9uICsgMTtcbiAgICAgICAgICAgIHJldHVybiB1bnJlYWREYXRhLnNsaWNlKDAsIGVuZE9mTGluZVBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIVFRQUmVxdWVzdC5wcm90b3R5cGUuaXNCdWZmZXJUb29Mb25nID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiA9PT0gYnVmZmVyLmxlbmd0aCAmJiBidWZmZXIubGVuZ3RoID4gTUFYX0JVRkZFUl9MRU5HVEg7XG4gICAgfTtcbiAgICByZXR1cm4gSFRUUFJlcXVlc3Q7XG59KGRpc3BhdGNoZXIpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGh0dHBfcmVxdWVzdCA9IChodHRwX3JlcXVlc3RfSFRUUFJlcXVlc3QpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2h0dHAvc3RhdGUudHNcbnZhciBTdGF0ZTtcbihmdW5jdGlvbiAoU3RhdGUpIHtcbiAgICBTdGF0ZVtTdGF0ZVtcIkNPTk5FQ1RJTkdcIl0gPSAwXSA9IFwiQ09OTkVDVElOR1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BFTlwiXSA9IDFdID0gXCJPUEVOXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJDTE9TRURcIl0gPSAzXSA9IFwiQ0xPU0VEXCI7XG59KShTdGF0ZSB8fCAoU3RhdGUgPSB7fSkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3RhdGUgPSAoU3RhdGUpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2h0dHAvaHR0cF9zb2NrZXQudHNcblxuXG5cbnZhciBhdXRvSW5jcmVtZW50ID0gMTtcbnZhciBodHRwX3NvY2tldF9IVFRQU29ja2V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIVFRQU29ja2V0KGhvb2tzLCB1cmwpIHtcbiAgICAgICAgdGhpcy5ob29rcyA9IGhvb2tzO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSByYW5kb21OdW1iZXIoMTAwMCkgKyAnLycgKyByYW5kb21TdHJpbmcoOCk7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBnZXRMb2NhdGlvbih1cmwpO1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBzdGF0ZS5DT05ORUNUSU5HO1xuICAgICAgICB0aGlzLm9wZW5TdHJlYW0oKTtcbiAgICB9XG4gICAgSFRUUFNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRSYXcoSlNPTi5zdHJpbmdpZnkoW3BheWxvYWRdKSk7XG4gICAgfTtcbiAgICBIVFRQU29ja2V0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhvb2tzLnNlbmRIZWFydGJlYXQodGhpcyk7XG4gICAgfTtcbiAgICBIVFRQU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChjb2RlLCByZWFzb24pIHtcbiAgICAgICAgdGhpcy5vbkNsb3NlKGNvZGUsIHJlYXNvbiwgdHJ1ZSk7XG4gICAgfTtcbiAgICBIVFRQU29ja2V0LnByb3RvdHlwZS5zZW5kUmF3ID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gc3RhdGUuT1BFTikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBydW50aW1lLmNyZWF0ZVNvY2tldFJlcXVlc3QoJ1BPU1QnLCBnZXRVbmlxdWVVUkwoZ2V0U2VuZFVSTCh0aGlzLmxvY2F0aW9uLCB0aGlzLnNlc3Npb24pKSkuc3RhcnQocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSFRUUFNvY2tldC5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsb3NlU3RyZWFtKCk7XG4gICAgICAgIHRoaXMub3BlblN0cmVhbSgpO1xuICAgIH07XG4gICAgSFRUUFNvY2tldC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uIChjb2RlLCByZWFzb24sIHdhc0NsZWFuKSB7XG4gICAgICAgIHRoaXMuY2xvc2VTdHJlYW0oKTtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gc3RhdGUuQ0xPU0VEO1xuICAgICAgICBpZiAodGhpcy5vbmNsb3NlKSB7XG4gICAgICAgICAgICB0aGlzLm9uY2xvc2Uoe1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgICAgICAgICAgcmVhc29uOiByZWFzb24sXG4gICAgICAgICAgICAgICAgd2FzQ2xlYW46IHdhc0NsZWFuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSFRUUFNvY2tldC5wcm90b3R5cGUub25DaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICBpZiAoY2h1bmsuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBzdGF0ZS5PUEVOKSB7XG4gICAgICAgICAgICB0aGlzLm9uQWN0aXZpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF5bG9hZDtcbiAgICAgICAgdmFyIHR5cGUgPSBjaHVuay5kYXRhLnNsaWNlKDAsIDEpO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ28nOlxuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKGNodW5rLmRhdGEuc2xpY2UoMSkgfHwgJ3t9Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk9wZW4ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShjaHVuay5kYXRhLnNsaWNlKDEpIHx8ICdbXScpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF5bG9hZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXZlbnQocGF5bG9hZFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UoY2h1bmsuZGF0YS5zbGljZSgxKSB8fCAnbnVsbCcpO1xuICAgICAgICAgICAgICAgIHRoaXMub25FdmVudChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgICAgIHRoaXMuaG9va3Mub25IZWFydGJlYXQodGhpcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShjaHVuay5kYXRhLnNsaWNlKDEpIHx8ICdbXScpO1xuICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZShwYXlsb2FkWzBdLCBwYXlsb2FkWzFdLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgSFRUUFNvY2tldC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gc3RhdGUuQ09OTkVDVElORykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5ob3N0bmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYXRpb24uYmFzZSA9IHJlcGxhY2VIb3N0KHRoaXMubG9jYXRpb24uYmFzZSwgb3B0aW9ucy5ob3N0bmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBzdGF0ZS5PUEVOO1xuICAgICAgICAgICAgaWYgKHRoaXMub25vcGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbm9wZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZSgxMDA2LCAnU2VydmVyIGxvc3Qgc2Vzc2lvbicsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIVFRQU29ja2V0LnByb3RvdHlwZS5vbkV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IHN0YXRlLk9QRU4gJiYgdGhpcy5vbm1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub25tZXNzYWdlKHsgZGF0YTogZXZlbnQgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhUVFBTb2NrZXQucHJvdG90eXBlLm9uQWN0aXZpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm9uYWN0aXZpdHkpIHtcbiAgICAgICAgICAgIHRoaXMub25hY3Rpdml0eSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIVFRQU29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLm9uZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMub25lcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhUVFBTb2NrZXQucHJvdG90eXBlLm9wZW5TdHJlYW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gcnVudGltZS5jcmVhdGVTb2NrZXRSZXF1ZXN0KCdQT1NUJywgZ2V0VW5pcXVlVVJMKHRoaXMuaG9va3MuZ2V0UmVjZWl2ZVVSTCh0aGlzLmxvY2F0aW9uLCB0aGlzLnNlc3Npb24pKSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmJpbmQoJ2NodW5rJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICBfdGhpcy5vbkNodW5rKGNodW5rKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmJpbmQoJ2ZpbmlzaGVkJywgZnVuY3Rpb24gKHN0YXR1cykge1xuICAgICAgICAgICAgX3RoaXMuaG9va3Mub25GaW5pc2hlZChfdGhpcywgc3RhdHVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmJpbmQoJ2J1ZmZlcl90b29fbG9uZycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnJlY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB1dGlsLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkNsb3NlKDEwMDYsICdDb3VsZCBub3Qgc3RhcnQgc3RyZWFtaW5nJywgZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEhUVFBTb2NrZXQucHJvdG90eXBlLmNsb3NlU3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdHJlYW0pIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLnVuYmluZF9hbGwoKTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBIVFRQU29ja2V0O1xufSgpKTtcbmZ1bmN0aW9uIGdldExvY2F0aW9uKHVybCkge1xuICAgIHZhciBwYXJ0cyA9IC8oW15cXD9dKilcXC8qKFxcPz8uKikvLmV4ZWModXJsKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBiYXNlOiBwYXJ0c1sxXSxcbiAgICAgICAgcXVlcnlTdHJpbmc6IHBhcnRzWzJdXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFNlbmRVUkwodXJsLCBzZXNzaW9uKSB7XG4gICAgcmV0dXJuIHVybC5iYXNlICsgJy8nICsgc2Vzc2lvbiArICcveGhyX3NlbmQnO1xufVxuZnVuY3Rpb24gZ2V0VW5pcXVlVVJMKHVybCkge1xuICAgIHZhciBzZXBhcmF0b3IgPSB1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJztcbiAgICByZXR1cm4gdXJsICsgc2VwYXJhdG9yICsgJ3Q9JyArICtuZXcgRGF0ZSgpICsgJyZuPScgKyBhdXRvSW5jcmVtZW50Kys7XG59XG5mdW5jdGlvbiByZXBsYWNlSG9zdCh1cmwsIGhvc3RuYW1lKSB7XG4gICAgdmFyIHVybFBhcnRzID0gLyhodHRwcz86XFwvXFwvKShbXlxcLzpdKykoKFxcL3w6KT8uKikvLmV4ZWModXJsKTtcbiAgICByZXR1cm4gdXJsUGFydHNbMV0gKyBob3N0bmFtZSArIHVybFBhcnRzWzNdO1xufVxuZnVuY3Rpb24gcmFuZG9tTnVtYmVyKG1heCkge1xuICAgIHJldHVybiBydW50aW1lLnJhbmRvbUludChtYXgpO1xufVxuZnVuY3Rpb24gcmFuZG9tU3RyaW5nKGxlbmd0aCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHJhbmRvbU51bWJlcigzMikudG9TdHJpbmcoMzIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbn1cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGh0dHBfc29ja2V0ID0gKGh0dHBfc29ja2V0X0hUVFBTb2NrZXQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2h0dHAvaHR0cF9zdHJlYW1pbmdfc29ja2V0LnRzXG52YXIgaHR0cF9zdHJlYW1pbmdfc29ja2V0X2hvb2tzID0ge1xuICAgIGdldFJlY2VpdmVVUkw6IGZ1bmN0aW9uICh1cmwsIHNlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHVybC5iYXNlICsgJy8nICsgc2Vzc2lvbiArICcveGhyX3N0cmVhbWluZycgKyB1cmwucXVlcnlTdHJpbmc7XG4gICAgfSxcbiAgICBvbkhlYXJ0YmVhdDogZnVuY3Rpb24gKHNvY2tldCkge1xuICAgICAgICBzb2NrZXQuc2VuZFJhdygnW10nKTtcbiAgICB9LFxuICAgIHNlbmRIZWFydGJlYXQ6IGZ1bmN0aW9uIChzb2NrZXQpIHtcbiAgICAgICAgc29ja2V0LnNlbmRSYXcoJ1tdJyk7XG4gICAgfSxcbiAgICBvbkZpbmlzaGVkOiBmdW5jdGlvbiAoc29ja2V0LCBzdGF0dXMpIHtcbiAgICAgICAgc29ja2V0Lm9uQ2xvc2UoMTAwNiwgJ0Nvbm5lY3Rpb24gaW50ZXJydXB0ZWQgKCcgKyBzdGF0dXMgKyAnKScsIGZhbHNlKTtcbiAgICB9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaHR0cF9zdHJlYW1pbmdfc29ja2V0ID0gKGh0dHBfc3RyZWFtaW5nX3NvY2tldF9ob29rcyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvaHR0cC9odHRwX3BvbGxpbmdfc29ja2V0LnRzXG52YXIgaHR0cF9wb2xsaW5nX3NvY2tldF9ob29rcyA9IHtcbiAgICBnZXRSZWNlaXZlVVJMOiBmdW5jdGlvbiAodXJsLCBzZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB1cmwuYmFzZSArICcvJyArIHNlc3Npb24gKyAnL3hocicgKyB1cmwucXVlcnlTdHJpbmc7XG4gICAgfSxcbiAgICBvbkhlYXJ0YmVhdDogZnVuY3Rpb24gKCkge1xuICAgIH0sXG4gICAgc2VuZEhlYXJ0YmVhdDogZnVuY3Rpb24gKHNvY2tldCkge1xuICAgICAgICBzb2NrZXQuc2VuZFJhdygnW10nKTtcbiAgICB9LFxuICAgIG9uRmluaXNoZWQ6IGZ1bmN0aW9uIChzb2NrZXQsIHN0YXR1cykge1xuICAgICAgICBpZiAoc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHNvY2tldC5yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNvY2tldC5vbkNsb3NlKDEwMDYsICdDb25uZWN0aW9uIGludGVycnVwdGVkICgnICsgc3RhdHVzICsgJyknLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgaHR0cF9wb2xsaW5nX3NvY2tldCA9IChodHRwX3BvbGxpbmdfc29ja2V0X2hvb2tzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvaXNvbW9ycGhpYy9odHRwL2h0dHBfeGhyX3JlcXVlc3QudHNcblxudmFyIGh0dHBfeGhyX3JlcXVlc3RfaG9va3MgPSB7XG4gICAgZ2V0UmVxdWVzdDogZnVuY3Rpb24gKHNvY2tldCkge1xuICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBydW50aW1lLmdldFhIUkFQSSgpO1xuICAgICAgICB2YXIgeGhyID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoeGhyLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmICh4aHIucmVzcG9uc2VUZXh0ICYmIHhoci5yZXNwb25zZVRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uQ2h1bmsoeGhyLnN0YXR1cywgeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnJlc3BvbnNlVGV4dCAmJiB4aHIucmVzcG9uc2VUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbkNodW5rKHhoci5zdGF0dXMsIHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5lbWl0KCdmaW5pc2hlZCcsIHhoci5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB4aHI7XG4gICAgfSxcbiAgICBhYm9ydFJlcXVlc3Q6IGZ1bmN0aW9uICh4aHIpIHtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIHhoci5hYm9ydCgpO1xuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBodHRwX3hocl9yZXF1ZXN0ID0gKGh0dHBfeGhyX3JlcXVlc3RfaG9va3MpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9ydW50aW1lcy9pc29tb3JwaGljL2h0dHAvaHR0cC50c1xuXG5cblxuXG5cbnZhciBIVFRQID0ge1xuICAgIGNyZWF0ZVN0cmVhbWluZ1NvY2tldDogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTb2NrZXQoaHR0cF9zdHJlYW1pbmdfc29ja2V0LCB1cmwpO1xuICAgIH0sXG4gICAgY3JlYXRlUG9sbGluZ1NvY2tldDogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTb2NrZXQoaHR0cF9wb2xsaW5nX3NvY2tldCwgdXJsKTtcbiAgICB9LFxuICAgIGNyZWF0ZVNvY2tldDogZnVuY3Rpb24gKGhvb2tzLCB1cmwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBodHRwX3NvY2tldChob29rcywgdXJsKTtcbiAgICB9LFxuICAgIGNyZWF0ZVhIUjogZnVuY3Rpb24gKG1ldGhvZCwgdXJsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVJlcXVlc3QoaHR0cF94aHJfcmVxdWVzdCwgbWV0aG9kLCB1cmwpO1xuICAgIH0sXG4gICAgY3JlYXRlUmVxdWVzdDogZnVuY3Rpb24gKGhvb2tzLCBtZXRob2QsIHVybCkge1xuICAgICAgICByZXR1cm4gbmV3IGh0dHBfcmVxdWVzdChob29rcywgbWV0aG9kLCB1cmwpO1xuICAgIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBodHRwX2h0dHAgPSAoSFRUUCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3J1bnRpbWVzL3dlYi9odHRwL2h0dHAudHNcblxuXG5odHRwX2h0dHAuY3JlYXRlWERSID0gZnVuY3Rpb24gKG1ldGhvZCwgdXJsKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlUmVxdWVzdChodHRwX3hkb21haW5fcmVxdWVzdCwgbWV0aG9kLCB1cmwpO1xufTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHdlYl9odHRwX2h0dHAgPSAoaHR0cF9odHRwKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcnVudGltZXMvd2ViL3J1bnRpbWUudHNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBSdW50aW1lID0ge1xuICAgIG5leHRBdXRoQ2FsbGJhY2tJRDogMSxcbiAgICBhdXRoX2NhbGxiYWNrczoge30sXG4gICAgU2NyaXB0UmVjZWl2ZXJzOiBTY3JpcHRSZWNlaXZlcnMsXG4gICAgRGVwZW5kZW5jaWVzUmVjZWl2ZXJzOiBEZXBlbmRlbmNpZXNSZWNlaXZlcnMsXG4gICAgZ2V0RGVmYXVsdFN0cmF0ZWd5OiBkZWZhdWx0X3N0cmF0ZWd5LFxuICAgIFRyYW5zcG9ydHM6IHRyYW5zcG9ydHNfdHJhbnNwb3J0cyxcbiAgICB0cmFuc3BvcnRDb25uZWN0aW9uSW5pdGlhbGl6ZXI6IHRyYW5zcG9ydF9jb25uZWN0aW9uX2luaXRpYWxpemVyLFxuICAgIEhUVFBGYWN0b3J5OiB3ZWJfaHR0cF9odHRwLFxuICAgIFRpbWVsaW5lVHJhbnNwb3J0OiBqc29ucF90aW1lbGluZSxcbiAgICBnZXRYSFJBUEk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5YTUxIdHRwUmVxdWVzdDtcbiAgICB9LFxuICAgIGdldFdlYlNvY2tldEFQSTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LldlYlNvY2tldCB8fCB3aW5kb3cuTW96V2ViU29ja2V0O1xuICAgIH0sXG4gICAgc2V0dXA6IGZ1bmN0aW9uIChQdXNoZXJDbGFzcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB3aW5kb3cuUHVzaGVyID0gUHVzaGVyQ2xhc3M7XG4gICAgICAgIHZhciBpbml0aWFsaXplT25Eb2N1bWVudEJvZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5vbkRvY3VtZW50Qm9keShQdXNoZXJDbGFzcy5yZWFkeSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghd2luZG93LkpTT04pIHtcbiAgICAgICAgICAgIERlcGVuZGVuY2llcy5sb2FkKCdqc29uMicsIHt9LCBpbml0aWFsaXplT25Eb2N1bWVudEJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5pdGlhbGl6ZU9uRG9jdW1lbnRCb2R5KCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldERvY3VtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9LFxuICAgIGdldFByb3RvY29sOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERvY3VtZW50KCkubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgfSxcbiAgICBnZXRBdXRob3JpemVyczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4geyBhamF4OiB4aHJfYXV0aCwganNvbnA6IGpzb25wX2F1dGggfTtcbiAgICB9LFxuICAgIG9uRG9jdW1lbnRCb2R5OiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkRvY3VtZW50Qm9keShjYWxsYmFjayk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlSlNPTlBSZXF1ZXN0OiBmdW5jdGlvbiAodXJsLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBuZXcganNvbnBfcmVxdWVzdCh1cmwsIGRhdGEpO1xuICAgIH0sXG4gICAgY3JlYXRlU2NyaXB0UmVxdWVzdDogZnVuY3Rpb24gKHNyYykge1xuICAgICAgICByZXR1cm4gbmV3IHNjcmlwdF9yZXF1ZXN0KHNyYyk7XG4gICAgfSxcbiAgICBnZXRMb2NhbFN0b3JhZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVYSFI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0WEhSQVBJKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVNaWNyb3NvZnRYSFIoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlWE1MSHR0cFJlcXVlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcy5nZXRYSFJBUEkoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgIH0sXG4gICAgY3JlYXRlTWljcm9zb2Z0WEhSOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9LFxuICAgIGdldE5ldHdvcms6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldF9pbmZvX05ldHdvcms7XG4gICAgfSxcbiAgICBjcmVhdGVXZWJTb2NrZXQ6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcy5nZXRXZWJTb2NrZXRBUEkoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih1cmwpO1xuICAgIH0sXG4gICAgY3JlYXRlU29ja2V0UmVxdWVzdDogZnVuY3Rpb24gKG1ldGhvZCwgdXJsKSB7XG4gICAgICAgIGlmICh0aGlzLmlzWEhSU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkhUVFBGYWN0b3J5LmNyZWF0ZVhIUihtZXRob2QsIHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1hEUlN1cHBvcnRlZCh1cmwuaW5kZXhPZignaHR0cHM6JykgPT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5IVFRQRmFjdG9yeS5jcmVhdGVYRFIobWV0aG9kLCB1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgJ0Nyb3NzLW9yaWdpbiBIVFRQIHJlcXVlc3RzIGFyZSBub3Qgc3VwcG9ydGVkJztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaXNYSFJTdXBwb3J0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcy5nZXRYSFJBUEkoKTtcbiAgICAgICAgcmV0dXJuIChCb29sZWFuKENvbnN0cnVjdG9yKSAmJiBuZXcgQ29uc3RydWN0b3IoKS53aXRoQ3JlZGVudGlhbHMgIT09IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBpc1hEUlN1cHBvcnRlZDogZnVuY3Rpb24gKHVzZVRMUykge1xuICAgICAgICB2YXIgcHJvdG9jb2wgPSB1c2VUTFMgPyAnaHR0cHM6JyA6ICdodHRwOic7XG4gICAgICAgIHZhciBkb2N1bWVudFByb3RvY29sID0gdGhpcy5nZXRQcm90b2NvbCgpO1xuICAgICAgICByZXR1cm4gKEJvb2xlYW4od2luZG93WydYRG9tYWluUmVxdWVzdCddKSAmJiBkb2N1bWVudFByb3RvY29sID09PSBwcm90b2NvbCk7XG4gICAgfSxcbiAgICBhZGRVbmxvYWRMaXN0ZW5lcjogZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5sb2FkJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3aW5kb3cuYXR0YWNoRXZlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2luZG93LmF0dGFjaEV2ZW50KCdvbnVubG9hZCcsIGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlVW5sb2FkTGlzdGVuZXI6IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VubG9hZCcsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAod2luZG93LmRldGFjaEV2ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5kZXRhY2hFdmVudCgnb251bmxvYWQnLCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJhbmRvbUludDogZnVuY3Rpb24gKG1heCkge1xuICAgICAgICB2YXIgcmFuZG9tID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNyeXB0byA9IHdpbmRvdy5jcnlwdG8gfHwgd2luZG93Wydtc0NyeXB0byddO1xuICAgICAgICAgICAgdmFyIHJhbmRvbSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDEpKVswXTtcbiAgICAgICAgICAgIHJldHVybiByYW5kb20gLyBNYXRoLnBvdygyLCAzMik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHJhbmRvbSgpICogbWF4KTtcbiAgICB9XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcnVudGltZSA9IChSdW50aW1lKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS90aW1lbGluZS9sZXZlbC50c1xudmFyIFRpbWVsaW5lTGV2ZWw7XG4oZnVuY3Rpb24gKFRpbWVsaW5lTGV2ZWwpIHtcbiAgICBUaW1lbGluZUxldmVsW1RpbWVsaW5lTGV2ZWxbXCJFUlJPUlwiXSA9IDNdID0gXCJFUlJPUlwiO1xuICAgIFRpbWVsaW5lTGV2ZWxbVGltZWxpbmVMZXZlbFtcIklORk9cIl0gPSA2XSA9IFwiSU5GT1wiO1xuICAgIFRpbWVsaW5lTGV2ZWxbVGltZWxpbmVMZXZlbFtcIkRFQlVHXCJdID0gN10gPSBcIkRFQlVHXCI7XG59KShUaW1lbGluZUxldmVsIHx8IChUaW1lbGluZUxldmVsID0ge30pKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRpbWVsaW5lX2xldmVsID0gKFRpbWVsaW5lTGV2ZWwpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL3RpbWVsaW5lL3RpbWVsaW5lLnRzXG5cblxuXG52YXIgdGltZWxpbmVfVGltZWxpbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbWVsaW5lKGtleSwgc2Vzc2lvbiwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5zZW50ID0gMDtcbiAgICAgICAgdGhpcy51bmlxdWVJRCA9IDA7XG4gICAgfVxuICAgIFRpbWVsaW5lLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAobGV2ZWwsIGV2ZW50KSB7XG4gICAgICAgIGlmIChsZXZlbCA8PSB0aGlzLm9wdGlvbnMubGV2ZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnB1c2goZXh0ZW5kKHt9LCBldmVudCwgeyB0aW1lc3RhbXA6IHV0aWwubm93KCkgfSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saW1pdCAmJiB0aGlzLmV2ZW50cy5sZW5ndGggPiB0aGlzLm9wdGlvbnMubGltaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUaW1lbGluZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5sb2codGltZWxpbmVfbGV2ZWwuRVJST1IsIGV2ZW50KTtcbiAgICB9O1xuICAgIFRpbWVsaW5lLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMubG9nKHRpbWVsaW5lX2xldmVsLklORk8sIGV2ZW50KTtcbiAgICB9O1xuICAgIFRpbWVsaW5lLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmxvZyh0aW1lbGluZV9sZXZlbC5ERUJVRywgZXZlbnQpO1xuICAgIH07XG4gICAgVGltZWxpbmUucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50cy5sZW5ndGggPT09IDA7XG4gICAgfTtcbiAgICBUaW1lbGluZS5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChzZW5kZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhID0gZXh0ZW5kKHtcbiAgICAgICAgICAgIHNlc3Npb246IHRoaXMuc2Vzc2lvbixcbiAgICAgICAgICAgIGJ1bmRsZTogdGhpcy5zZW50ICsgMSxcbiAgICAgICAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICAgICAgICBsaWI6ICdqcycsXG4gICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLm9wdGlvbnMudmVyc2lvbixcbiAgICAgICAgICAgIGNsdXN0ZXI6IHRoaXMub3B0aW9ucy5jbHVzdGVyLFxuICAgICAgICAgICAgZmVhdHVyZXM6IHRoaXMub3B0aW9ucy5mZWF0dXJlcyxcbiAgICAgICAgICAgIHRpbWVsaW5lOiB0aGlzLmV2ZW50c1xuICAgICAgICB9LCB0aGlzLm9wdGlvbnMucGFyYW1zKTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgc2VuZGZuKGRhdGEsIGZ1bmN0aW9uIChlcnJvciwgcmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFRpbWVsaW5lLnByb3RvdHlwZS5nZW5lcmF0ZVVuaXF1ZUlEID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVuaXF1ZUlEKys7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaXF1ZUlEO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVsaW5lO1xufSgpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRpbWVsaW5lX3RpbWVsaW5lID0gKHRpbWVsaW5lX1RpbWVsaW5lKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9zdHJhdGVnaWVzL3RyYW5zcG9ydF9zdHJhdGVneS50c1xuXG5cblxuXG52YXIgdHJhbnNwb3J0X3N0cmF0ZWd5X1RyYW5zcG9ydFN0cmF0ZWd5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmFuc3BvcnRTdHJhdGVneShuYW1lLCBwcmlvcml0eSwgdHJhbnNwb3J0LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgfVxuICAgIFRyYW5zcG9ydFN0cmF0ZWd5LnByb3RvdHlwZS5pc1N1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LmlzU3VwcG9ydGVkKHtcbiAgICAgICAgICAgIHVzZVRMUzogdGhpcy5vcHRpb25zLnVzZVRMU1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydFN0cmF0ZWd5LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKG1pblByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWxBdHRlbXB0KG5ldyBVbnN1cHBvcnRlZFN0cmF0ZWd5KCksIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnByaW9yaXR5IDwgbWluUHJpb3JpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsQXR0ZW1wdChuZXcgVHJhbnNwb3J0UHJpb3JpdHlUb29Mb3coKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0LmNyZWF0ZUNvbm5lY3Rpb24odGhpcy5uYW1lLCB0aGlzLnByaW9yaXR5LCB0aGlzLm9wdGlvbnMua2V5LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB2YXIgaGFuZHNoYWtlID0gbnVsbDtcbiAgICAgICAgdmFyIG9uSW5pdGlhbGl6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQudW5iaW5kKCdpbml0aWFsaXplZCcsIG9uSW5pdGlhbGl6ZWQpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LmNvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGhhbmRzaGFrZSA9IGZhY3RvcnkuY3JlYXRlSGFuZHNoYWtlKHRyYW5zcG9ydCwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdW5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb25FcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdW5iaW5kTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvbkNsb3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHVuYmluZExpc3RlbmVycygpO1xuICAgICAgICAgICAgdmFyIHNlcmlhbGl6ZWRUcmFuc3BvcnQ7XG4gICAgICAgICAgICBzZXJpYWxpemVkVHJhbnNwb3J0ID0gc2FmZUpTT05TdHJpbmdpZnkodHJhbnNwb3J0KTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBUcmFuc3BvcnRDbG9zZWQoc2VyaWFsaXplZFRyYW5zcG9ydCkpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdW5iaW5kTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0LnVuYmluZCgnaW5pdGlhbGl6ZWQnLCBvbkluaXRpYWxpemVkKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC51bmJpbmQoJ29wZW4nLCBvbk9wZW4pO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnVuYmluZCgnZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC51bmJpbmQoJ2Nsb3NlZCcsIG9uQ2xvc2VkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnNwb3J0LmJpbmQoJ2luaXRpYWxpemVkJywgb25Jbml0aWFsaXplZCk7XG4gICAgICAgIHRyYW5zcG9ydC5iaW5kKCdvcGVuJywgb25PcGVuKTtcbiAgICAgICAgdHJhbnNwb3J0LmJpbmQoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgIHRyYW5zcG9ydC5iaW5kKCdjbG9zZWQnLCBvbkNsb3NlZCk7XG4gICAgICAgIHRyYW5zcG9ydC5pbml0aWFsaXplKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhYm9ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bmJpbmRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZHNoYWtlKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRzaGFrZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wcmlvcml0eSA8IHApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRzaGFrZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZHNoYWtlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBUcmFuc3BvcnRTdHJhdGVneTtcbn0oKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0cmFuc3BvcnRfc3RyYXRlZ3kgPSAodHJhbnNwb3J0X3N0cmF0ZWd5X1RyYW5zcG9ydFN0cmF0ZWd5KTtcbmZ1bmN0aW9uIGZhaWxBdHRlbXB0KGVycm9yLCBjYWxsYmFjaykge1xuICAgIHV0aWwuZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWJvcnQ6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICAgICAgZm9yY2VNaW5Qcmlvcml0eTogZnVuY3Rpb24gKCkgeyB9XG4gICAgfTtcbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9zdHJhdGVnaWVzL3N0cmF0ZWd5X2J1aWxkZXIudHNcblxuXG5cblxuXG52YXIgc3RyYXRlZ3lfYnVpbGRlcl9UcmFuc3BvcnRzID0gcnVudGltZS5UcmFuc3BvcnRzO1xudmFyIHN0cmF0ZWd5X2J1aWxkZXJfZGVmaW5lVHJhbnNwb3J0ID0gZnVuY3Rpb24gKGNvbmZpZywgbmFtZSwgdHlwZSwgcHJpb3JpdHksIG9wdGlvbnMsIG1hbmFnZXIpIHtcbiAgICB2YXIgdHJhbnNwb3J0Q2xhc3MgPSBzdHJhdGVneV9idWlsZGVyX1RyYW5zcG9ydHNbdHlwZV07XG4gICAgaWYgKCF0cmFuc3BvcnRDbGFzcykge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRUcmFuc3BvcnQodHlwZSk7XG4gICAgfVxuICAgIHZhciBlbmFibGVkID0gKCFjb25maWcuZW5hYmxlZFRyYW5zcG9ydHMgfHxcbiAgICAgICAgYXJyYXlJbmRleE9mKGNvbmZpZy5lbmFibGVkVHJhbnNwb3J0cywgbmFtZSkgIT09IC0xKSAmJlxuICAgICAgICAoIWNvbmZpZy5kaXNhYmxlZFRyYW5zcG9ydHMgfHxcbiAgICAgICAgICAgIGFycmF5SW5kZXhPZihjb25maWcuZGlzYWJsZWRUcmFuc3BvcnRzLCBuYW1lKSA9PT0gLTEpO1xuICAgIHZhciB0cmFuc3BvcnQ7XG4gICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBpZ25vcmVOdWxsT3JpZ2luOiBjb25maWcuaWdub3JlTnVsbE9yaWdpbiB9LCBvcHRpb25zKTtcbiAgICAgICAgdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydF9zdHJhdGVneShuYW1lLCBwcmlvcml0eSwgbWFuYWdlciA/IG1hbmFnZXIuZ2V0QXNzaXN0YW50KHRyYW5zcG9ydENsYXNzKSA6IHRyYW5zcG9ydENsYXNzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRyYW5zcG9ydCA9IHN0cmF0ZWd5X2J1aWxkZXJfVW5zdXBwb3J0ZWRTdHJhdGVneTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zcG9ydDtcbn07XG52YXIgc3RyYXRlZ3lfYnVpbGRlcl9VbnN1cHBvcnRlZFN0cmF0ZWd5ID0ge1xuICAgIGlzU3VwcG9ydGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGNvbm5lY3Q6IGZ1bmN0aW9uIChfLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSB1dGlsLmRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBVbnN1cHBvcnRlZFN0cmF0ZWd5KCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFib3J0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQuZW5zdXJlQWJvcnRlZCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmNlTWluUHJpb3JpdHk6IGZ1bmN0aW9uICgpIHsgfVxuICAgICAgICB9O1xuICAgIH1cbn07XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvb3B0aW9ucy50c1xuXG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgJ1lvdSBtdXN0IHBhc3MgYW4gb3B0aW9ucyBvYmplY3QnO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jbHVzdGVyID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgJ09wdGlvbnMgb2JqZWN0IG11c3QgcHJvdmlkZSBhIGNsdXN0ZXInO1xuICAgIH1cbiAgICBpZiAoJ2Rpc2FibGVTdGF0cycgaW4gb3B0aW9ucykge1xuICAgICAgICBsb2dnZXIud2FybignVGhlIGRpc2FibGVTdGF0cyBvcHRpb24gaXMgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBlbmFibGVTdGF0cycpO1xuICAgIH1cbn1cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9hdXRoL3VzZXJfYXV0aGVudGljYXRvci50c1xuXG5cbnZhciBjb21wb3NlQ2hhbm5lbFF1ZXJ5ID0gZnVuY3Rpb24gKHBhcmFtcywgYXV0aE9wdGlvbnMpIHtcbiAgICB2YXIgcXVlcnkgPSAnc29ja2V0X2lkPScgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnNvY2tldElkKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gYXV0aE9wdGlvbnMucGFyYW1zKSB7XG4gICAgICAgIHF1ZXJ5ICs9XG4gICAgICAgICAgICAnJicgK1xuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICtcbiAgICAgICAgICAgICAgICAnPScgK1xuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChhdXRoT3B0aW9ucy5wYXJhbXNba2V5XSk7XG4gICAgfVxuICAgIGlmIChhdXRoT3B0aW9ucy5wYXJhbXNQcm92aWRlciAhPSBudWxsKSB7XG4gICAgICAgIHZhciBkeW5hbWljUGFyYW1zID0gYXV0aE9wdGlvbnMucGFyYW1zUHJvdmlkZXIoKTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGR5bmFtaWNQYXJhbXMpIHtcbiAgICAgICAgICAgIHF1ZXJ5ICs9XG4gICAgICAgICAgICAgICAgJyYnICtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgK1xuICAgICAgICAgICAgICAgICAgICAnPScgK1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoZHluYW1pY1BhcmFtc1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcXVlcnk7XG59O1xudmFyIFVzZXJBdXRoZW50aWNhdG9yID0gZnVuY3Rpb24gKGF1dGhPcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBydW50aW1lLmdldEF1dGhvcml6ZXJzKClbYXV0aE9wdGlvbnMudHJhbnNwb3J0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgXCInXCIgKyBhdXRoT3B0aW9ucy50cmFuc3BvcnQgKyBcIicgaXMgbm90IGEgcmVjb2duaXplZCBhdXRoIHRyYW5zcG9ydFwiO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gY29tcG9zZUNoYW5uZWxRdWVyeShwYXJhbXMsIGF1dGhPcHRpb25zKTtcbiAgICAgICAgcnVudGltZS5nZXRBdXRob3JpemVycygpW2F1dGhPcHRpb25zLnRyYW5zcG9ydF0ocnVudGltZSwgcXVlcnksIGF1dGhPcHRpb25zLCBBdXRoUmVxdWVzdFR5cGUuVXNlckF1dGhlbnRpY2F0aW9uLCBjYWxsYmFjayk7XG4gICAgfTtcbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB1c2VyX2F1dGhlbnRpY2F0b3IgPSAoVXNlckF1dGhlbnRpY2F0b3IpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9jb3JlL2F1dGgvY2hhbm5lbF9hdXRob3JpemVyLnRzXG5cblxudmFyIGNoYW5uZWxfYXV0aG9yaXplcl9jb21wb3NlQ2hhbm5lbFF1ZXJ5ID0gZnVuY3Rpb24gKHBhcmFtcywgYXV0aE9wdGlvbnMpIHtcbiAgICB2YXIgcXVlcnkgPSAnc29ja2V0X2lkPScgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnNvY2tldElkKTtcbiAgICBxdWVyeSArPSAnJmNoYW5uZWxfbmFtZT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5jaGFubmVsTmFtZSk7XG4gICAgZm9yICh2YXIga2V5IGluIGF1dGhPcHRpb25zLnBhcmFtcykge1xuICAgICAgICBxdWVyeSArPVxuICAgICAgICAgICAgJyYnICtcbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArXG4gICAgICAgICAgICAgICAgJz0nICtcbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoYXV0aE9wdGlvbnMucGFyYW1zW2tleV0pO1xuICAgIH1cbiAgICBpZiAoYXV0aE9wdGlvbnMucGFyYW1zUHJvdmlkZXIgIT0gbnVsbCkge1xuICAgICAgICB2YXIgZHluYW1pY1BhcmFtcyA9IGF1dGhPcHRpb25zLnBhcmFtc1Byb3ZpZGVyKCk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkeW5hbWljUGFyYW1zKSB7XG4gICAgICAgICAgICBxdWVyeSArPVxuICAgICAgICAgICAgICAgICcmJyArXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICtcbiAgICAgICAgICAgICAgICAgICAgJz0nICtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGR5bmFtaWNQYXJhbXNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5O1xufTtcbnZhciBDaGFubmVsQXV0aG9yaXplciA9IGZ1bmN0aW9uIChhdXRoT3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgcnVudGltZS5nZXRBdXRob3JpemVycygpW2F1dGhPcHRpb25zLnRyYW5zcG9ydF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IFwiJ1wiICsgYXV0aE9wdGlvbnMudHJhbnNwb3J0ICsgXCInIGlzIG5vdCBhIHJlY29nbml6ZWQgYXV0aCB0cmFuc3BvcnRcIjtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBxdWVyeSA9IGNoYW5uZWxfYXV0aG9yaXplcl9jb21wb3NlQ2hhbm5lbFF1ZXJ5KHBhcmFtcywgYXV0aE9wdGlvbnMpO1xuICAgICAgICBydW50aW1lLmdldEF1dGhvcml6ZXJzKClbYXV0aE9wdGlvbnMudHJhbnNwb3J0XShydW50aW1lLCBxdWVyeSwgYXV0aE9wdGlvbnMsIEF1dGhSZXF1ZXN0VHlwZS5DaGFubmVsQXV0aG9yaXphdGlvbiwgY2FsbGJhY2spO1xuICAgIH07XG59O1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2hhbm5lbF9hdXRob3JpemVyID0gKENoYW5uZWxBdXRob3JpemVyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9hdXRoL2RlcHJlY2F0ZWRfY2hhbm5lbF9hdXRob3JpemVyLnRzXG52YXIgQ2hhbm5lbEF1dGhvcml6ZXJQcm94eSA9IGZ1bmN0aW9uIChwdXNoZXIsIGF1dGhPcHRpb25zLCBjaGFubmVsQXV0aG9yaXplckdlbmVyYXRvcikge1xuICAgIHZhciBkZXByZWNhdGVkQXV0aG9yaXplck9wdGlvbnMgPSB7XG4gICAgICAgIGF1dGhUcmFuc3BvcnQ6IGF1dGhPcHRpb25zLnRyYW5zcG9ydCxcbiAgICAgICAgYXV0aEVuZHBvaW50OiBhdXRoT3B0aW9ucy5lbmRwb2ludCxcbiAgICAgICAgYXV0aDoge1xuICAgICAgICAgICAgcGFyYW1zOiBhdXRoT3B0aW9ucy5wYXJhbXMsXG4gICAgICAgICAgICBoZWFkZXJzOiBhdXRoT3B0aW9ucy5oZWFkZXJzXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHB1c2hlci5jaGFubmVsKHBhcmFtcy5jaGFubmVsTmFtZSk7XG4gICAgICAgIHZhciBjaGFubmVsQXV0aG9yaXplciA9IGNoYW5uZWxBdXRob3JpemVyR2VuZXJhdG9yKGNoYW5uZWwsIGRlcHJlY2F0ZWRBdXRob3JpemVyT3B0aW9ucyk7XG4gICAgICAgIGNoYW5uZWxBdXRob3JpemVyLmF1dGhvcml6ZShwYXJhbXMuc29ja2V0SWQsIGNhbGxiYWNrKTtcbiAgICB9O1xufTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9jb25maWcudHNcbnZhciBfX2Fzc2lnbiA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5cblxuXG5cbmZ1bmN0aW9uIGdldENvbmZpZyhvcHRzLCBwdXNoZXIpIHtcbiAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICBhY3Rpdml0eVRpbWVvdXQ6IG9wdHMuYWN0aXZpdHlUaW1lb3V0IHx8IGRlZmF1bHRzLmFjdGl2aXR5VGltZW91dCxcbiAgICAgICAgY2x1c3Rlcjogb3B0cy5jbHVzdGVyLFxuICAgICAgICBodHRwUGF0aDogb3B0cy5odHRwUGF0aCB8fCBkZWZhdWx0cy5odHRwUGF0aCxcbiAgICAgICAgaHR0cFBvcnQ6IG9wdHMuaHR0cFBvcnQgfHwgZGVmYXVsdHMuaHR0cFBvcnQsXG4gICAgICAgIGh0dHBzUG9ydDogb3B0cy5odHRwc1BvcnQgfHwgZGVmYXVsdHMuaHR0cHNQb3J0LFxuICAgICAgICBwb25nVGltZW91dDogb3B0cy5wb25nVGltZW91dCB8fCBkZWZhdWx0cy5wb25nVGltZW91dCxcbiAgICAgICAgc3RhdHNIb3N0OiBvcHRzLnN0YXRzSG9zdCB8fCBkZWZhdWx0cy5zdGF0c19ob3N0LFxuICAgICAgICB1bmF2YWlsYWJsZVRpbWVvdXQ6IG9wdHMudW5hdmFpbGFibGVUaW1lb3V0IHx8IGRlZmF1bHRzLnVuYXZhaWxhYmxlVGltZW91dCxcbiAgICAgICAgd3NQYXRoOiBvcHRzLndzUGF0aCB8fCBkZWZhdWx0cy53c1BhdGgsXG4gICAgICAgIHdzUG9ydDogb3B0cy53c1BvcnQgfHwgZGVmYXVsdHMud3NQb3J0LFxuICAgICAgICB3c3NQb3J0OiBvcHRzLndzc1BvcnQgfHwgZGVmYXVsdHMud3NzUG9ydCxcbiAgICAgICAgZW5hYmxlU3RhdHM6IGdldEVuYWJsZVN0YXRzQ29uZmlnKG9wdHMpLFxuICAgICAgICBodHRwSG9zdDogZ2V0SHR0cEhvc3Qob3B0cyksXG4gICAgICAgIHVzZVRMUzogc2hvdWxkVXNlVExTKG9wdHMpLFxuICAgICAgICB3c0hvc3Q6IGdldFdlYnNvY2tldEhvc3Qob3B0cyksXG4gICAgICAgIHVzZXJBdXRoZW50aWNhdG9yOiBidWlsZFVzZXJBdXRoZW50aWNhdG9yKG9wdHMpLFxuICAgICAgICBjaGFubmVsQXV0aG9yaXplcjogYnVpbGRDaGFubmVsQXV0aG9yaXplcihvcHRzLCBwdXNoZXIpXG4gICAgfTtcbiAgICBpZiAoJ2Rpc2FibGVkVHJhbnNwb3J0cycgaW4gb3B0cylcbiAgICAgICAgY29uZmlnLmRpc2FibGVkVHJhbnNwb3J0cyA9IG9wdHMuZGlzYWJsZWRUcmFuc3BvcnRzO1xuICAgIGlmICgnZW5hYmxlZFRyYW5zcG9ydHMnIGluIG9wdHMpXG4gICAgICAgIGNvbmZpZy5lbmFibGVkVHJhbnNwb3J0cyA9IG9wdHMuZW5hYmxlZFRyYW5zcG9ydHM7XG4gICAgaWYgKCdpZ25vcmVOdWxsT3JpZ2luJyBpbiBvcHRzKVxuICAgICAgICBjb25maWcuaWdub3JlTnVsbE9yaWdpbiA9IG9wdHMuaWdub3JlTnVsbE9yaWdpbjtcbiAgICBpZiAoJ3RpbWVsaW5lUGFyYW1zJyBpbiBvcHRzKVxuICAgICAgICBjb25maWcudGltZWxpbmVQYXJhbXMgPSBvcHRzLnRpbWVsaW5lUGFyYW1zO1xuICAgIGlmICgnbmFjbCcgaW4gb3B0cykge1xuICAgICAgICBjb25maWcubmFjbCA9IG9wdHMubmFjbDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZztcbn1cbmZ1bmN0aW9uIGdldEh0dHBIb3N0KG9wdHMpIHtcbiAgICBpZiAob3B0cy5odHRwSG9zdCkge1xuICAgICAgICByZXR1cm4gb3B0cy5odHRwSG9zdDtcbiAgICB9XG4gICAgaWYgKG9wdHMuY2x1c3Rlcikge1xuICAgICAgICByZXR1cm4gXCJzb2NranMtXCIgKyBvcHRzLmNsdXN0ZXIgKyBcIi5wdXNoZXIuY29tXCI7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0cy5odHRwSG9zdDtcbn1cbmZ1bmN0aW9uIGdldFdlYnNvY2tldEhvc3Qob3B0cykge1xuICAgIGlmIChvcHRzLndzSG9zdCkge1xuICAgICAgICByZXR1cm4gb3B0cy53c0hvc3Q7XG4gICAgfVxuICAgIHJldHVybiBnZXRXZWJzb2NrZXRIb3N0RnJvbUNsdXN0ZXIob3B0cy5jbHVzdGVyKTtcbn1cbmZ1bmN0aW9uIGdldFdlYnNvY2tldEhvc3RGcm9tQ2x1c3RlcihjbHVzdGVyKSB7XG4gICAgcmV0dXJuIFwid3MtXCIgKyBjbHVzdGVyICsgXCIucHVzaGVyLmNvbVwiO1xufVxuZnVuY3Rpb24gc2hvdWxkVXNlVExTKG9wdHMpIHtcbiAgICBpZiAocnVudGltZS5nZXRQcm90b2NvbCgpID09PSAnaHR0cHM6Jykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0cy5mb3JjZVRMUyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldEVuYWJsZVN0YXRzQ29uZmlnKG9wdHMpIHtcbiAgICBpZiAoJ2VuYWJsZVN0YXRzJyBpbiBvcHRzKSB7XG4gICAgICAgIHJldHVybiBvcHRzLmVuYWJsZVN0YXRzO1xuICAgIH1cbiAgICBpZiAoJ2Rpc2FibGVTdGF0cycgaW4gb3B0cykge1xuICAgICAgICByZXR1cm4gIW9wdHMuZGlzYWJsZVN0YXRzO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBidWlsZFVzZXJBdXRoZW50aWNhdG9yKG9wdHMpIHtcbiAgICB2YXIgdXNlckF1dGhlbnRpY2F0aW9uID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGRlZmF1bHRzLnVzZXJBdXRoZW50aWNhdGlvbiksIG9wdHMudXNlckF1dGhlbnRpY2F0aW9uKTtcbiAgICBpZiAoJ2N1c3RvbUhhbmRsZXInIGluIHVzZXJBdXRoZW50aWNhdGlvbiAmJlxuICAgICAgICB1c2VyQXV0aGVudGljYXRpb25bJ2N1c3RvbUhhbmRsZXInXSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1c2VyQXV0aGVudGljYXRpb25bJ2N1c3RvbUhhbmRsZXInXTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZXJfYXV0aGVudGljYXRvcih1c2VyQXV0aGVudGljYXRpb24pO1xufVxuZnVuY3Rpb24gYnVpbGRDaGFubmVsQXV0aChvcHRzLCBwdXNoZXIpIHtcbiAgICB2YXIgY2hhbm5lbEF1dGhvcml6YXRpb247XG4gICAgaWYgKCdjaGFubmVsQXV0aG9yaXphdGlvbicgaW4gb3B0cykge1xuICAgICAgICBjaGFubmVsQXV0aG9yaXphdGlvbiA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0cy5jaGFubmVsQXV0aG9yaXphdGlvbiksIG9wdHMuY2hhbm5lbEF1dGhvcml6YXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hhbm5lbEF1dGhvcml6YXRpb24gPSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQ6IG9wdHMuYXV0aFRyYW5zcG9ydCB8fCBkZWZhdWx0cy5hdXRoVHJhbnNwb3J0LFxuICAgICAgICAgICAgZW5kcG9pbnQ6IG9wdHMuYXV0aEVuZHBvaW50IHx8IGRlZmF1bHRzLmF1dGhFbmRwb2ludFxuICAgICAgICB9O1xuICAgICAgICBpZiAoJ2F1dGgnIGluIG9wdHMpIHtcbiAgICAgICAgICAgIGlmICgncGFyYW1zJyBpbiBvcHRzLmF1dGgpXG4gICAgICAgICAgICAgICAgY2hhbm5lbEF1dGhvcml6YXRpb24ucGFyYW1zID0gb3B0cy5hdXRoLnBhcmFtcztcbiAgICAgICAgICAgIGlmICgnaGVhZGVycycgaW4gb3B0cy5hdXRoKVxuICAgICAgICAgICAgICAgIGNoYW5uZWxBdXRob3JpemF0aW9uLmhlYWRlcnMgPSBvcHRzLmF1dGguaGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2F1dGhvcml6ZXInIGluIG9wdHMpXG4gICAgICAgICAgICBjaGFubmVsQXV0aG9yaXphdGlvbi5jdXN0b21IYW5kbGVyID0gQ2hhbm5lbEF1dGhvcml6ZXJQcm94eShwdXNoZXIsIGNoYW5uZWxBdXRob3JpemF0aW9uLCBvcHRzLmF1dGhvcml6ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbm5lbEF1dGhvcml6YXRpb247XG59XG5mdW5jdGlvbiBidWlsZENoYW5uZWxBdXRob3JpemVyKG9wdHMsIHB1c2hlcikge1xuICAgIHZhciBjaGFubmVsQXV0aG9yaXphdGlvbiA9IGJ1aWxkQ2hhbm5lbEF1dGgob3B0cywgcHVzaGVyKTtcbiAgICBpZiAoJ2N1c3RvbUhhbmRsZXInIGluIGNoYW5uZWxBdXRob3JpemF0aW9uICYmXG4gICAgICAgIGNoYW5uZWxBdXRob3JpemF0aW9uWydjdXN0b21IYW5kbGVyJ10gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY2hhbm5lbEF1dGhvcml6YXRpb25bJ2N1c3RvbUhhbmRsZXInXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5uZWxfYXV0aG9yaXplcihjaGFubmVsQXV0aG9yaXphdGlvbik7XG59XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvd2F0Y2hsaXN0LnRzXG52YXIgd2F0Y2hsaXN0X2V4dGVuZHMgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcblxuXG52YXIgd2F0Y2hsaXN0X1dhdGNobGlzdEZhY2FkZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgd2F0Y2hsaXN0X2V4dGVuZHMoV2F0Y2hsaXN0RmFjYWRlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdhdGNobGlzdEZhY2FkZShwdXNoZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZnVuY3Rpb24gKGV2ZW50TmFtZSwgZGF0YSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiTm8gY2FsbGJhY2tzIG9uIHdhdGNobGlzdCBldmVudHMgZm9yIFwiICsgZXZlbnROYW1lKTtcbiAgICAgICAgfSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucHVzaGVyID0gcHVzaGVyO1xuICAgICAgICBfdGhpcy5iaW5kV2F0Y2hsaXN0SW50ZXJuYWxFdmVudCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFdhdGNobGlzdEZhY2FkZS5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAocHVzaGVyRXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcHVzaGVyRXZlbnQuZGF0YS5ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAod2F0Y2hsaXN0RXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXQod2F0Y2hsaXN0RXZlbnQubmFtZSwgd2F0Y2hsaXN0RXZlbnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFdhdGNobGlzdEZhY2FkZS5wcm90b3R5cGUuYmluZFdhdGNobGlzdEludGVybmFsRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucHVzaGVyLmNvbm5lY3Rpb24uYmluZCgnbWVzc2FnZScsIGZ1bmN0aW9uIChwdXNoZXJFdmVudCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IHB1c2hlckV2ZW50LmV2ZW50O1xuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3B1c2hlcl9pbnRlcm5hbDp3YXRjaGxpc3RfZXZlbnRzJykge1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZUV2ZW50KHB1c2hlckV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gV2F0Y2hsaXN0RmFjYWRlO1xufShkaXNwYXRjaGVyKSk7XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB3YXRjaGxpc3QgPSAod2F0Y2hsaXN0X1dhdGNobGlzdEZhY2FkZSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2NvcmUvdXRpbHMvZmxhdF9wcm9taXNlLnRzXG5mdW5jdGlvbiBmbGF0UHJvbWlzZSgpIHtcbiAgICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlcywgcmVqKSB7XG4gICAgICAgIHJlc29sdmUgPSByZXM7XG4gICAgICAgIHJlamVjdCA9IHJlajtcbiAgICB9KTtcbiAgICByZXR1cm4geyBwcm9taXNlOiBwcm9taXNlLCByZXNvbHZlOiByZXNvbHZlLCByZWplY3Q6IHJlamVjdCB9O1xufVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZmxhdF9wcm9taXNlID0gKGZsYXRQcm9taXNlKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS91c2VyLnRzXG52YXIgdXNlcl9leHRlbmRzID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5cblxuXG5cblxudmFyIHVzZXJfVXNlckZhY2FkZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdXNlcl9leHRlbmRzKFVzZXJGYWNhZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVXNlckZhY2FkZShwdXNoZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZnVuY3Rpb24gKGV2ZW50TmFtZSwgZGF0YSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdObyBjYWxsYmFja3Mgb24gdXNlciBmb3IgJyArIGV2ZW50TmFtZSk7XG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNpZ25pbl9yZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMudXNlcl9kYXRhID0gbnVsbDtcbiAgICAgICAgX3RoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCA9IG51bGw7XG4gICAgICAgIF90aGlzLnNpZ25pbkRvbmVQcm9taXNlID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX3NpZ25pbkRvbmVSZXNvbHZlID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX29uQXV0aG9yaXplID0gZnVuY3Rpb24gKGVyciwgYXV0aERhdGEpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIkVycm9yIGR1cmluZyBzaWduaW46IFwiICsgZXJyKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnB1c2hlci5zZW5kX2V2ZW50KCdwdXNoZXI6c2lnbmluJywge1xuICAgICAgICAgICAgICAgIGF1dGg6IGF1dGhEYXRhLmF1dGgsXG4gICAgICAgICAgICAgICAgdXNlcl9kYXRhOiBhdXRoRGF0YS51c2VyX2RhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5wdXNoZXIgPSBwdXNoZXI7XG4gICAgICAgIF90aGlzLnB1c2hlci5jb25uZWN0aW9uLmJpbmQoJ3N0YXRlX2NoYW5nZScsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gX2EucHJldmlvdXMsIGN1cnJlbnQgPSBfYS5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzICE9PSAnY29ubmVjdGVkJyAmJiBjdXJyZW50ID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zaWduaW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2aW91cyA9PT0gJ2Nvbm5lY3RlZCcgJiYgY3VycmVudCAhPT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9uZXdTaWduaW5Qcm9taXNlSWZOZWVkZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLndhdGNobGlzdCA9IG5ldyB3YXRjaGxpc3QocHVzaGVyKTtcbiAgICAgICAgX3RoaXMucHVzaGVyLmNvbm5lY3Rpb24uYmluZCgnbWVzc2FnZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGV2ZW50LmV2ZW50O1xuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3B1c2hlcjpzaWduaW5fc3VjY2VzcycpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fb25TaWduaW5TdWNjZXNzKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLnNlcnZlclRvVXNlckNoYW5uZWwgJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsLm5hbWUgPT09IGV2ZW50LmNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVXNlckZhY2FkZS5wcm90b3R5cGUuc2lnbmluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zaWduaW5fcmVxdWVzdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaWduaW5fcmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2lnbmluKCk7XG4gICAgfTtcbiAgICBVc2VyRmFjYWRlLnByb3RvdHlwZS5fc2lnbmluID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2lnbmluX3JlcXVlc3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25ld1NpZ25pblByb21pc2VJZk5lZWRlZCgpO1xuICAgICAgICBpZiAodGhpcy5wdXNoZXIuY29ubmVjdGlvbi5zdGF0ZSAhPT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1c2hlci5jb25maWcudXNlckF1dGhlbnRpY2F0b3Ioe1xuICAgICAgICAgICAgc29ja2V0SWQ6IHRoaXMucHVzaGVyLmNvbm5lY3Rpb24uc29ja2V0X2lkXG4gICAgICAgIH0sIHRoaXMuX29uQXV0aG9yaXplKTtcbiAgICB9O1xuICAgIFVzZXJGYWNhZGUucHJvdG90eXBlLl9vblNpZ25pblN1Y2Nlc3MgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy51c2VyX2RhdGEgPSBKU09OLnBhcnNlKGRhdGEudXNlcl9kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHBhcnNpbmcgdXNlciBkYXRhIGFmdGVyIHNpZ25pbjogXCIgKyBkYXRhLnVzZXJfZGF0YSk7XG4gICAgICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnVzZXJfZGF0YS5pZCAhPT0gJ3N0cmluZycgfHwgdGhpcy51c2VyX2RhdGEuaWQgPT09ICcnKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJ1c2VyX2RhdGEgZG9lc24ndCBjb250YWluIGFuIGlkLiB1c2VyX2RhdGE6IFwiICsgdGhpcy51c2VyX2RhdGEpO1xuICAgICAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NpZ25pbkRvbmVSZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmliZUNoYW5uZWxzKCk7XG4gICAgfTtcbiAgICBVc2VyRmFjYWRlLnByb3RvdHlwZS5fc3Vic2NyaWJlQ2hhbm5lbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBlbnN1cmVfc3Vic2NyaWJlZCA9IGZ1bmN0aW9uIChjaGFubmVsKSB7XG4gICAgICAgICAgICBpZiAoY2hhbm5lbC5zdWJzY3JpcHRpb25QZW5kaW5nICYmIGNoYW5uZWwuc3Vic2NyaXB0aW9uQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5yZWluc3RhdGVTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjaGFubmVsLnN1YnNjcmlwdGlvblBlbmRpbmcgJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5wdXNoZXIuY29ubmVjdGlvbi5zdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlcnZlclRvVXNlckNoYW5uZWwgPSBuZXcgY2hhbm5lbHNfY2hhbm5lbChcIiNzZXJ2ZXItdG8tdXNlci1cIiArIHRoaXMudXNlcl9kYXRhLmlkLCB0aGlzLnB1c2hlcik7XG4gICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbC5iaW5kX2dsb2JhbChmdW5jdGlvbiAoZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lLmluZGV4T2YoJ3B1c2hlcl9pbnRlcm5hbDonKSA9PT0gMCB8fFxuICAgICAgICAgICAgICAgIGV2ZW50TmFtZS5pbmRleE9mKCdwdXNoZXI6JykgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5lbWl0KGV2ZW50TmFtZSwgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbnN1cmVfc3Vic2NyaWJlZCh0aGlzLnNlcnZlclRvVXNlckNoYW5uZWwpO1xuICAgIH07XG4gICAgVXNlckZhY2FkZS5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXNlcl9kYXRhID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbCkge1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJUb1VzZXJDaGFubmVsLnVuYmluZF9hbGwoKTtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyVG9Vc2VyQ2hhbm5lbC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnNlcnZlclRvVXNlckNoYW5uZWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNpZ25pbl9yZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25pbkRvbmVSZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVzZXJGYWNhZGUucHJvdG90eXBlLl9uZXdTaWduaW5Qcm9taXNlSWZOZWVkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zaWduaW5fcmVxdWVzdGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2lnbmluRG9uZVByb21pc2UgJiYgIXRoaXMuc2lnbmluRG9uZVByb21pc2UuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IGZsYXRfcHJvbWlzZSgpLCBwcm9taXNlID0gX2EucHJvbWlzZSwgcmVzb2x2ZSA9IF9hLnJlc29sdmUsIF8gPSBfYS5yZWplY3Q7XG4gICAgICAgIHByb21pc2UuZG9uZSA9IGZhbHNlO1xuICAgICAgICB2YXIgc2V0RG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb21pc2UuZG9uZSA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHByb21pc2UudGhlbihzZXREb25lKVtcImNhdGNoXCJdKHNldERvbmUpO1xuICAgICAgICB0aGlzLnNpZ25pbkRvbmVQcm9taXNlID0gcHJvbWlzZTtcbiAgICAgICAgdGhpcy5fc2lnbmluRG9uZVJlc29sdmUgPSByZXNvbHZlO1xuICAgIH07XG4gICAgcmV0dXJuIFVzZXJGYWNhZGU7XG59KGRpc3BhdGNoZXIpKTtcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHVzZXIgPSAodXNlcl9Vc2VyRmFjYWRlKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvY29yZS9wdXNoZXIudHNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIHB1c2hlcl9QdXNoZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFB1c2hlcihhcHBfa2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNoZWNrQXBwS2V5KGFwcF9rZXkpO1xuICAgICAgICB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMua2V5ID0gYXBwX2tleTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBnZXRDb25maWcob3B0aW9ucywgdGhpcyk7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSBmYWN0b3J5LmNyZWF0ZUNoYW5uZWxzKCk7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2VtaXR0ZXIgPSBuZXcgZGlzcGF0Y2hlcigpO1xuICAgICAgICB0aGlzLnNlc3Npb25JRCA9IHJ1bnRpbWUucmFuZG9tSW50KDEwMDAwMDAwMDApO1xuICAgICAgICB0aGlzLnRpbWVsaW5lID0gbmV3IHRpbWVsaW5lX3RpbWVsaW5lKHRoaXMua2V5LCB0aGlzLnNlc3Npb25JRCwge1xuICAgICAgICAgICAgY2x1c3RlcjogdGhpcy5jb25maWcuY2x1c3RlcixcbiAgICAgICAgICAgIGZlYXR1cmVzOiBQdXNoZXIuZ2V0Q2xpZW50RmVhdHVyZXMoKSxcbiAgICAgICAgICAgIHBhcmFtczogdGhpcy5jb25maWcudGltZWxpbmVQYXJhbXMgfHwge30sXG4gICAgICAgICAgICBsaW1pdDogNTAsXG4gICAgICAgICAgICBsZXZlbDogdGltZWxpbmVfbGV2ZWwuSU5GTyxcbiAgICAgICAgICAgIHZlcnNpb246IGRlZmF1bHRzLlZFUlNJT05cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVTdGF0cykge1xuICAgICAgICAgICAgdGhpcy50aW1lbGluZVNlbmRlciA9IGZhY3RvcnkuY3JlYXRlVGltZWxpbmVTZW5kZXIodGhpcy50aW1lbGluZSwge1xuICAgICAgICAgICAgICAgIGhvc3Q6IHRoaXMuY29uZmlnLnN0YXRzSG9zdCxcbiAgICAgICAgICAgICAgICBwYXRoOiAnL3RpbWVsaW5lL3YyLycgKyBydW50aW1lLlRpbWVsaW5lVHJhbnNwb3J0Lm5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnZXRTdHJhdGVneSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcnVudGltZS5nZXREZWZhdWx0U3RyYXRlZ3koX3RoaXMuY29uZmlnLCBvcHRpb25zLCBzdHJhdGVneV9idWlsZGVyX2RlZmluZVRyYW5zcG9ydCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGZhY3RvcnkuY3JlYXRlQ29ubmVjdGlvbk1hbmFnZXIodGhpcy5rZXksIHtcbiAgICAgICAgICAgIGdldFN0cmF0ZWd5OiBnZXRTdHJhdGVneSxcbiAgICAgICAgICAgIHRpbWVsaW5lOiB0aGlzLnRpbWVsaW5lLFxuICAgICAgICAgICAgYWN0aXZpdHlUaW1lb3V0OiB0aGlzLmNvbmZpZy5hY3Rpdml0eVRpbWVvdXQsXG4gICAgICAgICAgICBwb25nVGltZW91dDogdGhpcy5jb25maWcucG9uZ1RpbWVvdXQsXG4gICAgICAgICAgICB1bmF2YWlsYWJsZVRpbWVvdXQ6IHRoaXMuY29uZmlnLnVuYXZhaWxhYmxlVGltZW91dCxcbiAgICAgICAgICAgIHVzZVRMUzogQm9vbGVhbih0aGlzLmNvbmZpZy51c2VUTFMpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uYmluZCgnY29ubmVjdGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc3Vic2NyaWJlQWxsKCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMudGltZWxpbmVTZW5kZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50aW1lbGluZVNlbmRlci5zZW5kKF90aGlzLmNvbm5lY3Rpb24uaXNVc2luZ1RMUygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5iaW5kKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnQuZXZlbnQ7XG4gICAgICAgICAgICB2YXIgaW50ZXJuYWwgPSBldmVudE5hbWUuaW5kZXhPZigncHVzaGVyX2ludGVybmFsOicpID09PSAwO1xuICAgICAgICAgICAgaWYgKGV2ZW50LmNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IF90aGlzLmNoYW5uZWwoZXZlbnQuY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5oYW5kbGVFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbnRlcm5hbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmdsb2JhbF9lbWl0dGVyLmVtaXQoZXZlbnQuZXZlbnQsIGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmJpbmQoJ2Nvbm5lY3RpbmcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jaGFubmVscy5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uYmluZCgnZGlzY29ubmVjdGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2hhbm5lbHMuZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmJpbmQoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFB1c2hlci5pbnN0YW5jZXMucHVzaCh0aGlzKTtcbiAgICAgICAgdGhpcy50aW1lbGluZS5pbmZvKHsgaW5zdGFuY2VzOiBQdXNoZXIuaW5zdGFuY2VzLmxlbmd0aCB9KTtcbiAgICAgICAgdGhpcy51c2VyID0gbmV3IHVzZXIodGhpcyk7XG4gICAgICAgIGlmIChQdXNoZXIuaXNSZWFkeSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUHVzaGVyLnJlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBQdXNoZXIuaXNSZWFkeSA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gUHVzaGVyLmluc3RhbmNlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIFB1c2hlci5pbnN0YW5jZXNbaV0uY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQdXNoZXIuZ2V0Q2xpZW50RmVhdHVyZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBrZXlzKGZpbHRlck9iamVjdCh7IHdzOiBydW50aW1lLlRyYW5zcG9ydHMud3MgfSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LmlzU3VwcG9ydGVkKHt9KTtcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgUHVzaGVyLnByb3RvdHlwZS5jaGFubmVsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHMuZmluZChuYW1lKTtcbiAgICB9O1xuICAgIFB1c2hlci5wcm90b3R5cGUuYWxsQ2hhbm5lbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxzLmFsbCgpO1xuICAgIH07XG4gICAgUHVzaGVyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY29ubmVjdCgpO1xuICAgICAgICBpZiAodGhpcy50aW1lbGluZVNlbmRlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRpbWVsaW5lU2VuZGVyVGltZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXNpbmdUTFMgPSB0aGlzLmNvbm5lY3Rpb24uaXNVc2luZ1RMUygpO1xuICAgICAgICAgICAgICAgIHZhciB0aW1lbGluZVNlbmRlciA9IHRoaXMudGltZWxpbmVTZW5kZXI7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lbGluZVNlbmRlclRpbWVyID0gbmV3IFBlcmlvZGljVGltZXIoNjAwMDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVTZW5kZXIuc2VuZCh1c2luZ1RMUyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFB1c2hlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgaWYgKHRoaXMudGltZWxpbmVTZW5kZXJUaW1lcikge1xuICAgICAgICAgICAgdGhpcy50aW1lbGluZVNlbmRlclRpbWVyLmVuc3VyZUFib3J0ZWQoKTtcbiAgICAgICAgICAgIHRoaXMudGltZWxpbmVTZW5kZXJUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFB1c2hlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChldmVudF9uYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB0aGlzLmdsb2JhbF9lbWl0dGVyLmJpbmQoZXZlbnRfbmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFB1c2hlci5wcm90b3R5cGUudW5iaW5kID0gZnVuY3Rpb24gKGV2ZW50X25hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2VtaXR0ZXIudW5iaW5kKGV2ZW50X25hbWUsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBQdXNoZXIucHJvdG90eXBlLmJpbmRfZ2xvYmFsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsX2VtaXR0ZXIuYmluZF9nbG9iYWwoY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFB1c2hlci5wcm90b3R5cGUudW5iaW5kX2dsb2JhbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmdsb2JhbF9lbWl0dGVyLnVuYmluZF9nbG9iYWwoY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFB1c2hlci5wcm90b3R5cGUudW5iaW5kX2FsbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmdsb2JhbF9lbWl0dGVyLnVuYmluZF9hbGwoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBQdXNoZXIucHJvdG90eXBlLnN1YnNjcmliZUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNoYW5uZWxOYW1lO1xuICAgICAgICBmb3IgKGNoYW5uZWxOYW1lIGluIHRoaXMuY2hhbm5lbHMuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWxzLmNoYW5uZWxzLmhhc093blByb3BlcnR5KGNoYW5uZWxOYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKGNoYW5uZWxOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUHVzaGVyLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoY2hhbm5lbF9uYW1lKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVscy5hZGQoY2hhbm5lbF9uYW1lLCB0aGlzKTtcbiAgICAgICAgaWYgKGNoYW5uZWwuc3Vic2NyaXB0aW9uUGVuZGluZyAmJiBjaGFubmVsLnN1YnNjcmlwdGlvbkNhbmNlbGxlZCkge1xuICAgICAgICAgICAgY2hhbm5lbC5yZWluc3RhdGVTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghY2hhbm5lbC5zdWJzY3JpcHRpb25QZW5kaW5nICYmXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uc3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICBjaGFubmVsLnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFubmVsO1xuICAgIH07XG4gICAgUHVzaGVyLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChjaGFubmVsX25hbWUpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzLmZpbmQoY2hhbm5lbF9uYW1lKTtcbiAgICAgICAgaWYgKGNoYW5uZWwgJiYgY2hhbm5lbC5zdWJzY3JpcHRpb25QZW5kaW5nKSB7XG4gICAgICAgICAgICBjaGFubmVsLmNhbmNlbFN1YnNjcmlwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbHMucmVtb3ZlKGNoYW5uZWxfbmFtZSk7XG4gICAgICAgICAgICBpZiAoY2hhbm5lbCAmJiBjaGFubmVsLnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFB1c2hlci5wcm90b3R5cGUuc2VuZF9ldmVudCA9IGZ1bmN0aW9uIChldmVudF9uYW1lLCBkYXRhLCBjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uc2VuZF9ldmVudChldmVudF9uYW1lLCBkYXRhLCBjaGFubmVsKTtcbiAgICB9O1xuICAgIFB1c2hlci5wcm90b3R5cGUuc2hvdWxkVXNlVExTID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcudXNlVExTO1xuICAgIH07XG4gICAgUHVzaGVyLnByb3RvdHlwZS5zaWduaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXNlci5zaWduaW4oKTtcbiAgICB9O1xuICAgIFB1c2hlci5pbnN0YW5jZXMgPSBbXTtcbiAgICBQdXNoZXIuaXNSZWFkeSA9IGZhbHNlO1xuICAgIFB1c2hlci5sb2dUb0NvbnNvbGUgPSBmYWxzZTtcbiAgICBQdXNoZXIuUnVudGltZSA9IHJ1bnRpbWU7XG4gICAgUHVzaGVyLlNjcmlwdFJlY2VpdmVycyA9IHJ1bnRpbWUuU2NyaXB0UmVjZWl2ZXJzO1xuICAgIFB1c2hlci5EZXBlbmRlbmNpZXNSZWNlaXZlcnMgPSBydW50aW1lLkRlcGVuZGVuY2llc1JlY2VpdmVycztcbiAgICBQdXNoZXIuYXV0aF9jYWxsYmFja3MgPSBydW50aW1lLmF1dGhfY2FsbGJhY2tzO1xuICAgIHJldHVybiBQdXNoZXI7XG59KCkpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29yZV9wdXNoZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChwdXNoZXJfUHVzaGVyKTtcbmZ1bmN0aW9uIGNoZWNrQXBwS2V5KGtleSkge1xuICAgIGlmIChrZXkgPT09IG51bGwgfHwga2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgJ1lvdSBtdXN0IHBhc3MgeW91ciBhcHAga2V5IHdoZW4geW91IGluc3RhbnRpYXRlIFB1c2hlci4nO1xuICAgIH1cbn1cbnJ1bnRpbWUuc2V0dXAocHVzaGVyX1B1c2hlcik7XG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdXNoZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pusher-js/dist/web/pusher.js\n");

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = jQuery;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/app": 0,
/******/ 			"css/app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/js/app.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/sass/app.scss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;